---
editor_options: 
  markdown: 
    wrap: 72
---

# Chuỗi lây nhiễm {#transmission-chains}

<!-- ======================================================= -->

## Tổng quan

Công cụ chính để xử lý, phân tích và trực quan hóa chuỗi truyền nhiễm và
dữ liệu theo dõi liên hệ là package **epicontacts**, được phát triển bởi
những chuyên gia làm việc tại RECON. Hãy thử biểu đồ tương tác bên dưới
bằng cách di chuột qua các nút để biết thêm thông tin, kéo-thả để di
chuyển chúng và nhấp vào chúng để đánh dấu các trường hợp phía dưới.

```{r out.width=c('25%', '25%'), fig.show='hold', echo=F}

## install development version of epicontacts
if(
  !"epicontacts" %in% rownames(installed.packages()) |
  packageVersion("epicontacts") != "1.2.0"
) remotes::install_github("reconhub/epicontacts@timeline")

## install and load packages
pacman::p_load(tidyverse, epicontacts, magrittr, here, webshot, visNetwork)

## load linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%
  filter(!duplicated(case_id))

## generate contacts
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id,
    location = sample(c("Community", "Nosocomial"), n(), TRUE),
    duration = sample.int(10, n(), TRUE)
  ) %>%
  drop_na(from)

## generate epicontacts
epic <- epicontacts::make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)

## subset object
epic %<>% subset(
  node_attribute = list(date_onset = c(as.Date(c("2014-06-01", "2014-07-01"))))
) %>%
  thin("contacts")

## plot with date of onset as x-axis
plot(
  epic,
  x_axis = "date_onset",
  label = FALSE,
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  node_shape = "gender",
  shapes = c(f = "female", m = "male"),
  unlinked_pos = "bottom",
  date_labels = "%b %d %Y",
  node_size = 35,
  font_size = 20,
  arrow_size = 0.5,
  height = 800,
  width = 700,
  edge_linetype = "location",
  legend_width = 0.15,
  highlight_downstream = TRUE,
  selector = FALSE
)

```

<!-- ======================================================= -->

## Chuẩn bị

### Gọi packages {.unnumbered}

Đầu tiên hãy tải các package tiêu chuẩn cần thiết để nhập và xử lý dữ
liệu. Trong cuốn sách này, chúng tôi nhấn mạnh đến `p_load()` từ
**pacman**, sẽ cài đặt gói nếu cần *và* tải xuống để sử dụng. Bạn cũng
có thể tải các package có `library()` từ **base** R. Xem chương [R cơ
bản] để biết thêm thông tin về các package trong R.

```{r transmission_chains_packages, eval = FALSE}
pacman::p_load(
   rio,          # File import
   here,         # File locator
   tidyverse,    # Data management + ggplot2 graphics
   remotes       # Package installation from github
)
```

Bạn sẽ sử dụng phiên bản phát triển của **epicontacts**, có thể được cài
đặt từ github bằng cách sử dụng hàm `p_install_github()` từ **pacman**.
Bạn chỉ cần chạy lệnh này dưới đây một lần, không phải bất cứ khi nào
bạn sử dụng package (sau đó, bạn có thể sử dụng `p_load()` như bình
thường).

```{r transmission_chains_epicontacts_install, eval = FALSE}
pacman::p_install_gh("reconhub/epicontacts@timeline")
```

### Nạp dữ liệu {.unnumbered}

Chúng tôi nạp bộ dữ liệu về các trường hợp mô phỏng từ một vụ dịch
Ebola. Nếu bạn muốn tải xuống dữ liệu để làm theo từng bước, hãy xem
hướng dẫn trong chương [Tải sách và dữ liệu]. Bộ dữ liệu được nạp bằng
hàm `import()` từ package **rio**. Xem chương về [Nhập xuất dữ liệu] để
biết các cách nạp dữ liệu khác nhau.

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.xlsx")
```

50 hàng đầu tiên của bộ dữ liệu `linelist` được hiển thị bên dưới. Mối
quan tâm đặc biệt là các cột `case_id`, `generation`, `infector`, và
`source`.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Tạo đối tượng epicontacts {.unnumbered}

Sau đó, chúng ta cần tạo một đối tượng **epicontacts**, với yêu cầu hai
kiểu dữ liệu như sau:

-   Bộ dữ liệu `linelist` ghi lại các trường hợp trong đó cột là biến và
    hàng tương ứng với các quan sát duy nhất
-   Xác định liên kết giữa các quan sát trên ID duy nhất (có thể là liên
    hệ, sự kiện lây nhiễm, v.v.)

Với bộ dữ liệu `linelist`, chúng ta chỉ cần tạo một danh sách phụ giữa
các trường hợp, cụ thể hơn là giữa các ID. Chúng ta có thể trích xuất
các sự lây nhiễm liên kết từ bộ số liệu `linelist` bằng cách liên kết
cột `infector` với cột `case_id`. Tại thời điểm này, chúng ta cũng có
thể thêm "edge properties", theo đó nghĩa là bất kỳ biến nào mô tả mối
liên kết giữa hai trường hợp, không phải bản thân các trường hợp đó. Để
minh họa, chúng ta sẽ thêm một biến `location` mô tả vị trí của sự kiện
truyền nhiễm và một biến thời lượng mô tả khoảng thời gian tiếp xúc tính
bằng ngày.

Trong đoạn code dưới đây, hàm **dplyr** `transmute` tương tự như hàm
`mutate`, ngoại trừ nó chỉ giữ các cột mà chúng ta đã chỉ định trong
hàm. Hàm `drop_na` sẽ lọc ra bất kỳ hàng nào mà các cột được chỉ định có
giá trị `NA` ; trong trường hợp này, chúng ta chỉ muốn giữ lại các hàng
mà tác nhân lây nhiễm đã biết.

```{r transmission_chains_create_contacts,}
## generate contacts
contacts <- linelist %>%
  transmute(
    infector = infector,
    case_id = case_id,
    location = sample(c("Community", "Nosocomial"), n(), TRUE),
    duration = sample.int(10, n(), TRUE)
  ) %>%
  drop_na(infector)
```

Bây giờ chúng ta có thể tạo đối tượng **epicontacts** bằng cách sử dụng
hàm `make_epicontacts`. Chúng ta cần chỉ định cột trong bộ dữ liệu
`linelist` trỏ đến mã định danh trường hợp duy nhất (ID), cũng như cột
trong liên hệ trỏ đến mã định danh duy nhất của các trường hợp liên quan
trong mỗi liên kết. Các liên kết này là định hướng trong đó việc lây
nhiễm sẽ đi *từ* các yếu tố lây nhiễm *đến* ca bệnh, vì vậy chúng ta cần
chỉ định các đối số `from` và `to` cho phù hợp. Do đó, chúng ta cũng đặt
đối số `directed` thành `TRUE`, điều này sẽ ảnh hưởng đến các hoạt động
về sau.

```{r transmission_chains_create_epicontacts,}
## generate epicontacts object
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts,
  id = "case_id",
  from = "infector",
  to = "case_id",
  directed = TRUE
)
```

Khi kiểm tra các đối tượng **epicontacts**, chúng ta có thể thấy rằng
cột `case_id` trong bộ dữ liệu `linelist` đã được đổi tên thành `id` và
các cột `case_id` và cột `infector` trong liên hệ đã được đổi tên thành
`from` và `to`. Điều này đảm bảo tính nhất quán trong các hoạt động xử
lý, trực quan và phân tích tiếp theo.

```{r transmission_chains_view_epicontacts,}
## view epicontacts object
epic
```

<!-- ======================================================= -->

## Xử lý

### Chia nhỏ bộ dữ liệu {.unnumbered}

Phương thức `subset()` cho các đối tượng **epicontacts** cho phép, trong
số những thứ khác, lọc mạng lưới dựa trên các thuộc tính của bộ dữ liệu
`linelist` ("thuộc tính nút") và cơ sở dữ liệu mối liên hệ ("thuộc tính
edge"). Các giá trị này phải được chuyển đổi dưới dạng danh sách đã đặt
tên cho đối số tương ứng. Ví dụ: trong đoạn code bên dưới, chúng tôi chỉ
giữ lại các trường hợp nam giới trong bộ số liệu `linelist` có ngày lây
nhiễm từ tháng 4 đến tháng 7 năm 2014 (các ngày được chỉ định là khoảng)
và các liên hệ lây nhiễm xảy ra trong bệnh viện.

```{r transmission_chains_subset_nodes,}
sub_attributes <- subset(
  epic,
  node_attribute = list(
    gender = "m",
    date_infection = as.Date(c("2014-04-01", "2014-07-01"))
  ), 
  edge_attribute = list(location = "Nosocomial")
)
sub_attributes
```

Chúng ta có thể sử dụng hàm `thin` để lọc bộ số liệu `linelist` để bao
gồm các trường hợp được tìm thấy sự tiếp xúc bằng cách đặt argument
`what = "linelist"`, hoặc lọc các liên hệ để bao gồm các trường hợp được
tìm thấy trong bộ số liệu `linelist` bằng cách đặt argument
`what = "contacts"`. Trong đoạn code dưới đây, chúng ta đang lọc thêm
các tiếp xúc dịch tễ để chỉ giữ sự lây nhiễm liên quan đến các trường
hợp nam giới bị lây nhiễm giữa tháng 4 và tháng 7, chúng ta đã lọc ở
trên. Chúng ta có thể thấy rằng chỉ có hai liên kết lây nhiễm đã biết
phù hợp với đặc điểm đó.

```{r transmission_chains_thin,}
sub_attributes <- thin(sub_attributes, what = "contacts")
nrow(sub_attributes$contacts)
```

Ngoài các thuộc tính Node và Edge, các mạng liên kết có thể được cắt tỉa
để chỉ bao gồm các thành phần được kết nối với các nút nhất định.
Argument `cluster_id` đã lấy một vectơ của ID ca bệnh và trả về bộ số
liệu `linelist` của các cá nhân được liên kết, trực tiếp hoặc gián tiếp,
cho các ID đó. Trong đoạn code dưới đây, chúng ta có thể thấy rằng tổng
cộng 13 trường hợp trong bộ số liệu `linelist` có liên quan đến các cụm
chứa `2ae019` và `71577a`.

```{r}
sub_id <- subset(epic, cluster_id = c("2ae019","71577a"))
nrow(sub_id$linelist)
```

Phương thức `subset()` cho các đối tượng `epicontacts` cũng cho phép lọc
theo kích thước cụm bằng cách sử dụng các argument `cs`, `cs_min` và
`cs_max`. Trong đoạn code bên dưới, chúng ta chỉ giữ lại các trường hợp
được liên kết với các cụm 10 trường hợp hoặc lớn hơn và có thể thấy rằng
271 trường hợp trong trong bộ số liệu `linelist` có liên quan đến các
cụm đó.

```{r}
sub_cs <- subset(epic, cs_min = 10)
nrow(sub_cs$linelist)
```

### Truy cập thông tin ID {.unnumbered}

Hàm `get_id()` truy xuất thông tin về ID ca bệnh trong bộ dữ liệu và có
thể được tham số hóa như sau:

-   **linelist**: ID trong bộ số liệu `linelist`
-   **contacts**: ID trong bộ số liệu tiếp xúc (kết hợp "from" và "to")
-   **from**: ID trong cột "from" của bộ dữ liệu tiếp xúc
-   **to**: ID trong cột "to" của bộ dữ liệu tiếp xúc
-   **all**: ID xuất hiện bất kỳ chỗ nào ở một trong hai bộ dữ liệu
-   **common**: ID xuất hiện trong cả bộ dữ liệu tiếp xúc và bộ dữ liệu
    `linelist`

Ví dụ: 10 ID đầu tiên trong bộ dữ liệu tiếp xúc là gì?

```{r transmission_chains_get_ids,}
contacts_ids <- get_id(epic, "contacts")
head(contacts_ids, n = 10)
```

Có bao nhiêu ID được tìm thấy trong cả hai bộ dữ liệu tiếp xúc và
`linelist`?

```{r transmission_chains_get_both,}
length(get_id(epic, "common"))
```

<!-- ======================================================= -->

## Trực quan

### Biểu đồ cơ bản {.unnumbered}

Tất cả các hình ảnh trực quan của các đối tượng **epicontacts** được xử
lý bởi hàm `plot`. Trước tiên, chúng ta sẽ lọc đối tượng **epicontacts**
để chỉ bao gồm các trường hợp có ngày bắt đầu vào tháng 6 năm 2014 bằng
cách sử dụng hàm `subset`, và chỉ bao gồm các tiếp xúc được liên kết với
các trường hợp đó bằng cách sử dụng hàm `thin`.

```{r transmission_chains_basic_plot_sub,}
## subset epicontacts object
sub <- epic %>%
  subset(
    node_attribute = list(date_onset = c(as.Date(c("2014-06-30", "2014-06-01"))))
  ) %>%
 thin("contacts")
```

Sau đó, chúng ta có thể tạo biểu đồ cơ bản, có tính tương tác rất đơn
giản như sau:

```{r transmission_chains_basic_plot,}
## plot epicontacts object
plot(
  sub,
  width = 700,
  height = 700
)
```

Bạn có thể di chuyển các nút xung quanh bằng cách kéo chúng, di chuột
qua chúng để biết thêm thông tin và nhấp vào chúng để đánh dấu các
trường hợp được kết nối.

Có một số lượng lớn các argument để sửa đổi thêm biểu đồ này. Chúng ta
sẽ trình bày những vấn đề chính ở đây, nhưng hãy kiểm tra tài liệu qua
lệnh `?vis_epicontacts` (hàm được gọi khi sử dụng biểu đồ trên đối tượng
**epicontacts**) để có được mô tả đầy đủ về các argument của hàm.

#### Trực quan hóa các thuộc tính của nút {.unnumbered}

Màu nút, hình dạng nút và kích thước nút có thể được ánh xạ tới một cột
nhất định trong bộ số liệu `linelist` bằng cách sử dụng các argument
`node_color`, `node_shape` và `node_size`. Điều này tương tự với cú pháp
`aes` mà bạn có thể thấy trong **ggplot2**.

Màu sắc, hình dạng và kích thước cụ thể của các nút có thể được chỉ định
như sau:

-   **Màu sắc** thông qua argument `col_pal`, bằng cách cung cấp danh
    sách tên cho chi tiết thủ công của từng màu như được thực hiện bên
    dưới hoặc bằng cách cung cấp chức năng bảng màu như
    `colorRampPalette(c("black", "red", "orange"))`, sẽ cung cấp một dải
    màu giữa các màu được chỉ định.

-   **Định dạng** bằng cách chuyển một danh sách đã đặt tên đến argument
    `shapes`, chỉ định một hình dạng cho mỗi phần tử duy nhất trong cột
    bộ số liệu `linelist` được chỉ định bởi argument `node_shape`. Xem
    `codeawesome` cho các dạng có sẵn.

-   **Size** by passing a size range of the nodes to the `size_range`
    argument. **Kích thước** bằng cách chuyển một phạm vi kích thước của
    các nút tới argument `size_range`.

Dưới đây là một ví dụ, trong đó màu sắc thể hiệ cho kết quả, định hình
giới tính và kích thước độ tuổi:

```{r transmission_chains_node_attribute,}
plot(
  sub, 
  node_color = "outcome",
  node_shape = "gender",
  node_size = 'age',
  col_pal = c(Death = "firebrick", Recover = "green"),
  shapes = c(f = "female", m = "male"),
  size_range = c(40, 60),
  height = 700,
  width = 700
)
```

#### Trực quan hóa các thuộc tính phụ {.unnumbered}

Màu, chiều rộng và kiểu đường có thể được ánh xạ tới một cột nhất định
trong bộ dữ liệu tiếp xúc bằng cách sử dụng các `edge_color`,
`edge_width` và `edge_linetype`. Các màu cụ thể và độ rộng của các cạnh
có thể được chỉ định như sau:

-   **Màu sắc** thông qua argument `edge_col_pal`, theo cách tương tự
    được sử dụng cho `col_pal`.

-   **Độ rộng** bằng cách chuyển phạm vi kích thước của các nút tới
    argument `width_range`.

Đây là ví dụ:

```{r transmission_chains_edge_attribute,}

plot(
  sub, 
  node_color = "outcome",
  node_shape = "gender",
  node_size = 'age',
  col_pal = c(Death = "firebrick", Recover = "green"),
  shapes = c(f = "female", m = "male"),
  size_range = c(40, 60),
  edge_color = 'location',
  edge_linetype = 'location',
  edge_width = 'duration',
  edge_col_pal = c(Community = "orange", Nosocomial = "purple"),
  width_range = c(1, 3),
  height = 700,
  width = 700
)

```

### Trục tạm thời {.unnumbered}

Chúng ta cũng có thể trực quan mạng dọc theo trục thời gian bằng cách
ánh xạ argument `x_axis` vào một cột trong bộ số liệu `linelist`. Trong
ví dụ dưới đây, trục x biểu thị ngày bắt đầu triệu chứng. Chúng ta cũng
đã chỉ định argument `arrow_size` để đảm bảo các mũi tên không quá lớn
và đặt `label = FALSE` để làm cho hình bớt lộn xộn.

```{r transmission_chains_x_axis,}
plot(
  sub,
  x_axis = "date_onset",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

Có một số lượng lớn các argument bổ sung để sau này chỉ định cách mạng
này được hiển thị dọc theo trục thời gian, bạn có thể kiểm tra thông qua
`?vis_temporal_interactive` (hàm được gọi khi sử dụng `plot` trên đối
tượng **epicontacts** với `x_axis` được chỉ định). Chúng ta sẽ mô tả bên
dưới.

#### Chỉ định hình dạng cây lây nhiễm {.unnumbered}

Có hai hình dạng chính mà cây lây nhiễm có thể giả định, được chỉ định
bằng cách sử dụng argument `network_shape`. Đầu tiên là hình dạng
`branching` như hình trên, trong đó một cạnh thẳng nối hai nút bất kỳ.
Đây là cách trình bày trực quan nhất, tuy nhiên có thể dẫn đến các cạnh
chồng lên nhau trong một mạng kết nối dày đặc. Hình thứ hai là
`rectangle`, tạo ra một cái cây giống như phát sinh loài. Ví dụ:

```{r transmission_chains_rectangle,}
plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

Mỗi nút có thể được xác định một vị trí dọc duy nhất bằng cách chuyển
đổi argument `position_dodge`. Vị trí của các trường hợp không được kết
nối (tức là không có lây nhiễm được báo cáo) được xác định bằng cách sử
dụng argument `unlinked_pos`.

```{r transmission_chains_dodge,}
plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  position_dodge = TRUE,
  unlinked_pos = "bottom",
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

Vị trí của nút "mẹ" so với các nút "con" có thể được xác định bằng cách
sử dụng argument `parent_pos`. Tùy chọn mặc định là đặt nút "mẹ" ở giữa,
tuy nhiên nó có thể được đặt ở dưới cùng (`parent_pos = 'bottom'`) hoặc
ở trên cùng (`parent_pos = 'top'`).

```{r transmission_chains_parent_pos,}
plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  parent_pos = "top",
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

#### Lưu biểu đồ {.unnumbered}

Bạn có thể lưu một biểu đồ dưới dạng tệp tin html tương tác, độc lập với
hàm `visSave` từ package **VisNetwork**:

```{r transmission_chains_save, eval=F}

plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  parent_pos = "top",
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
) %>%
  visNetwork::visSave("network.html")

```

Rất tiếc, việc lưu các kết quả đầu ra mạng lưới lây nhiễm này dưới dạng
hình ảnh trở nên khó khăn và bạn cần lưu dưới dạng tệp tin html và sau
đó chụp ảnh màn hình của tệp tin này bằng backage **webshot**. Trong
đoạn code dưới đây, chúng ta đang chuyển đổi tệp tin html được lưu ở
trên thành dạng file ảnh PNG:

```{r transmission_chains_webshot, eval=F}
webshot(url = "network.html", file = "network.png")
```

### Dòng thời gian {.unnumbered}

Bạn cũng có thể viết hoa các mốc thời gian cho mạng lưới truyền nhiễm,
được biểu diễn trên trục x của mỗi trường hợp. Điều này có thể được sử
dụng để quan sát các vị trí ca bệnh, ví dụ, hoặc thời gian dẫn đến kết
quả cuối cùng. Để tạo dòng thời gian, chúng ta cần tạo data.frame gồm ít
nhất ba cột bao gồm ID, ngày bắt đầu của "sự kiện" và ngày kết thúc của
"sự kiện". Bạn cũng có thể thêm bất kỳ cột giá trị nào khác mà sau đó có
thể được ánh xạ tới các thuộc tính nút và cạnh của dòng thời gian. Trong
đoạn code dưới đây, chúng ta tạo một mốc thời gian từ ngày bắt đầu có
triệu chứng đến ngày kết quả quả cuối cùng và giữ các biến kết quả và
bệnh viện mà chúng ta sử dụng để xác định hình dạng và màu sắc của nút.
Lưu ý rằng bạn có thể có nhiều hơn một hàng/sự kiện tiến trình cho mỗi
trường hợp, ví dụ: nếu một trường hợp được chuyển viện giữa nhiều bệnh
viện.

```{r transmission_chains_create_timeline,}

## generate timeline
timeline <- linelist %>%
  transmute(
    id = case_id,
    start = date_onset,
    end = date_outcome,
    outcome = outcome,
    hospital = hospital
  )

```

Sau đó, chúng tôi chuyển phần tử dòng thời gian vào argument `timeline`.
Chúng ta có thể ánh xạ các thuộc tính dòng thời gian với màu sắc, hình
dạng và kích thước của nút dòng thời gian theo cùng một cách đã xác định
trong các phần trước, ngoại trừ việc chúng ta có hai nút: nút bắt đầu và
nút kết thúc của mỗi dòng thời gian, có các argument riêng biệt. Ví dụ:
`tl_start_node_color` xác định cột dòng thời gian nào được ánh xạ với
màu của nút bắt đầu, trong khi `tl_end_node_shape` xác định cột dòng
thời gian nào được ánh xạ tới hình dạng của nút kết thúc. Chúng ta cũng
có thể ánh xạ màu, chiều rộng, kiểu đường kẻ và nhãn vào *cạnh* dòng
thời gian thông qua các argument `tl_edge_`.

Xem `?vis_temporal_interactive` (hàm được gọi khi vẽ biểu đồ một đối
tượng epicontacts) để biết tài liệu chi tiết về các argument. Mỗi
argument cũng được chú thích trong đoạn code bên dưới:

```{r transmission_chains_vis_timeline,}

## define shapes
shapes <- c(
  f = "female",
  m = "male",
  Death = "user-times",
  Recover = "heartbeat",
  "NA" = "question-circle"
)

## define colours
colours <- c(
  Death = "firebrick",
  Recover = "green",
  "NA" = "grey"
)

## make plot
plot(
  sub,
  ## max x coordinate to date of onset
  x_axis = "date_onset",
  ## use rectangular network shape
  network_shape = "rectangle",
  ## mape case node shapes to gender column
  node_shape = "gender",
  ## we don't want to map node colour to any columns - this is important as the
  ## default value is to map to node id, which will mess up the colour scheme
  node_color = NULL,
  ## set case node size to 30 (as this is not a character, node_size is not
  ## mapped to a column but instead interpreted as the actual node size)
  node_size = 30,
  ## set transmission link width to 4 (as this is not a character, edge_width is
  ## not mapped to a column but instead interpreted as the actual edge width)
  edge_width = 4,
  ## provide the timeline object
  timeline = timeline,
  ## map the shape of the end node to the outcome column in the timeline object
  tl_end_node_shape = "outcome",
  ## set the size of the end node to 15 (as this is not a character, this
  ## argument is not mapped to a column but instead interpreted as the actual
  ## node size)
  tl_end_node_size = 15,
  ## map the colour of the timeline edge to the hospital column
  tl_edge_color = "hospital",
  ## set the width of the timeline edge to 2 (as this is not a character, this
  ## argument is not mapped to a column but instead interpreted as the actual
  ## edge width)
  tl_edge_width = 2,
  ## map edge labels to the hospital variable
  tl_edge_label = "hospital",
  ## specify the shape for everyone node attribute (defined above)
  shapes = shapes,
  ## specify the colour palette (defined above)
  col_pal = colours,
  ## set the size of the arrow to 0.5
  arrow_size = 0.5,
  ## use two columns in the legend
  legend_ncol = 2,
  ## set font size
  font_size = 15,
  ## define formatting for dates
  date_labels = c("%d %b %Y"),
  ## don't plot the ID labels below nodes
  label = FALSE,
  ## specify height
  height = 1000,
  ## specify width
  width = 1200,
  ## ensure each case node has a unique y-coordinate - this is very important
  ## when using timelines, otherwise you will have overlapping timelines from
  ## different cases
  position_dodge = TRUE
)

```

<!-- ======================================================= -->

## Phân tích

### Tổng hợp {.unnumbered}

Chúng ta có thể xem tổng quan về một số thuộc tính mạng lưới bằng cách
sử dụng hàm `summary`.

```{r transmission_chains_summarise_epicontacts,}
## summarise epicontacts object
summary(epic)
```

Ví dụ, chúng ta có thể thấy rằng chỉ có 57% ca lây nhiễm có cả hai
trường hợp trong bộ số liệu `linelist`; điều này có nghĩa là chúng ta
không có dữ liệu trong bộ số liệu `linelist` về một số lượng đáng kể các
trường hợp liên quan đến các chuỗi lây nhiễm này.

### Đặc điểm cặp {.unnumbered}

Hàm `get_pairwise()` cho phép xử lý (các) biến trong bộ số liệu
`linelist` theo từng cặp trong bộ dữ liệu lây nhiễm. Ở ví dụ sau, ngày
khởi phát bệnh được trích xuất từ bộ số liệu `linelist` để tính toán sự
khác biệt giữa ngày khởi phát bệnh cho từng cặp. Giá trị được tạo ra từ
phép so sánh này đại diện cho **khoảng nối tiếp** (**serial interval -
si)**.

```{r transmission_chains_pairwise,}
si <- get_pairwise(epic, "date_onset")   
summary(si)
tibble(si = si) %>%
  ggplot(aes(si)) +
  geom_histogram() +
  labs(
    x = "Serial interval",
    y = "Frequency"
  )
```

`get_pairwise()` sẽ diễn giải phân lớp của cột đang được sử dụng để so
sánh và sẽ điều chỉnh phương pháp so sánh các giá trị của nó cho phù
hợp. Đối với số và ngày (như ví dụ **si** ở trên), hàm sẽ trừ các giá
trị. Khi được áp dụng cho các cột là ký tự hoặc phân loại,
`get_pairwise()` sẽ gán các giá trị lại với nhau. Bởi vì hàm cũng cho
phép xử lý tùy ý (xem argument "f"), các kết hợp rời rạc này có thể dễ
dàng được mô tả và phân tích.

```{r transmission_chains_pairwise_2,}
head(get_pairwise(epic, "gender"), n = 10)
get_pairwise(epic, "gender", f = table)
fisher.test(get_pairwise(epic, "gender", f = table))
```

Ở đây, chúng ta thấy có một mối liên hệ lớn giữa các liên kết lây nhiễm
và giới tính.

### Xác định cụm {.unnumbered}

Hàm `get_clusters()` có thể được sử dụng để xác định các thành phần được
kết nối trong một đối tượng `epicontacts`. Đầu tiên, chúng ta sử dụng nó
để truy xuất `data.frame` chứa thông tin cụm:

```{r transmission_chains_cluster,}
clust <- get_clusters(epic, output = "data.frame")
table(clust$cluster_size)
ggplot(clust, aes(cluster_size)) +
  geom_bar() +
  labs(
    x = "Cluster size",
    y = "Frequency"
  )
```

Hãy để chúng ta xem xét các cụm lớn nhất. Đối với điều này, chúng ta
thêm thông tin cụm vào đối tượng epicontacts và sau đó đặt nó để chỉ giữ
lại các cụm lớn nhất:

```{r transmission_chains_cluster_2,}
epic <- get_clusters(epic)
max_size <- max(epic$linelist$cluster_size)
plot(subset(epic, cs = max_size))
```

### Tính toán mức độ {.unnumbered}

Mức độ của một nút tương ứng với số cạnh hoặc kết nối của nó với các nút
khác. `get_degree()` cung cấp một phương pháp dễ dàng để tính toán giá
trị này cho các mạng lưới `epicontacts`. Mức độ cao trong ngữ cảnh này
cho biết một cá nhân đã tiếp xúc với nhiều người khác. Argument `type`
chỉ ra rằng chúng ta muốn đếm cả mức độ trong và ngoài, argument
`only_linelist` chỉ ra rằng chúng ta chỉ muốn tính mức độ cho các trường
hợp trong bộ số liệu `linelist`.

```{r transmission_chains_degree,}
deg_both <- get_degree(epic, type = "both", only_linelist = TRUE)
```

Những cá nhân nào có 10 lây nhiễm nhiều nhất?

```{r}
head(sort(deg_both, decreasing = TRUE), 10)
```

Số lượng lây nhiễm trung bình là bao nhiêu?

```{r}
mean(deg_both)
```

<!-- ======================================================= -->

## Tham khảo

[Epicontacts
page](https://www.repidemicsconsortium.org/epicontacts/index.html) cung
cấp tổng quan về các hàm và package bao gồm một số thông tin chi tiết
chuyên sâu hơn.

[Github page](http://github.com/reconhub/epicontacts) có thể được sử
dụng để nêu vấn đề và yêu cầu chỉnh sửa.
