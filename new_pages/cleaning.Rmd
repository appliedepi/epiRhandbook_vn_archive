# Làm sạch số liệu và các hàm quan trọng {#cleaning}

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

Chương này trình bày các bước phổ biến được sử dụng trong quá trình "làm sạch" bộ dữ liệu và cũng giải thích việc sử dụng các hàm quản lý dữ liệu thiết yếu trong R.

Để giải thích rõ hơn quá trình làm sạch dữ liệu, chương này bắt đầu từ cách nạp bộ dữ liệu thô dạng danh sách và tiến hành từng bước trong quá trình làm sạch. Trong code R, sự biểu thị dưới dạng một chuỗi "pipe", tham chiếu đến toán tử "pipe" `%>%` để chuyển tiếp từ thao tác này sang thao tác tiếp theo trong cùng một bộ dữ liệu.

### Các hàm quan trọng {.unnumbered}

Cuốn sách này nhấn mạnh việc sử dụng các hàm từ và hệ sinh thái của package [**tidyverse**](https://www.tidyverse.org/). Các hàm thiết yếu trong R trình bày trong chương này được liệt kê dưới đây.

Nhiều hàm thuộc về package [**dplyr**](https://dplyr.tidyverse.org/), mà cung cấp các hàm dạng "verb" để giải quyết các thách thức trong thao tác xử lý dữ liệu (tham chiếu đến một bộ dữ liệu "data frame-[plier](https://www.thefreedictionary.com/plier#:~:text=also%20ply%C2%B7er%20(pl%C4%AB%E2%80%B2,holding%2C%20bending%2C%20or%20cutting.)%22). **dplyr** là một phần trong hệ sinh thái của package **tidyverse** (mà bao gồm các package khác như **ggplot2**, **tidyr**, **stringr**, **tibble**, **purrr**, **magrittr**, và **forcats**).

+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| Hàm                                                 | Chức năng                                                  | Package                  |
+=====================================================+============================================================+==========================+
| `%>%`                                               | "pipe" (chuyển tiếp) dữ liệu từ một hàm sang hàm tiếp theo | **magrittr**             |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `mutate()`                                          | tạo, chuyển dạng, và định dạng lại cột                     | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `select()`                                          | giữ lại, xóa, chọn, hoặc đổi tên cột                       | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `rename()`                                          | đổi tên cột                                                | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `clean_names()`                                     | chuẩn hóa cú pháp tên cột                                  | **janitor**              |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `as.character()`, `as.numeric()`, `as.Date()`, etc. | chuyển đổi định dạng cột                                   | **base** R               |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `across()`                                          | chuyển dạng đồng thời nhiều cột                            | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| **tidyselect** hàm logic để chọn cột                | **tidyselect**                                             |                          |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `filter()`                                          | giữ lại các dòng theo điều kiện                            | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `distinct()`                                        | lọc trùng quan sát                                         | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `rowwise()`                                         | xử lý theo/trong mỗi dòng                                  | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `add_row()`                                         | thêm dòng thủ công                                         | **tibble**               |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `arrange()`                                         | săp xếp dòng                                               | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `recode()`                                          | Cấu trúc lại giá trị trong cột                             | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `case_when()`                                       | Cấu trúc lại giá trị trong cột kèm điều kiện               | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `replace_na()`, `na_if()`, `coalesce()`             | các hàm đặc biệt để cấu trúc lại                           | **tidyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `age_categories()` and `cut()`                      | tạo biến định tính từ biến định lượng                      | **epikit** và R **base** |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `clean_variable_spelling()`                         | tái cấu trúc/làm sạch giá trị sử dụng từ điển dữ liệu      | **linelist**             |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `which()`                                           | áp dụng các điều kiện logic; trả về các chỉ số             | R **base**               |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+

Nếu bạn muốn xem các hàm này so sánh với các câu lệnh trong Stata hoặc SAS, hãy xem chương [Transition to R].

Bạn có thể gặp một khung quản lý dữ liệu thay thế từ package **data.table** trong R với các toán tử như `:=` và thường xuyên sử dụng dấu ngoặc `[ ]`. Cách tiếp cận và cú pháp này được giải thích ngắn gọn trong chương [Data Table].

### Thuật ngữ {.unnumbered}

Trong cuốn sách này, chúng tôi quy ước chung "cột" và "hàng" thay cho "biến" và "quan sát". Như đã giải thích trong phần dẫn trên ["tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html), hầu hết các bộ dữ liệu dịch tễ-thống kê đều có cấu trúc gồm các hàng, cột và giá trị.

*Variables (biến)* chứa các giá trị đo lường cùng một thuộc tính cơ bản (như nhóm tuổi, kết quả hoặc ngày bắt đầu). *Observations (quan sát)* chứa tất cả các giá trị được đo trên cùng một đơn vị (ví dụ: một người, địa điểm hoặc mẫu phòng thí nghiệm). Vì vậy, những khía cạnh này có thể khó xác định một cách hữu hình hơn.

Trong bộ dữ liệu "tidy", mỗi cột là một biến, mỗi hàng là một quan sát và mỗi ô là một giá trị duy nhất. Tuy nhiên, một số bộ dữ liệu bạn gặp phải sẽ không giống với mô tả này - bộ dữ liệu định dạng "wide" có thể có một biến số được chia thành nhiều cột (xem ví dụ trong chương [Pivoting data]). Tương tự như vậy, các quan sát có thể được chia thành nhiều hàng.

Hầu hết cuốn sách này là về quản lý và chuyển đổi dữ liệu, do đó, việc đề cập đến cấu trúc dữ liệu cụ thể của các hàng và cột sẽ thích hợp hơn là các quan sát và biến một cách trừu tượng. Các trường hợp ngoại lệ chủ yếu xảy ra trong các chương về phân tích dữ liệu, nơi bạn sẽ thấy nhiều tham chiếu hơn đến các biến và quan sát.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Làm sạch pipeline

**Chương này tiến hành các bước làm sạch điển hình, thêm chúng tuần tự vào một pipeline sạch.**

Trong phân tích dịch tễ học và xử lý dữ liệu, các bước làm sạch thường được thực hiện tuần tự, liên kết với nhau. Trong R, điều này thường biểu thị như một "pipeline" làm sạch, trong đó *bộ dữ liệu thô được chuyển tiếp hoặc "dẫn" từ bước làm sạch này sang bước làm sạch khác*.

Các chuỗi như vậy sử dụng các hàm dạng "verb" trong package **dplyr** và toán tử pipe `%>%` trong package **magrittr**. Pipe bắt đầu từ dữ liệu "thô" ("linelist_raw.xlsx") và kết thúc bằng bộ dữ liệu "sạch" trên R (`linelist`) có thể được sử dụng, lưu, xuất, v.v.

Trong quy trình làm sạch dữ liệu, thứ tự của các bước là quan trọng. Các bước làm sạch có thể bao gồm:

-   Nạp dữ liệu
-   Làm sạch hoặc đổi tên cột
-   Lọc trùng
-   Tạo và chuyển đổi cột (ví dụ: mã hóa lại hoặc chuẩn hóa các giá trị)
-   Lọc hoặc thêm hàng

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Gọi package

Đoạn code chunk này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm `p_load ()` from package **pacman**, cài đặt package nếu cần *và* gọi package để sử dụng. Bạn cũng có thể tải các package đã cài đặt với hàm `library()` sẵn có trong R **base**. Xem chương [R basics] để biết thêm thông tin về các package trong R.

```{r, message = F}
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  janitor,    # data cleaning and tables
  lubridate,  # working with dates
  epikit,     # age_categories() function
  tidyverse   # data management and visualization
)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Nạp dữ liệu

### Nạp {.unnumbered}

Ở đây, chúng tôi nạp tệp tin Excel "thô" bằng cách sử dụng hàm `import ()` từ package **rio**. Package **rio** có thể xử lý linh hoạt nhiều loại tệp tin (ví dụ: .xlsx, .csv, .tsv, .rds. Xem chương về [Import and export] để biết thêm thông tin và mẹo về các tình huống bất thường (ví dụ: loại bỏ hàng, thiết lập giá trị trống, nạp Google sheets, v.v.).

Nếu bạn muốn hiểu rõ hơn, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>hãy tải xuống file linelist "thô"</a> (với file dạng .xlsx).

Nếu bộ dữ liệu của bạn quá lớn và mất nhiều thời gian để nạp, rất hữu ích khi đặt lệnh nạp dữ liệu và đồng thời tách dữ liệu riêng biệt với chuỗi pipe và dữ liệu "thô" sẽ được lưu thành một file riêng biệt. Điều này cũng cho phép dễ dàng so sánh giữa phiên bản gốc và phiên bản đã làm sạch.

Dưới đây, chúng tôi nạp file Excel thô và lưu nó dưới dạng bộ dữ liệu `linelist_raw`. Chúng tôi giả định rằng file này nằm trong thư mục làm việc của bạn hoặc thư mục gốc của R project và vì vậy không có thư mục con nào được chỉ định trong đường dẫn file.

```{r, echo=F, message=F}
# HIDDEN FROM READER
# actually load the data using here()
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

Bạn có thể xem 50 hàng đầu tiên của bộ dữ liệu bên dưới. Lưu ý: hàm R **base** `head(n)` cho phép bạn chỉ xem các hàng `n` đầu tiên trong bảng điều khiển R.

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Đánh giá {.unnumbered}

Bạn có thể sử dụng hàm `skim()` từ package **skimr** để có góc nhìn tổng quan về toàn bộ bộ dữ liệu (xem chương [Descriptive tables] để biết thêm thông tin). Các cột được tóm tắt theo phân lớp/định dạng như ký tự và số. Lưu ý: "POSIXct" là một loại phân lớp ngày thô (xem chương [Working with dates].

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Tên cột

Trong R, *tên* cột là giá trị dạng "tiêu đề" hoặc "trên cùng" của một cột. Chúng được sử dụng để tham chiếu đến các cột trong đoạn code và đóng vai trò như một nhãn mặc định trong các bảng biểu.

Phần mềm thống kê khác như SAS và STATA sử dụng *"nhãn"* cùng hiển thị dưới dạng dài hơn so với tên cột. Mặc dù R cung cấp tính năng thêm nhãn của cột vào dữ liệu, nhưng điều này hầu hết không được nhấn mạnh trong thực tế. Để đặt tên cột "dễ nhìn" cho các bảng biểu, người ta thường điều chỉnh hiển thị của chúng trong các lệnh vẽ biểu đồ để tạo ra kết quả (ví dụ: tiêu đề trục hoặc chú giải của một biểu đồ hoặc tiêu đề cột trong bảng - xem chương [scales section of the ggplot tips page](#%20ggplot_tips_scales) và các chương [Tables for presentation]). Nếu bạn muốn gán nhãn cột trong dữ liệu, hãy đọc thêm online [tại đây](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) và [tại đây](https%20:%20//cran.r-project.org/web/packages/labelt/vignettes/intro_labelling.html).

Vì tên cột trong R được sử dụng rất thường xuyên, vì vậy chúng phải có cú pháp "sạch". Chúng tôi đề xuất những tiêu chí sau:

-   Tên ngắn
-   Không có khoảng trắng (thay thế bằng dấu gạch dưới\_)
-   Không có ký tự lạ (&, \#, \<, \>, ...)
-   Thống nhất cách định danh (e.g. toàn bộ tên cột ngày như **date\_**onset, **date\_**report, **date\_**death...)

The columns names of `linelist_raw` are printed below using `names()` from **base** R. We can see that initially:\
Tên các cột trong `linelist_raw` được biểu thị bên dưới bằng cách sử dụng hàm `names ()` từ **base** R. Ban đầu chúng ta có thể thấy rằng:

-   Một số tên có thể chứa khoảng trắng (e.g. `infection date`)
-   Một số mẫu tên khác nhau được sử dụng cho biến ngày (`date onset` vs. `infection date`)
-   Phải có một *tiêu đề được hợp nhất* ở hai cột cuối cùng trong file .xlsx. Chúng tôi biết điều này vì tên của hai cột được hợp nhất ("merge_header") được R gán cho cột đầu tiên và cột thứ hai được gán tên giữ chỗ "... 28" (vì lúc đó nó trống và là cột thứ 28).

```{r}
names(linelist_raw)
```

[***NOTE:*** To reference a column name that includes spaces, surround the name with back-ticks, for example: linelist\$`` ` '\x60infection date\x60'` ``. note that on your keyboard, the back-tick (\`) is different from the single quotation mark (').]{style="color: black;"}

### Nhãn {.unnumbered}

Some other statistical software such as SAS have variable *labels*

Một số phần mềm thống kê khác như SAS có *nhãn biến*

### Làm sạch tự động {.unnumbered}

The function `clean_names()` from the package **janitor** standardizes column names and makes them unique by doing the following:

Hàm `clean_names()` từ package **janitor** chuẩn hóa tên cột và biến chúng thành duy nhất bằng cách thực hiện như sau:

-   Chuyển đổi tất cả các tên cột thành chỉ bao gồm dấu gạch dưới, số và chữ cái
-   Các ký tự có dấu được chuyển ngữ sang dạng ASCII (ví dụ: o tiếng Đức với âm sắc trở thành "o", "enye" tiếng Tây Ban Nha trở thành "n")
-   Tùy chọn viết hoa cho tên cột mới có thể được chỉ định bằng cách sử dụng argument `case =` ("snake" là mặc định, các lựa chọn thay thế bao gồm "sentence", "title", "small_camel"...)
-   Bạn có thể chỉ định các tên thay thế cụ thể bằng cách cung cấp một vectơ cho argument `replace =` (ví dụ: `replace = c(onset = "date_of_onset")`)
-   Đây là một bộ dữ liệu [vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning) trực tuyến

Dưới đây, quy trình làm sạch bắt đầu bằng cách sử dụng hàm `clean_names()` trên từng dòng dữ liệu ban đầu.

```{r clean_names}
# pipe the raw dataset through the function clean_names(), assign result as "linelist"  
linelist <- linelist_raw %>% 
  janitor::clean_names()

# see the new column names
names(linelist)
```

[***GHI CHÚ***: Tên cột cuối cùng "... 28" đã được đổi thành "x28".]{style="color: black;"}

### Làm sạch tên cột thủ công {.unnumbered}

Việc đặt tên lại các cột theo cách thủ công thường là cần thiết, ngay cả sau bước chuẩn hóa ở trên. Dưới đây, việc đổi tên được thực hiện bằng cách sử dụng hàm `rename()` từ package **dplyr**, như một phần của quy trình. `rename()` sử dụng kiểu `NEW = OLD` - tên cột mới được đặt trước tên cột cũ.

Dưới đây, một lệnh đổi tên được thêm vào quy trình làm sạch. Các khoảng trắng đã được thêm vào một cách chọn lọc để căn chỉnh code dễ đọc hơn.

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
```

Bây giờ bạn có thể thấy rằng tên các cột đã được thay đổi:

```{r message=FALSE, echo=F}
names(linelist)
```

#### Thay đối tên cột theo vị trí {.unnumbered}

Bạn cũng có thể đổi tên theo vị trí cột, thay vì tên cột, ví dụ:

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### Đổi tên bằng hàm `select()` và `summarise()` {.unnumbered}

Như một mẹo, bạn cũng có thể đổi tên các cột bằng hàm `select()` và `summarise()` trong package **dplyr.** `select()` được sử dụng để chỉ giữ một số cột nhất định (và được đề cập sau trong chương này). `summarise()` được đề cập trong các chương [Grouping data] và [Descriptive tables]. Các hàm này cũng sử dụng định dạng `new_name = old_name`. Đây là một ví dụ:

```{r, eval=F}
linelist_raw %>% 
  select(# NEW name             # OLD name
         date_infection       = `infection date`,    # rename and KEEP ONLY these columns
         date_hospitalisation = `hosp date`)
```

### Các thách thức khác {.unnumbered}

#### Cột trống tên trên file Excel {.unnumbered}

R không thể nhận diện các cột trong bộ dữ liệu mà không có tên cột (tiêu đề). Vì vậy, nếu bạn nạp một bộ dữ liệu Excel có dữ liệu nhưng không có tiêu đề cột, R sẽ điền vào các tiêu đề đó mặc định như "... 1" hoặc "... 2". Phần số đại diện cho số cột (ví dụ: nếu cột thứ 4 trong bộ dữ liệu không có tiêu đề, thì R sẽ mặc định đặt tên là "... 4").

Bạn có thể làm sạch các tên cột này theo cách thủ công bằng cách tham chiếu số vị trí của chúng (xem ví dụ ở trên) hoặc tên được chỉ định của chúng (`linelist_raw$...1`).

#### Hợp nhất tên cột và ô Excel {.unnumbered}

Hợp nhất các ô trong file Excel là một sự cố thường xảy ra khi nhận dữ liệu. Như đã giải thích trong chương [Transition to R], các ô được hợp nhất có thể dễ nhìn cho con người đọc dữ liệu, nhưng không phải là "cấu trúc dữ liệu cơ bản" và gây ra nhiều vấn đề cho máy khi nhận diện dữ liệu. R không thể chứa các ô đã hợp nhất.

Nhắc nhở người nhập liệu rằng **dữ liệu có thể đọc được của con người không giống với dữ liệu mà máy có thể đọc được**. Cố gắng đào tạo người dùng về các nguyên tắc về [**tidy data**](https://r4ds.had.co.nz/tidy-data.html). Nếu có thể, hãy cố gắng thay đổi quy trình để dữ liệu có định dạng gọn gàng hơn mà không hợp nhất các ô.

-   Mỗi biến là một cột riêng biệt
-   Mỗi quan sát là một dòng riêng biệt
-   Mỗi giá trị là một ô riêng biệt

Khi sử dụng hàm `import()` của package **rio**, giá trị trong một ô đã hợp nhất sẽ được gán cho ô đầu tiên và các ô tiếp theo sẽ trống.

Một giải pháp để xử lý các ô đã hợp nhất là nạp dữ liệu bằng hàm `readWorkbook()` từ package **openxlsx**. Thiết lập mệnh đề `fillMergedCells = TRUE`. Điều này cho phép giá trị trong ô hợp nhất được tham chiếu cho tất cả các ô nằm trong phạm vi hợp nhất.

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

[***NGUY HIỂM***: Nếu các tên cột được hợp nhất với `readWorkbook()`, có thể sẽ trả về tên cột trùng lặp, mà bạn sẽ cần phải sửa thủ công - R không làm việc được với các tên cột trùng lặp! Bạn có thể đặt lại tên cho chúng bằng cách tham chiếu vị trí của chúng (ví dụ: cột 5), như được giải thích trong chương làm sạch tên cột thủ công.]{style="color: red;"}

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Chọn hoặc đổi vị trí cột

Sử dụng hàm `select()` từ package **dplyr** để chọn các cột bạn muốn giữ lại và sắp xếp lại thứ tự của chúng trong bộ dữ liệu.

[***LƯU Ý***`: Trong các ví dụ dưới đây, bộ dữ liệu linelist` `được điều chỉnh với hàm select() và biểu thị, nhưng không lưu. Phục vụ mục đích mô tả. Tên cột đã sửa đổi được biểu thị bằng cách chuyển tiếp bộ dữ liệu tới hàm names()`.]{style="color: orange;"}

**Here are ALL the column names in the linelist at this point in the cleaning pipe chain:**

**Dưới đây là TẤT CẢ các tên cột trong bộ dữ liệu linelist tại thời điểm làm sạch**:

```{r}
names(linelist)
```

### Giữ cột {.unnumbered}

**Giữ lại những cột mong muốn**

Viết tên cột cần giữ trong hàm `select()`, không có dấu ngoặc kép. Kết quả trả về sẽ xuất hiện trong bộ dữ liệu theo thứ tự mà bạn cung cấp. Lưu ý rằng nếu bạn chỉ định một cột không tồn tại, R sẽ báo lỗi (xem cách sử dụng hàm `any_of()` bên dưới nếu bạn không muốn gặp lỗi trong trường hợp này).

```{r}
# linelist dataset is piped through select() command, and names() prints just the column names
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # display the column names
```

### Hàm trợ giúp "tidyselect" {#clean_tidyselect .unnumbered}

Các hàm trợ giúp này được xây dựng để giúp bạn dễ dàng chỉ định các cột cần giữ, loại bỏ hoặc chuyển đổi. Chúng trong package **tidyselect**, nằm trong hệ sinh thái **tidyverse** và làm cơ sở cho cách chọn cột trong các hàm **dplyr**.

Ví dụ: nếu bạn muốn sắp xếp lại các cột, hàm `everything()` là một hàm hữu ích để biểu thị "tất cả các cột khác chưa được đề cập". Lệnh dưới đây di chuyển các cột `date_onset` và `date_hospitalisation` lên hàng đầu (bên trái) của bộ dữ liệu, nhưng vẫn giữ tất cả các cột khác sau đó. Lưu ý rằng hàm `everything()` được viết bằng dấu ngoặc đơn trống:

```{r}
# move date_onset and date_hospitalisation to beginning
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

Dưới đây là các hàm trợ giúp "tidyselect" khác cũng hoạt động *trong* các hàm **dplyr** như `select()`, `across()`, và `summarise()`:

-   `everything()` - tất cả các cột khác chưa được đề cập

-   `last_col()` - cột cuối cùng

-   `where()` - áp dụng một hàm cho tất cả các cột và chọn những cột trả về giá trị TRUE

-   `contains()` - cột chứa giá trị chuỗi ký tự

    -   Ví dụ: `select(contains("time"))`

-   `starts_with()` - khớp với các tiền tố được chỉ định

    -   Ví dụ: `select(starts_with("date_"))`

-   `ends_with()` - khớp với các hậu tố được chỉ định

    -   Ví dụ: `select(ends_with("_post"))`

-   `matches()` - để áp dụng một mệnh đề chính quy (regex)

    -   Ví dụ: `select(matches("[pt]al"))`

-   `num_range()` - một khoảng số học như x01, x02, x03

-   `any_of()` - khớp NẾU cột tồn tại nhưng không báo lỗi nếu không tìm thấy

    -   Ví dụ: `select(any_of(date_onset, date_death, cardiac_arrest))`

Ngoài ra, sử dụng các toán tử bình thường như `c()` để liệt kê một số cột, `:` cho các cột liên tiếp, `!` cho đối lập, `&` cho VÀ, và `|` cho HOẶC.

Sử dụng `where()` để chỉ định tiêu chí logic cho các cột. Nếu đưa một hàm vào trong `where()`, không đưa các dấu ngoặc đơn trống của hàm đó. Câu lệnh bên dưới chọn các cột là phân lớp Số.

```{r}
# select columns that are class Numeric
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

Sử dụng `contains()` để chọn các cột trong đó tên cột chứa một chuỗi ký tự được chỉ định. `ends_with()` và `starts_with()` cung cấp nhiều sắc thái để lựa chọn khác nhau.

```{r}
# select columns containing certain characters
linelist %>% 
  select(contains("date")) %>% 
  names()
```

Hàm `matches()` hoạt động tương tự như hàm `contains()` nhưng có thể được cung cấp một biểu thức chính quy (xem chương [Characters and strings]), chẳng hạn như nhiều chuỗi được phân tách bằng toán tự OR trong dấu ngoặc đơn:

```{r}
# searched for multiple character matches
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

[***LƯU Ý***: Nếu tên cột mà bạn đưa ra không tồn tại trong dữ liệu, máy có thể báo lỗi và dừng code của bạn. Cân nhắc sử dụng `any_of()` để trích dẫn các cột có thể hoặc không thể tồn tại, đặc biệt hữu ích trong các lựa chọn loại trừ (loại bỏ).]{style="color: orange;"}

Chỉ có một trong các cột này được giữ lại, nhưng không có lỗi được báo và code sẽ tiếp tục các bước trong quy trình làm sạch.

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```

### Xóa cột {.unnumbered}

**Chỉ ra cột nào cần loại bỏ** bằng cách đặt biểu tượng dấu trừ "-" ở phía trước tên cột (ví dụ chọn `select(-outcome)`) hoặc một vectơ tên cột (như bên dưới). Tất cả các cột khác sẽ được giữ nguyên.

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>% # remove date_onset and all columns from fever to vomit
  names()
```

Bạn cũng có thể xóa một cột bằng cú pháp trong **base** R, bằng cách xác định nó dưới dạng `NULL`. Ví dụ:

```{r, eval=F}
linelist$date_onset <- NULL   # deletes column with base R syntax 
```

### Độc lập {.unnumbered}

`select()` cũng có thể được sử dụng như một lệnh độc lập (không bắt buộc trong chuỗi các bước làm sạch). Trong trường hợp này, argument đầu tiên trong bộ dữ liệu gốc sẽ được tham chiếu.

```{r}
# Create a new linelist with id and age-related columns
linelist_age <- select(linelist, case_id, contains("age"))

# display the column names
names(linelist_age)
```

#### Thêm vào quy trình làm sạch {.unnumbered}

Trong bộ dữ liệu `linelist_raw`, có một vài cột chúng ta không cần: `row_num`, `merged_header`, và `x28`. Chúng tôi xóa chúng bằng lệnh `select()` trong các bước làm sạch:

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    #####################################################

    # remove column
    select(-c(row_num, merged_header, x28))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Lọc trùng-lặp

Xem chương [De-duplication] để biết các tùy chọn mở rộng về cách lọc trùng-lặp dữ liệu. Chỉ một ví dụ lọc trùng hàng rất đơn giản được trình bày ở đây.

Package **dplyr** cung cấp hàm `distinct()`. Hàm này kiểm tra mọi hàng và rút gọn bộ dữ liệu cho chỉ còn các hàng là duy nhất. Nghĩa là, nó loại bỏ 100% các hàng trùng-lặp.

Khi đánh giá các hàng trùng-lặp, nó sẽ thực hiện trên các cột được chỉ định - mặc định, nó xem xét tất cả các cột. Như trình bày trong chương lọc trùng-lặp, bạn có thể điều chỉnh phạm vi cột này để tính duy nhất của các hàng sẽ chỉ được đánh giá trong phạm vi một số cột nhất định.

Trong ví dụ đơn giản này, chúng ta chỉ cần thêm câu lệnh trống `distinct()` vào chuỗi các bước làm sạch. Điều này đảm bảo không có hàng nào là bản sao 100% của các hàng khác (được đánh giá trên tất cả các cột).

Chúng tôi bắt đầu với các hàng `nrow(linelist)` trong `linelist`.

```{r}
linelist <- linelist %>% 
  distinct()
```

Sau khi lọc trùng-lặp, có hàng `nrow(linelist)`. Bất kỳ hàng nào bị xóa cũng sẽ là 100% bản sao của các hàng khác.

Dưới đây, lệnh `distinct()` được thêm vào quy trình làm sạch:

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    #####################################################
    
    # de-duplicate
    distinct()
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Tạo và biến đổi cột

**Chúng tôi khuyến khích sử dụng hàm `mutate()` trong package dplyr để thêm một cột mới hoặc để sửa đổi một cột sẵn có.**

Dưới đây là một ví dụ về tạo cột mới với hàm `mutate()`. Cú pháp là: `mutate(new_column_name = value or transformation)`

Trong Stata, điều này tương tự như lệnh `generate`, nhưng hàm `mutate()` trong R cũng có thể được sử dụng để điều chỉnh cột sẵn có.

### Tạo cột mới {.unnumbered}

Tính năng cơ bản nhất của hàm `mutate()` là để tạo một cột mới, có thể thấy trong ví dụ dưới đây. Nó tạo một cột mới `new_col` trong đó giá trị trong mỗi hàng đều là 10.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

Bạn cũng có thể tham chiếu các giá trị trong các cột khác, để thực hiện phép tính toán. Dưới đây, cột mới `bmi` được tạo để tính chỉ số khối cơ thể (BMI) cho mỗi trường hợp - như được tính bằng công thức BMI = kg/m\^2, sử dụng cột `ht_cm` và cột `wt_kg`.

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

Nếu tạo nhiều cột mới, hãy tách riêng từng cột bằng dấu phẩy và dòng mới. Dưới đây là các ví dụ về tạo các cột mới, bao gồm các cột mà chứa các giá trị từ các cột khác kết hợp bằng hàm `str_glue()` từ package **stringr** (xem chương [Characters and strings].

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # new column = duplicate/copy another existing column
    new_var_static = 7,                   # new column = all values the same
    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") # new column = pasting together values from other columns
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        # show only new columns, for demonstration purposes
```

Đánh giá các cột mới. Đối với mục tiêu minh họa, chỉ các cột mới và các cột được sử dụng để tạo tạo cột mới được hiển thị:

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[***MẸO***: Một biến thể của hàm `mutate()` là hàm `transmute()`. Hàm này thêm một cột mới giống như `mutate()`, nhưng cũng bỏ/xóa tất cả các cột khác mà bạn không đề cập trong dấu ngoặc đơn của hàm.]{style="color: darkgreen;"}

```{r, eval=F}
# HIDDEN FROM READER
# removes new demo columns created above
# linelist <- linelist %>% 
#   select(-contains("new_var"))
```

### Chuyển đổi phân lớp của cột {.unnumbered}

Các cột chứa giá trị là ngày tháng, số hoặc giá trị logic (TRUE/FALSE) sẽ chỉ hoạt động như mong đợi nếu chúng được phân loại chính xác. Có sự khác biệt giữa "2" của phân lớp ký tự và 2 của phân lớp số!

Có nhiều cách để chọn phân lớp cho cột trong các lệnh nạp, nhưng thường phức tạp. Xem chương [R Basics] về các lớp đối tượng để tìm hiểu thêm về cách chuyển đổi phân lớp đối tượng và cột.

Đầu tiên, hãy kiểm tra các cột quan trọng để xem chúng đã đúng định dạng chính xác chưa. Chúng tôi cũng đã thấy điều này ngay từ khi chúng tôi chạy lệnh `skim()`.

Hiện tại, phân lớp của cột `age` là dạng ký tự. Để thực hiện các phân tích định lượng, chúng ta cần những giá trị số này được nhận biết là dạng số!

```{r}
class(linelist$age)
```

Phân lớp của cột `date_onset` cũng là ký tự! Để thực hiện phân tích, những cột ngày này phải được nhận biết là dạng ngày tháng!

```{r}
class(linelist$date_onset)
```

Để giải quyết vấn đề này, hãy sử dụng hàm `mutate()` để định dạng và chuyển đổi lại một cột. Chúng tôi giữ nguyên cột đó và định dạng lại sang một phân lớp khác. Đây là một ví dụ cơ bản, chuyển đổi hoặc đảm bảo rằng cột `age` là phân lớp dạng số:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

Theo cách tương tự, bạn có thể sử dụng hàm `as.character()` và hàm `as.logical()`. Để chuyển đổi sang phân lớp định tính, bạn có thể sử dụng hàm `factor()` từ **base** R hoặc hàm `as_factor()` từ package **forcats**. Đọc thêm ở chương [Factors].

Bạn phải cẩn thận khi chuyển đổi sang phân lớp Ngày. Một số phương pháp được giải thích rõ hơn ở chương [Working with dates]. Thông thường, tất cả các giá trị ngày ban đầu phải ở cùng một định dạng cần chuyển đổi để có thể sử dụng (ví dụ: "MM/DD/YYYY" hoặc "DD MM YYYY"). Sau khi chuyển đổi thành thành phân lớp Ngày, hãy kiểm tra dữ liệu của bạn để xác nhận rằng mỗi giá trị đã được chuyển đổi chính xác.

### Nhóm dữ liệu {.unnumbered}

Nếu bộ dữ liệu của bạn đã được *nhóm* (xem chương [Grouping data]), hàm `mutate()` có thể hoạt động khác so với nếu bộ dữ liệu không được nhóm. Bất kỳ hàm tổng hợp nào, như `mean()`, `median()`, `max()`, v.v. sẽ tính theo nhóm, không phải theo tất cả các hàng.

```{r, eval=F}
# age normalized to mean of ALL rows
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# age normalized to mean of hospital group
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

Đọc thêm về cách sử dụng hàm `mutate()` trên các bộ dữ liệu được nhóm ở [tài liệu về mutate trong package tidyverse](https://dplyr.tidyverse.org/reference/mutate.html).

### Chuyển đổi nhiều cột {#clean_across .unnumbered}

Thông thường, để viết mã ngắn gọn, bạn muốn áp dụng cùng một biến đổi cho nhiều cột cùng một lúc. Một cách chuyển đổi có thể được áp dụng cho nhiều cột cùng một lúc bằng cách sử dụng hàm `across()` từ package **dplyr** (cũng trong package **tidyverse**). Hàm `across()` có thể được sử dụng với bất kỳ hàm nào trong packe **dplyr**, nhưng thường được sử dụng với hàm `select()`, `mutate()`, `filter()`, hoặc `summarise()`. Xem cách sử dụng hàm `summarise()` trong chương [Descriptive tables].

Chỉ định các cột bằng argument `.cols =` và các hàm để sử dụng bằng `.fns =`. Bất kỳ argument bổ sung nào để cung cấp cho hàm `.fns` đều có thể được bao gồm sau dấu phẩy, vẫn nằm trong hàm `across()`.

#### Lựa chọn cột với hàm `across()` {.unnumbered}

Chỉ định các cột bằng argument `.cols =`. Bạn có thể đặt tên riêng cho chúng hoặc sử dụng tính năng trợ giúp "tidyselect". Chỉ định hàm bằng `.fns =`. Lưu ý rằng cách sử dụng hàm được trình bày bên dưới, hàm được viết mà *không có* dấu ngoặc đơn ().

Ở đây, phép biến đổi `as.character()` được áp dụng cho tên cột cụ thể trong hàm `across()`.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

The "tidyselect" helper functions are available to assist you in specifying columns. They are detailed above in the section on Selecting and re-ordering columns, and they include: `everything()`, `last_col()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()` and `any_of()`.

Các tính năng trợ giúp "tidyselect" có sẵn để hỗ trợ bạn trong việc chỉ định các cột. Chúng được trình bày chi tiết ở trên trong chương Chọn và sắp xếp thứ tự cột, bao gồm: `everything()`, `last_col()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()` và `any_of()`.

Đây là một ví dụ về cách thay đổi tất cả các cột thành phân lớp dạng ký tự:

```{r, eval=F}
#to change all columns to character class
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

Chuyển đổi tất cả các cột thành dạng ký tự có tên chứa chuỗi ký tự "date" (lưu ý vị trí của dấu phẩy và dấu ngoặc đơn):

```{r, eval=F}
#to change all columns to character class
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

Below, an example of mutating the columns that are currently class POSIXct (a raw datetime class that shows timestamps) - in other words, where the function `is.POSIXct()` evaluates to `TRUE`. Then we want to apply the function `as.Date()` to these columns to convert them to a normal class Date.

Dưới đây, một ví dụ về việc thay đổi các cột hiện là phân lớp POSIXct (một phân lớp datetime thô hiển thị timestamps) - nói cách khác, hàm `is.POSIXct()` đánh giá là `TRUE`. Sau đó, chúng tôi muốn áp dụng hàm `as.Date()` cho các cột này để chuyển đổi chúng thành phân lớp Ngày thông thường.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

-   Lưu ý rằng trong hàm `across()`, chúng tôi cũng sử dụng hàm `where()` như `is.POSIXct` được đánh giá là TRUE hoặc FALSE.\
-   Lưu ý rằng hàm `is.POSIXct()` là từ package **lubridate**. Các hàm "is" tương tự khác như `is.character()`, `is.numeric()`, và `is.logical()` từ **base R**

#### Hàm `across()` {.unnumbered}

Bạn có thể đọc tài liệu với hàm `?across` để biết chi tiết về cách sử dụng hàm `across()`. Một vài điểm tóm tắt: có một số cách để chỉ định (các) hàm để thực hiện trên một cột và bạn thậm chí có thể tự chỉ định các chức năng:

-   Bạn có thể chỉ cung cấp tên hàm (ví dụ: `mean` hoặc `as.character`)\

-   Bạn có thể cung cấp hàm theo kiểu **purrr** (ví dụ: `~ mean(.x, na.rm = TRUE)`) (xem chương [Iteration, loops, and lists])\

-   Bạn có thể chỉ định nhiều hàm bằng cách cung cấp danh sách (ví dụ: `list(mean = mean, n_miss = ~ sum(is.na(.x))`).

    -   Nếu bạn cung cấp nhiều hàm, nhiều cột được chuyển đổi sẽ được trả về trên mỗi cột ban đầu, với các tên duy nhất theo định dạng `col_fn`. Bạn có thể điều chỉnh cách đặt tên các cột mới với argument `.names =` bằng cách sử dụng cú pháp **glue** (xem chương [Characters and strings]) trong đó `{.col}` và `{.fn}` được viết tắt cho cột và hàm đầu vào.

Dưới đây là một số tài nguyên trực tuyến về cách sử dụng hàm `across()`: [creator Hadley Wickham's thoughts/rationale](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/)

### Hàm `coalesce()` {.unnumbered}

Hàm **dplyr** tìm giá trị không bị thiếu đầu tiên tại mỗi vị trí. Nó "điền vào" các giá trị còn thiếu với giá trị có sẵn đầu tiên theo thứ tự bạn chỉ định.

Đây là một ví dụ *ngoài phạm vi của bộ dữ liệu*: Giả sử bạn có hai vectơ, một vectơ chứa làng của bệnh nhân được phát hiện và một vectơ chứa làng của bệnh nhân cư trú . Bạn có thể sử dụng hàm `coalesce()` để chọn giá trị không bị thiếu đầu tiên cho mỗi biến số:

```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # print
```

Điều này hoạt động tương tự nếu bạn cung cấp các cột trong bộ dữ liệu: đối với mỗi hàng, hàm sẽ gán giá trị cột mới với giá trị không bị thiếu đầu tiên trong các cột bạn đã cung cấp (theo thứ tự được cung cấp).

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

This is an example of a "row-wise" operation. For more complicated row-wise calculations, see the section below on Row-wise calculations.

Đây là một ví dụ về thao tác "theo hàng (row-wise)". Để biết các phép tính theo hàng phức tạp hơn, hãy xem chương bên dưới về Tính toán theo hàng.

### Toán lũy tích {.unnumbered}

Nếu bạn muốn một cột phản ánh tổng tích lũy/trung bình/tối thiểu/tối đa, v.v. như được đánh giá xuống các hàng của bộ dữ liệu cho đến thời điểm đó, hãy sử dụng các hàm sau:

`cumsum()` trả về tổng lũy tích, như được hiển thị bên dưới:

```{r}
sum(c(2,4,15,10))     # returns only one number
cumsum(c(2,4,15,10))  # returns the cumulative sum at each step
```

Điều này có thể được sử dụng trong bộ dữ liệu khi tạo một cột mới. Ví dụ: để tính toán số ca lũy tích mỗi ngày trong một đợt bùng dịch, hãy xem xét đoạn code như sau:

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # begin with case linelist
  count(date_onset) %>%                 # count of rows per day, as column 'n'   
  mutate(cumulative_cases = cumsum(n))  # new column, of the cumulative sum at each row
```

Dưới đây là 10 hàng đầu tiên:

```{r}
head(cumulative_case_counts, 10)
```

Xem chương [Epidemic curves] để biết cách lập biểu đồ tỷ lệ lũy tích với epicurve.

Xem thêm:\
`cumsum()`, `cummean()`, `cummin()`, `cummax()`, `cumany()`, `cumall()`

### Sử dụng **base** R {.unnumbered}

Để định dạng một cột mới (hoặc định dạng lại một cột) bằng cách sử dụng **base** R, hãy viết tên của bộ dữ liệu, được liên kết với `$`, vào cột *mới* (hoặc cột được sửa đổi). Sử dụng toán tử gán `<-` để xác định (các) giá trị mới. Hãy nhớ rằng khi sử dụng **base** R, bạn phải chỉ định tên bộ dữ liệu trước tên cột (ví dụ: `dataframe$column`). Đây là một ví dụ về cách tạo cột `bmi` bằng cách sử dụng **base** R:

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

### Thêm vào chuỗi xử lý {.unnumbered}

**Dưới đây, một cột mới được thêm vào chuỗi các bước xử lý và một số phân lớp được chuyển đổi.**

```{r }
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################
    # add new column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```

## Mã hóa lại giá trị

Dưới đây là một số tình huống mà bạn cần mã hóa lại (thay đổi) các giá trị:

-   để chỉnh sửa một giá trị cụ thể (ví dụ: một ngày có năm hoặc định dạng không chính xác)
-   để hợp nhất các giá trị không được đánh vần giống nhau
-   để tạo một cột chứa giá trị phân loại mới
-   để tạo một cột chứa danh mục số mới (ví dụ: danh mục độ tuổi)

### Giá trị cụ thể {.unnumbered}

Để thay đổi các giá trị theo cách thủ công, bạn có thể sử dụng hàm `recode()` trong hàm `mutate()`.

Hãy tưởng tượng có một ngày không bình thường trong dữ liệu (ví dụ: "2014-14-15"): bạn có thể sửa ngày theo cách thủ công trong dữ liệu nguồn thô hoặc, bạn có thể ghi thay đổi trong chuỗi các bước làm sạch thông qua `mutate()` và `recode()`. Phần sau đó sẽ rõ ràng hơn và có thể dựng lại cho bất kỳ ai khác muốn hiểu hoặc lặp lại phân tích của bạn.

```{r, eval=F}
# fix incorrect values                   # old value       # new value
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Dòng `mutate()` ở trên có thể được đọc là: "biến đổi cột `date_onset` để bằng với cột `date_onset` được mã hóa lại để GIÁ TRỊ CŨ được đổi thành GIÁ TRỊ MỚI". Lưu ý rằng pattern này (CŨ = MỚI) của hàm `recode()` ngược lại với hầu hết các pattern trong R (mới = cũ). Cộng đồng phát triển R đang làm việc để sửa đổi điều này.

**Đây là một ví dụ khác về việc mã hóa lại nhiều giá trị trong một cột.**

Trong bộ dữ liệu `linelist` , các giá trị trong cột "hospital" phải được làm sạch. Có một số cách viết khác nhau và nhiều giá trị bị thiếu.

```{r}
table(linelist$hospital, useNA = "always")  # print table of all unique values, including missing  
```

Lệnh `recode()` bên dưới định dạng lại cột "hospital" là cột hiện tại "hospital", nhưng với các thay đổi mã hóa được chỉ định. Đừng quên dấu phẩy sau mỗi chỉ định!

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # for reference: OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```

Bây giờ chúng ta thấy các cách viết trong cột `hospital` đã được sửa chữa và hợp nhất:

```{r}
table(linelist$hospital, useNA = "always")
```

[***MẸO***: Số lượng khoảng trắng trước và sau dấu bằng không quan trọng. Làm cho mã của bạn dễ đọc hơn bằng cách căn chỉnh dấu = cho tất cả hoặc hầu hết các hàng. Ngoài ra, hãy cân nhắc thêm hàng bình luận để làm rõ cho người đọc bên nào CŨ và bên nào MỚI.]{style="color: darkgreen;"}

[***MẸO***: Đôi khi tồn tại một giá trị ký tự *trống* trong bộ dữ liệu (không được nhận dạng là giá trị của R vì bị thiếu - `NA`). Bạn có thể tham chiếu giá trị này bằng hai dấu ngoặc kép không có khoảng trắng ở giữa ("").]{style="color: darkgreen;"}

### Theo logic {.unnumbered}

Dưới đây, chúng tôi trình bày cách mã hóa lại các giá trị trong một cột bằng cách sử dụng logic và điều kiện:

-   Sử dụng hàm `replace()`, `ifelse()` và `if_else()` cho logic đơn giản
-   Sử dụng hàm `case_when()` cho logic phức tạp

### Logic đơn giản {.unnumbered}

#### `replace()` {.unnumbered}

Để viết lại mã với các tiêu chí logic đơn giản, bạn có thể sử dụng `replace()` trong `mutate()`. `replace()` là một hàm từ **base** R. Sử dụng một điều kiện logic để chỉ định các hàng cần thay đổi. Cú pháp chung là:

`mutate(col_to_change = replace(col_to_change, criteria for rows, new value))`.

Một tình huống phổ biến để sử dụng `replace()` để chỉ **thay đổi một giá trị trong một hàng, bằng cách sử dụng định danh hàng duy nhất**. Dưới đây, giới tính được thay đổi thành "Female" trong hàng có cột `case_id` là "2195".

```{r, eval=F}
# Example: change gender of one specific observation to "Female" 
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

Lệnh tương tự sử dụng cú pháp trong **base** R và dấu ngoặc vuông [] ở bên dưới. Nó có nội dung là "Thay đổi giá trị của cột `gender` trong bộ dữ liệu `linelist` (đối với các hàng mà cột `case_id` của `linelist` có giá trị '2195') thành 'Female' ".

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```

#### `ifelse()` và `if_else()` {.unnumbered}

Một cách khác áp dụng cho logic đơn giản là hàm `ifelse()` và hàm tương tự là `if_else()`. Tuy nhiên, trong hầu hết các trường hợp để mã hóa lại rõ ràng hơn là sử dụng hàm `case_when()` (chi tiết bên dưới). Câu lệnh "if else" này là các phiên bản đơn giản hóa của câu lệnh lập trình `if` và `else`. Cú pháp chung là:\
`ifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)`

Dưới đây, cột `source_known` được chỉ định. Giá trị của nó trong một hàng được đặt thành "known" nếu giá trị của hàng trong cột `source` không bị thiếu. Nếu thiếu giá trị trong cột `source`, thì giá trị trong `source_known` được đặt thành "unknown".

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

`if_else()` là một phiên bản đặc biệt từ package **dplyr** để xử lý ngày tháng. Lưu ý rằng nếu giá trị 'true' là một ngày thì giá trị 'false' cũng phải đủ điều kiện là một ngày, do đó sử dụng giá trị đặc biệt `NA_real_` thay vì chỉ `NA`.

```{r, eval=F}
# Create a date of death column, which is NA if patient has not died.
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

**Tránh lồng ghép nhiều lệnh ifelse với nhau... thay vào đó hãy sử dụng `case_when()`!** `case_when()` dễ đọc hơn và bạn sẽ mắc ít lỗi hơn.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```

Ngoài phạm vi của bộ dữ liệu, nếu bạn muốn một đối tượng được sử dụng trong code của mình chuyển đổi giá trị của nó, hãy xem xét sử dụng hàm `switch()` từ **base** R.

### Logic phức tạp {#clean_case_when .unnumbered}

Sử dụng `case_when()` của package **dplyr** nếu bạn đang mã hóa lại thành nhiều nhóm mới hoặc nếu bạn cần sử dụng các câu lệnh logic phức tạp để mã hóa lại các giá trị. Hàm này đánh giá mọi hàng trong bộ dữ liệu, đánh giá xem các hàng có đáp ứng các tiêu chí đã chỉ định hay không và chỉ định giá trị mới chính xác.

Câu lệnh `case_when()` bao gồm hai cấu phần là Right-Hand Side (RHS) và Left-Hand Side (LHS) được phân tách bằng "dấu ngã" `~`. Các tiêu chí logic nằm ở phía bên trái và các giá trị hoàn toàn nằm ở phía bên phải của mỗi câu lệnh. Các câu lệnh được phân tách bằng dấu phẩy.

Ví dụ: chúng tôi sử dụng cột `age` và `age_unit` để tạo cột `age_years`:

```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # if age is given in years
            age_unit == "months" ~ age/12,    # if age is given in months
            is.na(age_unit)      ~ age,       # if age unit is missing, assume years
            TRUE                 ~ NA_real_)) # any other circumstance, assign missing
```

Khi mỗi hàng trong dữ liệu được đánh giá, các tiêu chí được áp dụng/đánh giá theo thứ tự đã viết trong `case_when()` - từ trên xuống dưới. Nếu tiêu chí hàng đầu đánh giá là `TRUE` cho một hàng nhất định, giá trị RHS sẽ được chỉ định và các tiêu chí còn lại thậm chí không được kiểm tra cho hàng đó. Vì vậy, tốt nhất là bạn nên viết các tiêu chí cụ thể nhất trước và cuối cùng là tiêu chí chung chung.

Dọc theo những dòng đó, trong dòng lệnh cuối cùng của bạn, hãy đặt `TRUE` ở phía bên trái, sẽ ghi lại bất kỳ hàng nào không đáp ứng bất kỳ tiêu chí nào trước đó. Phía bên phải của câu lệnh này có thể được gán một giá trị như "kiểm tra tôi!" hoặc thiếu giá trị.

[***LƯU Ý***: Các giá trị ở phía bên phải đều phải cùng một phần lớp - số, ký tự, ngày tháng, lôgic, v.v. Để gán giá trị thiếu (NA), bạn có thể cần sử dụng các biến thể đặc biệt của `NA` như `NA_character_`, `NA_real_` (cho số hoặc POSIX) và `as.Date(NA)`. Đọc thêm trong chương [Working with dates].]{style="color: red;"}

### Giá trị thiếu {.unnumbered}

Dưới đây là các chức năng đặc biệt để xử lý các giá trị bị thiếu trong khi làm sạch dữ liệu.

Xem chương về [Missing data] để biết thêm các mẹo chi tiết về xác định và xử lý các giá trị bị thiếu. Ví dụ, hàm `is.na()` kiểm tra một cách logic sự thiếu giá trị.

**`replace_na()`**

Để thay đổi các giá trị bị thiếu (`NA`) thành một giá trị cụ thể, chẳng hạn như "Missing", hãy sử dụng hàm `replace_na()` trong hàm `mutate()` trong package **dplyr**. Lưu ý rằng điều này được sử dụng theo cách tương tự như `recode` ở trên - tên của biến phải được lặp lại trong `replace_na()`.

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

**fct_explicit_na()**

Đây là một chức năng từ package **forcats**. Package **forcats** xử lý các cột dạng phân loại. Phân loại là cách của R để xử lý các giá trị có thứ tự như `c("First", "Second", "Third")` hoặc để thiết lập thứ tự cho các giá trị (ví dụ: bệnh viện) xuất hiện trong bảng và biểu đồ. Xem chương [Factors].

Nếu dữ liệu của bạn là biến dạng phân loại và bạn cố gắng chuyển giá trị `NA` thành "Missing" bằng cách sử dụng `replace_na()`, bạn sẽ gặp lỗi này: `invalid factor level, NA generated`. Bạn đã cố gắng thêm "Missing" làm giá trị, trong khi nó có thể không được xác định là một lớp trong biến phân loại, và câu lệnh bị từ chối.

Cách dễ nhất để giải quyết vấn đề này là sử dụng hàm **forcats** `fct_explicit_na()` để chuyển đổi một cột thành phân lớp dạng phân loại và chuyển đổi các giá trị `NA` thành ký tự "(Missing)".

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

Một giải pháp thay thế chậm hơn sẽ là thêm lớp phân loại bằng cách sử dụng hàm `fct_expand()` và sau đó chuyển đổi các giá trị bị thiếu.

**`na_if()`**

Để chuyển đổi một *giá trị cụ thể* thành `NA`, hãy sử dụng `na_if()` trong package **dplyr**. Lệnh dưới đây thực hiện thao tác ngược lại với `replace_na()`. Trong ví dụ bên dưới, bất kỳ giá trị nào bị "Missing" trong `hospital` cột đều được chuyển đổi thành `NA`.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

Lưu ý: `na_if()` **không thể sử dụng cho tiêu chí logic** (ví dụ: "all values \> 99") - hãy sử dụng `replace()` or `case_when()` cho điều này:

```{r, eval=F}
# Convert temperatures above 40 to NA 
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# Convert onset dates earlier than 1 Jan 2000 to missing
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

### Từ điển làm sạch {.unnumbered}

Sử dụng package **linelist** trong R và hàm `clean_variable_spelling()` để làm sạch bộ dữ liệu bằng *từ điển làm sạch*. **linelist** là một package được phát triển bởi [RECON](https://github.com/reconhub/linelist) - R Epidemics Consortium.

1)  Tạo từ điển làm sạch với 3 cột:

    -   Cột "từ" (giá trị không chính xác)\
    -   Cột "tới" (giá trị chính xác)\
    -   Một cột chỉ định cột cho các thay đổi sẽ được áp dụng (hoặc ".global" để áp dụng cho tất cả các cột)

Lưu ý: các mục từ điển .global sẽ bị ghi đè bởi các mục từ điển theo cột cụ thể.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```

2)  Nạp tệp từ điển vào R. Ví dụ này có thể được tải xuống theo hướng dẫn trong chương [Download handbook and data].

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3)  Chuyển bộ dữ liệu linelist ban đầu đến hàm `clean_variable_spelling()`, xác định `wordlists =` bộ dữ liệu từ điển làm sạch. Argument `spelling_vars =` có thể được sử dụng để chỉ định cột nào trong từ điển tham chiếu đến các cột khác (cột thứ 3 theo mặc định) hoặc có thể được đặt thành `NULL` để từ điển áp dụng cho tất cả các cột dạng ký tự và phân loại. Lưu ý rằng chức năng này có thể mất nhiều thời gian để chạy.

```{r}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        # dict column containing column names, defaults to 3rd column in dict
  )
```

Bây giờ, hãy cuộn sang bên phải để xem các giá trị đã thay đổi như thế nào - đặc biệt là `gender` (chữ thường thành chữ hoa) và tất cả các cột triệu chứng đã được chuyển từ có/không thành 1/0.

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Lưu ý rằng tên cột của bạn trong từ điển làm sạch phải tương ứng với tên *tại thời điểm* này trong tệp lệnh làm sạch của bạn. Xem [online reference for the linelist package](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html) để biết thêm chi tiết.

#### Thêm vào chuỗi làm sạch {.unnumbered}

**Bên dưới, một số cột và biến đổi cột mới được thêm vào chuỗi các bước làm sạch.**

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 
  
    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
   # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
   ###################################################

    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Biến danh mục số {#num_cats}

Ở đây chúng tôi mô tả một số cách tiếp cận đặc biệt để tạo cột dạng danh mục từ các cột dạng số. Các ví dụ phổ biến bao gồm danh mục độ tuổi, nhóm giá trị trong phòng thí nghiệm, v.v. Ở đây chúng ta sẽ thảo luận:

-   `age_categories()`, từ package **epikit**\
-   `cut()`, từ **base** R\
-   `case_when()`\
-   Chia khoảng phân vị với `quantile()` and `ntile()`

### Đánh giá phân phối {.unnumbered}

Trong ví dụ này, chúng tôi sẽ tạo một cột `age_cat` bằng cách sử dụng cột `age_years`.

```{r}
#check the class of the linelist variable age
class(linelist$age_years)
```

Trước tiên, hãy kiểm tra việc phân phối dữ liệu của bạn để đưa ra các điểm cắt thích hợp. Xem chương [ggplot basics].

```{r, out.height='50%'}
# examine the distribution
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

[***CHÚ Ý***: Đôi khi, các biến số sẽ nhập dưới dạng phân lớp "ký tự". Điều này xảy ra nếu có các ký tự không phải số trong một số giá trị, ví dụ: có bản ghi nhập "2 tháng" cho biến tuổi hoặc (tùy thuộc vào cài đặt ngôn ngữ R của bạn) nếu dấu phẩy được sử dụng cho số thập phân (ví dụ: "4,5 "nghĩa là bốn rưỡi).]{style="color: orange;"}

<!-- ======================================================= -->

### `age_categories()` {.unnumbered}

Với package **epikit**, bạn có thể sử dụng hàm `age_categories()` để dễ dàng phân loại và gắn nhãn các cột dạng số (lưu ý: hàm này cũng có thể được áp dụng cho các biến ngoài biến tuổi). Như một "bonum", cột trả về tự động là một cột dạng danh mục có thứ tự.

Dưới đây là các yêu cầu ban đầu:

-   Một vectơ số (cột)\
-   Argument `breakers =` - cung cấp một vectơ số của các điểm cắt cho các phân nhóm mới.

Đầu tiên, ví dụ đơn giản nhất:

```{r}
# Simple example
################
pacman::p_load(epikit)                    # load package

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70)))

# show table
table(linelist$age_cat, useNA = "always")
```

Các giá trị cắt bạn chỉ định mặc định là các giới hạn thấp hơn - nghĩa là chúng được đưa vào nhóm "cao hơn"/các nhóm "mở" ở phía dưới/bên trái. Như trình bày dưới đây, bạn có thể thêm 1 vào mỗi giá trị cắt để đạt được các nhóm mà được "mở" ở trên cùng/bên phải.

```{r}
# Include upper ends for the same categories
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

# show table
table(linelist$age_cat, useNA = "always")
```

Bạn có thể điều chỉnh cách hiển thị nhãn bằng `separator =`. Giá trị mặc định là "-"

Bạn có thể điều chỉnh cách xử lý các số ở hàng đầu, với arguemnt `ceiling =`. Để thiết lập mức giới hạn trên với `ceiling = TRUE`. Trong cách sử dụng này, giá trị cắt cao nhất được cung cấp là "ceiling" và danh mục "XX+" không được tạo. Bất kỳ giá trị nào trên giá trị cắt cao nhất (hoặc `upper =`, nếu được xác định) đều được phân loại là `NA`. Dưới đây là một ví dụ với `ceiling = TRUE`, do đó không có danh mục nào là XX + và các giá trị trên 70 (giá trị cắt cao nhất) được chỉ định là NA.

```{r}
# With ceiling set to TRUE
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 is ceiling, all above become NA

# show table
table(linelist$age_cat, useNA = "always")
```

Ngoài ra, thay vì `breakers =`, bạn có thể sử dụng hàm `lower =`, `upper =`, và `by =`:

-   `lower =` Mức giới hạn thấp nhất bạn muốn xem xét - mặc định là 0\
-   `upper =` Mức giới hạn cao nhất bạn muốn xem xét\
-   `by =` Khoảng cách "năm" giữa các nhóm

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# show table
table(linelist$age_cat, useNA = "always")
```

Xem chương Tính năng trợ giúp để biết thêm chi tiết (nhập `?age_categories` trong bảng điều khiển R).

<!-- ======================================================= -->

### `cut()` {.unnumbered}

`cut()` là một hàm trong thay trong **base R** cho hàm `age_categories()`, nhưng tôi nghĩ bạn sẽ thấy lý do tại sao `age_categories()` được phát triển để đơn giản hóa quá trình này. Một số khác biệt đáng chú ý từ `age_categories()` là:

-   Bạn không cần cài đặt/gọi package khác\
-   Bạn có thể chỉ định xem các nhóm đang mở/đóng ở bên phải/bên trái\
-   Bạn cần phải cung cấp nhãn chính xác\
-   Nếu bạn muốn 0 được thêm vào trong nhóm thấp nhất, bạn cần phải chỉ định điều này

Cú pháp cơ bản trong `cut()` trước tiên là cung cấp cột số cần xử lý (`age_years`), sau đó là argument *cắt*, là một vectơ số `c()` bao gồm các điểm cắt. Sử dụng `cut()`, kết quả trả về là cột phân loại theo thứ tự.

Mặc định, việc phân loại xảy ra sao cho phía bên phải/phía trên là "mở" và bao gồm (và phía bên trái/phía dưới là "đóng" hoặc riêng biệt). Đây là hành động ngược lại với hàm `age_categories()`. Các nhãn mặc định sử dụng ký hiệu "(A,B]", có nghĩa là A không được bao gồm nhưng B thì có. **Đảo ngược hành động này bằng cách cung cấp** **argument `right = TRUE`**.

Do đó, theo mặc định, các giá trị "0" bị loại trừ khỏi nhóm thấp nhất và được phân loại là `NA`! Giá trị "0" có thể là trẻ sơ sinh được mã hóa là 0 tuổi, vì vậy hãy thật thận trọng! Để thay đổi điều này, hãy thêm argument `include.lowest = TRUE` để mọi giá trị "0" sẽ được đưa vào nhóm thấp nhất. Nhãn được tạo tự động cho danh mục thấp nhất sau đó sẽ là "[A],B]". Lưu ý rằng nếu bạn thêm `include.lowest = TRUE` **và** `right = TRUE`, hành động này bây giờ sẽ áp dụng cho điểm cắt giá trị *cao nhất* và phân loại, không phải điểm thấp nhất.

Bạn có thể cung cấp một vectơ nhãn tùy chỉnh bằng cách sử dụng argument `labels =`. Vì chúng được viết theo cách thủ công, hãy rất cẩn thận để đảm bảo chúng chính xác! Kiểm tra cách sử dụng của bạn bằng cách lập bảng chéo, như được mô tả bên dưới.

Dưới đây là một ví dụ về `cut()` được áp dụng cho `age_years` để tạo biến `age_cat` mới:

```{r}
# Create new variable, by cutting the numeric age variable
# lower break is excluded but upper break is included in each category
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # include 0 in lowest group
      ))

# tabulate the number of observations per group
table(linelist$age_cat, useNA = "always")
```

**Kiểm tra đoạn code của bạn!!!** Xác minh rằng mỗi giá trị độ tuổi đã được chỉ định đúng danh mục bằng cách lập bảng chéo giữa các cột số và danh mục. Kiểm tra việc gán các giá trị ranh giới (ví dụ: 15, nếu các danh mục lân cận là 10-15 và 16-20).

```{r}
# Cross tabulation of the numeric and category columns. 
table("Numeric Values" = linelist$age_years,   # names specified in table for clarity.
      "Categories"     = linelist$age_cat,
      useNA = "always")                        # don't forget to examine NA values
```

**Gán nhãn giá trị `NA`**

Bạn có thể muốn gán nhãn cho các giá trị `NA` chẳng hạn như "Missing". Bởi vì cột mới là phân lớp phân loại (giá trị bị hạn chế), bạn không thể chỉ đơn giản thay đổi nó bằng `replace_na()`, vì giá trị này sẽ không được chấp nhận. Thay vào đó, hãy sử dụng `fct_explicit_na()` từ **forcats** như được giải thích trong chương [Factors].

```{r}
linelist <- linelist %>% 
  
  # cut() creates age_cat, automatically of class Factor      
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # make missing values explicit
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # you can specify the label
  )    

# table to view counts
table(linelist$age_cat, useNA = "always")
```

**Tạo nhanh điểm cắt và dán nhãn**

Để có một cách nhanh chóng để tạo điểm cắt và gắn nhãn vectơ, hãy thực hành như bên dưới. Xem chương [R basics] về hàm `seq()` và `rep()`.

```{r, eval=F}
# Make break points from 0 to 90 by 5
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# Make labels for the above categories, assuming default cut() settings
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# check that both vectors are the same length
length(age_seq) == length(age_labels)
```

Đọc thêm về hàm `cut()` trong chươngTrợ giúp bằng cách nhập `?cut` trong bảng điều khiển R.

### Chia khoảng phân vị {.unnumbered}

Theo cách hiểu thông thường, "phân vị" hoặc "phần trăm" thường đề cập đến một giá trị ngưỡng dưới mà tỷ lệ giá trị giảm xuống. Ví dụ: phần trăm độ tuổi thứ 95 trong `linelist` sẽ là độ tuổi dưới 95% độ tuổi.

Tuy nhiên, trong cách nói thông thường, "tứ phân vị" và "thập phân" cũng có thể đề cập đến *phân nhóm dữ liệu* được chia đều thành 4 hoặc 10 nhóm (lưu ý sẽ có nhiều điểm cắt hơn phân nhóm).

Để nhận biết điểm cắt của khoảng phân vị, bạn có thể sử dụng `quantile()` từ package **stats** từ **base** R. Bạn cung cấp một vectơ số (ví dụ: một cột trong bộ dữ liệu) và vectơ các giá trị xác suất số từ 0 đến 1. Các điểm cắt được trả về dưới dạng một vectơ số. Đọc thêm chi tiết các phương pháp thống kê bằng cách nhập `?quantile`.

-   Nếu vectơ số đầu vào của bạn có bất kỳ giá trị nào bị thiếu, tốt nhất nên thiết lập `na.rm = TRUE`\
-   Thiết lập`names = FALSE` để lấy một vectơ số chưa được đặt tên

```{r}
quantile(linelist$age_years,               # specify numeric vector to work on
  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want
  na.rm = TRUE)                            # ignore missing values 
```

Bạn có thể sử dụng kết quả của `quantile()` làm điểm cắt trong `age_categories()` hoặc `cut()`. Dưới đây, chúng tôi tạo một cột `deciles` mới bằng cách sử dụng `cut()` trong đó các dấu ngắt được xác định bằng cách sử dụng `quantiles()` trên `age_years`. Dưới đây, chúng tôi hiển thị kết quả bằng `tabyl()` từ **janitor** để bạn có thể xem tỷ lệ phần trăm (xem chương [Descriptive tables]). Lưu ý rằng chúng không chính xác là 10% trong mỗi nhóm.

```{r}
linelist %>%                                # begin with linelist
  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years
    breaks = quantile(                      # define cut breaks using quantile()
      age_years,                               # operate on age_years
      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1
      na.rm = TRUE),                           # ignore missing values
    include.lowest = TRUE)) %>%             # for cut() include age 0
  janitor::tabyl(deciles)                   # pipe to table to display
```

### Nhóm có khoảng đều {.unnumbered}

Một công cụ khác để tạo nhóm số là hàm `ntile()` trong package **dplyr**, cố gắng chia dữ liệu của bạn thành n *nhóm có khoảng cách đều - nhưng lưu ý rằng không giống như với `quantile()`, cùng một giá trị có thể xuất hiện trong nhiều nhóm*. Cung cấp vectơ số và sau đó là số lượng nhóm. Các giá trị trong cột mới được tạo chỉ là nhóm "số" (ví dụ: 1 đến 10), không phải phạm vi giá trị như khi sử dụng `cut()`.

```{r}
# make groups with ntile()
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# make table of counts and proportions by group
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# attach min/max values to demonstrate ranges
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# combine and print - note that values are present in multiple groups
left_join(ntile_table, ntile_ranges, by = "even_groups")
```

<!-- ======================================================= -->

### `case_when()` {.unnumbered}

Có thể sử dụng hàm **dplyr** `case_when()` để tạo danh mục từ cột số, nhưng dễ dàng sử dụng hơn so với `age_categories()` từ **epikit** hoặc `cut()` vì chúng sẽ tự động tạo ra một biến danh mục có thứ tự.

Nếu sử dụng `case_when()`, vui lòng xem lại cách sử dụng thích hợp như đã mô tả trước đó trong chương Mã hóa lại giá trị. Cũng lưu ý rằng tất cả các giá trị bên tay phải phải thuộc cùng một phân lớp. Do đó, nếu bạn muốn giá trị `NA` ở phía bên phải, bạn nên viết "Missing" hoặc sử dụng giá trị `NA` đặc biệt là `NA_character_`.

### Thêm vào chuỗi làm sạch {.unnumbered}

Dưới đây, code để tạo hai cột phân loại tuổi được thêm vào chuỗi các bước làm sạch:

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 

    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################   
    mutate(
          # age categories: custom
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # age categories: 0 to 85 by 5s
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```

<!-- ======================================================= -->

## Thêm hàng

### Thêm từng hàng một {.unnumbered}

Việc thêm từng hàng một theo cách thủ công là rất đơn điệu nhưng có thể được thực hiện với hàm `add_row()` từ package **dplyr**. Hãy nhớ rằng mỗi cột chỉ được chứa các giá trị của một phân lớp (ký tự, số, lôgic, v.v.). Vì vậy, thêm một hàng yêu cầu chú trọng đến sắc thái để duy trì điều này.

```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

Sử dụng `.before` và `.after.` để chỉ định vị trí của hàng bạn muốn thêm. `.before = 3` sẽ cho phép hàng mới trước hàng thứ 3 hiện tại. Hành động mặc định là thêm hàng vào cuối. Các cột không được chỉ định sẽ được để trống (`NA`).

*Số hàng* mới có thể trông lạ ("... 23") nhưng số hàng trong các hàng tồn tại trước đó *đã* thay đổi. Vì vậy, nếu sử dụng lệnh hai lần, hãy kiểm tra/thử việc chèn một cách cẩn thận.

Nếu một phân lớp bạn cung cấp không hoạt động, bạn sẽ thấy báo lỗi như sau:

    Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.

(khi chèn một hàng có giá trị ngày tháng, hãy nhớ đặt thông tin `as.Date()` ví dụ như `as.Date("2020-10-10")`).

### Ràng buộc hàng {.unnumbered}

Để kết hợp các bộ dữ liệu với nhau bằng cách liên kết các hàng của một bộ dữ liệu với cuối bộ dữ liệu khác, bạn có thể sử dụng `bind_rows()` từ **dplyr**. Điều này được giải thích chi tiết hơn trong chương [Joining data].

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Lọc hàng

Bước làm sạch điển hình sau khi bạn đã làm sạch các cột và các giá trị được mã hóa lại đó là *lọc* bộ dữ liệu cho các hàng cụ thể bằng cách sử dụng hàm `filter()` trong package **dplyr**.

Trong hàm `filter()`, chỉ định logic phải là giá trị `TRUE` cho một hàng trong bộ dữ liệu được giữ. Dưới đây chúng tôi trình bày cách lọc hàng dựa trên điều kiện logic đơn giản và phức tạp.

<!-- ======================================================= -->

### Lọc đơn giản {.unnumbered}

Ví dụ đơn giản này xác định lại bộ dữ liệu `linelist`, đã lọc các hàng để đáp ứng điều kiện logic. **Chỉ những hàng mà câu lệnh logic trong dấu ngoặc đơn đánh giá là `TRUE` mới được giữ lại**.

Trong ví dụ này, câu lệnh lôgic là `gender == "f"`, được hỏi liệu giá trị trong cột `gender` có bằng "f" (phân biệt chữ hoa chữ thường) hay không.

Trước khi bộ lọc được áp dụng, số hàng trong `linelist` là `nrow(linelist)`.

```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # keep only rows where gender is equal to "f"
```

Sau khi bộ lọc được áp dụng, số hàng trong `linelist` là `linelist %>% filter(gender == "f") %>% nrow()`.

### Lọc bỏ các giá trị bị thiếu {.unnumbered}

Khá phổ biến là muốn lọc bỏ các hàng có giá trị bị thiếu. Hãy bỏ qua cách lọc cổ điển `filter(!is.na(column) & !is.na(column))` và thay vào đó, hãy sử dụng trong package **tidyr** được xây dựng để tùy chỉnh cho mục đích này: `drop_na()`. Nếu chạy với dấu ngoặc trống, nó sẽ loại bỏ các hàng có bất kỳ giá trị nào bị thiếu. Ngoài ra, bạn có thể cung cấp tên của các cột cụ thể sẽ được đánh giá về độ thiếu hoặc sử dụng các chức năng trợ giúp "tidyselect" được mô tả [ở trên](#clean_tidyselect).

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years
```

Xem chương về [Missing data] để biết nhiều kỹ thuật phân tích và quản lý dữ liệu bị thiếu.

### Lọc bằng số thứ của hàng {.unnumbered}

Trong bộ dữ liệu hoặc tibble, mỗi hàng thường sẽ có một "số hàng" (khi được nhìn thấy trong R Viewer) xuất hiện ở bên trái của cột đầu tiên. Bản thân nó không phải là một cột trong dữ liệu, nhưng nó có thể được sử dụng trong câu lệnh `filter()`.

Để lọc dựa trên "số hàng", bạn có thể sử dụng hàm **dplyr** `row_number()` với "dấu ngoặc đơn mở" như một phần của câu lệnh lọc logic. Thường thì bạn sẽ sử dụng toán tử `%in%` và một dãy số như một phần của câu lệnh logic đó, như được trình bày bên dưới. Để xem N hàng *đầu tiên*, bạn cũng có thể sử dụng hàm đặc biệt `head()` trong package **dplyr**.

```{r, eval=F}
# View first 100 rows
linelist %>% head(100)     # or use tail() to see the n last rows

# Show row 5 only
linelist %>% filter(row_number() == 5)

# View rows 2 through 20, and three specific columns
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

Bạn cũng có thể chuyển đổi số thứ tự hàng thành cột bằng cách sử dụng hàm **tibble** `rownames_to_column()` (không viết bất kỳ ký tự nào trong dấu ngoặc đơn).

<!-- ======================================================= -->

### Lọc phức tạp {.unnumbered}

Các câu lệnh logic phức tạp hơn có thể được xây dựng bằng cách sử dụng các toán tử ngoặc đơn `( )`, HOẶC `|`, PHỦ ĐỊNH `!`, `%in%`, và VÀ `&`. Dưới đây là một ví dụ:

Lưu ý: Bạn có thể sử dụng `!` trước một mệnh đề logic để phủ định nó. Ví dụ, `!is.na(column)` trả về giá trị TRUE nếu cột đó không bị thiếu giá trị. Tương tự như vậy `!column %in% c("a", "b", "c")` trả về kết quả là TRUE nếu giá trị cột *không* có trong vectơ.

#### Kiểm tra dữ liệu {.unnumbered}

Dưới đây là một dòng lệnh đơn giản để tạo biểu đồ các ngày bắt đầu. Thấy rằng một đợt bùng phát nhỏ thứ hai từ năm 2012-2013 cũng được bao gồm trong tập bộ liệu thô này. **Trong các phân tích của chúng tôi, chúng tôi muốn xóa các bản ghi từ đợt bùng phát sớm hơn.**

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```

#### Cách lọc và xử lý các giá trị số và ngày bị thiếu {.unnumbered}

Chúng ta có thể chỉ lọc theo `date_onset` đến những hàng sau tháng 6 năm 2013 không? **Lưu ý! Việc áp dụng code `filter(date_onset > as.Date("2013-06-01")))` sẽ xóa bất kỳ hàng nào trong đợt dịch sau đó có ngày bắt đầu bị thiếu!**

[***NGUY HIỂM***: Việc lọc với điều kiện lớn hơn (\>) hoặc nhỏ hơn (\<) một ngày hoặc số có thể loại bỏ bất kỳ hàng nào có giá trị bị thiếu (`NA`)! Điều này là do `NA` được coi là giá trị lớn hoặc nhỏ vô hạn.]{style="color: red;"}

*(Xem chương [Working with dates] để biết thêm thông tin về cách xử lý với ngày tháng và package **lubridate**)*

#### Thiết kế bộ lọc {.unnumbered}

Kiểm tra một bảng chéo để đảm bảo rằng chúng tôi chỉ loại bỏ các hàng cần loại bỏ:

```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset
      useNA     = "always")                              # show missing values
```

Chúng tôi có thể lọc theo tiêu chí nào khác để loại bỏ đợt bùng phát đầu tiên (trong năm 2012 & 2013) khỏi bộ dữ liệu? Chúng ta thấy rằng:

-   Vụ dịch đầu tiên năm 2012 & 2013 xảy ra tại Bệnh viện A, Bệnh viện B, tại Bệnh viện Hàng Hải cũng có 10 trường hợp mắc.\
-   Bệnh viện A & B *không* có ca bệnh nào trong đợt dịch thứ hai, nhưng Bệnh viện Hàng Hải thì có.

Chúng tôi muốn loại bỏ:

-   Các dòng `nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))` bắt đầu vào năm 2012 và 2013 tại bệnh viện A, B hoặc Hàng Hải:

    -   Loại trừ các hàng `nrow(linelist %>% filter(date_onset < as.Date("2013-06-01")))` bắt đầu vào năm 2012 và 2013
    -   Loại trừ các hàng `nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))` từ bệnh viện A và B với các giá trị ngày bị thiếu\
    -   Không loại bỏ các dòng khác `nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))` bị thiếu ngày bắt đầu.

Chúng ta bắt đầu với `linelist` bằng câu lệnh `nrnow(linelist)`. Đây là toàn bộ câu lệnh:

```{r}
linelist <- linelist %>% 
  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

Khi chúng tôi kiểm tra chéo, chúng tôi thấy rằng Bệnh viện A & B bị loại bỏ hoàn toàn, và 10 trường hợp của Bệnh viện Hàng Hải từ năm 2012 & 2013 bị loại bỏ và tất cả các giá trị khác đều tương tự - đúng như chúng tôi muốn.

```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset
      useNA     = "always")                              # show missing values
```

Nhiều câu lệnh có thể được bao hàm trong một lệnh lọc (được phân tách bằng dấu phẩy) hoặc bạn luôn có thể viết chúng riêng biệt và nối tiếp nhau trong chuỗi các bước làm sạch để rõ ràng hơn.

*Ghi chú: một số độc giả có thể nhận thấy rằng sẽ dễ dàng hơn nếu chỉ lọc theo `date_hospitalisation` vì nó hoàn chỉnh 100% mà không có giá trị nào bị thiếu. Đây là sự thật. Nhưng `date_onset` được sử dụng cho mục đích thể hiện sự phức tạp của việc lọc.*

### Độc lập {.unnumbered}

Việc lọc cũng có thể được thực hiện như một lệnh độc lập (không phải là một phần của chuỗi các bước làm sạch). Giống như các hàm **dplyr** khác, trong trường hợp này, argument đầu tiên phải chính là bộ dữ liệu.

```{r, eval=F}
# dataframe <- filter(dataframe, condition(s) for rows to keep)

linelist <- filter(linelist, !is.na(case_id))
```

Bạn cũng có thể sử dụng **base** R để chia nhỏ dữ liệu bằng cách sử dụng dấu ngoặc vuông phản ánh [hàng, cột] mà bạn muốn giữ lại.

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```

### Xem nhanh các bản ghi {.unnumbered}

Thường thì bạn muốn xem nhanh một vài bản ghi, chỉ cho một vài cột. Hàm `View()` trong **base** R sẽ hiển thị một khung dữ liệu để xem trong RStudio.

Xem `linelist` trong RStudio:

```{r, eval=F}
View(linelist)
```

Dưới đây là hai ví dụ về việc xem các ô cụ thể (hàng cụ thể và cột cụ thể):

**Với hàm `filter()` và `select()` trong dplyr:**

Với hàm `View()`, chuyển tiếp bộ dữ liệu đến hàm `filter()` để giữ các hàng nhất định và sau đó `select()` để giữ các cột nhất định. Ví dụ, để xem xét ngày khởi phát và nhập viện của 3 trường hợp cụ thể:

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```

Bạn có thể đạt được điều tương tự với cú pháp trong **base** R, sử dụng dấu ngoặc `[ ]` cho tập hợp con bạn muốn xem.

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```

#### Thêm vào chuỗi làm sạch {.unnumbered}

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 

    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    mutate(
          # age categories: custom
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # age categories: 0 to 85 by 5s
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% 
    
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################
    filter(
          # keep only rows where case_id is not missing
          !is.na(case_id),  
          
          # also filter to keep only the second outbreak
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Tính toán theo hàng

Nếu bạn muốn thực hiện một phép tính trong một hàng, bạn có thể sử dụng hàm `rowwise()` từ **dplyr**. Xem chi tiết tại [row-wise calculations](https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html).\
Ví dụ: code này sử dụng hàm `rowwise()` và sau đó tạo một cột mới mà tổng số cột triệu chứng được chứa giá trị "có", cho mỗi hàng trong `linelist`. Các cột được chỉ định trong `sum()` theo tên trong vectơ `c()`. `rowwise()` về cơ bản là một loại `group_by()` đặc biệt, vì vậy tốt nhất bạn nên sử dụng `ungroup()` khi bạn hoàn tất (trong chương [Grouping data]).

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # for display
```

Khi bạn chỉ định cột để đánh giá, bạn có thể muốn sử dụng các tính năng trợ giúp "tidyselect" được mô tả trong chương `select()`. Bạn chỉ cần thực hiện duy nhất một lần (vì bạn không sử dụng chúng trong một hàm **dplyr** như `select()` or `summarise()`).

Đặt tiêu chí đặc tả cột trong hàm **dplyr** `c_across()`. Điều này là do `c_across` ([documentation](https://dplyr.tidyverse.org/reference/c_across.html)) được thiết kế để hoạt động cụ thể với hàm `rowwise()`. Ví dụ, như đoạn code sau:

-   Áp dụng `rowwise()` nên bước tiếp theo (`sum()`) được áp dụng trong mỗi hàng (không tính tổng toàn bộ các cột)\
-   Tạo cột mới `num_NA_dates`, được xác định cho mỗi hàng là số cột (có tên chứa "ngày tháng") mà `is.na()` trả về giá trị TRUE (nghĩa là chúng bị thiếu dữ liệu)\
-   `ungroup()` để loại bỏ ảnh hưởng của `rowwise()` cho các bước tiếp theo

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # for display
```

Bạn cũng có thể cung cấp các hàm khác, chẳng hạn như `max()` để lấy ngày mới nhất hoặc gần đây nhất cho mỗi hàng:

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # for display
```

## Sắp xếp

Sử dụng hàm **dplyr** `arrange()` để sắp xếp hoặc sắp xếp thứ tự các hàng theo giá trị cột.

Đơn giản hãy liệt kê các cột theo thứ tự mà chúng cần được sắp xếp. Thêm `.by_group = TRUE` nếu bạn muốn việc sắp xếp xảy ra trước tiên theo bất kỳ *hành động nhóm dữ liệu* nào được áp dụng trong dữ liệu (xem chương [Grouping data]).

Mặc định, cột sẽ được sắp xếp theo thứ tự "tăng dần" (áp dụng cho cột số và cả cột ký tự). Bạn có thể sắp xếp một biến theo thứ tự "giảm dần" bằng cách đặt tên biến trong hàm `desc()`.

Việc sắp xếp dữ liệu với `arrange()` đặc biệt hữu ích khi tạo [Tables for presentation], sử dụng `slice()` để lấy các hàng "trên cùng" trên mỗi nhóm hoặc thiết lập thứ tự danh mục theo thứ tự xuất hiện.

Ví dụ: để sắp xếp các hàng trong `linelist` theo `hospital`, sau đó theo `date_onset` thứ tự giảm dần, chúng tôi sẽ thực hiện như sau:

```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```

```{r, echo=F}
# HIDDEN
#
# convert one remaining old outbreak row to missing for ease
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```

```{r echo=F}
# REARRANGE COLUMNS FOR EXPORT
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}
# EXPORT CLEANED LINELIST FILE TO "DATA" FOLDER
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"))
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```
