# Ký tự và chuỗi {#characters-strings}

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Characters_Strings_1500x500.png"))
```


Trang này trình bày việc sử dụng package **stringr** để đánh giá và xử lý các giá trị ký tự (“chuỗi”).

1. Các hàm kết hợp, sắp xếp, phân tách, sắp xếp - `str_c()`, `str_glue()`, `str_order()`, `str_split()`  

2. Làm sạch và chuẩn hóa
    * Các hàm điều chỉnh độ dài ký tự - `str_pad()`, `str_trunc()`, `str_wrap()`  
    * Các hàm thay đổi - `str_to_upper()`, `str_to_title()`, `str_to_lower()`, `str_to_sentence()`  
    
3. Các hàm đánh giá phân giải bới vị trí - `str_length()`, `str_sub()`, `word()`  

4. Các hàm làm việc với patterns  
    * Detect and locate - `str_detect()`, `str_subset()`, `str_match()`, `str_extract()`  
    * Modify and replace - `str_sub()`, `str_replace_all()`  

5.  Regular expressions ("regex")

Để dễ hiển thị, hầu hết các ví dụ đều mô phỏng trên một vectơ ngắn dạng ký tự đã được xác định, tuy nhiên chúng có thể dễ dàng được điều chỉnh cho phù hợp với một cột trong bộ dữ liệu.  

Package [stringr vignette](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html) này đã cung cấp nhiều cảm hứng cho chương này. 


<!-- ======================================================= -->

## Chuẩn bị { }

### Gọi packages {.unnumbered}  

Cài đặt hoặc gọi package **stringr** và các packages **tidyverse** khác.  

```{r}
# install/load packages
pacman::p_load(
  stringr,    # many functions for handling strings
  tidyverse,  # for optional data manipulation
  tools)      # alternative for converting to title case

```

### Nhập dữ liệu {.unnumbered}

Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải dữ liệu linelist "đã được làm sạch" </a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import case linelist 
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị bên dưới. 

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Unite, split, và arrange

Chương này bao gồm:  

* Sử dụng hàm `str_c()`, `str_glue()`, và `unite()` để ghép nối ký tự 
* Sử dụng hàm `str_order()` để sắp xếp ký tự  
* Sử dụng hàm `str_split()` và `separate()` để phân tách ký tự


### Kết hợp các chuỗi ký tự {.unnumbered}

Để kết hợp hoặc nối nhiều chuỗi ký tự thành một chuỗi ký tự, chúng tôi khuyên bạn nên sử dụng hàm `str_c` từ **stringr**. Nếu bạn có các giá trị ký tự đặc biệt để kết hợp, chỉ cần chỉ rõ chúng dưới dạng arguments, được phân tách bằng dấu phẩy.     

```{r}
str_c("String1", "String2", "String3")
```

Đối số `sep = ` chèn một giá dạng trị ký tự vào giữa mỗi argument (ví dụ: chèn dấu phẩy, dấu cách hoặc dòng mới `"\n"`)  

```{r}
str_c("String1", "String2", "String3", sep = ", ")
```

Argument `collapse = ` có liên quan nếu bạn đang nhập nhiều *vectơ* làm đối số cho hàm `str_c()`. Nó được sử dụng để tách các phần tử của một vectơ *kết quả*, sao cho vectơ kết quả chỉ là một phần tử chứa ký tự dài. 


Ví dụ dưới đây cho thấy sự kết hợp của hai vectơ thành một (tên và họ). Một ví dụ tương tự khác có thể là các phạm vi hạn chế và số lượng trường hợp. Trong ví dụ này: 

* Giá trị `sep = ` xuất hiện giữa từng tên đầu và tên cuối
* Giá trị `collapse = ` xuất hiện giữa tên từng người

```{r}
first_names <- c("abdul", "fahruk", "janice") 
last_names  <- c("hussein", "akinleye", "okeke")

# sep displays between the respective input strings, while collapse displays between the elements produced
str_c(first_names, last_names, sep = " ", collapse = ";  ")
```

Lưu ý: Tùy thuộc vào bối cảnh hiển thị mong muốn, khi xử lý một chuỗi kết hợp như vậy với các dòng mới, bạn có thể cần phải đặt toàn bộ cụm từ trong hàm `cat()` để các dòng mới được xử lý đúng cách: 

```{r}
# For newlines to print correctly, the phrase may need to be wrapped in cat()
cat(str_c(first_names, last_names, sep = " ", collapse = ";\n"))
```


### Chuỗi động {.unnumbered}

Sử dụng hàm `str_glue()` để chèn đoạn code động của R vào chuỗi ký tự. Đây là một hàm hữu dụng để tạo tiêu đề biểu đồ động, như mô tả bên dưới:

* Tất cả nội dung nằm giữa dấu ngoặc kép `str_glue("")`  
* Bất kỳ đoạn code động hoặc tham chiếu nào đến các giá trị được xác định trước đều được đặt trong dấu ngoặc nhọn `{}` trong dấu ngoặc kép. Có thể có nhiều dấu ngoặc nhọn trong cùng một câu lệnh `str_glue()`.  
* Để hiển thị  dấu ngoặc kép '', hãy sử dụng dấu ngoặc *đơn* trong dấu ngoặc kép xung quanh (ví dụ: khi cung cấp định dạng ngày - xem ví dụ bên dưới) 
* Mẹo: Bạn có thể sử dụng `\n` để bắt buộc xuống một dòng mới   
* Mẹo: Bạn có thể sử dụng `format()` để điều chỉnh hiển thị ngày và sử dụng hàm `Sys.Date()` để hiển thị ngày hiện tại. 

Một ví dụ đơn giản về tiêu đề biểu đồ động: 

```{r}
str_glue("Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.")
```

Một định dạng thay thế để xác định rõ từng vị trí trong dấu ngoặc và xác định code trong từng argument ở cuối hàm `str_glue()` như bên dưới. Điều này có thể cải thiện khả năng giải mã code nếu văn bản dài. 

```{r}
str_glue("Linelist as of {current_date}.\nLast case hospitalized on {last_hospital}.\n{n_missing_onset} cases are missing date of onset and not shown",
         current_date = format(Sys.Date(), '%d %b %Y'),
         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),
         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))
         )

```


**Kéo từ bộ dữ liệu**  

Đôi khi, sẽ rất hữu ích khi lấy dữ liệu từ một bộ dữ liệu và gán lại với nhau theo trình tự. Dưới đây là một ví dụ về bộ dữ liệu. Chúng tôi sẽ sử dụng cách này để tóm tắt nhanh về các sự hạn chế, cũng như số ca mới và tổng số ca. 

```{r}
# make case data frame
case_table <- data.frame(
  zone        = c("Zone 1", "Zone 2", "Zone 3", "Zone 4", "Zone 5"),
  new_cases   = c(3, 0, 7, 0, 15),
  total_cases = c(40, 4, 25, 10, 103)
  )
```

```{r, echo=F}
DT::datatable(case_table, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Sử dụng hàm `str_glue_data()`,  được tạo ra để lấy dữ liệu từ các quan sát của bộ dữ liệu: 

```{r}
case_table %>% 
  str_glue_data("{zone}: {new_cases} ({total_cases} total cases)")
```


**Kết hợp các chuỗi ký tự trên các dòng**  

Nếu bạn đang cố gắng các giá trị "roll-up" trong một cột trong bộ dữ liệu, ví dụ: kết hợp các giá trị từ nhiều hàng thành một hàng bằng cách gán chúng cùng với ký tự phân cách, hãy xem thêm ở chương [De-duplication] về ["rolling-up" values](#str_rollup).  

**Một bộ dữ liệu thành một dòng**  

Bạn có thể tạo ra dãy thông tin chỉ trong một dòng bằng cách sử dụng lệnh `str_c()`  (làm rõ bộ dữ liệu và tên cột), đồng thời cung cấp các argument `sep = ` và `collapse = `.   

```{r}
str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  ")
```

Bạn có thể thêm đoạn tiền tố “New Cases:” vào đầu dòng thông tin bằng cách đặt trong hàm `str_c()` (nếu “New Cases:” nằm trong hàm `str_c()` ban đầu thì nó sẽ xuất hiện nhiều lần). 

```{r}
str_c("New Cases: ", str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  "))
```


### Hợp nhất các cột {#str_unite .unnumbered}

Trong bộ dữ liệu, việc tập hợp các giá trị dạng ký tự từ nhiều cột lại với nhau có thể thực hiện bằng cách dùng hàm `unite()` từ package **tidyr**. Tính năng này ngược lại với hàm `separate()`.  

Đầu tiên, cần tên của cột mới. Sau đó, cần tên của các cột mà bạn muốn hợp nhất.  

* Mặc định, dấu ngăn cách được sử dụng trong cột hợp nhất là dấu gạch dưới _, nhưng có thể được thay đổi bằng argument `sep = `.   
* `remove = ` loại bỏ các cột ban đầu ra khỏi bộ dữ liệu (mặc định là TRUE)   
* `na.rm = ` loại bỏ các giá trị bị thiếu trong khi hợp nhất (mặc định là FALSE)   

Dưới đây, chúng tôi xác định một bộ dữ liệu ngắn để minh họa:  

```{r, message = F, warning=F}
df <- data.frame(
  case_ID = c(1:6),
  symptoms  = c("jaundice, fever, chills",     # patient 1
                "chills, aches, pains",        # patient 2 
                "fever",                       # patient 3
                "vomiting, diarrhoea",         # patient 4
                "bleeding from gums, fever",   # patient 5
                "rapid pulse, headache"),      # patient 6
  outcome = c("Recover", "Death", "Death", "Recover", "Recover", "Recover"))
```

```{r}
df_split <- separate(df, symptoms, into = c("sym_1", "sym_2", "sym_3"), extra = "merge")
```

Đây là bộ dữ liệu mẫu:

```{r, echo=F}
DT::datatable(df_split, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Dưới đây, chúng tôi hợp nhất ba cột triệu chứng: 

```{r}
df_split %>% 
  unite(
    col = "all_symptoms",         # name of the new united column
    c("sym_1", "sym_2", "sym_3"), # columns to unite
    sep = ", ",                   # separator to use in united column
    remove = TRUE,                # if TRUE, removes input cols from the data frame
    na.rm = TRUE                  # if TRUE, missing values are removed before uniting
  )
```

<!-- ======================================================= -->

### Phân tách  {.unnumbered}  

Để phân tách một chuỗi ký tự dựa trên một pattern, hãy sử dụng hàm `str_split()`.Hàm này đánh giá (các) chuỗi ký tự và trả về `list` các vectơ ký tự chứa các giá trị mới được tách. 

Ví dụ đơn giản dưới đây đánh giá một chuỗi ký tự và chia thành ba phần. Mặc định, hàm trả về một đối tượng của phân lớp `list`  với một phần tử (một vectơ ký tự) cho mỗi chuỗi được sử dụng ban đầu. Nếu `simplify = TRUE` nó trả về một ma trận ký tự. 

Trong ví dụ này, một chuỗi ký tự được cung cấp và hàm trả về danh sách có một phần tử - một vectơ ký tự chứa ba giá trị. 

```{r}
str_split(string = "jaundice, fever, chills",
          pattern = ",")
```

Nếu kết quả được lưu, thì bạn có thể truy cập giá trị phân chia thứ n bằng cú pháp dấu ngoặc. Để truy cập vào một giá trị cụ thể, bạn có thể sử dụng cú pháp như sau:  `the_returned_object[[1]][2]`, sẽ truy cập giá trị thứ hai từ chuỗi ký tự được đánh giá ban đầu (“fever”). Xem thêm ở chương [R Cơ bản] để biết thêm chi tiết về cách truy vấn các phần tử. 

```{r}
pt1_symptoms <- str_split("jaundice, fever, chills", ",")

pt1_symptoms[[1]][2]  # extracts 2nd value from 1st (and only) element of the list
```

Nếu nhiều chuỗi ký tự được sử dụng trong hàm `str_split()`, sẽ có nhiều hơn một phần tử trong danh sách trả về. 

```{r}
symptoms <- c("jaundice, fever, chills",     # patient 1
              "chills, aches, pains",        # patient 2 
              "fever",                       # patient 3
              "vomiting, diarrhoea",         # patient 4
              "bleeding from gums, fever",   # patient 5
              "rapid pulse, headache")       # patient 6

str_split(symptoms, ",")                     # split each patient's symptoms
```

Thay vào đó, để trả về “ma trận chuỗi ký tự”, có thể hữu ích nếu tạo cột trong bộ dữ liệu, đặt đối số `simplify = TRUE` như hình dưới đây:  

```{r}
str_split(symptoms, ",", simplify = TRUE)
```

Bạn cũng có thể điều chỉnh số phần tách ra với argument `n = `. Ví dụ: điều này hạn chế số phần  tách ra chỉ có 2 phần. Bất kỳ dấu phẩy nào khác vẫn sẽ nằm trong giá trị thứ hai. 

```{r}
str_split(symptoms, ",", simplify = TRUE, n = 2)
```

*Lưu ý - các kết quả tương tự có thể thực hiện thành công với hàm `str_split_fixed()`, trong đó bạn không đưa ra argument `simplify` mà thay vào đó phải chỉ định số cột (`n`).* 

```{r, eval=F}
str_split_fixed(symptoms, ",", n = 2)
```

### Tách cột {.unnumbered}  

Nếu bạn đang cố gắng chia tách cột trong bộ dữ liệu, cách tốt nhất là sử dụng hàm `separate()` từ package **dplyr**. Nó được sử dụng để chia một cột ký tự thành các cột khác nhau. 

Giả sử chúng ta có một bộ dữ liệu đơn giản `df` (được định nghĩa và thống nhất trong [unite section](#str_unite)) chứa một cột `case_ID` , một cột dạng ký tự có nhiều triệu chứng và một cột kết quả. Mục tiêu của chúng tôi là tách cột `symptoms` thành nhiều cột - mỗi cột chứa một triệu chứng. 

```{r, echo=F}
DT::datatable(df, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Giả sử dữ liệu được đưa vào hàm `separate()`, trước tiên hãy chọn ra cột sẽ được phân tách. TSau đó, điền thông tin vào `into = `  dưới dạng vectơ `c( )` có chứa tên cột *mới* như hình dưới đây. 

* Dấu phân cách trong `sep = ` có thể là một ký tự hoặc một số (được hiểu là vị trí ký tự cần tách) 
* Mặc định là `remove = ` FALSE, xóa cột đầu vào ban ban đầu
* Mặc định là `convert = ` FALSE, các ký tự “NA” sẽ thành `NA`  
* `extra = ` kiểm soát điều gì sẽ xảy ra nếu có nhiều giá trị được tạo bởi sự phân tách nhiều hơn các cột mới được đặt tên. 
     * `extra = "warn"` m có nghĩa là bạn sẽ thấy một cảnh báo nhưng nó sẽ loại bỏ các giá trị thừa (**mặc định là vậy**)  
     * `extra = "drop"` có nghĩa là các giá trị thừa sẽ bị loại bỏ mà không có cảnh báo 
     * **`extra = "merge"` sẽ chỉ phân tách thành số cột mới được liệt kê trong `into` - *điều này sẽ bảo toàn tất cả dữ liệu của bạn**

Dưới đây là một ví dụ về `extra = "merge"` i- không có dữ liệu nào bị mất. Hai cột mới được xác định nhưng bất kỳ triệu chứng thứ ba nào sẽ quy về trong cột mới thứ hai: 

```{r}
# third symptoms combined into second new column
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",", extra = "merge")
```

Khi sử dụng lệnh `extra = "drop"` mặc định như bên dưới, một cảnh báo sẽ được đưa ra nhưng triệu chứng thứ ba bị mất: 

```{r}
# third symptoms are lost
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",")
```


<span style="color: orange;">**CẨN TRỌNG:** Nếu bạn không cung cấp đủ giá trị `cho`các cột mới, dữ liệu của bạn có thể bị cắt bớt .</span>  


### Sắp xếp theo thứ tự bảng chữ cái {.unnumbered} 

Một số chuỗi ký tự có thể được sắp xếp theo thứ tự bảng chữ cái. Hàm `str_order()` trả về thứ tự đã được sắp xếp, trong khi hàm `str_sort()` trả về các chuỗi theo thứ tự đó. 

```{r}
# strings
health_zones <- c("Alba", "Takota", "Delta")

# return the alphabetical order
str_order(health_zones)

# return the strings in alphabetical order
str_sort(health_zones)
```

Để sử dụng một bảng chữ cái khác, hãy thêm argument `locale = `. See the full list of locales by entering `stringi::stri_locale_list()` in the R console.  


### base R functions {.unnumbered}

It is common to see **base** R functions `paste()` and `paste0()`, which concatenate vectors after converting all parts to character. They act similarly to `str_c()` but the syntax is arguably more complicated - in the parentheses each part is separated by a comma. The parts are either character text (in quotes) or pre-defined code objects (no quotes). For example:

```{r}
n_beds <- 10
n_masks <- 20

paste0("Regional hospital needs ", n_beds, " beds and ", n_masks, " masks.")
```

`sep =` and `collapse =` arguments can be specified. `paste()` is simply `paste0()` with a default `sep = " "` (one space).

## Clean and standardise

<!-- ======================================================= -->

### Change case {.unnumbered}

Often one must alter the case/capitalization of a string value, for example names of jursidictions. Use `str_to_upper()`, `str_to_lower()`, and `str_to_title()`, from **stringr**, as shown below:

```{r}
str_to_upper("California")

str_to_lower("California")
```

Using \*base\*\* R, the above can also be achieved with `toupper()`, `tolower()`.

**Title case**

Transforming the string so each word is capitalized can be achieved with `str_to_title()`:

```{r}
str_to_title("go to the US state of california ")
```

Use `toTitleCase()` from the **tools** package to achieve more nuanced capitalization (words like "to", "the", and "of" are not capitalized).

```{r}
tools::toTitleCase("This is the US state of california")
```

You can also use `str_to_sentence()`, which capitalizes only the first letter of the string.

```{r}
str_to_sentence("the patient must be transported")
```

### Pad length {#str_pad .unnumbered}

Use `str_pad()` to add characters to a string, to a minimum length. By default spaces are added, but you can also pad with other characters using the `pad =` argument.

```{r}
# ICD codes of differing length
ICD_codes <- c("R10.13",
               "R10.819",
               "R17")

# ICD codes padded to 7 characters on the right side
str_pad(ICD_codes, 7, "right")

# Pad with periods instead of spaces
str_pad(ICD_codes, 7, "right", pad = ".")
```

For example, to pad numbers with leading zeros (such as for hours or minutes), you can pad the number to minimum length of 2 with `pad = "0"`.

```{r}
# Add leading zeros to two digits (e.g. for times minutes/hours)
str_pad("4", 2, pad = "0") 

# example using a numeric column named "hours"
# hours <- str_pad(hours, 2, pad = "0")
```

### Truncate {.unnumbered}

`str_trunc()` sets a maximum length for each string. If a string exceeds this length, it is truncated (shortened) and an ellipsis (...) is included to indicate that the string was previously longer. Note that the ellipsis *is* counted in the length. The ellipsis characters can be changed with the argument `ellipsis =`. The optional `side =` argument specifies which where the ellipsis will appear within the truncated string ("left", "right", or "center").

```{r}
original <- "Symptom onset on 4/3/2020 with vomiting"
str_trunc(original, 10, "center")
```

### Standardize length {.unnumbered}

Use `str_trunc()` to set a maximum length, and then use `str_pad()` to expand the very short strings to that truncated length. In the example below, 6 is set as the maximum length (one value is truncated), and then one very short value is padded to achieve length of 6.

```{r}
# ICD codes of differing length
ICD_codes   <- c("R10.13",
                 "R10.819",
                 "R17")

# truncate to maximum length of 6
ICD_codes_2 <- str_trunc(ICD_codes, 6)
ICD_codes_2

# expand to minimum length of 6
ICD_codes_3 <- str_pad(ICD_codes_2, 6, "right")
ICD_codes_3
```

### Remove leading/trailing whitespace {.unnumbered}

Use `str_trim()` to remove spaces, newlines (`\n`) or tabs (`\t`) on sides of a string input. Add `"right"` `"left"`, or `"both"` to the command to specify which side to trim (e.g. `str_trim(x, "right")`.

```{r}
# ID numbers with excess spaces on right
IDs <- c("provA_1852  ", # two excess spaces
         "provA_2345",   # zero excess spaces
         "provA_9460 ")  # one excess space

# IDs trimmed to remove excess spaces on right side only
str_trim(IDs)
```

### Remove repeated whitespace within {.unnumbered}

Use `str_squish()` to remove repeated spaces that appear *inside* a string. For example, to convert double spaces into single spaces. It also removes spaces, newlines, or tabs on the outside of the string like `str_trim()`.

```{r}
# original contains excess spaces within string
str_squish("  Pt requires   IV saline\n") 
```

Enter `?str_trim`, `?str_pad` in your R console to see further details.

### Wrap into paragraphs {.unnumbered}

Use `str_wrap()` to wrap a long unstructured text into a structured paragraph with fixed line length. Provide the ideal character length for each line, and it applies an algorithm to insert newlines (`\n`) within the paragraph, as seen in the example below.

```{r}
pt_course <- "Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020."

str_wrap(pt_course, 40)
```

The **base** function `cat()` can be wrapped around the above command in order to print the output, displaying the new lines added.

```{r}
cat(str_wrap(pt_course, 40))
```

<!-- ======================================================= -->

## Handle by position

### Extract by character position {.unnumbered}

Use `str_sub()` to return only a part of a string. The function takes three main arguments:

1)  the character vector(s)\
2)  start position\
3)  end position

A few notes on position numbers:

-   If a position number is positive, the position is counted starting from the left end of the string.\
-   If a position number is negative, it is counted starting from the right end of the string.\
-   Position numbers are inclusive.\
-   Positions extending beyond the string will be truncated (removed).

Below are some examples applied to the string "pneumonia":

```{r}
# start and end third from left (3rd letter from left)
str_sub("pneumonia", 3, 3)

# 0 is not present
str_sub("pneumonia", 0, 0)

# 6th from left, to the 1st from right
str_sub("pneumonia", 6, -1)

# 5th from right, to the 2nd from right
str_sub("pneumonia", -5, -2)

# 4th from left to a position outside the string
str_sub("pneumonia", 4, 15)
```

### Extract by word position {.unnumbered}

To extract the nth 'word', use `word()`, also from **stringr**. Provide the string(s), then the first word position to extract, and the last word position to extract.

By default, the separator between 'words' is assumed to be a space, unless otherwise indicated with `sep =` (e.g. `sep = "_"` when words are separated by underscores.

```{r}
# strings to evaluate
chief_complaints <- c("I just got out of the hospital 2 days ago, but still can barely breathe.",
                      "My stomach hurts",
                      "Severe ear pain")

# extract 1st to 3rd words of each string
word(chief_complaints, start = 1, end = 3, sep = " ")
```

### Replace by character position {.unnumbered}

`str_sub()` paired with the assignment operator (`<-`) can be used to modify a part of a string:

```{r}
word <- "pneumonia"

# convert the third and fourth characters to X 
str_sub(word, 3, 4) <- "XX"

# print
word
```

An example applied to multiple strings (e.g. a column). Note the expansion in length of "HIV".

```{r}
words <- c("pneumonia", "tubercolosis", "HIV")

# convert the third and fourth characters to X 
str_sub(words, 3, 4) <- "XX"

words
```

### Evaluate length {.unnumbered}

```{r}
str_length("abc")
```

Alternatively, use `nchar()` from **base** R

<!-- ======================================================= -->

## Patterns

Many **stringr** functions work to detect, locate, extract, match, replace, and split based on a specified *pattern*.

<!-- ======================================================= -->

### Detect a pattern {.unnumbered}

Use `str_detect()` as below to detect presence/absence of a pattern within a string. First provide the string or vector to search in (`string =`), and then the pattern to look for (`pattern =`). Note that by default the search *is case sensitive*!

```{r}
str_detect(string = "primary school teacher", pattern = "teach")
```

The argument `negate =` can be included and set to `TRUE` if you want to know if the pattern is NOT present.

```{r}
str_detect(string = "primary school teacher", pattern = "teach", negate = TRUE)
```

To ignore case/capitalization, wrap the pattern within `regex()`, and *within* `regex()` add the argument `ignore_case = TRUE` (or `T` as shorthand).

```{r}
str_detect(string = "Teacher", pattern = regex("teach", ignore_case = T))
```

When `str_detect()` is applied to a character vector or a data frame column, it will return TRUE or FALSE for each of the values.

```{r}
# a vector/column of occupations 
occupations <- c("field laborer",
                 "university professor",
                 "primary school teacher & tutor",
                 "tutor",
                 "nurse at regional hospital",
                 "lineworker at Amberdeen Fish Factory",
                 "physican",
                 "cardiologist",
                 "office worker",
                 "food service")

# Detect presence of pattern "teach" in each string - output is vector of TRUE/FALSE
str_detect(occupations, "teach")
```

If you need to count the `TRUE`s, simply `sum()` the output. This counts the number `TRUE`.

```{r}
sum(str_detect(occupations, "teach"))
```

To search inclusive of multiple terms, include them separated by OR bars (`|`) within the `pattern =` argument, as shown below:

```{r}
sum(str_detect(string = occupations, pattern = "teach|professor|tutor"))
```

If you need to build a long list of search terms, you can combine them using `str_c()` and `sep = |`, then define this is a character object, and then reference the vector later more succinctly. The example below includes possible occupation search terms for front-line medical providers.

```{r}
# search terms
occupation_med_frontline <- str_c("medical", "medicine", "hcw", "healthcare", "home care", "home health",
                                "surgeon", "doctor", "doc", "physician", "surgery", "peds", "pediatrician",
                               "intensivist", "cardiologist", "coroner", "nurse", "nursing", "rn", "lpn",
                               "cna", "pa", "physician assistant", "mental health",
                               "emergency department technician", "resp therapist", "respiratory",
                                "phlebotomist", "pharmacy", "pharmacist", "hospital", "snf", "rehabilitation",
                               "rehab", "activity", "elderly", "subacute", "sub acute",
                                "clinic", "post acute", "therapist", "extended care",
                                "dental", "dential", "dentist", sep = "|")

occupation_med_frontline
```

This command returns the number of occupations which contain any one of the search terms for front-line medical providers (`occupation_med_frontline`):

```{r}
sum(str_detect(string = occupations, pattern = occupation_med_frontline))
```

**Base R string search functions**

The **base** function `grepl()` works similarly to `str_detect()`, in that it searches for matches to a pattern and returns a logical vector. The basic syntax is `grepl(pattern, strings_to_search, ignore.case = FALSE, ...)`. One advantage is that the `ignore.case` argument is easier to write (there is no need to involve the `regex()` function).

Likewise, the **base** functions `sub()` and `gsub()` act similarly to `str_replace()`. Their basic syntax is: `gsub(pattern, replacement, strings_to_search, ignore.case = FALSE)`. `sub()` will replace the first instance of the pattern, whereas `gsub()` will replace all instances of the pattern.

#### Convert commas to periods {.unnumbered}

Here is an example of using `gsub()` to convert commas to periods in a vector of numbers. This could be useful if your data come from parts of the world other than the United States or Great Britain.

The inner `gsub()` which acts first on `lengths` is converting any periods to no space "". The period character "." has to be "escaped" with two slashes to actually signify a period, because "." in regex means "any character". Then, the result (with only commas) is passed to the outer `gsub()` in which commas are replaced by periods.

```{r, eval=F}
lengths <- c("2.454,56", "1,2", "6.096,5")

as.numeric(gsub(pattern = ",",                # find commas     
                replacement = ".",            # replace with periods
                x = gsub("\\.", "", lengths)  # vector with other periods removed (periods escaped)
                )
           )                                  # convert outcome to numeric
```

### Replace all {.unnumbered}

Use `str_replace_all()` as a "find and replace" tool. First, provide the strings to be evaluated to `string =`, then the pattern to be replaced to `pattern =`, and then the replacement value to `replacement =`. The example below replaces all instances of "dead" with "deceased". Note, this IS case sensitive.

```{r}
outcome <- c("Karl: dead",
            "Samantha: dead",
            "Marco: not dead")

str_replace_all(string = outcome, pattern = "dead", replacement = "deceased")
```

Notes:

-   To replace a pattern with `NA`, use `str_replace_na()`.\
-   The function `str_replace()` replaces only the first instance of the pattern within each evaluated string.

<!-- ======================================================= -->

### Detect within logic {.unnumbered}

**Within `case_when()`**

`str_detect()` is often used within `case_when()` (from **dplyr**). Let's say `occupations` is a column in the linelist. The `mutate()` below creates a new column called `is_educator` by using conditional logic via `case_when()`. See the page on data cleaning to learn more about `case_when()`.

```{r, eval=F}
df <- df %>% 
  mutate(is_educator = case_when(
    # term search within occupation, not case sensitive
    str_detect(occupations,
               regex("teach|prof|tutor|university",
                     ignore_case = TRUE))              ~ "Educator",
    # all others
    TRUE                                               ~ "Not an educator"))
```

As a reminder, it may be important to add exclusion criteria to the conditional logic (`negate = F`):

```{r, eval=F}
df <- df %>% 
  # value in new column is_educator is based on conditional logic
  mutate(is_educator = case_when(
    
    # occupation column must meet 2 criteria to be assigned "Educator":
    # it must have a search term AND NOT any exclusion term
    
    # Must have a search term
    str_detect(occupations,
               regex("teach|prof|tutor|university", ignore_case = T)) &              
    
    # AND must NOT have an exclusion term
    str_detect(occupations,
               regex("admin", ignore_case = T),
               negate = TRUE                        ~ "Educator"
    
    # All rows not meeting above criteria
    TRUE                                            ~ "Not an educator"))
```

<!-- ======================================================= -->

### Locate pattern position {.unnumbered}

To locate the *first* position of a pattern, use `str_locate()`. It outputs a start and end position.

```{r}
str_locate("I wish", "sh")
```

Like other `str` functions, there is an "\_all" version (`str_locate_all()`) which will return the positions of *all* instances of the pattern within each string. This outputs as a `list`.

```{r}
phrases <- c("I wish", "I hope", "he hopes", "He hopes")

str_locate(phrases, "h" )     # position of *first* instance of the pattern
str_locate_all(phrases, "h" ) # position of *every* instance of the pattern
```

<!-- ======================================================= -->

### Extract a match {.unnumbered}

`str_extract_all()` returns the matching patterns themselves, which is most useful when you have offered several patterns via "OR" conditions. For example, looking in the string vector of occupations (see previous tab) for *either* "teach", "prof", or "tutor".

`str_extract_all()` returns a `list` which contains *all matches* for each evaluated string. See below how occupation 3 has two pattern matches within it.

```{r}
str_extract_all(occupations, "teach|prof|tutor")
```

`str_extract()` extracts *only the first match* in each evaluated string, producing a character vector with one element for each evaluated string. It returns `NA` where there was no match. The `NA`s can be removed by wrapping the returned vector with `na.exclude()`. Note how the second of occupation 3's matches is not shown.

```{r}
str_extract(occupations, "teach|prof|tutor")
```

<!-- ======================================================= -->

### Subset and count {.unnumbered}

Aligned functions include `str_subset()` and `str_count()`.

`str_subset()` returns the actual values which contained the pattern:

```{r}
str_subset(occupations, "teach|prof|tutor")
```

`str_count()` returns a vector of numbers: the **number of times** a search term appears in each evaluated value.

```{r}
str_count(occupations, regex("teach|prof|tutor", ignore_case = TRUE))
```

<!-- ======================================================= -->

### Regex groups {.unnumbered}

UNDER CONSTRUCTION

<!-- ======================================================= -->

## Special characters

**Backslash `\` as escape**

The backslash `\` is used to "escape" the meaning of the next character. This way, a backslash can be used to have a quote mark display *within* other quote marks (`\"`) - the middle quote mark will not "break" the surrounding quote marks.

Note - thus, if you want to *display* a backslash, you must escape it's meaning with *another* backslash. So you must write two backslashes `\\` to display one.

**Special characters**

| Special character                                                                 | Represents                          |
|-----------------------------------------------------------------------------------|-------------------------------------|
| `"\\"`                                                                            | backslash                           |
| `"\n"`                                                                            | a new line (newline)                |
| `"\""`                                                                            | double-quote *within* double quotes |
| `'\''`                                                                            | single-quote *within* single quotes |
| `"\`"`| grave accent`"\r"`| carriage return`"\t"`| tab`"\v"`| vertical tab`"\b"\` | backspace                           |

Run `?"'"` in the R Console to display a complete list of these special characters (it will appear in the RStudio Help pane).

<!-- ======================================================= -->

## Regular expressions (regex)

<!-- ======================================================= -->

## Regex and special characters

Regular expressions, or "regex", is a concise language for describing patterns in strings. If you are not familiar with it, a regular expression can look like an alien language. Here we try to de-mystify this language a little bit.

*Much of this section is adapted from [this tutorial](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432) and [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)*. We selectively adapt here knowing that this handbook might be viewed by people without internet access to view the other tutorials.

A regular expression is often applied to extract specific patterns from "unstructured" text - for example medical notes, chief complaints, patient history, or other free text columns in a data frame

There are four basic tools one can use to create a basic regular expression:

1)  Character sets\
2)  Meta characters\
3)  Quantifiers\
4)  Groups

**Character sets**

Character sets, are a way of expressing listing options for a character match, within brackets. So any a match will be triggered if any of the characters within the brackets are found in the string. For example, to look for vowels one could use this character set: "[aeiou]". Some other common character sets are:

| Character set | Matches for                     |
|---------------|---------------------------------|
| `"[A-Z]"`     | any single capital letter       |
| `"[a-z]"`     | any single lowercase letter     |
| `"[0-9]"`     | any digit                       |
| `[:alnum:]`   | any alphanumeric character      |
| `[:digit:]`   | any numeric digit               |
| `[:alpha:]`   | any letter (upper or lowercase) |
| `[:upper:]`   | any uppercase letter            |
| `[:lower:]`   | any lowercase letter            |

Character sets can be combined within one bracket (no spaces!), such as `"[A-Za-z]"` (any upper or lowercase letter), or another example `"[t-z0-5]"` (lowercase t through z OR number 0 through 5).

**Meta characters**

Meta characters are shorthand for character sets. Some of the important ones are listed below:

| Meta character | Represents                                           |
|----------------|------------------------------------------------------|
| `"\\s"`        | a single space                                       |
| `"\\w"`        | any single alphanumeric character (A-Z, a-z, or 0-9) |
| `"\\d"`        | any single numeric digit (0-9)                       |

**Bộ định lượng**

Thông thường, bạn không muốn tìm kiếm kết quả phù hợp chỉ trên một ký tự. Bộ định lượng cho phép bạn chỉ định độ dài của các chữ cái/số để cho phép ghép nối.

Bộ định lượng là các số được viết trong dấu ngoặc nhọn `{ }` *sau* ký tự mà chúng đang định lượng, ví dụ:

-   `"A{2}"` sẽ trả về trường hợp **hai** chữ cái A viết hoa.\
-   `"A{2,4}"` sẽ trả về các trường hợp **từ hai đến bốn** chữ cái A viết hoa *(không đặt dấu cách!)*.\
-   `"A{2,}"` sẽ trả về các trường hợp **từ hai hoặc nhiều hơn** chữ cái A viết hoa.\
-   `"A+"` sẽ trả về các trường hợp **từ một hoặc nhiều hơn** chữ cái A viết hoa (nhóm được mở rộng cho đến khi gặp một ký tự khác).\
-   Bắt đầu bằng dấu hoa thị `*` để trả về **khôgn hoặc nhiều hơn** kết quả phù hợp (hữu ích nếu bạn không chắc chắn pattern có sẵn)

Sử dụng ký hiệu dấu cộng `+` như một bộ định lượng, việc khớp sẽ xảy ra cho tới khi gặp ký tự khác. Ví dụ, biểu thứ này sẽ trả về tất cả *các từ* (ký tự alpha: `"[A-Za-z]+"`

```{r}
# test string for quantifiers
test <- "A-AA-AAA-AAAA"
```

Khi bộ định lượng {2} được sử dụng, chỉ các cặp chữ A liên tiếp được trả về. Hai cặp được xác định trong `AAAA`.

```{r}
str_extract_all(test, "A{2}")
```

Khi bộ định lượng {2,4} được sử dụng, các nhóm chữ A liên tiếp có độ dài từ hai đến bốn được trả về.

```{r}
str_extract_all(test, "A{2,4}")
```

Với bộ định lượng `+`, các nhóm của **một hoặc nhiều hơn** được trả về:

```{r}
str_extract_all(test, "A+")
```

**Vị trí tương đối**

Những biểu thức dưới đây yêu cầu cho những thứ đứng trước hoặc theo sau một mẫu. Ví dụ, để trích xuất câu, "two numbers that are followed by a period" (`""`). (?\<=\\.)\\s(?=[A-Z])

```{r}
str_extract_all(test, "")
```

| Biểu thức vị trí | Khớp với                            |
|------------------|-------------------------------------|
| `"(?<=b)a"`      | "a" **bị đứng trước** bởi "b"       |
| `"(?<!b)a"`      | "a" **KHÔNG bị đứng trước** bởi "b" |
| `"a(?=b)"`       | "a" **được theo sau** bởi "b"       |
| `"a(?!b)"`       | "a" **KHÔNG được theo sau** bởi "b" |

**Nhóm**

Việc bắt các nhóm trong biểu thức chính quy là một cách để kết quả trả về có tổ chức hơn khi trích xuất.

**Ví dụ về Regex**

Dưới đây là một văn bản tự do sử dụng làm ví dụ. Chúng ta sẽ cố gắng trích xuất thông tin hữu ích từ nó bằng cách sử dụng cụm từ tìm kiếm theo biểu thức chính quy.

```{r}
pt_note <- "Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute."
```

Biểu thức sau đây khớp với tất cả các từ (bất kỳ ký tự nào cho đến khi gặp thứ không phải ký tự, chẳng hạn như dấu cách):

```{r}
str_extract_all(pt_note, "[A-Za-z]+")
```

Biểu thức `"[0-9]{1,2}"` khớp với các số liên tiếp có độ dài 1 hoặc 2 chữ số. Nó cũng có thể được viết là `"\\d{1,2}"`, hoặc `"[:digit:]{1,2}"`.

```{r}
str_extract_all(pt_note, "[0-9]{1,2}")
```

<!-- This expression will extract all sentences (assuming first letter is capitalized, and the sentence ends with a period). The pattern reads in English as: "A capital letter followed by some lowercase letters, a space, some letters, a space,     -->

<!-- ```{r} -->

<!-- str_extract_all(pt_note, "[A-Z][a-z]+\\s\\w+\\s\\d{1,2}\\s\\w+\\s*\\w*") -->

<!-- ``` -->

Bạn có thể xem danh sách hữu ích về các biểu thức regex và các mẹo trên trang 2 của [cheatsheet này](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

Bạn cũng có thể xem [tutorial này](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432).

<!-- ======================================================= -->

## Nguồn

Bạn có thể tìm thấy trang tham khảo cho các hàm **stringr** [tại đây](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

Một vignette về **stringr** có thể được tìm thấy [tại đây](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)
