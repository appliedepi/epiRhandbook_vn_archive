
# Biểu đồ nhiệt {#heatmaps}  


Biểu đồ nhiệt, còn được gọi là "bản đồ nhiệt" hoặc "bảng nhiệt", là những hình ảnh trực quan hữu ích khi cố gắng hiển thị 3 biến (trục x, trục y và màu sắc). Dưới đây chúng tôi minh họa hai ví dụ:

* Ma trận trực quan về các sự kiện lây truyền theo độ tuổi ("ai lây nhiễm cho ai")
* Theo dõi các chỉ số báo cáo trên nhiều cơ sở/khu vực theo thời gian 

```{r, out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "transmission_matrix.png"))

knitr::include_graphics(here::here("images", "heat_tile.png"))

```





<!-- ======================================================= -->
## Chuẩn bị cho vẽ biểu đồ nhiệt { }

### Tải packages {.unnumbered}  

Đoạn mã dưới đây hiển thị cách tải các packages cần thiết cho việc phân tích dữ liệu. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, cài đặt packages nếu cần *và* tải nó để sử dụng. Bạn cũng có thể tải các packages đã cài đặt với hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về packages R. 

```{r}
pacman::p_load(
  tidyverse,       # data manipulation and visualization
  rio,             # importing data 
  lubridate        # working with dates
  )
```

**Bộ dữ liệu**  

Chương này sẽ sử dụng danh sách trường hợp bùng phát mô phỏng cho phần ma trận lây truyền và tập dữ liệu riêng về số ca sốt rét được ghi nhận hàng ngày theo cơ sở. Chúng sẽ được tải và làm sạch trong từng phần riêng. 






## Ma trận lây truyền 

Bảng nhiệt có thể hữu ích để trực quan hóa ma trận. Một ví dụ là hiển thị "ai đã lây nhiễm" trong một đợt bùng phát. Giả sử rằng bạn có đầy đủ thông tin về các sự kiện lây truyền. 

Lưu ý rằng chương [Truy vết tiếp xúc] có một ví dụ khác về tạo ma trận tiếp xúc thành bảng nhiệt, sử dụng một dataset khác (có lẽ đơn giản hơn) trong đó tuổi của các trường hợp và nguồn của chúng được căn chỉnh gọn gàng trong cùng một hàng của khung dữ liệu. Dataset này cũng được sử dụng để tạo bản đồ *mật độ* trong chương [Các tips với ggplot]. Ví dụ dưới đây bắt đầu từ một danh sách các trường hợp liên quan chủ yếu đến thao tác dữ liệu trước khi có thể vẽ một khung dữ liệu. Vì vậy, có rất nhiều phương pháp vẽ biểu đồ để bạn lựa chọn...


Chúng tôi bắt đầu từ danh sách trường hợp của một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, hãy <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click để tải một linelist "đã làm sạch" ở đây</a> (as .rds file). Nhập dữ liệu của bạn bằng hàm `import()` từ package **rio**  (hàm này chấp nhận nhiều loại tệp như .xlsx, .rds, .csv - Xem chương [Nhập xuất dữ liệu] để biết thêm chi tiết). 


Danh sách dưới đây bao gồm 50 hàng đầu tiên của linelist: 


```{r, echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```


Trong linelist này:  

* Mỗi trường hợp được thể hiện trong một hàng, được phân biệt bằng `case_id`  
* Kéo sang phải bạn sẽ thấy cột `infector` có chứa `case_id` của *nguồn lây*, mỗi nguồn lây cũng là một trường hợp trong linelist


```{r message=FALSE, echo=F}
# display the population as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### Chuẩn bị dữ liệu {.unnumbered}  

**Mục tiêu**: Chúng ta cần tạo một khung dữ liệu kiểu "ngang", tức là các dữ liệu của một biến được biểu diễn trên một hàng, các cột sẽ chứa thông tin của hàng đó đối với tất cả các sự kiện truyền được quan sát trong linelist. 

Để đạt được mục tiêu này, một số bước trong thao tác dữ liệu cần được thực hiện:  

#### Tạo khung dữ liệu trường hợp {.unnumbered} 

Để bắt đầu, chúng tôi tạo một khung dữ liệu về các trường hợp, độ tuổi của các biến và những nguồn lây nhiễm - chúng tôi gọi khung dữ liệu là `case_ages`. 50 hàng đầu tiên của khung dữ liệu được hiển thị bên dưới.   

```{r}
case_ages <- linelist %>% 
  select(case_id, infector, age_cat) %>% 
  rename("case_age_cat" = "age_cat")
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(case_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Tạo khung dữ liệu nguồn lây nhiễm {.unnumbered}  

Tiếp theo, chúng tôi tạo một khung dữ liệu của những nguồn lây nhiễm - tại thời điểm này, nó bao gồm một cột duy nhất. Đây là các ID đầu nhập từ một linelist. Không phải mọi trường hợp đều có nguồn lây, vì vậy chúng tôi loại bỏ các giá trị bị thiếu. 50 hàng đầu tiên được hiển thị bên dưới. 

```{r}
infectors <- linelist %>% 
  select(infector) %>% 
  drop_na(infector)
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(infectors, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Tiếp theo, chúng tôi thu thập tuổi của những người lây nhiễm. Điều này không đơn giản, vì trong `linelist`, tuổi của người lây nhiễm không được liệt kê như vậy. Chúng tôi thu thập được kết quả này bằng cách kết hợp các trường hợp trong `linelist` cho những người lây nhiễm. Chúng tôi bắt đầu với dữ liệu về người lây nhiễm và `left_join()` (thêm) các trường hợp trong `linelist` vào cột bên trái của khung dữ liệu "baseline", cột id của `infector` kết hợp với cột `case_id` ở bên phải khung dữ liệu `linelist`. 

Do đó, dữ liệu từ bản ghi trường hợp của người lây nhiễm trong linelist (bao gồm cả tuổi) được thêm vào hàng của người lây nhiễm. 50 hàng đầu tiên được hiển thị bên dưới. 

```{r}
infector_ages <- infectors %>%             # begin with infectors
  left_join(                               # add the linelist data to each infector  
    linelist,
    by = c("infector" = "case_id")) %>%    # match infector to their information as a case
  select(infector, age_cat) %>%            # keep only columns of interest
  rename("infector_age_cat" = "age_cat")   # rename for clarity
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(infector_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Sau đó, chúng tôi kết hợp các trường hợp và tuổi với những người lây nhiễm và tuổi của người lây nhiễm. Mỗi khung dữ liệu này có chung cột `infector`, vì vậy nó được sử dụng cho phép nối. Các hàng đầu tiên được hiển thị bên dưới: 

```{r}
ages_complete <- case_ages %>%  
  left_join(
    infector_ages,
    by = "infector") %>%        # each has the column infector
  drop_na()                     # drop rows with any missing data
```


```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(ages_complete, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Dưới đây là bảng tổng hợp đơn giản về số lượng giữa các nhóm tuổi trường hợp và người lây nhiễm. Nhãn được thêm vào để phân biệt. 

```{r}
table(cases = ages_complete$case_age_cat,
      infectors = ages_complete$infector_age_cat)
```


Chúng ta có thể chuyển đổi bảng này thành khung dữ liệu với hàm `data.frame()` từ **base** R, hàm sẽ tự động chuyển đổi dữ liệu sang kiểu "ngang", để có thể áp dụng trong hàm `ggplot()`. Các hàng đầu tiên được hiển thị bên dưới. 

```{r}
long_counts <- data.frame(table(
    cases     = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat))
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(long_counts, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Bây giờ chúng ta làm tương tự, nhưng áp dụng hàm `prop.table()` từ **base** R vào bảng để thay vì đếm, chúng ta nhận được tỷ lệ của tất cả các biến. 50 hàng đầu tiên được hiển thị bên dưới. 

```{r}
long_prop <- data.frame(prop.table(table(
    cases = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat)))
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(long_prop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




### Tạo biểu đồ nhiệt {.unnumbered}  

Cuối cùng, chúng ta có thể vẽ biểu đồ nhiệt với hàm `geom_tile()` trong package **ggplot2**. Xem chương [Các tips với ggplot] để tìm hiểu sâu hơn về thang màu/tô màu cho biểu đồ, đặc biệt là hàm `scale_fill_gradient()`. 

* Trong thẩm mỹ thì `aes()` của hàm `geom_tile()` sẽ đặt trục x và y làm tuổi của các trường hợp và tuổi của người lây nhiễm  
* Ngoài ra trong `aes()` hãy đặt đối số `fill = ` thành cột `Freq` -  đây là giá trị sẽ được chuyển đổi thành màu gạch
* Đặt màu tỷ lệ với `scale_fill_gradient()` -  bạn có thể chỉ định màu cao/thấp  
  * Lưu ý rằng `scale_color_gradient()` thì khác! Trong trường hợp này, bạn muốn tô màu
* Vì màu được tạo thông qua "fill",  bạn có thể sử dụng đối số  `fill = ` đối số trong hàm `labs()` để thay đổi tiêu đề chú giải 

```{r}
ggplot(data = long_prop)+       # use long data, with proportions as Freq
  geom_tile(                    # visualize it in tiles
    aes(
      x = cases,         # x-axis is case age
      y = infectors,     # y-axis is infector age
      fill = Freq))+            # color of the tile is the Freq column in the data
  scale_fill_gradient(          # adjust the fill color of the tiles
    low = "blue",
    high = "orange")+
  labs(                         # labels
    x = "Case age",
    y = "Infector age",
    title = "Who infected whom",
    subtitle = "Frequency matrix of transmission events",
    fill = "Proportion of all\ntranmsission events"     # legend title
  )
  
```



<!-- ======================================================= -->
## Các chỉ số báo cáo theo thời gian { }

Thông thường, trong lĩnh vực y tế công cộng, một mục tiêu là đánh giá xu hướng theo thời gian của nhiều thực thể (cơ sở, khu vực pháp lý, v.v.). Một cách để hình dung các xu hướng như vậy theo thời gian là biểu đồ nhiệt trong đó trục x là thời gian và trên trục y là các thực thể. 


### Chuẩn bị dữ liệu {.unnumbered}

Chúng ta bắt đầu bằng cách nhập bộ dữ liệu báo cáo về bệnh sốt rét hàng ngày từ nhiều cơ sở. Các báo cáo chứa dữu liệu về ngày, tỉnh, huyện và số lượng sốt rét. Xem chương [Tải sách và dữ liệu] để biết thông tin về cách tải xuống các dữ liệu này. Dưới đây là 30 hàng đầu tiên: 

```{r, echo=F}
facility_count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  select(location_name, data_date, District, malaria_tot)
```

```{r, eval=F}
facility_count_data <- import("malaria_facility_count_data.rds")
```


```{r, echo=F}
DT::datatable(head(facility_count_data,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```


#### Tổng hợp và tóm tắt {.unnumbered}

**Mục tiêu của ví dụ này** là chuyển đổi  *tổng số* số ca bệnh sốt rét hàng ngày tại các cơ sở (xem trong tab trước) thành số liệu thống kê tóm tắt *hàng tuần* về hiệu suất báo cáo của cơ sở - trong trường hợp này là *tỷ lệ số ngày mỗi tuần mà cơ sở báo cáo bất kỳ dữ liệu*. Đối với ví dụ này, chúng tôi sẽ chỉ hiển thị dữ liệu cho **Spring District**. 

Để đạt được điều này, chúng ta sẽ thực hiện các bước quản lý dữ liệu sau:

1) Lọc dữ liệu phù hợp (theo địa điểm, ngày tháng)   
2) Tạo cột tuần bằng cách sử dụng hàm `floor_date()` trong package **lubridate**  
    + Hàm này trả về ngày bắt đầu trong tuần của một ngày cụ thể, sử dụng ngày bắt đầu được chỉ định của mỗi tuần (ví dụ: "Thứ Hai") 
3) Dữ liệu được nhóm theo cột "cơ sở" và "tuần" để tạo ra các đơn vị phân tích của "cơ sở-tuần"  
4) Hàm `summarise()` tạo các cột mới để phản ánh thống kê tóm tắt cho mỗi nhóm cơ sở theo tuần:  
    + Số ngày mỗi tuần (7 - một giá trị không đổi)  
    + Số lượng báo cáo nhận được từ cơ sở-tuần (có thể nhiều hơn 7!)  
    + Tổng số ca sốt rét do cơ sở báo cáo trong tuần (chỉ dành cho ai quan tâm)   
    + Số ngày *duy nhất* trong tuần cơ sở có dữ liệu được báo cáo  
    + **Phần trăm trong số 7 ngày mỗi cơ sở-tuần mà dữ liệu được báo cáo**  
5) Khung dữ liệu được kết hợp với hàm `right_join()` thành một danh sách toàn diện về tất cả các kết hợp cơ sở-tuần có thể có, để làm cho tập dữ liệu hoàn chỉnh. Ma trận của tất cả các kết hợp có thể có được tạo bằng cách áp dụng hàm `expand()` cho hai cột đó của khung dữ liệu giống như tại thời điểm đó trong pipe (được biểu thị bằng `.`). Vì sử dụng hàm `right_join()`, nên tất cả các hàng trong khung dữ liệu `expand()` được giữ lại và được thêm vào `agg_weeks` nếu cần. Các hàng mới này xuất hiện với các giá trị tóm tắt `NA` (missing). 


Dưới đâ là từng bước thực hiện: 

```{r, message=FALSE, warning=FALSE}
# Create weekly summary dataset
agg_weeks <- facility_count_data %>% 
  
  # filter the data as appropriate
  filter(
    District == "Spring",
    data_date < as.Date("2020-08-01")) 
```

Bây giờ tập dữ liệu có hàng ` nrow(agg_weeks)`, trước đây là hàng ` nrow(facility_count_data)`.  
 
Tiếp theo, chúng ta tạo cột `tuần` để phản ánh ngày bắt đầu trong tuần cho mỗi bản ghi. Thực hiện điều này với hàm `floor_date ()` trong package **lubridate**, được đặt thành "tuần" và các tuần sẽ bắt đầu vào Thứ Hai (ngày 1 trong tuần - Chủ Nhật sẽ là 7). Các hàng trên cùng được hiển thị bên dưới. 

```{r}
agg_weeks <- agg_weeks %>% 
  # Create week column from data_date
  mutate(
    week = lubridate::floor_date(                     # create new column of weeks
      data_date,                                      # date column
      unit = "week",                                  # give start of the week
      week_start = 1))                                # weeks to start on Mondays 
```

Cột tuần mới có thể được nhìn thấy ở ngoài cùng bên phải của khung dữ liệu: 

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Bây giờ chúng ta nhóm dữ liệu thành các cơ sở-tuần và tóm tắt chúng để tạo ra số liệu thống kê cho mỗi cơ sở-tuần. Xem trang trên [Bảng mô tả] để biết các mẹo. Bản thân việc nhóm sẽ không thay đổi khung dữ liệu, nhưng nó ảnh hưởng đến cách tính toán thống kê tóm tắt tiếp theo. 

Các hàng trên cùng được hiển thị bên dưới. Lưu ý cách các cột đã thay đổi hoàn toàn để phản ánh thống kê tóm tắt mong muốn. Mỗi hàng phản ánh một cơ sở-tuần. 

```{r, warning=F, message=F}
agg_weeks <- agg_weeks %>%   

  # Group into facility-weeks
  group_by(location_name, week) %>%
  
  # Create summary statistics columns on the grouped data
  summarize(
    n_days          = 7,                                          # 7 days per week           
    n_reports       = dplyr::n(),                                 # number of reports received per week (could be >7)
    malaria_tot     = sum(malaria_tot, na.rm = T),                # total malaria cases reported
    n_days_reported = length(unique(data_date)),                  # number of unique days reporting per week
    p_days_reported = round(100*(n_days_reported / n_days)))      # percent of days reporting
```

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Cuối cùng, chúng ta chạy lệnh bên dưới để đảm bảo rằng TẤT CẢ các cơ sở-tuần có thể có trong dữ liệu, ngay cả khi chúng bị missing trước đó. 

Chúng ta đang sử dụng hàm `right_join()` trên chính nó (tập dữ liệu được đại diện bởi ".") nhưng đã được mở rộng để bao gồm tất cả các kết hợp có thể có của các cột `week` và `location_name`. Xem tài liệu về hàm `expand()` trong chương [Xoay trục dữ liệu]. Trước khi chạy đoạn code này, tập dữ liệu cần chứa các hàng `nrow(agg_weeks)`. 

```{r, message=F, warning=F}
# Create data frame of every possible facility-week
expanded_weeks <- agg_weeks %>% 
  mutate(week = as.factor(week)) %>%         # convert date to a factor so expand() works correctly
  tidyr::expand(., week, location_name) %>%  # expand data frame to include all possible facility-week combinations
                                             # note: "." represents the dataset at that moment in the pipe chain
  mutate(week = as.Date(week))               # re-convert week to class Date so the subsequent right_join works
```

Đây là `expanded_weeks`:  

```{r, echo=F}
DT::datatable(expanded_weeks, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

TRước khi chạy dòng lệnh này, biến `agg_weeks` gồm hàng ` nrow(agg_weeks)`.    

```{r}
# Use a right-join with the expanded facility-week list to fill-in the missing gaps in the data
agg_weeks <- agg_weeks %>%      
  right_join(expanded_weeks) %>%                            # Ensure every possible facility-week combination appears in the data
  mutate(p_days_reported = replace_na(p_days_reported, 0))  # convert missing values to 0                           
```

Sau khi chạy dòng lệnh này, biến `agg_weeks` vẫn bao gồm ` nrow(agg_weeks)`.    


<!-- ======================================================= -->
### Tạo biểu đồ nhiệt {.unnumbered}


Lệnh `ggplot()` được thực hiện bằng cách sử dụng hàm `geom_tile()` từ package **ggplot2**:  

* Các tuần trên trục x được chuyển đổi thành ngày tháng, cho phép sử dụng `scale_x_date()`  
* `location_name` trên trục y sẽ hiển thị tất cả các tên cơ sở 
* Lệnh `fill` là `p_days_reported`, hiệu suất cho cơ sở-tuần (số) 
* `scale_fill_gradient()` được sử dụng trên tô màu với một số, chỉ định màu sắc cho cao, thấp và `NA`  
* `scale_x_date()` được sử dụng trên trục x chỉ định các nhãn 2 tuần một lần và định dạng của chúng   
* Các chủ đề và nhãn hiển thị có thể được điều chỉnh khi cần thiết 




<!-- ======================================================= -->
### Cơ bản {.unnumbered}  

Biểu đồ nhiệt cơ bản sẽ được tạo như  bên dưới, sử dụng màu mặc định, tỷ lệ, v.v. Như đã giải thích ở trên, trong `aes()` của `geom_tile()`, bạn phải cung cấp cột trục x, cột trục y, **và** một cột cho `fill = `. Phần tô là giá trị số thể hiện dưới dạng màu ô. 

```{r}
ggplot(data = agg_weeks)+
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported))
```

### Làm sạch biểu đồ nhiệt {.unnumbered}

Chúng ta có thể làm cho biểu đồ này trông đẹp hơn bằng cách thêm các hàm **ggplot2** bổ sung, như được hiển thị bên dưới. Xem thêm chương [Các tips với ggplot] để biết thêm chi tiết.  

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                  # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```





<!-- ======================================================= -->
### Sắp xếp thứ tự trục y {.unnumbered}  
 
Hiện tại, các cơ sở được sắp xếp theo thứ tự "theo bảng chữ cái" từ dưới lên trên. Nếu bạn muốn điều chỉnh thứ tự các cơ sở trục y, hãy chuyển đổi chúng thành hệ số thứ bậc và cung cấp thứ tự. Xem xêm chương [Factors] để biết các mẹo để thực hiện điều này. 

Vì có rất nhiều cơ sở và chúng ta không muốn viết hết chúng ra, chúng ta sẽ thử một cách tiếp cận khác - sắp xếp thứ tự các cơ sở trong khung dữ liệu và sử dụng cột tên kết quả làm thứ tự cấp yếu tố. Bên dưới, cột `location_name` được chuyển đổi thành một hệ số và thứ tự của các cấp của nó được đặt dựa trên tổng số ngày báo cáo do cơ sở nộp trong toàn bộ khoảng thời gian. 

Để làm điều này, chúng ta tạo một khung dữ liệu đại diện cho tổng số báo cáo cho mỗi cơ sở, được sắp xếp theo thứ tự tăng dần. Chúng ta có thể sử dụng vectơ này để sắp xếp các mức thứ tự trong biểu đồ.   

```{r}
facility_order <- agg_weeks %>% 
  group_by(location_name) %>% 
  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %>% 
  arrange(tot_reports) # ascending order
```

Xem khung dữ liệu bên dưới:   

```{r, echo=F}
DT::datatable(facility_order, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```



Bây giờ, hãy sử dụng một cột từ khung dữ liệu trên (`facility_order$location_name`) để làm thứ tự các thứ bậc factors của `location_name` trong khung dữ liệu `agg_weeks`: 

```{r, warning=F, message=F}
# load package 
pacman::p_load(forcats)

# create factor and define levels manually
agg_weeks <- agg_weeks %>% 
  mutate(location_name = fct_relevel(
    location_name, facility_order$location_name)
    )
```

Và bây giờ dữ liệu được vẽ lại, với location_name là một factor có thứ tự: 

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                  # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```





<!-- ======================================================= -->
### Biểu diễn các giá trị {.unnumbered}  


Bạn có thể thêm lệnh `geom_text()` trước các ô, để hiển thị số lượng thực của mỗi ô. Hãy lưu ý rằng điều này có thể trông không đẹp nếu bạn có nhiều ô nhỏ! 
 
Đoạn mã sau đã được thêm vào: `geom_text(aes(label = p_days_reported))`. Điều này thêm văn bản vào mỗi ô. Văn bản được hiển thị là giá trị được gán cho đối số  `label = `, trong trường hợp này đã được đặt thành cùng một cột số `p_days_reported` cũng được sử dụng để tạo gradient màu.  



  
```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  # text
  geom_text(
    aes(
      x = week,
      y = location_name,
      label = p_days_reported))+      # add text on top of tile
  
  # fill scale
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                    # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```




<!-- ======================================================= -->
## Tài liệu tham khảo { }

[scale_fill_gradient()](https://ggplot2.tidyverse.org/reference/scale_gradient.html)  

[R graph gallery - heatmap](https://ggplot2.tidyverse.org/reference/scale_gradient.html)  




