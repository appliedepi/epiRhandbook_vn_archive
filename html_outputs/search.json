[{"path":"index.html","id":"section","chapter":"","heading":"","text":"","code":""},{"path":"index.html","id":"dịch-tễ-học-ứng-dụng-và-y-tế-công-cộng-với-r","chapter":"","heading":"Dịch tễ học ứng dụng và y tế công cộng với R","text":"Sổ tay này hướng tới:Là một tài liệu tham khảo R một cách nhanh chóngCung cấp các ví dụ tập trung vào nhiệm vụ giải quyết các vấn đề dịch tễ học phổ biếnHỗ trợ các nhà dịch tễ học chuyển sang sử dụng RCó thể sử dụng trong các tình huống có kết nối internet thấp thông qua phiên bản ngoại tuyến  Được viết bởi các nhà dịch tễ học, dành cho các nhà dịch tễ họcChúng tôi là những nhà dịch tễ học đến từ khắp mọi nơi trên thế giới, viết trong thời gian rảnh của mình để cung cấp tài liệu này tới cộng đồng. Sự động viên và góp ý của bạn luôn được chào đón thông qua:Gửi biểu mẫu phản hồiEmail tới epiRhandbook@gmail.com hoặc tweet @epiRhandbookGửi các vấn đề cho chúng tôi tại Github repository","code":""},{"path":"index.html","id":"sổ-tay-này-được-sử-dụng-như-thế-nào","chapter":"","heading":"Sổ tay này được sử dụng như thế nào","text":"Truy cập các trang trong phần Mục lục, hoặc sử dụng ô tìm kiếmNhấn biểu tượng “copy” để sao chép codeKết hợp theo dõi cùng với các bộ dữ liệu minh họaXem phần “Tài nguyên” trong từng chương để tìm thêm tài liệuPhiên bản ngoại tuyếnXem hướng dẫn tại trang Tải sách và dữ liệu.","code":""},{"path":"index.html","id":"lời-cảm-ơn","chapter":"","heading":"Lời cảm ơn","text":"Sổ tay này được tạo ra bởi sự hợp tác của các nhà dịch tễ học từ khắp nơi trên thế giới, đúc kết kinh nghiệm cùng với các tổ chức khác bao gồm các cơ quan y tế địa phương, tiểu bang, tỉnh và quốc gia, Tổ chức Y tế Thế giới (), Tổ chức Bác sỹ không biên giới (MSF), hệ thống các bệnh viện, và các đơn vị nghiên cứu.Sổ tay này không phải là sản phẩm đã được phê duyệt của bất kỳ tổ chức cụ thể nào. Mặc dù chúng tôi cố gắng đảm bảo tính chính xác, nhưng chúng tôi không chịu trách nhiệm về nội dung trong cuốn sách này.","code":""},{"path":"index.html","id":"những-người-đóng-góp","chapter":"","heading":"Những người đóng góp","text":"Chủ biên: Neale BatraNhóm nòng cốt dự án: Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay CampbellNhóm tác giả: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen LinNhóm dịch giả: Nguyễn Thanh Lương, Nguyễn Thị Khánh Huyền, Võ Hữu Thuận, Nguyễn Trung Thành, Vũ Thu Hà, Hồ Hoàng DungNhóm phản biện: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao MuiangaHình minh họa: Calder Fong","code":""},{"path":"index.html","id":"tài-trợ-và-hỗ-trợ","chapter":"","heading":"Tài trợ và hỗ trợ","text":"Sổ tay này nhận được tài trợ thông qua kinh phí hỗ trợ trợ xây dựng năng lực khẩn cấp COVID-19 từ TEPHINET, mạng lưới toàn cầu của các Chương trình Đào tạo Dịch tễ học Thực địa (FETPs).Các hỗ trợ hành chính được cung cấp bởi mạng lưới cựu sinh EPIET (EAN), với lời cảm ơn đặc biệt tới Annika Wendland. EPIET là Chương trình đào tạo Dịch tễ học can thiệp tại Châu Âu.Đặc biệt gửi lời cảm ơn tới Trung tâm Điều hành Amsterdam (OCA) của Tổ chức Bác sỹ không biên giới (MSF) cho những sự hỗ trợ của họ trong quá trình phát triển cuốn sổ tay này.Ấn phẩm này được hỗ trợ bởi Hợp đồng Hợp tác số NU2GGH001873, được tài trợ bởi Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh thông qua TEPHINET, một chương trình của Lực lượng đặc nhiệm về sức khỏe toàn cầu. Nội dung của sổ tay hoàn toàn tác giả chịu trách nhiệm và đại diện cho quan điểm chính thức của Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh, Bộ Y tế và Dịch vụ Nhân sinh, Lực lượng Đặc nhiệm về Sức khỏe Toàn cầu, hoặc TEPHINET","code":""},{"path":"index.html","id":"cảm-hứng","chapter":"","heading":"Cảm hứng","text":"Rất nhiều các hướng dẫn và tóm tắt cung cấp kiến thức sử dụng để phát triển nội dung sổ tay này được tham khảo trong các trang nội dung tương ứng.Một cách tổng quát hơn, các nguồn sau đây đã truyền nguồn cảm hứng cho cuốn sổ tay này:“R4Epis” project (một sự hợp tác giữa MSF và RECON)R Epidemics Consortium (RECON)R Data Science book (R4DS)bookdown: Authoring Books Technical Documents R MarkdownNetlify để lưu trữ trang web này","code":""},{"path":"index.html","id":"điều-khoản-sử-dụng-và-đóng-góp","chapter":"","heading":"Điều khoản sử dụng và đóng góp","text":"","code":""},{"path":"index.html","id":"giấy-phép","chapter":"","heading":"Giấy phép","text":"Sổ tay này được cấp phép theo Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Chúng tôi khuyến khích các khóa học và các chương trình đào tạo dịch tễ sử dụng cuốn sổ tay này cho sinh viên của mình. Nếu bạn có thắc mắc về mục đích sử dụng của mình, hãy gửi email tới epiRhandbook@gmail.com.","code":""},{"path":"index.html","id":"trích-dẫn","chapter":"","heading":"Trích dẫn","text":"Neale Batra và cộng sự, Cẩm nang Dịch tễ học với R. ","code":""},{"path":"index.html","id":"đóng-góp","chapter":"","heading":"Đóng góp","text":"Nếu bạn muốn đóng góp nội dung, vui lòng liên hệ với chúng tôi thông qua Github hoặc email. Chúng tôi đang triển khai lịch trình cập nhật cho cuốn sách cũng như xây dựng hướng dẫn dành cho cộng tác viên.Xin lưu ý rằng dự án epiRhandbook được phát hành cùng với bộ Quy tắc ứng xử của cộng tác viên. Bằng cách đóng góp cho dự án này, bạn đồng ý tuân theo các điều khoản của nó.","code":""},{"path":"editorial-style.html","id":"editorial-style","chapter":"1 Biên tập và ghi chú kỹ thuật","heading":"1 Biên tập và ghi chú kỹ thuật","text":"Trong chương này, chúng tôi sẽ mô tả triết lý và phong cách viết code, cũng như các quyết định biên tập cụ thể được thực hiện trong việc tạo ra cuốn sổ tay này.","code":""},{"path":"editorial-style.html","id":"cách-tiếp-cận-và-phong-cách","chapter":"1 Biên tập và ghi chú kỹ thuật","heading":"1.1 Cách tiếp cận và phong cách","text":"Độc giả tiềm năng của cuốn sách này là rất lớn, bao gồm những người hoàn toàn mới đối với R, và cả những người dùng R có kinh nghiệm đang tìm kiếm cho mình các phương pháp và mẹo hay nhất. Vì vậy, cuốn sách cần phải vừa dễ tiếp cận vừa ngắn gọn. đó, cách tiếp cận của chúng tôi là cung cấp lượng văn bản giải thích vừa đủ để một người mới sử dụng R cũng có thể áp dụng code và hiểu code đang làm gì.Một vài điểm lưu ý:Đây là cuốn sách tham khảo về code đi kèm với những ví dụ tương đối ngắn gọn - không phải một cuốn sách giáo khoa về R hay khoa học dữ liệuĐây là một cuốn sổ tay về R sử dụng trong dịch tễ học ứng dụng - không phải là một hướng dẫn về các phương pháp của dịch tễ học ứng dụngCuốn sách dự kiến sẽ luôn được thay đổi và cập nhập các R packages tối ưu cho một nhiệm vụ luôn được thay đổi thường xuyên, vì vậy chúng tôi hoan nghênh những thảo luận về những điều được nhấn mạnh trong cuốn sách này","code":""},{"path":"editorial-style.html","id":"r-packages","chapter":"1 Biên tập và ghi chú kỹ thuật","heading":"R packages","text":"Quá nhiều lựa chọnMột trong những khía cạnh thách thức nhất của việc học R là bạn biết package nào được sử dụng trong trường hợp nào. Việc vật lộn với một công việc mà chỉ sau này bạn nhận ra là có một package R giúp bạn thực hiện tất cả những điều đó trong một dòng lệnh là điều không hề hiếm gặp!Trong sổ tay này, chúng tôi cố gắng cung cấp cho bạn ít nhất hai cách để hoàn thành công việc: một phương pháp đã thử và đúng (có thể là base R hoặc tidyverse) và một R package đặc biệt được thiết kế riêng cho mục đích đó. Chúng tôi muốn bạn có một số tùy chọn trong trường hợp bạn không thể tải xuống một package nhất định hoặc package đó không hoạt động với bạn.Khi lựa chọn package để làm việc, chúng tôi ưu tiên các R package và phương pháp tiếp cận đã được cộng đồng thử nghiệm và hiệu chỉnh, giảm thiểu số lượng package được sử dụng trong một phiên làm việc điển hình, bao gồm sự ổn định (không thay đổi thường xuyên) và giúp hoàn thành nhiệm vụ một cách đơn giản và gọn gàngCuốn sách này ưu tiện các package và câu lệnh từ thư viện tidyverse. Tidyverse là một tuyển tập các R package được thiết kế dành riêng cho khoa học dữ liệu, trong đó các package này chia sẻ nền tảng ngữ pháp và cấu trúc dữ liệu chung. Tất cả các package từ thư viện tidyverse có thể được cài đặt hoặc gọi thông qua thư viện tidyverse. Đọc thêm tại tidyverse website.Khi thích hợp, chúng tôi cũng cung cấp các tùy chọn code sử dụng base R - là các packages và hàm có sẵn của R khi cài đặt. Điều này là chúng tôi nhận thấy rằng một số độc giả của cuốn sách này có thể không có Internet tốt để tải xuống các package bổ sung.Liên kết các hàm và packages một cách rõ ràngTrong các hướng dẫn về R thường rất khó chịu khi một hàm được hiển thị trong code, nhưng bạn không biết hàm đó đến từ package nào! Chúng tôi cố gắng tránh tình trạng này.Trong các đoạn văn bản trần thuật, tên các package được viết đậm (ví dụ: dplyr) và các hàm được viết như sau: mutate(). Chúng tôi cố gắng nói rõ ràng về một hàm đến từ package nào, bằng cách tham chiếu package đó trong đoạn văn bản gần đó hoặc nhấn mạnh package đó một cách rõ ràng trong đoạn code như sau: dplyr::mutate(). Điều này nhìn có vẻ thừa thãi, nhưng chúng tôi làm điều đó là có mục đích.Tham khảo thêm chương R cơ bản để hiểu thêm về package và hàm.","code":""},{"path":"editorial-style.html","id":"phong-cách-viết-code","chapter":"1 Biên tập và ghi chú kỹ thuật","heading":"Phong cách viết code","text":"Trong sổ tay này, chúng tôi thường viết theo phong cách “thêm dòng mới”, điều này làm cho code trông có vẻ “dài hơn”. Chúng tôi làm vậy vì một vài lý sau đây:Chúng tôi có thể viết các giải thích bằng # bên cạnh mỗi phần nhỏ của codeNhìn chung, code dài hơn (theo chiều dọc) thì dễ đọc hơnNó cũng dễ đọc hơn trong một diện tích màn hình hẹp (không cần kéo thanh điều hướng trái phải)Từ việc thụt lề, có thể dễ dàng hơn để biết arguments nào thuộc về hàm nàoKết quả là, code lẽ ra sẽ được viết trông như thế này:…bây giờ sẽ được viết như thế này:Code R thường không bị ảnh hưởng bởi thêm các dòng mới hoặc thụt lề. Khi viết code, nếu bạn xuống dòng ngay sau dấu phẩy thì R sẽ tự động thụt lề cho bạn.Chúng tôi cũng sử dụng rất nhiều những khoảng cách (ví dụ n = 1 thay vì n=1) vì nó giúp dễ đọc hơn. Hãy văn minh với những người đang đọc code của bạn!","code":"\nlinelist %>% \n  group_by(hospital) %>%  # group rows by hospital\n  slice_max(date, n = 1, with_ties = F) # if there's a tie (of date), take the first row\nlinelist %>% \n  group_by(hospital) %>% # group rows by hospital\n  slice_max(\n    date,                # keep row per group with maximum date value \n    n = 1,               # keep only the single highest row \n    with_ties = F)       # if there's a tie (of date), take the first row"},{"path":"editorial-style.html","id":"danh-pháp","chapter":"1 Biên tập và ghi chú kỹ thuật","heading":"Danh pháp","text":"Trong sổ tay này, chúng tôi thường đề cập đến “cột” và “hàng” thay vì dùng “biến” và “quan sát”. Như đã giải thích trong phần sơ lược về “tidy data”, hầu hết các bộ dữ liệu thống kê dịch tễ học bao gồm các hàng, cột và giá trị theo cấu trúcBiến số chứa các giá trị đo lường của cùng một thuộc tính (như nhóm tuổi, kết cục hoặc ngày khởi phát). Các quan sát bao gồm tất cả các giá trị được đo trên cùng một đơn vị (ví dụ: người, địa điểm hoặc mẫu phòng thí nghiệm). Vì vậy, những khía cạnh này có thể khó được định nghĩa một cách cụ thể.Trong một bộ dữ liệu “tidy”, mỗi cột là một biến số, mỗi hàng là một quan sát và mỗi ô là một giá trị duy nhất. Tuy nhiên, bạn có thể gặp một số bộ dữ liệu không phù hợp với quy luật này - bộ dữ liệu định dạng “ngang” có thể có một biến số được chia thành nhiều cột (xem ví dụ trong chương Pivoting dữ liệu). Tương tự như vậy, các quan sát có thể được trải thành nhiều hàng.Phần lớn cuốn sách này tập trung vào quản lý và biến đổi dữ liệu, vì vậy việc đề cập đến cấu trúc dữ liệu cụ thể của các hàng và cột sẽ liên quan hơn là đề cập tới các khái niệm trừu tượng như các quan sát và biến. Các trường hợp ngoại lệ chủ yếu xảy ra trong các chương về phân tích dữ liệu, ở đó chúng tôi đề cập nhiều hơn đến các biến số và quan sát.","code":""},{"path":"editorial-style.html","id":"lưu-ý","chapter":"1 Biên tập và ghi chú kỹ thuật","heading":"Lưu ý","text":"Dưới đây là một vài lưu ý bạn có thể gặp trong cuốn sách:GHI CHÚ: Đây là ghi chúMẸO: Đây là mẹo.CẨN TRỌNG: Đây là ghi chú cẩn trọng.NGUY HIỂM: Đây là một cảnh báo.","code":""},{"path":"editorial-style.html","id":"quyết-định-biên-tập","chapter":"1 Biên tập và ghi chú kỹ thuật","heading":"1.2 Quyết định biên tập","text":"Dưới đây, chúng tôi ghi lại các quyết định biên tập quan trọng về việc lựa chọn package và hàm. Nếu bạn không đồng ý hoặc muốn đưa ra một công cụ mới để xem xét, vui lòng tham gia/bắt đầu cuộc thảo luận trên Trang Github của chúng tôi.Bảng các package, hàm, và các quyết định biên tập khác","code":""},{"path":"editorial-style.html","id":"các-bản-sửa-đổi-chính","chapter":"1 Biên tập và ghi chú kỹ thuật","heading":"1.3 Các bản sửa đổi chính","text":"","code":""},{"path":"editorial-style.html","id":"thông-tin-phiên-làm-việc-r-rstudio-packages","chapter":"1 Biên tập và ghi chú kỹ thuật","heading":"1.4 Thông tin phiên làm việc (R, RStudio, packages)","text":"Dưới đây là thông tin về các phiên bản của các R package, RStudio và R được sử dụng trong quá trình rendering cuốn sách này.","code":"\nsessioninfo::session_info()## - Session info ----------------------------------------------------------------------------------------------------------------------------------------------------------\n##  setting  value                       \n##  version  R version 4.1.0 (2021-05-18)\n##  os       Windows 10 x64              \n##  system   x86_64, mingw32             \n##  ui       RStudio                     \n##  language (EN)                        \n##  collate  English_United States.1252  \n##  ctype    English_United States.1252  \n##  tz       Europe/Berlin               \n##  date     2021-10-06                  \n## \n## - Packages --------------------------------------------------------------------------------------------------------------------------------------------------------------\n##  package     * version    date       lib source                               \n##  assertthat    0.2.1      2019-03-21 [1] CRAN (R 4.1.0)                       \n##  backports     1.2.1      2020-12-09 [1] CRAN (R 4.1.0)                       \n##  bookdown      0.22       2021-04-22 [1] CRAN (R 4.1.0)                       \n##  broom         0.7.6      2021-04-05 [1] CRAN (R 4.2.0)                       \n##  bslib         0.2.5.1    2021-05-18 [1] CRAN (R 4.2.0)                       \n##  cellranger    1.1.0      2016-07-27 [1] CRAN (R 4.1.0)                       \n##  cli           2.5.0      2021-04-26 [1] CRAN (R 4.1.0)                       \n##  colorspace    2.0-1      2021-05-04 [1] CRAN (R 4.2.0)                       \n##  crayon        1.4.1      2021-02-08 [1] CRAN (R 4.2.0)                       \n##  curl          4.3        2019-12-02 [1] CRAN (R 4.0.0)                       \n##  data.table    1.13.0     2020-07-24 [1] CRAN (R 4.1.0)                       \n##  DBI           1.1.1      2021-01-15 [1] CRAN (R 4.2.0)                       \n##  dbplyr        2.0.0      2020-11-03 [1] CRAN (R 4.1.0)                       \n##  digest        0.6.27     2020-10-24 [1] CRAN (R 4.1.0)                       \n##  downlit       0.2.1      2020-11-04 [1] CRAN (R 4.1.0)                       \n##  dplyr       * 1.0.6      2021-05-05 [1] CRAN (R 4.2.0)                       \n##  DT          * 0.16       2020-10-13 [1] CRAN (R 4.1.0)                       \n##  ellipsis      0.3.2      2021-04-29 [1] CRAN (R 4.2.0)                       \n##  epicontacts   1.2.0      2021-06-05 [1] Github (reconhub/epicontacts@facf491)\n##  evaluate      0.14       2019-05-28 [1] CRAN (R 4.1.0)                       \n##  fansi         0.5.0      2021-05-25 [1] CRAN (R 4.2.0)                       \n##  forcats     * 0.5.1      2021-01-27 [1] CRAN (R 4.2.0)                       \n##  foreign       0.8-81     2020-12-22 [2] CRAN (R 4.1.0)                       \n##  fs            1.5.0      2020-07-31 [1] CRAN (R 4.0.3)                       \n##  generics      0.1.0      2020-10-31 [1] CRAN (R 4.1.0)                       \n##  ggplot2     * 3.3.3      2020-12-30 [1] CRAN (R 4.2.0)                       \n##  glue          1.4.2      2020-08-27 [1] CRAN (R 4.1.0)                       \n##  gtable        0.3.0      2019-03-25 [1] CRAN (R 4.1.0)                       \n##  haven         2.3.1      2020-06-01 [1] CRAN (R 4.1.0)                       \n##  here        * 1.0.0      2020-11-15 [1] CRAN (R 4.1.0)                       \n##  highr         0.9        2021-04-16 [1] CRAN (R 4.2.0)                       \n##  hms           1.1.0      2021-05-17 [1] CRAN (R 4.2.0)                       \n##  htmltools     0.5.1.1    2021-01-22 [1] CRAN (R 4.2.0)                       \n##  htmlwidgets   1.5.3      2020-12-10 [1] CRAN (R 4.1.0)                       \n##  httr          1.4.2      2020-07-20 [1] CRAN (R 4.1.0)                       \n##  igraph        1.2.6      2020-10-06 [1] CRAN (R 4.2.0)                       \n##  incidence2    1.1        2021-05-29 [1] CRAN (R 4.2.0)                       \n##  jquerylib     0.1.4      2021-04-26 [1] CRAN (R 4.2.0)                       \n##  jsonlite      1.7.2      2020-12-09 [1] CRAN (R 4.1.0)                       \n##  knitr         1.33       2021-04-24 [1] CRAN (R 4.2.0)                       \n##  lifecycle     1.0.0      2021-02-15 [1] CRAN (R 4.2.0)                       \n##  lubridate   * 1.7.10     2021-02-26 [1] CRAN (R 4.2.0)                       \n##  magrittr      2.0.1      2020-11-17 [1] CRAN (R 4.1.0)                       \n##  modelr        0.1.8      2020-05-19 [1] CRAN (R 4.1.0)                       \n##  munsell       0.5.0      2018-06-12 [1] CRAN (R 4.1.0)                       \n##  openxlsx      4.2.3      2020-10-27 [1] CRAN (R 4.1.0)                       \n##  pacman        0.5.1      2019-03-11 [1] CRAN (R 4.1.0)                       \n##  pillar        1.6.1      2021-05-16 [1] CRAN (R 4.2.0)                       \n##  pkgconfig     2.0.3      2019-09-22 [1] CRAN (R 4.1.0)                       \n##  purrr       * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                       \n##  R6            2.5.0      2020-10-28 [1] CRAN (R 4.1.0)                       \n##  Rcpp          1.0.6      2021-01-15 [1] CRAN (R 4.1.0)                       \n##  readr       * 1.3.1      2018-12-21 [1] CRAN (R 4.0.0)                       \n##  readxl        1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                       \n##  remotes       2.2.0      2020-07-21 [1] CRAN (R 4.1.0)                       \n##  reprex        0.3.0      2019-05-16 [1] CRAN (R 4.1.0)                       \n##  rio         * 0.5.16     2018-11-26 [1] CRAN (R 4.1.0)                       \n##  rlang         0.4.11     2021-04-30 [1] CRAN (R 4.2.0)                       \n##  rmarkdown     2.6.4      2021-01-17 [1] Github (rstudio/rmarkdown@0a2a3ca)   \n##  rprojroot     2.0.2      2020-11-15 [1] CRAN (R 4.1.0)                       \n##  rstudioapi    0.13       2020-11-12 [1] CRAN (R 4.1.0)                       \n##  rvest         0.3.6      2020-07-25 [1] CRAN (R 4.1.0)                       \n##  sass          0.4.0      2021-05-12 [1] CRAN (R 4.2.0)                       \n##  scales        1.1.1      2020-05-11 [1] CRAN (R 4.1.0)                       \n##  sessioninfo   1.1.1      2018-11-05 [1] CRAN (R 4.1.0)                       \n##  stringi       1.6.2      2021-05-17 [1] CRAN (R 4.2.0)                       \n##  stringr     * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                       \n##  tibble      * 3.1.2      2021-05-16 [1] CRAN (R 4.2.0)                       \n##  tidyr       * 1.1.3      2021-03-03 [1] CRAN (R 4.2.0)                       \n##  tidyselect    1.1.1      2021-04-30 [1] CRAN (R 4.2.0)                       \n##  tidyverse   * 1.3.0      2019-11-21 [1] CRAN (R 4.0.0)                       \n##  trending      0.0.3      2021-04-19 [1] CRAN (R 4.2.0)                       \n##  utf8          1.2.1.9000 2021-04-21 [1] Github (patperry/r-utf8@15e56f0)     \n##  vctrs         0.3.8      2021-04-29 [1] CRAN (R 4.2.0)                       \n##  withr         2.4.2      2021-04-18 [1] CRAN (R 4.1.0)                       \n##  xfun          0.23       2021-05-15 [1] CRAN (R 4.2.0)                       \n##  xml2          1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                       \n##  yaml          2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                       \n##  zip           2.1.1      2020-08-27 [1] CRAN (R 4.1.0)                       \n## \n## [1] D:/Rlibrary\n## [2] C:/Program Files/R/R-4.1.0/library"},{"path":"data-used.html","id":"data-used","chapter":"2 Tải sách và dữ liệu","heading":"2 Tải sách và dữ liệu","text":"","code":""},{"path":"data-used.html","id":"tải-sách-ngoại-tuyến","chapter":"2 Tải sách và dữ liệu","heading":"2.1 Tải sách ngoại tuyến","text":"Bạn có thể tải xuống phiên bản ngoại tuyến của sổ tay này dưới dạng tệp HTML để có thể xem trong trình duyệt web của mình ngay cả khi bạn không có kết nối internet. Nếu bạn đang cân nhắc việc sử dụng ngoại tuyến Sổ tay Epi R, dưới đây là một số điều bạn cần cân nhắc:Khi bạn mở tệp, có thể mất một đến hai phút để tải các hình ảnh và mục lụcPhiên bản ngoại tuyến có bố cục hơi khác với phiên bản trực tuyến - là một trang rất dài với Mục lục ở phía bên trái. Để tìm kiếm các cụm từ cụ thể, hãy sử dụng Ctrl + F (Cmd-f)Xem chương Package đề xuất để hỗ trợ bạn cài đặt các R package thích hợp trước khi bạn mất kết nối internetCài đặt package epirhandbook của chúng tôi trong đó chứa tất cả các dữ liệu minh họa (quy trình cài đặt được mô tả bên dưới)Có hai cách bạn có thể tải xuống sổ tay:","code":""},{"path":"data-used.html","id":"sử-dụng-link-download","chapter":"2 Tải sách và dữ liệu","heading":"Sử dụng link download","text":"Để truy cập nhanh, nháy phải chuột vào link này và lựa chọn “Save link ”.Nếu trên máy Mac, hãy sử dụng Cmd + Nhấp chuột. Nếu trên điện thoại di động, hãy bấm và giữ liên kết và chọn “Save link”. Sổ tay sẽ tải xuống thiết bị của bạn. Nếu trên màn hình xuất hiện mã HTML gốc, hãy đảm bảo bạn đã làm đúng theo các hướng dẫn bên trên hoặc thử Phương án 2.","code":""},{"path":"data-used.html","id":"sử-dụng-package-của-chúng-tôi","chapter":"2 Tải sách và dữ liệu","heading":"Sử dụng package của chúng tôi","text":"Chúng tôi cung cấp một R package có tên là epirhandbook. Nó bao gồm một hàm có tên download_book() giúp bạn tải xuống sổ tay này từ kho Github của chúng tôi vào máy tính của bạn.Package này cũng chứa hàm get_data() giúp tải xuống toàn bộ các dữ liệu minh họa vào máy tính của bạn.Chạy dòng code sau để cài đặt package epirhandbook từ Github repository appliedepi. Đây không phải là package thuộc CRAN, đó cần sử dụng hàm đặc biệt p_install_gh() để cài đặt nó từ Github.Bây giờ, bạn gọi package để sử dụng cho phiên làm việc R hiện tại:Tiếp theo, bạn chạy hàm download_book() (phần trong ngoặc bỏ trống) để tải sổ tay vào máy tính của bạn. Nếu bạn sử dụng RStudio, một cửa sổ sẽ xuất hiện cho phép bạn lựa chọn thư mục lưu trữ.","code":"\n# install the latest version of the Epi R Handbook package\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n# load the package for use\npacman::p_load(epirhandbook)\n# download the offline handbook to your computer\ndownload_book()"},{"path":"data-used.html","id":"tải-dữ-liệu-xuống-để-tiện-theo-dõi","chapter":"2 Tải sách và dữ liệu","heading":"2.2 Tải dữ liệu xuống để tiện theo dõi","text":"Để “tiện theo dõi” cùng với sổ tay này, bạn có thể tải xuống các bộ dữ liệu minh họa và các kết quả.","code":""},{"path":"data-used.html","id":"sử-dụng-package-của-chúng-tôi-1","chapter":"2 Tải sách và dữ liệu","heading":"Sử dụng package của chúng tôi","text":"Cách dễ nhất để tải xuống tất cả dữ liệu là cài đặt package epirhandbook của chúng tôi. Nó chứa hàm get_data() giúp lưu toàn bộ dữ liệu minh họa vào một thư mục bạn chọn trên máy tính của mình.Để cài đặt package epirhandbook, bạn chạy theo code dưới đây. Lưu ý là package này không từ CRAN, đó cần sử dụng hàm p_install_gh() để cài đặt. Thông tin đầu vào sẽ được chuyển tới trang Github của chúng tôi (“appliedepi”) và package epirhandbook.Bây giờ, bạn gọi package để sử dụng cho phiên làm việc hiện tại:Tiếp theo, sử dụng hàm get_data() trong package để tải dữ liệu minh họa và máy tính của bạn. Chạy hàm get_data(\"\") để tải toàn bộ dữ liệu minh họa, hoặc bạn có thể nêu tên một tệp cụ thể và phần mở rộng bên trong dấu ngoặc kép để tải một tệp duy nhất.Dữ liệu sẽ được tải xuống cùng với package và bạn đơn giản chỉ cần lưu nó vào một thư mục trên máy tính của bạn. Một cửa sổ sẽ xuất hiện, cho phép bạn chọn vị trí lưu thư mục. Chúng tôi khuyên bạn nên tạo một thư mục mới tên là “data” vì có khoảng 30 tệp (bao gồm các bộ dữ liệu minh họa và kết quả).Khi bạn dùng hàm get_data() để lưu tệp dữ liệu vào máy tính của mình, bạn sẽ vẫn cần nhập dữ liệu vào R. Xem chương Nhập xuất dữ liệu để biết thêm chi tiết.Nếu bạn muốn, bạn có thể xem toàn bộ dữ liệu sử dụng trong cuốn sách này ở thư mục “dữ liệu” trong kho Github của chúng tôi.","code":"\n# install the latest version of the Epi R Handbook package\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n# load the package for use\npacman::p_load(epirhandbook)\n# download all the example data into a folder on your computer\nget_data(\"all\")\n\n# download only the linelist example data into a folder on your computer\nget_data(file = \"linelist_cleaned.rds\")\n# download a specific file into a folder on your computer\nget_data(\"linelist_cleaned.rds\")"},{"path":"data-used.html","id":"tải-từng-thứ-một","chapter":"2 Tải sách và dữ liệu","heading":"Tải từng thứ một","text":"Tùy chọn này liên quan đến việc tải xuống từng tệp dữ liệu từ kho lưu trữ Github của chúng tôi thông qua liên kết hoặc lệnh R dành riêng cho từng tệp. Một số loại tệp cho phép nút tải xuống, trong khi những loại khác có thể được tải xuống thông qua lệnh R.","code":""},{"path":"data-used.html","id":"dữ-liệu-linelist","chapter":"2 Tải sách và dữ liệu","heading":"Dữ liệu linelist","text":"Đây là số liệu bùng phát Ebola giả định, được nhóm tác giả cẩm nang mở rộng từ bộ dữ liệu thực hành ebola_sim trong package outbreaks.Bấm để tải xuống dữ liệu “thô” linelist (.xlsx). Bộ dữ liệu “thô” là một trang tính Excel với dữ liệu lộn xộn. Sử dụng số liệu này trong chương Làm sạch số liệu và các hàm quan trọng.Bấm để tải xuống dữ liệu “thô” linelist (.xlsx). Bộ dữ liệu “thô” là một trang tính Excel với dữ liệu lộn xộn. Sử dụng số liệu này trong chương Làm sạch số liệu và các hàm quan trọng.Bấm để tải xuống dữ liệu “đã làm sạch” linelist (.rds). Sử dụng tệp này cho tất cả các chương khác trong sổ tay có sử dụng bộ dữ liệu linelist. Tệp mở rộng .rds là một kiểu file của R có khả năng lưu trữ các thông tin cột. Điều này đảm bảo bạn sẽ có ít việc phải làm khi làm sạch số liệu sau khi nhập số liệu vào R.Bấm để tải xuống dữ liệu “đã làm sạch” linelist (.rds). Sử dụng tệp này cho tất cả các chương khác trong sổ tay có sử dụng bộ dữ liệu linelist. Tệp mở rộng .rds là một kiểu file của R có khả năng lưu trữ các thông tin cột. Điều này đảm bảo bạn sẽ có ít việc phải làm khi làm sạch số liệu sau khi nhập số liệu vào R.Các tệp liên quan khác:Bấm để tải xuống dữ liệu “đã làm sạch” linelist dưới dạng tệp ExcelBấm để tải xuống dữ liệu “đã làm sạch” linelist dưới dạng tệp ExcelMột phần của chương làm sạch sử dụng “từ điển làm sạch” (tệp .csv). Bạn có thể tải nó trực tiếp vào R bằng cách chạy các lệnh sau:Một phần của chương làm sạch sử dụng “từ điển làm sạch” (tệp .csv). Bạn có thể tải nó trực tiếp vào R bằng cách chạy các lệnh sau:","code":"\npacman::p_load(rio) # install/load the rio package\n\n# import the file directly from Github\ncleaning_dict <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv\")"},{"path":"data-used.html","id":"data_malaria","chapter":"2 Tải sách và dữ liệu","heading":"Dữ liệu số trường hợp sốt rét","text":"Đây là số liệu giả định về số lượng trường hợp sốt rét theo nhóm tuổi, cơ sở điều trị và ngày. Tệp mở rộng .rds là một kiểu file của R có khả năng lưu trữ các thông tin cột. Điều này đảm bảo bạn sẽ có ít việc phải làm khi làm sạch số liệu sau khi nhập số liệu vào R. Bấm để tải file dữ liệu sốt rét (.rds file) ","code":""},{"path":"data-used.html","id":"dữ-liệu-thang-đo-likert","chapter":"2 Tải sách và dữ liệu","heading":"Dữ liệu thang đo Likert","text":"Đây là dữ liệu giả định từ một cuộc khảo sát sử dụng thang đo Likert, được sử dụng trong chương Tháp dân số và thang đo Likert. Bạn có thể tải những dữ liệu này trực tiếp vào R bằng cách chạy các lệnh sau:","code":"\npacman::p_load(rio) # install/load the rio package\n\n# import the file directly from Github\nlikert_data <- import(\"https://raw.githubusercontent.com/nsbatra/Epi_R_handbook/master/data/likert_data.csv\")"},{"path":"data-used.html","id":"flexdashboard","chapter":"2 Tải sách và dữ liệu","heading":"Flexdashboard","text":"Dưới đây là các liên kết đến tệp được dùng trong chương Dashboards với R Markdown:Để tải xuống R Markdown dashboard về một đợt bùng phát dịch, bấm phải chuột vào link này (Cmd+click đối với Mac) và chọn “Save link ”.Để tải xuống HTML dashboard, bấm phải chuột vào link này (Cmd+click đối với Mac) và chọn “Save link ”.","code":""},{"path":"data-used.html","id":"truy-vết-tiếp-xúc","chapter":"2 Tải sách và dữ liệu","heading":"Truy vết tiếp xúc","text":"Chương Truy vết tiếp xúc trình bày phân tích dữ liệu truy vết tiếp xúc, sử dụng dữ liệu minh họa từ Go.Data. Dữ liệu được sử dụng trong chương này có thể được tải xuống dưới dạng tệp .rds bằng cách bấm vào các liên kết sau: Bấm để tải xuống dữ liệu điều tra trường hợp (.rds file)  Bấm để tải xuống dữ liệu ghi nhận tiếp xúc (.rds file)  Bấm để tải xuống dữ liệu theo dõi liên hệ (.rds file) LƯU Ý: Dữ liệu truy vết tiếp xúc có cấu trúc từ phần mềm khác (ví dụ: KoBo, DHIS2 Tracker, CommCare) có thể sẽ khác. Nếu bạn muốn đóng góp dữ liệu hoặc nội dung mẫu thay thế cho trang này, vui lòng liên hệ chúng tôi.MẸO: Nếu bạn đang triển khai Go.Data và muốn kết nối với API phiên bản của bạn, vui lòng xem chương Nhập xuất dữ liệu (mục API) và Go.Data Cộng đồng thực hành.","code":""},{"path":"data-used.html","id":"gis","chapter":"2 Tải sách và dữ liệu","heading":"GIS","text":"Shapefiles có nhiều tệp thành phần phụ, mỗi tệp có một phần mở rộng tệp khác nhau. Một tệp sẽ có phần mở rộng “.shp”, nhưng những tệp khác có thể là “.dbf”, “.prj”, v.v.Chương GIS cơ bản cung cấp các liên kết đến trang web Humanitarian Data Exchange, nơi bạn có thể tải xuống trực tiếp các shapefiles dưới dạng tệp nén.Ví dụ, dữ liệu phân bố của các cơ sở y tế có thể được tải xuống tại đây. Bạn tải tệp “hotosm_sierra_leone_health_facilities_points_shp.zip”. Sau khi được lưu vào máy tính của bạn, hãy “giải nén” thư mục. Bạn sẽ thấy một số tệp có các phần mở rộng khác nhau (ví dụ: “.shp”, “.prj”, “.shx”) - tất cả những tệp này phải được lưu vào cùng một thư mục trên máy tính của bạn. Sau đó, để nhập vào R, hãy cung cấp đường dẫn đến tệp và tên của tệp “.shp” bằng hàm st_read() từ package sf (đã được mô tả trong chương GIS cơ bản).Nếu bạn làm theo Cách 1 để tải xuống tất cả dữ liệu minh họa (thông qua package epirhandbook của chúng tôi), tất cả các shapefiles đã được bao gồm.Ngoài ra, bạn có thể tải xuống các shapefiles từ thư mục “data” trên trang R Handbook Github (xem thư mục con “gis”). Tuy nhiên, cần lưu ý rằng bạn sẽ phải tải từng tệp con xuống máy tính của mình. Trong Github, nhấp vào từng tệp riêng lẻ và tải chúng xuống bằng cách nhấp vào nút “Download”. Xem hình minh họa dưới đây, bạn có thể thấy shapefile “sl_adm3” bao gồm nhiều tệp con như thế nào - và mỗi tệp đều cần được tải xuống từ Github.","code":""},{"path":"data-used.html","id":"cây-phả-hệ","chapter":"2 Tải sách và dữ liệu","heading":"Cây phả hệ","text":"Xem chương Cây phả hệ. Tệp có tên Newick về cây phả hệ được xây dựng từ việc giải trình tự toàn bộ bộ gen của 299 mẫu Shigella sonnei và dữ liệu mẫu tương ứng (được chuyển đổi thành tệp văn bản). Các mẫu và kết quả từ nước Bỉ được cung cấp thông qua Trung tâm tham khảo quốc gia về Salmonella và Shigella (NRC Bỉ) trong phạm vi dự án EUPHEM Fellow của ECDC thực hiện, và cũng sẽ được xuất bản dưới dạng bản thảo. Dữ liệu quốc tế được cung cấp công khai trên cơ sở dữ liệu công cộng (ncbi) và đã được xuất bản trước đó.Để tải xuống file cây phả hệ “Shigella_tree.txt”, nhấn chuột phải vào link này (Cmd+click đối với Mac) và chọn “Save link ”.Để tải xuống file “sample_data_Shigella_tree.csv” với thông tin bổ sung cho từng mẫu, nhấn chuột phải vào link này (Cmd+click đối với Mac) và chọn “Save link ”.Để xem subset-tree mới được tạo, nhấn chuột phải vào link này (Cmd+click đối với Mac) và chọn “Save link ”. Tệp .txt sẽ được tải xuống máy tính của bạn.Sau đó bạn có thể nhập tệp .txt files bằng hàm read.tree() từ ape package, như đã được trình bày trong chương này.","code":"\nape::read.tree(\"Shigella_tree.txt\")"},{"path":"data-used.html","id":"chuẩn-hóa","chapter":"2 Tải sách và dữ liệu","heading":"Chuẩn hóa","text":"Xem trong chương [Tỷ lệ chuẩn hóa]. Bạn có thể tải dữ liệu trực tiếp từ kho lưu trữ Github của chúng tôi trên internet vào phiên làm việc R của bạn bằng các lệnh sau :","code":"\n# install/load the rio package\npacman::p_load(rio) \n\n##############\n# Country A\n##############\n# import demographics for country A directly from Github\nA_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# import deaths for country A directly from Github\nA_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n##############\n# Country B\n##############\n# import demographics for country B directly from Github\nB_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# import deaths for country B directly from Github\nB_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n\n###############\n# Reference Pop\n###############\n# import demographics for country B directly from Github\nstandard_pop_data <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")"},{"path":"data-used.html","id":"data_outbreak","chapter":"2 Tải sách và dữ liệu","heading":"Chuỗi thời gian và phát hiện ổ dịch","text":"Xem trong chương Chuỗi thời gian và phát hiện ổ dịch. Chúng tôi sử dụng các trường hợp campylobacter được báo cáo ở Đức từ 2002-2011, có sẵn từ package surveillance của R. (lưu ý. tập dữ liệu này đã được điều chỉnh từ bản gốc, trong đó 3 tháng dữ liệu cuối năm 2011 đã bị xóa để dùng với mục đích minh họa) Bấm để tải xuống dữ liệu Campylobacter ở Đức (.xlsx) Chúng tôi cũng sử dụng dữ liệu khí hậu ở Đức từ 2002-2011 (nhiệt độ tính bằng độ C và lượng mưa tính bằng milimet). Dữ liệu được tải xuống từ tập dữ liệu phân tích vệ tinh Copernicus của EU bằng cách sử dụng package ecmwfr . Bạn sẽ cần tải xuống tất cả những thứ này và nhập chúng vào R bằng hàm stars::read_stars() như đã được giải thích trong chương chuỗi thời gian. Bấm để tải dữ liệu thời tiết ở Đức 2002 (.nc file)  Bấm để tải dữ liệu thời tiết ở Đức 2003 (.nc file)  Bấm để tải dữ liệu thời tiết ở Đức 2004 (.nc file)  Bấm để tải dữ liệu thời tiết ở Đức 2005 (.nc file)  Bấm để tải dữ liệu thời tiết ở Đức 2006 (.nc file)  Bấm để tải dữ liệu thời tiết ở Đức 2007 (.nc file)  Bấm để tải dữ liệu thời tiết ở Đức 2008 (.nc file)  Bấm để tải dữ liệu thời tiết ở Đức 2009 (.nc file)  Bấm để tải dữ liệu thời tiết ở Đức 2010 (.nc file)  Bấm để tải dữ liệu thời tiết ở Đức 2011 (.nc file) ","code":""},{"path":"data-used.html","id":"data_survey","chapter":"2 Tải sách và dữ liệu","heading":"Phân tích sống còn","text":"Đối với chương phân tích sống còn, chúng tôi sử dụng dữ liệu khảo sát tử vong giả định dựa trên mẫu khảo sát của MSF OCA. Dữ liệu giả định này là một phần của Dự án “R4Epis”. Bấm để tài xuống dữ liệu khảo sát giả định (.xlsx)  Bấm để tài xuống từ điển dữ liệu khảo sát giả định (.xlsx)  Bấm để tài xuống dữ liệu khảo sát quần thể giả định (.xlsx) ","code":""},{"path":"data-used.html","id":"data_shiny","chapter":"2 Tải sách và dữ liệu","heading":"Shiny","text":"Chương Dashboards với Shiny trình diễn việc xây dựng một ứng dụng đơn giản để hiển thị dữ liệu bệnh sốt rét.Để tải xuống các tệp R dùng để tạo thành ứng dụng Shiny:Bạn có thể  bấm vào đây để tải xuống tệp app.R trong đó chứa code của cả UI và Server của ứng dụng Shiny.Bạn có thể  bấm vào đây để tải tệp facility_count_data.rds có chứa dữ liệu sốt rét cho ứng dụng Shiny. Lưu ý rằng bạn có thể cần phải lưu trữ nó trong thư mục “data” để các đường dẫn tệp () hoạt động chính xác.Bạn có thể  bấm vào đây để tải tệp global.R mà sẽ được chạy trước khi mở ứng dụng, như đã được giải thích trong chương.Bạn có thể  bấm vào đây để tải tệp plot_epicurve.R có nguồn từ tệp global.R. Lưu ý rằng bạn có thể cần phải lưu trữ nó trong thư mục “funcs” để các đường dẫn tệp () hoạt động chính xác.","code":""},{"path":"basics.html","id":"basics","chapter":"3 R Cơ bản","heading":"3 R Cơ bản","text":"Chào mừng bạn!Chương này sẽ mô tả những kỹ thuật cơ bản của R. Đây không phải là hướng dẫn sử dụng toàn diện, nhưng sẽ cung cấp những kiến thức cơ bản và có thể hữu ích trong việc làm mới hiểu biết của bạn. Phần Tài nguyên học liệu sẽ liên kết đến những hướng dẫn sử dụng R bao quát hơn.Các phần của chương này đã được điều chỉnh dưới sự cho phép của Dự án R4Epis.Xem chương Chuyển đổi sang R để biết các mẹo khi chuyển đổi từ STATA, SAS hoặc Excel sang R.","code":""},{"path":"basics.html","id":"tại-sao-sử-dụng-r","chapter":"3 R Cơ bản","heading":"3.1 Tại sao sử dụng R?","text":"Như đã được công bố trên trang web dự án R, R là một ngôn ngữ và môi trường lập trình cho tính toán và đồ họa thống kê. Nó rất linh hoạt, có khả năng mở rộng và hướng tới cộng đồng.Chi phíR được sử dụng miễn phí! Có sự tồn tại mạnh mẽ về đạo đức trong cộng đồng người sử dụng nguồn tài nguyên mở và miễn phí.Khả năng tái lậpThực hiện quản lý và phân tích dữ liệu của bạn thông qua một ngôn ngữ lập trình (sánh với Excel hoặc công cụ khác mà thao tác chính là nhấp chuột/thao tác thủ công) giúp nâng cao khả năng tái lập, giúp phát hiện lỗi dễ dàng hơn và giảm bớt khối lượng công việc của bạn.Cộng đồngR có cộng đồng người dùng khổng lồ và có tính hợp tác. Các package và công cụ mới nhằm giải quyết các vấn đề thực tế được phát triển hàng ngày và được kiểm tra bởi cộng đồng người dùng. Ví dụ, R-Ladies là một tổ chức toàn cầu có sứ mệnh thúc đẩy sự đa dạng giới trong cộng đồng R và là một trong những tổ chức người dùng R lớn nhất. Thậm chí có thể có một phần của nhóm này đang ở gần bạn!","code":""},{"path":"basics.html","id":"các-thuật-ngữ-chính","chapter":"3 R Cơ bản","heading":"3.2 Các thuật ngữ chính","text":"RStudio - RStudio là Giao diện đồ họa người dùng (GUI) giúp sử dụng R dễ dàng hơn. Đọc thêm trong mục RStudio.Đối tượng - Bao gồm mọi thứ bạn lưu trữ trong R - bộ dữ liệu, biến, danh sách tên làng, quy mô dân số, thậm chí cả các kết quả đầu ra như đồ thị - là các đối tượng được gán tên và có thể được tham chiếu trong các lệnh sau này. Đọc thêm trong mục Đối tượng.Hàm - Mỗi hàm là một code hoạt động mà chấp nhận dữ liệu đầu vào và trả về kết quả đầu ra đã được biến đổi. Đọc thêm trong mục Các hàm.Packages - Mỗi package R là một gói câu lệnh có khả năng chia sẻ. Đọc thêm trong mục Packages.Scripts - Mỗi script là một tệp tài liệu chứa các lệnh của bạn. Đọc thêm trong mục Scripts","code":""},{"path":"basics.html","id":"learning","chapter":"3 R Cơ bản","heading":"3.3 Tài nguyên học liệu","text":"","code":""},{"path":"basics.html","id":"tài-nguyên-trong-rstudio","chapter":"3 R Cơ bản","heading":"Tài nguyên trong RStudio","text":"Tài liệu trợ giúpTìm kiếm tab “Help” của RStudio về tài liệu liên quan đến package R và các hàm cụ thể. Tab này nằm trong cửa sổ chứa các tab Files, Plots và Packages (thường ở cửa sổ phía dưới bên phải). Như một lối tắt, bạn cũng có thể nhập tên của một package hoặc câu lệnh vào R Console sau dấu hỏi chấm và không bao gồm dấu ngoặc đơn để mở trang trợ giúp liên quan.Ví dụ: ?filter hoặc ?diagrammeR.Các hướng dẫn có sự tương tácR có thể được học thông qua một số tương tác trong RStudio.RStudio cung cấp một cửa sổ Tutorial được hỗ trợ bởi package learnr. Chỉ cần cài đặt package này và mở hướng dẫn qua tab “Tutorial” trong cửa sổ RStudio phía trên bên phải (cũng chứa các tab Environment và History).Package swirl cung cấp các nội dung học tương tác trong R Console. Cài đặt và tải package này, rồi chạy lệnh swirl() (dấu ngoặc đơn trống) trong R Console. Bạn sẽ thấy các thông báo xuất hiện trong cửa sổ Console. Phản hồi bằng cách nhập vào Console. Nó sẽ hướng dẫn bạn qua một nội dung học bạn lựa chọn.","code":""},{"path":"basics.html","id":"cheatsheets","chapter":"3 R Cơ bản","heading":"Cheatsheets","text":"Có rất nhiều “cheatsheets” PDF có sẵn trên trang web của RStudio, ví dụ như:Factors với package forcatsNgày và thời gian với package lubridateChuỗi với package stringrCác vòng lặp với package purrrNhập dữ liệuCheatsheet biến đổi dữ liệu với package dplyrR Markdown (để tạo các tài liệu như PDF, Word, Powerpoint…)Shiny (để xây dựng các ứng dụng web tương tác)Trực quan hóa dữ liệu với package ggplot2Bản đồ học (GIS)Package leaflet (bản đồ tương tác)Python với R (package reticulate)Đây là tài nguyên R trực tuyến dành riêng cho Người dùng Excel","code":""},{"path":"basics.html","id":"twitter","chapter":"3 R Cơ bản","heading":"Twitter","text":"R có một cộng đồng twitter sôi động, nơi bạn có thể tìm hiểu các mẹo, lối tắt và tin tức - hãy theo dõi các tài khoản sau:Theo dõi chúng tôi: @epiRhandbookR Function Day @rfuntionaday là một nguồn tài nguyên tuyệt vờiR Data Science @rstats4dsRStudio @RStudioRStudio Tips @rstudiotipsR-Bloggers @RbloggersR-ladies @RLadiesGlobalHadley Wickham @hadleywickhamCũng như:#epitwitter và #rstats","code":""},{"path":"basics.html","id":"nguồn-tài-nguyên-trực-tuyến-miễn-phí","chapter":"3 R Cơ bản","heading":"Nguồn tài nguyên trực tuyến miễn phí","text":"Cuốn sách R Data Science (R dành cho Khoa học Dữ liệu) của Garrett Grolemund và Hadley WickhamTrang web của dự án R4Epis nhằm mục đích “phát triển các công cụ làm sạch, phân tích và báo cáo dữ liệu được chuẩn hóa dùng trong các trường hợp bùng phát dịch phổ biến và các cuộc điều tra dựa trên dân số mà sẽ được tiến hành trong các ứng phó khẩn cấp của Tổ chức Bác sỹ không biên giới” Bạn có thể tìm thấy tài liệu đào tạo cơ bản về R, các mẫu báo cáo RMarkdown và khảo sát về các đợt bùng phát dịch, cũng như các hướng dẫn để giúp bạn thiết lập chúng.","code":""},{"path":"basics.html","id":"các-ngôn-ngữ-khác-ngoài-tiếng-anh","chapter":"3 R Cơ bản","heading":"Các ngôn ngữ khác ngoài Tiếng Anh","text":"Tài liệu RStudio bằng tiếng Tây Ban NhaGiới thiệu cơ bản về R (tiếng Pháp)","code":""},{"path":"basics.html","id":"cài-đặt","chapter":"3 R Cơ bản","heading":"3.4 Cài đặt","text":"","code":""},{"path":"basics.html","id":"r-và-rstudio","chapter":"3 R Cơ bản","heading":"R và RStudio","text":"Làm thế nào để cài đặt RTruy cập vào trang web https://www.r-project.org/ và tải phiên bản mới nhất của R phù hợp với máy tính của bạn.Làm thế nào để cài đặt RStudioTruy cập vào trang web https://rstudio.com/products/rstudio/download/ và tải phiên bản Desktop mới nhất của RStudio phù hợp với máy tính của bạn.Quyền truy cập\nLưu ý rằng bạn nên cài đặt R và RStudio vào một ổ đĩa mà bạn có quyền đọc và ghi lại. Nếu không, khả năng cài đặt các package R (thường xuyên xảy ra) của bạn sẽ bị ảnh hưởng. Nếu bạn gặp sự cố, hãy thử mở RStudio bằng cách nhấp chuột phải vào biểu tượng và chọn “Run administrator”. Các mẹo khác có thể được tìm thấy trong chương R trên ổ cứng mạng.Làm thế nào để cập nhật R và RStudioPhiên bản R của bạn được ra R Console khi khởi động. Bạn cũng có thể chạy lệnh sessionInfo().Để cập nhật R, truy cập đến trang web được nhắc đến ở trên và cài đặt lại R. Ngoài ra, bạn có thể sử dụng package installr (trên Windows) bằng cách chạy câu lệnh installr::updateR(). Thao tác này sẽ mở ra các hộp thoại giúp bạn tải xuống phiên bản R mới nhất và cập nhật các package của bạn lên phiên bản R mới. Có thể tìm thấy thêm chi tiết trong tài liệu installr .Lưu ý rằng phiên bản R cũ sẽ vẫn tồn tại trong máy tính của bạn. Bạn có thể tạm thời chạy phiên bản cũ hơn (“installation” cũ hơn) của R bằng cách nhấp vào “Tools” -> “Global Options” trong RStudio và chọn một phiên bản R. Điều này có thể hữu ích nếu bạn muốn sử dụng một package chưa được cập nhật để hoạt động trên phiên bản R mới nhất.Để cập nhật RStudio, truy cập đến trang web được nhắc đến ở trên và cài đặt lại RStudio. Một tùy chọn khác là nhấp vào “Help” -> “Check Updates” trong RStudio, nhưng điều này có thể dẫn đến việc không hiển thị các bản cập nhật mới nhất.Để xem phiên bản R, RStudio hoặc package nào đã được sử dụng khi viết Sổ tay này, hãy xem chương Biên tập và ghi chú kỹ thuật.","code":""},{"path":"basics.html","id":"những-phần-mềm-khác-bạn-có-thể-cần-cài-đặt","chapter":"3 R Cơ bản","heading":"Những phần mềm khác bạn có thể cần cài đặt","text":"TinyTeX (để biên dịch tài liệu RMarkdown sang PDF)Pandoc (để biên dịch tài liệu RMarkdown)RTools (để xây dựng các package cho R)phantomjs (để lưu ảnh tĩnh của mạng động, chẳng hạn như chuỗi lây truyền)","code":""},{"path":"basics.html","id":"tinytex","chapter":"3 R Cơ bản","heading":"TinyTex","text":"TinyTex là một bản phân phối LaTeX tùy chỉnh, hữu ích khi tạo các tệp PDF từ R.\nTruy cập https://yihui.org/tinytex/ để tìm hiểu thêm thông tin.Để cài đặt TinyTex từ R:","code":"\ninstall.packages('tinytex')\ntinytex::install_tinytex()\n# to uninstall TinyTeX, run tinytex::uninstall_tinytex()"},{"path":"basics.html","id":"pandoc","chapter":"3 R Cơ bản","heading":"Pandoc","text":"Pandoc là một công cụ chuyển đổi văn bản, một phần mềm tách biệt với R. Nó đi kèm với RStudio và không cần phải tải xuống. Nó hỗ trợ quá trình chuyển đổi văn bản từ Rmarkdown sang các định dạng như .pdf và có bổ sung thêm một số tính năng phức tạp.","code":""},{"path":"basics.html","id":"rtools","chapter":"3 R Cơ bản","heading":"RTools","text":"RTools là một phần mềm được sử dụng để xây dựng package cho RCài đặt từ trang web: https://cran.r-project.org/bin/windows/Rtools/","code":""},{"path":"basics.html","id":"phantomjs","chapter":"3 R Cơ bản","heading":"phantomjs","text":"Phần mềm này thường được sử dụng để chụp “chụp ảnh màn hình” trang web. Ví dụ khi bạn tạo một chuỗi lây truyền với package epicontacts, một tệp HTML có thể tương tác và chuyển động được tạo ra. Nếu bạn muốn có hình ảnh tĩnh, sử dụng package webshot để tự động hóa quá trình này. Việc này sẽ yêu cầu chương trình bên ngoài “phantomjs”. Bạn có thể cài đặt phantomjs thông qua package webshot bằng lệnh webshot::install_phantomjs().","code":""},{"path":"basics.html","id":"rstudio","chapter":"3 R Cơ bản","heading":"3.5 RStudio","text":"","code":""},{"path":"basics.html","id":"làm-quen","chapter":"3 R Cơ bản","heading":"Làm quen","text":"Đầu tiên, mở RStudio. Biểu tượng của chúng có sự tương đồng, hãy chắc chắn bạn đang mở RStudio chứ không phải R.Để RStudio hoạt động bạn cũng cần phải cài đặt R trên máy tính (xem hướng dẫn cài đặt ở bên trên).RStudio là một giao diện người dùng (GUI) giúp sử dụng R dễ dàng hơn. Bạn có thể coi R như một động cơ đang đảm đương công việc chính của một phương tiện và RStudio là phần thân của phương tiện (với ghế ngồi, các phụ kiện,…) giúp bạn sử dụng động cơ tiến về phía trước. Bạn có thể xem toàn bộ cheatsheet giao diện người dùng của RStudio (PDF) tại đâyRStudio mặc định hiển thị bốn cửa sổ hình chữ nhật.MẸO: Nếu RStudio của bạn chỉ hiển thị một cửa sổ bên trái thì đó là bạn chưa mở scripts nào.Cửa sổ mã nguồn\nCửa sổ này, mặc định hiển thị phía trên bên trái, là một khoảng trống để chỉnh sửa, chạy và lưu các scripts của bạn. Script chứa các lệnh mà bạn muốn chạy. Cửa sổ này cũng có thể hiển thị thông tin dữ liệu (data frames).Đối với người dùng Stata, cửa sổ này tương tự với các cửa sổ -file và Data Editor.Cửa sổ R ConsoleR Console, mặc định ở cửa sổ bên trái hoặc phía dưới bên trái của RStudio, là ngôi nhà của “động cơ” R. Đây là nơi các lệnh thực sự được chạy, các kết quả đầu ra không phải là đồ họa và các thông báo lỗi/cảnh báo sẽ xuất hiện. Bạn có thể nhập và chạy các lệnh trực tiếp trong R Console, nhưng sẽ sớm nhận ra các lệnh này không được lưu như khi chạy lệnh từ một script.Nếu bạn đã quen thuộc với Stata, R Console giống như cửa sổ Command Window và Results Window.Cửa sổ Environment\nCửa sổ này, mặc định ở phía trên bên phải, thường được sử dụng để xem tóm tắt ngắn gọn về các đối tượng itrong R Environment ở phiên hiện tại. Các đối tượng này có thể bao gồm các tập dữ liệu đã được nhập, chỉnh sửa hoặc tạo mới, các tham số bạn đã xác định (ví dụ: một tuần dịch tễ cụ thể để phân tích), vectơ hoặc các danh sách bạn đã xác định trong quá trình phân tích (ví dụ: tên các vùng). Bạn có thể nhấp vào mũi tên bên cạnh tên của data frames để xem các biến số của nó.Cửa sổ này gần giống với cửa sổ Variables Manager trong Stata.Cửa sổ này cũng chứa History - nơi mà bạn có thể xem các lệnh đã làm trước đó. Nó cũng có một tab “Tutorial” - là nơi mà bạn có thể hoàn thành các hướng dẫn tương tác với R nếu bạn đã cài đặt package learnr. Nó cũng chứa một tab “Connections” cho phép các kết nối bên ngoài và có thể có cửa sổ “Git” nếu bạn chọn giao diện với Github.Cửa sổ Plots, Viewer, Packages, và Help\nCửa sổ phía dưới bên phải bao gồm một số tab quan trọng. Các đồ họa chính điển hình bao gồm bản đồ sẽ được hiển thị trong Cửa sổ Plot. Các kết quả đầu ra tương tác hoặc HTML sẽ được hiển thị trong cửa sổ Viewer. Cửa sổ File là một trình duyệt có thể được sử dụng để mở hoặc xóa tệp. Cửa sổ Packages cho phép bạn xem, cài đặt, cập nhật, xóa, tải/dỡ các package R và xem bạn có phiên bản package nào. Để tìm hiểu thêm về các package hãy xem mục packages bên dưới.Cửa sổ này chứa các nội dung tương đương với các cửa sổ Plots Manager và Project Manager trong Stata.","code":""},{"path":"basics.html","id":"các-cài-đặt-của-rstudio","chapter":"3 R Cơ bản","heading":"Các cài đặt của RStudio","text":"Thay đổi các cài đặt và giao diện của RStudio trong thanh menu thả xuống Tools, bằng cách chọn Global Options. Ở đó, bạn có thể thay đổi cài đặt mặc định, bao gồm cả màu giao diện/nền.Khởi động lạiNếu R của bạn bị treo, bạn có thể khởi động lại R bằng cách di chuột đến menu Session và nhấp vào “Restart R”. Thao tác này giúp tránh rắc rối khi đóng và mở RStudio. Mọi thứ trong môi trường R của bạn sẽ bị xóa khi thực hiện thao tác này.","code":""},{"path":"basics.html","id":"các-phím-tắt","chapter":"3 R Cơ bản","heading":"Các phím tắt","text":"Dưới đây là một vài phím tắt rất hữu dụng. Tất cả các phím tắt cho Windows, Max và Linux nằm ở chương 2 cheatsheet giao diện người dùng của RStudio.MẸO: Sử dụng phím Tab của bạn khi nhập để sử dụng chức năng tự động hoàn thành của RStudio. Điều này có thể giúp ngăn ngừa các lỗi chính tả. Nhấn Tab trong khi nhập để hiện ra menu thả xuống gồm các hàm và đối tượng có thể có, dựa trên những gì bạn đã nhập.","code":""},{"path":"basics.html","id":"functions","chapter":"3 R Cơ bản","heading":"3.6 Hàm","text":"Các hàm là phần cốt lõi của việc sử dụng R. Hàm là cách bạn thực hiện các tác vụ và hoạt động. Nhiều hàm được cài đặt sẵn với R, nhiều hàm khác sẵn sàng để tải xuống trong các packages (giải thích trong phần packages), và bạn thậm chí có thể viết các hàm tùy chỉnh của riêng mình!Phần khái niệm cơ bản của hàm giải thích:Thế nào là một hàm và cách mà chúng hoạt độngThế nào là đối số của hàmLàm cách nào để nhận được sự trợ giúp khi tìm hiểu một hàmLưu ý nhanh về cú pháp: Trong cuốn sổ tay này, các hàm được viết dưới dạng code văn bản với dấu mở ngoặc đơn như sau: filter(). Như đã giải thích trong phần packages, các hàm được tải xuống có sẵn trong các packages. Trong sổ tay này, tên các package được đậm, ví dụ như dplyr. Đôi khi trong code ví dụ, bạn có thể thấy tên hàm được liên kết rõ ràng với tên package của chính hàm đó bằng hai dấu hai chấm (::) như thế này: dplyr::filter(). Mục đích của việc liên kết này sẽ được giải thích trong phần package.","code":""},{"path":"basics.html","id":"các-hàm-cơ-bản","chapter":"3 R Cơ bản","heading":"Các hàm cơ bản","text":"Một hàm giống như một cỗ máy nhận các dữ liệu đầu vào, thực hiện một số thao tác với dữ liệu đó và sản xuất kết quả đầu ra. Kết quả đầu ra như thế nào phụ thuộc vào hàm mà bạn sử dụng.Các hàm thường hoạt động dựa trên các đối tượng được đặt trong dấu ngoặc đơn của hàm. Ví dụ, hàm sqrt() tính căn bậc hai của một số:Đối tượng được dùng cho một hàm cũng có thể là một cột trong tập dữ liệu (xem phần Đối tượng để biết chi tiết về tất cả các loại đối tượng). Vì R có thể lưu trữ nhiều tập dữ liệu, bạn sẽ cần xác định cả tập dữ liệu và cột. Một cách để làm điều này là sử dụng ký hiệu $ để liên kết tên của tập dữ liệu và tên của cột (dataset$column). Trong ví dụ dưới đây, hàm summary() được áp dụng cho cột age trong tập dữ liệu linelist, và kết quả đầu ra là bản tóm tắt các giá trị số và giá trị missing của cột.LƯU Ý: Đằng sau một hàm là hệ thống code bổ sung phức tạp đã được gói gọn cho người dùng thành một lệnh đơn giản.","code":"\nsqrt(49)## [1] 7\n# Print summary statistics of column 'age' in the dataset 'linelist'\nsummary(linelist$age)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.07   23.00   84.00      86"},{"path":"basics.html","id":"hàm-với-nhiều-đối-số","chapter":"3 R Cơ bản","heading":"Hàm với nhiều đối số","text":"Các hàm thường yêu cầu một số dữ liệu đầu vào, được gọi là đối số, đặt trong dấu ngoặc đơn của hàm, thường được phân tách bằng dấu phẩy.Một vài đối số là bắt buộc để hàm hoạt động chính xác, những đối số khác là tùy chọnNhững đối số tùy chọn có thiết lập mặc địnhCác đối số có thể nhận ký tự, số, logic (TRUE / FALSE) và các dữ liệu đầu vào khácDưới đây là một hàm giả định thú vị, được gọi là oven_bake(), là ví dụ về một hàm điển hình. Hàm này nhận một đối tượng đầu vào (ví dụ: một tập dữ liệu, hoặc trong ví dụ này là “bột”) và thực hiện các hoạt động được xác định bởi các đối số bổ sung (minutes = temperature =). Kết quả đầu ra có thể được ra cửa sổ console hoặc được lưu dưới dạng một đối tượng bằng cách sử dụng toán tử gán <-.Trong một ví dụ thực tế hơn, hàm age_pyramid() dưới đây tạo một biểu đồ tháp tuổi dựa trên nhóm tuổi đã xác định và cột phân tách nhị phân, ví dụ như giới tính. Hàm được cung cấp bởi ba đối số trong dấu ngoặc đơn và được phân tách nhau bằng dấu phẩy. Các giá trị được cung cấp cho các đối số thiết lập linelist là dataframe được sử dụng, age_cat5 là cột để đếm và giới tính là cột nhị phân để sử dụng chia kim tự tháp theo màu.Lệnh trên có thể được viết tương tự như bên dưới, theo cách dài hơn với một dòng mới cho mỗi đối số. Phong cách này có thể dễ đọc và dễ viết “bình luận” hơn với # để giải thích từng phần (bình luận mở rộng là một thực hành tốt!). Để chạy lệnh dài hơn này, bạn có thể bôi đen toàn bộ lệnh và nhấp vào “Run” hoặc chỉ cần đặt con trỏ vào dòng đầu tiên rồi nhấn đồng thời phím Ctrl và phím Enter.Không cần xác định nửa đầu của phép gán đối số (ví dụ: data =) nếu các đối số được viết theo một thứ tự cụ thể (được chỉ định trong tài liệu của hàm). Đoạn code dưới đây tạo ra cùng một kim tự tháp như ở trên, bởi vì hàm kì vọng thứ tự đối số là: data frame, biến age_group, biến split_by.Một lệnh age_pyramid() phức tạp hơn có thể bao gồm các đối số tùy chọn để:Hiển thị tỷ lệ thay vì số lượng (đặt proportional = TRUE khi giá trị mặc định là FALSE)Chỉ định hai màu để sử dụng (pal = là viết tắt của “bảng màu” và được cung cấp với một vectơ gồm hai tên màu. Xem chương đối tượng để biết cách hàm c() tạo ra một vectơ)LƯU Ý: Đối với các đối số mà bạn xác định với cả hai phần của đối số (ví dụ: proportional = TRUE), thứ tự của chúng trong tất cả các đối số không quan trọng.","code":"\n# Create an age pyramid\nage_pyramid(data = linelist, age_group = \"age_cat5\", split_by = \"gender\")\n# Create an age pyramid\nage_pyramid(\n  data = linelist,        # use case linelist\n  age_group = \"age_cat5\", # provide age group column\n  split_by = \"gender\"     # use gender column for two sides of pyramid\n  )\n# This command will produce the exact same graphic as above\nage_pyramid(linelist, \"age_cat5\", \"gender\")\nage_pyramid(\n  linelist,                    # use case linelist\n  \"age_cat5\",                  # age group column\n  \"gender\",                    # split by gender\n  proportional = TRUE,         # percents instead of counts\n  pal = c(\"orange\", \"purple\")  # colors\n  )"},{"path":"basics.html","id":"viết-hàm","chapter":"3 R Cơ bản","heading":"Viết hàm","text":"R là một ngôn ngữ được định hướng xung quanh hàm, vì thế bạn nên cảm thấy được trao quyền để tự viết các hàm của riêng mình. Việc tạo ra hàm mang đến một vài lợi thế:Tạo điều kiện thuận lợi cho lập trình mô-đun - tách code thành các phần độc lập và có thể quản lýThay thế việc copy--paste lặp đi lặp lại, điều mà có thể dễ xảy ra lỗiĐặt tên dễ nhớ cho các đoạn codeCách viết một hàm được trình bày cụ thể trong chương Viết hàm.","code":""},{"path":"basics.html","id":"packages","chapter":"3 R Cơ bản","heading":"3.7 Packages","text":"Packages chứa các hàm.Một package trong phần mềm R là một gói code và các tài liệu hướng dẫn có thể chia sẻ được chứa các hàm được định nghĩa trước. Cộng đồng người dùng phần mềm R luôn phát triển những package giúp giải quyết các vấn đề cụ thể, điều này có thể sẽ giúp bạn trong công việc của mình! Bạn sẽ có thể cần cài đặt và sử dụng hàng trăm package trong quá trình sử dụng phần mềm R.Khi cài đặt, R đã có sẵn các package và hàm “cơ bản” giúp thực hiện các nhiệm vụ đơn giản. Nhưng nhiều người dùng R tạo ra các hàm chuyên biệt, được cộng đồng R kiểm chứng và bạn có thể tải xuống dưới dạng package để sử dụng theo cách của riêng mình. Trong sách này, tên package được viết đậm. Một trong những khía cạnh thách thức hơn cả của R đó là thường có nhiều hàm hoặc package để lựa chọn nhằm hoàn thành một nhiệm vụ nhất định.","code":""},{"path":"basics.html","id":"cài-đặt-và-gọi","chapter":"3 R Cơ bản","heading":"Cài đặt và Gọi","text":"Các hàm được chứa trong packages có thể được tải (“cài đặt”) về máy tính của bạn từ internet. Khi một package được tải xuống, package đó sẽ được lưu trữ trong “thư viện” của bạn. Sau đó, bạn có thể truy cập các hàm mà nó chứa trong phiên làm việc hiện tại trên R của bạn bằng cách “Gọi” package.Hãy coi R là thư viện cá nhân của bạn: Khi bạn tải xuống một package, thư viện của bạn nhận được một cuốn sách mới gồm các hàm, nhưng mỗi lần bạn muốn sử dụng một hàm trong cuốn sách đó, bạn phải mượn (“gọi”) cuốn sách đó từ thư viện của mình.Tóm lại: để sử dụng các hàm có sẵn trong package R, phải thực hiện 2 bước:Package phải được cài đặt (một lần), vàPackage phải được gọi (trong mỗi phiên làm việc của R)","code":""},{"path":"basics.html","id":"thư-viện-của-bạn","chapter":"3 R Cơ bản","heading":"Thư viện của bạn","text":"“Thư viện” của bạn thực ra là một thư mục trên máy tính của bạn, bao gồm các thư mục chứa các package đã được cài đặt. Hãy tìm nơi R được cài đặt trong máy tính của bạn và tìm kiếm một thư mục có tên “win-library”. Ví dụ: R\\win-library\\4.0 (4.0 là phiên bản R - bạn sẽ có các thư viện khác nhau tùy theo phiên bản R mà bạn đã tải xuống).Bạn có thể ra đường dẫn tệp đến thư viện của mình bằng cách gõ lệnh .libPaths() (dấu ngoặc bỏ trống). Điều này trở nên đặc biệt quan trọng nếu làm việc với R trên ổ cứng mạng.","code":""},{"path":"basics.html","id":"cài-đặt-từ-cran","chapter":"3 R Cơ bản","heading":"Cài đặt từ CRAN","text":"Thông thường, người dùng R tải các package xuống từ CRAN. CRAN (Comprehensive R Archive Network - Mạng lưu trữ R toàn diện) là một kho công cộng trực tuyến gồm các package R đã được xuất bản bởi các thành viên cộng đồng R.Bạn có cần lo lắng về vi-rút và bảo mật khi tải xuống một package từ CRAN? Đọc bài viết sau để hiểm thêm về chủ đề này.","code":""},{"path":"basics.html","id":"làm-thế-nào-để-cài-đặt-và-gọi","chapter":"3 R Cơ bản","heading":"Làm thế nào để cài đặt và gọi","text":"Trong sách này, chúng tôi khuyên bạn nên sử dụng package pacman (viết tắt của “package manager”). Nó cung cấp một hàm thuận tiện p_load() mà sẽ cài đặt một package nếu cần và gọi nó để sử dụng trong phiên làm việc hiện tại.Cú pháp khá đơn giản. Chỉ cần liệt kê tên của các package trong dấu ngoặc đơn của hàm p_load() và phân tách chúng bằng dấu phẩy. Lệnh dưới đây sẽ cài đặt các package sau rio, tidyverse, và nếu chúng chưa được cài đặt và sẽ gọi chúng ra để sử dụng. Điều này làm cho cách tiếp cận p_load() trở nên thuận tiện và ngắn gọn nếu chia sẻ scripts với người khác. Lưu ý rằng tên package có phân biệt chữ hoa chữ thường.Lưu ý rằng chúng ta đã sử dụng cú pháp pacman::p_load() để viết rõ ràng tên package (pacman) trước tên hàm (p_load()), được nối với nhau bằng hai dấu hai chấm ::. Cú pháp này tiện dụng vì nó cũng gọi package pacman (giả sử package này đã được cài đặt).Ngoài ra còn có các hàm base R thay thế mà bạn sẽ gặp thường xuyên. Hàm base R để cài đặt một package là install.packages(). Tên của package muốn cài đặt phải được đặt trong dấu ngoặc đơn bên trong dấu ngoặc kép. Nếu bạn muốn cài đặt nhiều package trong một lệnh, chúng phải được liệt kê trong một vectơ dạng ký tự c().Lưu ý: lệnh này cài đặt một package, nhưng không gọi nó ra để sử dụng trong phiên làm việc hiện tại.Việc cài đặt cũng có thể được thực hiện bằng cách chọn và nhấp chuột vào cửa sổ RStudio “Package” và chọn “Install”, sau đó tìm kiếm tên package mong muốn cài đặt.Hàm base R để gọi một package ra sử dụng (sau khi nó đã được cài đặt) là library(). Hàm này chỉ có thể gọi một package tại một thời điểm (cách khác của lệnh p_load()). Bạn có thể nhập tên package có hoặc không có dấu ngoặc kép.Để kiểm tra xem một package đã được cài đặt và/hoặc đã được gọi hay chưa, bạn có thể xem Cửa số Package trong RStudio. Nếu package được cài đặt, nó sẽ hiển thị ở đó với số phiên bản. Nếu checkbox của nó được đánh dấu nghĩa là nó đã được gọi cho phiên làm việc hiện tại.Cài đặt từ GithubĐôi khi, bạn cần cài đặt một package chưa có sẵn từ CRAN. Hoặc có lẽ package đã có sẵn trên CRAN nhưng bạn muốn phiên bản mới hơn với các tính năng mới chưa được cung cấp trong phiên bản cũ. Chúng thường được lưu trữ trên trang web github.com trong một “kho lưu trữ (repository)” code công khai và miễn phí. Đọc thêm về Github trong chương Version control với Git và Github.Để download packages R từ Github, bạn có thể dụng hàm p_load_gh() từ pacman, hàm này sẽ cài đặt package nếu cần và gọi nó để sử dụng cho phiên làm việc R hiện tại. Cách khác để cài đặt bao gồm sử dụng package remotes hoặc devtools. Đọc thêm về các hàm của pacman tại Tài liệu về package.Để cài đặt từ Github, bạn phải cung cấp thêm các thông tin sau:Github ID của chủ sở hữuTên của repository chứa package(Tùy chọn) Tên của “nhánh” (phiên bản phát triển cụ thể) mà bạn muốn tải xuốngTrong các ví dụ dưới đây, từ đầu tiên trong dấu ngoặc kép là Github ID của chủ sở hữu kho lưu trữ, sau dấu gạch chéo là tên của kho lưu trữ (tên của package).Nếu bạn muốn cài đặt từ một “nhánh” (phiên bản) khác với nhánh chính, hãy thêm tên nhánh sau dấu “@”, được đặt phía sau tên kho lưu trữ.Nếu không có sự khác biệt giữa phiên bản Github và phiên bản trên máy tính của bạn, bạn không cần thực hiện thao tác này. Thay vào đó, bạn có thể “buộc” phải cài đặt lại bằng cách sử dụng p_load_current_gh() với đối số update = TRUE. Đọc thêm về pacman tại Minh họa trực tuyếnCài đặt từ ZIP hoặc TARBạn có thể cài đặt package từ một URL:Hoặc, tải xuống máy tính của bạn dưới dạng tệp nén:Cách 1: sử dụng lệnh install_local() từ package remotesCách 2: sử dụng lệnh install.packages() của base R, cung cấp đường dẫn tệp đến tệp ZIP và thiết lập type = \"source và repos = NULL.","code":"\n# Install (if necessary) and load packages for use\npacman::p_load(rio, tidyverse, here)\n# install a single package with base R\ninstall.packages(\"tidyverse\")\n\n# install multiple packages with base R\ninstall.packages(c(\"tidyverse\", \"rio\", \"here\"))\n# load packages for use, with base R\nlibrary(tidyverse)\nlibrary(rio)\nlibrary(here)\n# install/load the epicontacts package from its Github repository\np_load_gh(\"reconhub/epicontacts\")\n# install the \"timeline\" branch of the epicontacts package from Github\np_load_gh(\"reconhub/epicontacts@timeline\")\npackageurl <- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\nremotes::install_local(\"~/Downloads/dplyr-master.zip\")\ninstall.packages(\"~/Downloads/dplyr-master.zip\", repos=NULL, type=\"source\")"},{"path":"basics.html","id":"cú-pháp-code","chapter":"3 R Cơ bản","heading":"Cú pháp code","text":"Để tăng sự tường minh trong cuốn sách này, các hàm đôi khi sẽ được đặt sau tên package của chúng bằng cách sử dụng ký hiệu :: theo cách sau: package_name::function_name()Khi một package được gọi cho một phiên làm việc, việc làm này là không cần thiết. Bạn chỉ cần sử dụng function_name(). Tuy nhiên, việc viết tên package sẽ hữu ích khi một tên hàm phổ biến và có thể tồn tại trong nhiều package (ví dụ: plot()). Việc viết tên package sẽ giúp gọi package trong trường hợp nó chưa được gọi ra.","code":"\n# This command uses the package \"rio\" and its function \"import()\" to import a dataset\nlinelist <- rio::import(\"linelist.xlsx\", which = \"Sheet1\")"},{"path":"basics.html","id":"trợ-giúp-về-hàm","chapter":"3 R Cơ bản","heading":"Trợ giúp về hàm","text":"Để đọc thêm thông tin về một hàm, bạn có thể tìm kiếm hàm đó trong cửa sổ Help của RStudio nằm ở góc dưới bên phải. Hoặc bạn cũng có thể chạy một lệnh chẳng hạn như ?thefunctionname (đặt tên của hàm sau dấu chấm hỏi) và trang Trợ giúp sẽ xuất hiện trong cửa sổ Help. Cuối cùng, hãy thử tìm kiếm trên internet.","code":""},{"path":"basics.html","id":"cập-nhật-packages","chapter":"3 R Cơ bản","heading":"Cập nhật packages","text":"Bạn có thể cập nhật các packages bằng cách cài đặt lại chúng. Bạn cũng có thể bấm vào nút “Update” màu xanh lá cây trong cửa sổ packages của RStudio để xem packages nào có phiên bản mới để cài đặt. Lưu ý rằng code cũ của bạn có thể cần được cập nhật nếu có một bản sửa đổi lớn về cách hoạt động của một hàm!","code":""},{"path":"basics.html","id":"xóa-packages","chapter":"3 R Cơ bản","heading":"Xóa packages","text":"Sử dụng p_delete() từ pacman, hoặc remove.packages() từ base R. Ngoài ra, hãy tìm thư mục chứa thư viện của bạn và xóa thư mục theo cách thủ công.","code":""},{"path":"basics.html","id":"sự-phụ-thuộc","chapter":"3 R Cơ bản","heading":"Sự phụ thuộc","text":"Các packages thường phụ thuộc vào các packages khác để hoạt động. Chúng được gọi là sự phụ thuộc. Nếu một package không cài đặt được, thì package phụ thuộc vào nó có khả năng cũng không thể cài đặt được.Xem sự phụ thuộc của một package với lệnh p_depends(), và xem package nào phụ thuộc vào nó với p_depends_reverse()","code":""},{"path":"basics.html","id":"hàm-bị-che-giấu","chapter":"3 R Cơ bản","heading":"Hàm bị che giấu","text":"Không có gì lạ nếu hai hoặc nhiều packages chứa cùng một tên hàm. Ví dụ: packages dplyr có hàm filter(), nhưng package stats cũng vậy. Hàm filter() mặc định phụ thuộc vào thứ tự các package này được gọi lên trong phiên làm việc R - packages được gọi ra sau sẽ là mặc định cho hàm filter().Bạn có thể kiểm tra thứ tự của chúng trong cửa sổ Environment của R Studio - nhấp vào menu thả xuống “Global Environment” và xem thứ tự của các packages. Các hàm thuộc các packages ở vị trí thấp hơn trong danh sách thả xuống đó sẽ che giấu các hàm cùng tên trong các packages xuất hiện ở vị trí bên trên trong danh sách thả xuống. Khi bạn vừa gọi một package, R sẽ cảnh báo bạn trong bảng điều khiển nếu xảy ra hiện tượng này, nhưng điều này rất hay bị bỏ quên.Dưới đây là những cách bạn có thể sửa lỗi hàm bị che giấu:Ghi rõ tên package trong lệnh. Ví dụ, sử dụng dplyr::filter()Sắp xếp lại thứ tự mà các package được tải (ví dụ trong p_load()), và bắt đầu một phiên làm việc R mới","code":""},{"path":"basics.html","id":"gỡ-package","chapter":"3 R Cơ bản","heading":"Gỡ package","text":"Để gỡ (detach) một package, hãy sử dụng lệnh dưới đây, với tên package chính xác và chỉ có một dấu hai chấm. Lưu ý rằng điều này có thể không giải quyết được việc hàm bị che giấu.","code":"\ndetach(package:PACKAGE_NAME_HERE, unload=TRUE)"},{"path":"basics.html","id":"cài-đặt-phiên-bản-cũ-hơn","chapter":"3 R Cơ bản","heading":"Cài đặt phiên bản cũ hơn","text":"Xem hướng dẫn này để cài đặt phiên bản cũ hơn của một package cụ thể.","code":""},{"path":"basics.html","id":"packages-đề-xuất","chapter":"3 R Cơ bản","heading":"Packages đề xuất","text":"Xem chương Package đề xuất để biết danh sách các packages thường được sử dụng trong dịch tễ học.","code":""},{"path":"basics.html","id":"scripts","chapter":"3 R Cơ bản","heading":"3.8 Scripts","text":"Scripts là một phần cơ bản của lập trình. Chúng là các tài liệu chứa các câu lệnh của bạn (ví dụ: các hàm để tạo và chỉnh sửa bộ số liệu, các hàm để các biểu đồ trực quan hóa số liệu, v.v.). Bạn có thể lưu một scripts và chạy lại sau này. Có nhiều lợi ích để lưu trữ và chạy các lệnh của bạn từ một scripts (với nhập “từng lệnh” vào R console):Tiện dụng - bạn có thể chia sẻ công việc của mình với người khác bằng cách gửi cho họ các tập lệnh của bạnKhả năng tái lập - để bạn và những người khác biết chính xác những gì bạn đã làmKiểm soát phiên bản - để bạn có thể theo dõi các thay đổi chính bạn hoặc đồng nghiệp thực hiệnDễ dàng nhận xét/chú thích - để giải thích cho đồng nghiệp của bạn những gì bạn đã làm","code":""},{"path":"basics.html","id":"bình-luận","chapter":"3 R Cơ bản","heading":"Bình luận","text":"Khi viết script, bạn có thể thêm các chú thích (“bình luận”) xung quanh code R của bạn. Bình luận là cần thiết để giải thích cho chính bạn và những người đọc khác hiểu những gì bạn đang làm. Bạn có thể thêm bình luận bằng cách nhập dấu thăng (#) và viết bình luận của bạn sau đó. Nội dung bình luận sẽ xuất hiện với màu khác với code R.Bất kỳ code nào được viết sau dấu # sẽ không được chạy. đó, đặt dấu # trước dòng code cũng là một cách hữu ích để tạm thời vô hiệu hóa một dòng code (“comment ”) nếu bạn không muốn xóa nó). Bạn có thể comment /nhiều dòng cùng một lúc bằng cách bôi đen chúng và nhấn Ctrl + Shift + c (Cmd + Shift + c trong Mac).Bình luận những gì bạn đang làm và tại sao bạn làm như vậy.Chia code của bạn thành các phần hợp lýKèm theo code của bạn với mô tả từng bước về những gì đang được thực hiện (ví dụ: các bước được đánh số)","code":"\n# A comment can be on a line by itself\n# import data\nlinelist <- import(\"linelist_raw.xlsx\") %>%   # a comment can also come after code\n# filter(age > 50)                          # It can also be used to deactivate / remove a line of code\n  count()"},{"path":"basics.html","id":"phong-cách-viết-code-1","chapter":"3 R Cơ bản","heading":"Phong cách viết code","text":"Phong cách viết code của bạn rất quan trọng - đặc biệt là khi làm việc theo nhóm. Chúng tôi khuyên bạn nên tuân theo hướng dẫn phong cách viết code tidyverse . Bên cạnh đó còn có các packages khác như styler và lintr để giúp bạn tuân theo phong cách này.Một vài điểm rất cơ bản để làm cho code của bạn dễ dàng đọc được đối với người khác:\n* Khi đặt tên cho các đối tượng, chỉ sử dụng các chữ cái viết thường, số và dấu gạch dưới _, ví dụ: my_data\n* Thường xuyên sử dụng dấu cách, bao gồm cả xung quanh các toán tử, ví dụ: n = 1 và age_new <- age_old + 3","code":""},{"path":"basics.html","id":"ví-dụ-về-script","chapter":"3 R Cơ bản","heading":"Ví dụ về Script","text":"Dưới đây là một ví dụ về một đoạn ngắn R script. Hãy nhớ rằng, bạn càng giải thích ngắn gọn lệnh code của mình trong phần bình luận, thì đồng nghiệp của bạn sẽ càng thích bạn!","code":""},{"path":"basics.html","id":"r-markdown","chapter":"3 R Cơ bản","heading":"R markdown","text":"R markdown là một dạng của R script và có khả năng xuất thành các tệp đầu ra (PDF, Word, HTML, Powerpoint, v.v.). Đây là những công cụ vô cùng hữu ích và linh hoạt thường được sử dụng để tạo các báo cáo tự động. Ngay cả trang web và cuốn sách này cũng được viết bằng R markdown!Bạn cần biết rằng những người mới bắt đầu dùng R cũng có thể sử dụng R Markdown - đó đừng sợ! Để tìm hiểu thêm, hãy xem chương Báo cáo với R Markdown trong cuốn sách này.","code":""},{"path":"basics.html","id":"r-notebooks","chapter":"3 R Cơ bản","heading":"R notebooks","text":"Không có sự khác biệt trong cách viết giữa R markdown và R notebook. Tuy nhiên, việc thực thi của hai loại file này hơi khác nhau một chút. Xem trang Web này để biết thêm chi tiết.","code":""},{"path":"basics.html","id":"shiny","chapter":"3 R Cơ bản","heading":"Shiny","text":"Shiny apps/websites được chứa trong một script có tên app.R. Tệp này có ba thành phần:Giao diện người dùng (ui)Một hàm máy chúMột lệng gọi hàm shinyAppXem thêm trong cuốn sách này tại chương Dashboards với Shiny, hoặc hướng dẫn trực tuyến này: Shiny tutorialTrước đây, tệp bên trên được chia thành 2 tệp con (ui.R và server.R)","code":""},{"path":"basics.html","id":"thu-gọn-code","chapter":"3 R Cơ bản","heading":"Thu gọn Code","text":"Bạn có thể thu gọn các đoạn code để làm cho script của bạn dễ đọc hơn.Để làm điều này, hãy tạo tiêu đề văn bản bằng dấu thăng #, viết tiêu đề của bạn và thêm vào phía sau nó ít nhất hoặc là 4 dấu gạch ngang (-), dấu thăng (#) hoặc dấu bằng (=). Ngay sau đó, một mũi tên nhỏ sẽ xuất bên cạnh ở bên phải số thự tự của dòng lệnh. Bạn có thể nhấp vào mũi tên này và phần code bên dưới sẽ được thu gọn cho đến trước tiêu đề tiếp theo và một mũi tên hai chiều xuất hiện ở đây.Để mở rộng lại đoạn code đã thu gọn, hãy nhấp lại vào mũi tên hoặc biểu tượng mũi tên hai chiều. Ngoài ra còn có thể sử dụng thêm các phím tắt như đã được giải thích trong mục RStudio của chương này.Bằng cách tạo tiêu đề bằng #, bạn cũng sẽ kích hoạt Mục lục ở cuối tập lệnh của mình (xem bên dưới) mà bạn có thể sử dụng để điều hướng tập lệnh của mình. Bạn có thể tạo tiêu đề phụ bằng cách thêm các ký hiệu #, ví dụ: # # cho tiêu đề chính, ## fcho tiêu đề thứ hai, và ### cho tiêu đề thứ ba.Dưới đây là hai phiên bản của một ví dụ cho script. Ở bên trái là bản gốc với các tiêu đề được chú thích. Ở bên phải, bốn dấu gạch ngang đã được viết sau mỗi tiêu đề, làm cho chúng có thể thu gọn được. Hai trong số chúng đã được thu gọn và bạn có thể thấy Mục lục ở dưới cùng hiện hiển thị từng phần.Các phần code khác mặc định đủ điều kiện để thu gọn bao gồm các phần “nằm giữa” hai dấu ngoặc nhọn { }, chẳng hạn như định nghĩa hàm hoặc các khối điều kiện (câu lệnh else). Bạn có thể đọc thêm về cách thu gọn code tại trang của Rstudio.","code":""},{"path":"basics.html","id":"thư-mục-làm-việc","chapter":"3 R Cơ bản","heading":"3.9 Thư mục làm việc","text":"Thư mục làm việc là vị trí thư mục gốc được R sử dụng cho công việc của bạn - nơi R tìm kiếm và lưu các tệp theo mặc định. Mặc định là, R sẽ lưu các tệp mới và xuất tệp vào vị trí này, đồng thời sẽ tìm kiếm các tệp để nhập dữ liệu (ví dụ: bộ dữ liệu) tại đây.Thư mục làm việc xuất hiện bằng dòng chữ màu xám ở phía trên cửa sổ Rstudio Console. Bạn cũng có thể thư mục làm việc hiện tại bằng cách chạy lệnh getwd() (để trống dấu ngoặc đơn).","code":""},{"path":"basics.html","id":"gợi-ý-cách-tiếp-cận","chapter":"3 R Cơ bản","heading":"Gợi ý cách tiếp cận","text":"Xem thêm tại chương Dự án R để biết chi tiết về gợi ý các cách tiếp cận của chúng tôi trong việc quản lý thư mục làm việc của bạn.\nMột cách phổ biến, hiệu quả và không gặp sự cố khi quản lý thư mục làm việc và đường dẫn tệp là kết hợp 3 yếu tố này trong một quy trình làm việc với Dự án R có định hướng :Một dự án R để lưu trữ tất cả tệp của bạn (xem chương Dự án R)Package để định vị tệp (xem chương Nhập xuất dữ liệu)Packge rio để nhập/xuất tệp (xem chương Nhập xuất dữ liệu)","code":""},{"path":"basics.html","id":"thiết-lập-bằng-lệnh","chapter":"3 R Cơ bản","heading":"Thiết lập bằng lệnh","text":"Cho tới gần đây, nhiều người học R đã được dạy để bắt đầu script của họ bằng lệnh setwd(). Hãy thay đổi thói quen đó bằng cách sử dụng Dự án R và đọc thêm tài liệu sau để hiểu lý không nên sử dụng setwd(). Một cách ngắn gọn là, công việc của bạn chỉ thực hiện được trên máy tính của bạn, các đường dẫn tệp được sử dụng để nhập và xuất tệp trở nên “dễ lỗi” và điều này cản trở nghiêm trọng đến việc cộng tác và sử dụng code của bạn trên bất kỳ máy tính nào khác. Bạn có những lựa chọn khác dễ dàng hơn!Như đã nói ở trên, mặc dù chúng tôi không khuyến nghị phương pháp này trong hầu hết các trường hợp, bạn vẫn có thể sử dụng lệnh setwd() với đường dẫn tệp thư mục mong muốn trong dấu ngoặc kép, ví dụ:NGUY HIỂM: thiết lập một thư mục làm việc với setwd() có thể dẫn đến “lỗi” nếu đường dẫn tệp dành riêng cho một máy tính. Thay vào đó, hãy sử dụng đường dẫn tệp liên quan đến thư mục gốc Dự án R (với package ).","code":"\nsetwd(\"C:/Documents/R Files/My analysis\")"},{"path":"basics.html","id":"thiết-lập-thủ-công","chapter":"3 R Cơ bản","heading":"Thiết lập thủ công","text":"Để thiết lập thư mục làm việc một cách thủ công (trỏ và nhấp tương đương với setwd()), hãy chọn mục Session trên thanh công cụ và chọn “Set Working Directory”, sau đó chọn “Choose Directory”. Chú ý: nếu sử dụng phương pháp này, bạn sẽ phải thực hiện việc này theo cách thủ công mỗi khi mở RStudio.","code":""},{"path":"basics.html","id":"thiết-lập-bên-trong-một-dự-án-r","chapter":"3 R Cơ bản","heading":"Thiết lập bên trong một dự án R","text":"Nếu bạn đang mở một dự án R, thư mục làm việc sẽ mặc định là thư mục gốc của dự án R có chứa tệp “.rproj”. Điều này sẽ áp dụng nếu bạn mở RStudio bằng cách nhấp vào mở R Project (tệp có phần mở rộng “.rproj”).","code":""},{"path":"basics.html","id":"thư-mục-làm-việc-với-r-markdown","chapter":"3 R Cơ bản","heading":"Thư mục làm việc với R markdown","text":"Trong script ở R markdown, thư mục làm việc mặc định là thư mục chứa tệp R markdown (.Rmd). Nếu sử dụng dự án R và package , điều này sẽ không được áp dụng. Để biết thư mục làm việc là gì, sử dụng lệnh () như đã được giải thích tại chương Dự án R.Nếu bạn muốn thay đổi thư mục làm việc của một tệp độc lập ở R markdown (không phải ở dự án R), nếu bạn sử dụng setwd() điều này sẽ chỉ áp dụng chỉ cho đoạn code đó. Để thực hiện thay đổi cho tất cả các đoạn code trong R markdown, hãy điều chỉnh ở bước thiết lập để thêm tham số root.dir =, như bên dưới:Cách này dễ hơn nhiều với chỉ sử dụng R markdown bên trong một dự án R và sử dụng package .","code":"\nknitr::opts_knit$set(root.dir = 'desired/directorypath')"},{"path":"basics.html","id":"cung-cấp-đường-dẫn-tệp","chapter":"3 R Cơ bản","heading":"Cung cấp đường dẫn tệp","text":"Có lẽ điều khiến những người mới bắt đầu với R cảm thấy nản nhất (ít nhất là với người dùng máy tính Windows) đó là gõ đường dẫn tệp để nhập xuất dữ liệu. Chúng tôi có giải thích cặn kẽ về cách tạo đường dẫn tệp đầu vào tốt nhất trong chương Nhập xuất dữ liệu, nhưng dưới đây là một số điểm chính:Đường dẫn tệp bị lỗiDưới đây là ví dụ về đường dẫn tệp “tuyệt đối” hoặc “địa chỉ đầy đủ”. Chúng có thể bị lỗi nếu được sử dụng bởi một máy tính khác. Một ngoại lệ là nếu bạn đang sử dụng ổ đĩa chia sẻ/mạng.Đường dẫn với dấu gạch chéoNếu nhập đường dẫn tệp, hãy lưu ý hướng của các dấu gạch chéo. Sử dụng dấu gạch chéo xuôi (/) để tách các thành phần (“data/provincial.csv”). Đối với người dùng Windows, cách mặc định mà đường dẫn tệp được hiển thị là dấu gạch chéo ngược (\\) - vì vậy bạn sẽ cần phải thay đổi hướng của mỗi dấu gạch chéo. Nếu bạn sử dụng package được miêu tả ở Dự án R thì dấu gạch chéo không còn là vấn đề với bạn nữa.Đường dẫn tệp tương đốiNói chung, chúng tôi khuyên bạn nên cung cấp các đường dẫn tệp theo cách “tương đối” - nghĩa là, đường dẫn liên quan đến thư mục gốc Dự án R của bạn. Bạn có thể thực hiện việc này bằng cách sử dụng package như được giải thích trong chương Dự án R. Một đường dẫn tệp tương đối sẽ trông như thế này:Ngay cả khi sử dụng đường dẫn tệp tương đối trong dự án R, bạn vẫn có thể sử dụng đường dẫn tuyệt đối để nhập/xuất dữ liệu ở bên ngoài dự án R của bạn.","code":"C:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  \n# Import csv linelist from the data/linelist/clean/ sub-folders of an R project\nlinelist <- import(here(\"data\", \"clean\", \"linelists\", \"marin_country.csv\"))"},{"path":"basics.html","id":"objects","chapter":"3 R Cơ bản","heading":"3.10 Đối tượng","text":"Mọi thứ trong R đều là một đối tượng, và R là một ngôn ngữ “lập trình hướng đối tượng”. Các phần dưới đây sẽ giải thích:Cách tạo ra các đối tượng (<-)Các loại đối tượng (ví dụ: data frames, vectors..)Cách truy cập các tập con của đối tượng (ví dụ: các biến số trong một bộ dữ liệu)Các loại đối tượng (ví dụ: numeric, logical, integer, double, character, factor)","code":""},{"path":"basics.html","id":"mọi-thứ-đều-là-một-đối-tượng","chapter":"3 R Cơ bản","heading":"Mọi thứ đều là một đối tượng","text":"Phần này được dựa theo sách R4Epis project.\nMọi thứ bạn lưu trữ trong R - bao gồm bộ dữ liệu, biến số, danh sách tên làng, tổng số dân, thậm chí cả kết quả đầu ra như biểu đồ - đều là các đối tượng, được gán tên và có thể được tham chiếu trong các lệnh sau đó.Một đối tượng tồn tại khi bạn đã gán giá trị cho nó (xem phần gán bên dưới). Khi nó được gán một giá trị, đối tượng sẽ xuất hiện trong cửa sổ Environment (xem cửa sổ phía trên bên phải của RStudio). Sau đó, nó có thể được sử dụng, thao tác, thay đổi và định nghĩa lại.","code":""},{"path":"basics.html","id":"định-nghĩa-một-đối-tượng--","chapter":"3 R Cơ bản","heading":"Định nghĩa một đối tượng (<-)","text":"Tạo ra một đối tượng bằng cách gán cho chúng một giá trị bằng toán tử <-.\nBạn có thể nghĩ về toán tử gán <- tương đương với từ “được định nghĩa là”. Các lệnh gán thường tuân theo một trật tự quy định:tên đối tượng <- giá trị của đối tượng (hoặc quy trình / tính toán tạo ra giá trị)Ví dụ: bạn muốn ghi nhận một báo cáo tuần dịch tễ học hiện tại dưới dạng một đối tượng để tham chiếu tới code của bạn sau này. Trong ví dụ này, đối tượng current_week được tạo khi nó được gán giá trị \"2018-W10\" (dấu ngoặc kép sẽ quy định đây là giá trị dạng chữ). Đối tượng current_week sẽ xuất hiện trong cửa sổ RStudio Environment (phía trên bên phải) và có thể được tham chiếu tới các lệnh sau này.Xem các lệnh R và kết quả của chúng như dưới đây.CHÚ Ý: Lưu ý rằng số [1] trong kết quả ở R console đơn giản là chỉ ra rằng bạn đang xem mục đầu tiên của đầu raTHẬN TRỌNG: Giá trị của một đối tượng có thể bị ghi đè bất kỳ lúc nào bằng cách chạy lệnh gán để định nghĩa lại giá trị của nó. đó, thứ tự của các lệnh được chạy rất quan trọng.Lệnh sau sẽ định nghĩa lại giá trị của đối tượng current_week:Dấu bằng =Bạn cũng sẽ thấy các dấu bằng trong R code:Hai dấu bằng == giữa hai đối tượng hoặc giá trị dùng để đặt một câu hỏi logic: “cái này có bằng cái kia không?”.Bạn cũng sẽ thấy các dấu bằng trong các hàm được sử dụng để xác định giá trị của các đối số của hàm (đọc thêm ở các phần bên dưới), ví dụ: max(age, na.rm = TRUE).Bạn có thể sử dụng một dấu bằng = thay cho dấu <- để tạo và định nghĩa các đối tượng, nhưng điều này không được khuyến khích. Bạn có thể đọc về lý tại sao điều này không được khuyến khích ở đây.Bộ dữ liệuBộ dữ liệu (datasets) cũng là một đối tượng (thường là một “dataframes”) và phải được gán tên khi chúng được nhập. Trong đoạn mã dưới đây, đối tượng linelist được tạo và gán giá trị từ tệp CSV, tệp này được nhập bằng package rio và hàm import() của package này.Bạn có thể đọc thêm về nhập và xuất dữ liệu trong chương Nhập xuất dữ liệu.THẬN TRỌNG: Lưu ý nhanh về cách đặt tên đối tượng:Tên đối tượng không được chứa dấu cách, nhưng bạn nên sử dụng dấu gạch dưới (_) hoặc dấu chấm (.) thay vì dấu cách.Tên đối tượng phân biệt chữ hoa và chữ thường (nghĩa là Dataset_A khác với dataset_A).Tên đối tượng phải bắt đầu bằng chữ cái (không được bắt đầu bằng số như 1, 2 hoặc 3).Kết quả đầu raCác kết quả đầu ra như bảng và biểu đồ cung cấp một ví dụ về cách các kết quả đầu ra có thể được lưu dưới dạng đối tượng hoặc chỉ được ra mà không cần lưu. Ví dụ, một bảng chéo giữa giới tính và biến kết cục được tạo ra bởi hàm table() trong base R, có thể được trực tiếp vào R console (mà không cần lưu).Nhưng bảng này cũng có thể được lưu dưới dạng một đối tượng được đặt tên. Sau đó, bạn có thể nó ra.CộtCác cột trong tập dữ liệu cũng là các đối tượng và có thể được định nghĩa, ghi đè và tạo như được mô tả bên dưới trong phần Cột.Bạn có thể sử dụng toán tử gán từ base R để tạo một cột mới. Dưới đây, cột mới bmi (Body Mass Index) được tạo, và giá trị mới ứng với mỗi hàng là kết quả của một phép toán trên giá trị của các hàng trong cột wt_kg và cột ht_cm.Tuy nhiên, trong cuốn sách này, chúng tôi tập trung vào một cách tiếp cận khác để định nghĩa cột, sử dụng hàm mutate() trong package dplyr và piping với toán tử pipe (%>%). Cú pháp dễ đọc hơn và có những ưu điểm khác đã được giải thích trong cuốn sách này ở chương Làm sạch số liệu và các hàm quan trọng. Bạn có thể đọc thêm về piping trong phần Piping phía bên dưới.","code":"\ncurrent_week <- \"2018-W10\"   # this command creates the object current_week by assigning it a value\ncurrent_week                 # this command prints the current value of current_week object in the console## [1] \"2018-W10\"\ncurrent_week <- \"2018-W51\"   # assigns a NEW value to the object current_week\ncurrent_week                 # prints the current value of current_week in the console## [1] \"2018-W51\"\n# linelist is created and assigned the value of the imported CSV file\nlinelist <- import(\"my_linelist.csv\")\n# printed to R console only\ntable(linelist$gender, linelist$outcome)##    \n##     Death Recover\n##   f  1227     953\n##   m  1228     950\n# save\ngen_out_table <- table(linelist$gender, linelist$outcome)\n\n# print\ngen_out_table##    \n##     Death Recover\n##   f  1227     953\n##   m  1228     950\n# create new \"bmi\" column using base R syntax\nlinelist$bmi <- linelist$wt_kg / (linelist$ht_cm/100)^2\n# create new \"bmi\" column using dplyr syntax\nlinelist <- linelist %>% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)"},{"path":"basics.html","id":"objectstructure","chapter":"3 R Cơ bản","heading":"3.10.1 Cấu trúc đối tượng","text":"Các đối tượng có thể là một phần dữ liệu đơn lẻ (ví dụ: my_number <- 24), hoặc chúng có thể bao gồm dữ liệu có cấu trúc.Hình ảnh dưới đây được tham khảo từ hướng dẫn R trực tuyến này. Nó cho thấy một số cấu trúc dữ liệu phổ biến và tên của chúng. Hình ảnh này không bao gồm dữ liệu không gian. Bạn có thể xem thêm về dữ liệu không gian tại chương GIS cơ bản.Trong dịch tễ học (và đặc biệt là dịch tễ học thực địa), bạn sẽ thường xuyên phải tiếp xúc với data frames và vectors:Lưu ý rằng để tạo một vectơ “độc lập” (mà không phải là một phần của data frame), hàm c() được sử dụng để kết hợp các phần tử khác nhau. Ví dụ: nếu tạo một vectơ màu sắc thang màu của biểu đồ: vector_of_colors <- c(\"blue\", \"red2\", \"orange\", \"grey\")","code":""},{"path":"basics.html","id":"kiểu-đối-tượng","chapter":"3 R Cơ bản","heading":"Kiểu đối tượng","text":"Tất cả các đối tượng được lưu trữ trong R đều có một kiểu dữ liệu cho biết cách nó được xử lý. Có nhiều kiểu đối tượng, nhưng những kiểu phổ biến bao gồm:Bạn có thể kiểm tra kiểu của một đối tượng bằng cách cung cấp tên của nó tới hàm class(). Lưu ý: bạn có thể tham chiếu một cột cụ thể trong tập dữ liệu bằng cách sử dụng ký hiệu $ để phân tách tên của tập dữ liệu và tên của cột.Đôi khi, một cột sẽ được tự động chuyển đổi thành một kiểu khác bởi R. Hãy coi chừng điều này! Ví dụ: nếu bạn có một vectơ hoặc cột kiểu số, nhưng một giá trị ký tự được chèn vào … thì toàn bộ cột sẽ thay đổi thành kiểu ký tự.Một ví dụ phổ biến của điều này là khi thao tác với một data frame để bảng - nếu bạn tạo một hàng tính tổng và cố gắng dán /gắn phần trăm với số trong cùng một ô (ví dụ: 23 (40%)), toàn bộ cột dạng số ở trên sẽ chuyển đổi thành ký tự và không còn có thể được sử dụng cho các phép tính toán học nữa.Đôi khi, bạn sẽ cần chuyển đổi các đối tượng hoặc cột sang một loại khác.Tương tự như vậy, một số hàm base R có thể kiểm tra xem một đối tượng CÓ thuộc của một kiểu dữ liệu cụ thể nào hay không, chẳng hạn như .numeric(), .character(), .double(), .factor(), .integer()Bạn có thể tham khảo một tài liệu trực tuyến về các kiểu và cấu trúc dữ liệu trong R tại đây.","code":"\nclass(linelist)         # class should be a data frame or tibble## [1] \"data.frame\"\nclass(linelist$age)     # class should be numeric## [1] \"numeric\"\nclass(linelist$gender)  # class should be character## [1] \"character\"\nnum_vector <- c(1,2,3,4,5) # define vector as all numbers\nclass(num_vector)          # vector is numeric class## [1] \"numeric\"\nnum_vector[3] <- \"three\"   # convert the third element to a character\nclass(num_vector)          # vector is now character class## [1] \"character\""},{"path":"basics.html","id":"cột-biến-số","chapter":"3 R Cơ bản","heading":"Cột / Biến số ($)","text":"Một cột trong data frame về mặt kỹ thuật là một “vector” (xem bảng ở trên) - bao gồm một chuỗi các giá trị cùng loại (ký tự, số, lôgic, v.v.).Một vectơ có thể tồn tại độc lập với một data frame, ví dụ: vectơ tên cột mà bạn muốn đưa vào làm biến giải thích trong mô hình. Để tạo một vectơ “độc lập”, hãy sử dụng hàm c() như dưới đây:Các cột trong data frame cũng là vectơ và có thể được gọi, tham chiếu, trích xuất hoặc tạo bằng ký hiệu $. Ký hiệu $ kết nối tên của cột với tên của data frame tương ứng. Trong cuốn sách này, chúng tôi cố gắng sử dụng từ “cột” thay vì “biến số”.Bằng cách nhập tên của một dataframe, theo sau bởi ký tự $, bạn sẽ thấy menu gợi ý của tất cả các tên cột trong dataframe. Bạn có thể di chuyển giữa các cột bằng phím mũi tên, chọn cột bằng phím Enter để tránh lỗi chính tả!MẸO NÂNG CAO: Một số đối tượng phức tạp hơn (ví dụ: một danh sách hoặc đối tượng epicontacts) có thể có nhiều cấp độ có thể được truy cập thông qua nhiều ký tự đô la. Ví dụ: epicontacts$linelist$date_onset","code":"\n# define the stand-alone vector of character values\nexplanatory_vars <- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n# print the values in this named vector\nexplanatory_vars## [1] \"gender\" \"fever\"  \"chills\" \"cough\"  \"aches\"  \"vomit\"\n# Retrieve the length of the vector age_years\nlength(linelist$age) # (age is a column in the linelist data frame)"},{"path":"basics.html","id":"truy-cập-indexing-đối-tượng-bằng-dấu-ngoặc-vuông","chapter":"3 R Cơ bản","heading":"Truy cập / indexing đối tượng bằng dấu ngoặc vuông ([ ])","text":"Khi cần xem một phần của đối tượng, còn được gọi là “indexing”, bạn có thể sử dụng dấu ngoặc vuông [ ]. Sử dụng $ trên dataframe để truy cập một cột cũng là một kiểu indexing.Dấu ngoặc vuông cũng hoạt động để xem các phần cụ thể trong kết quả đầu ra, chẳng hạn như đầu ra của hàm summary():Dấu ngoặc vuông cũng hoạt động trên data frames để xem các hàng và cột cụ thể. Bạn có thể thực hiện việc này bằng cú pháp dataframe[rows, columns]:Lưu ý rằng bạn cũng có thể indexing hàng / cột trong một data frames và tibbles bằng cách sử dụng cú pháp của package dplyr (hàm filter() đối với hàng, và select() đối với cột). Đọc thêm về các hàm quan trọng này trong chương Làm sạch số liệu và các hàm quan trọng.Để lọc dựa trên “số thứ tự hàng”, bạn có thể sử dụng hàm row_number()trong package dplyr với dấu ngoặc đơn mở như một phần của biểu thức lọc logic. Thường thì bạn sẽ sử dụng toán tử %% và một khoảng giá trị số như một phần của câu lệnh logic đó, như được trình bày dưới đây. Để xem N hàng đầu tiên, bạn cũng có thể sử dụng hàm head() của package dplyr.Khi indexing một đối tượng chứa một danh sách bằng một dấu ngoặc vuông sẽ luôn trả về kiểu danh sách, ngay cả khi chỉ một đối tượng được trả về . Tuy nhiên, hai dấu ngoặc vuông có thể được sử dụng để truy cập một phần tử đơn lẻ đối và trả về một kiểu không phải là một danh sách.\nDấu ngoặc vuông cũng có thể được viết sau nhau, như được minh họa bên dưới.Bạn có thể xem một giải thích trực quan về việc indexing với ví dụ về hộp lắc hạt tiêu tại đây, rất hài hước và hữu ích.Đây là cách mà một danh sách được trong R console. Có hai phần tử được đặt tên:hospitals, một vector chứa ký tựaddresses, một data frame chứa các địa chỉDưới đây là các phương pháp indexing mà bạn có thể sử dụng:","code":"\nmy_vector <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")  # define the vector\nmy_vector[5]                                  # print the 5th element## [1] \"e\"\n# All of the summary\nsummary(linelist$age)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.07   23.00   84.00      86\n# Just the second element of the summary, with name (using only single brackets)\nsummary(linelist$age)[2]## 1st Qu. \n##       6\n# Just the second element, without name (using double brackets)\nsummary(linelist$age)[[2]]## [1] 6\n# Extract an element by name, without showing the name\nsummary(linelist$age)[[\"Median\"]]## [1] 13\n# View a specific row (2) from dataset, with all columns (don't forget the comma!)\nlinelist[2,]\n\n# View all rows, but just one column\nlinelist[, \"date_onset\"]\n\n# View values from row 2 and columns 5 through 10\nlinelist[2, 5:10] \n\n# View values from row 2 and columns 5 through 10 and 18\nlinelist[2, c(5:10, 18)] \n\n# View rows 2 through 20, and specific columns\nlinelist[2:20, c(\"date_onset\", \"outcome\", \"age\")]\n\n# View rows and columns based on criteria\n# *** Note the dataframe must still be named in the criteria!\nlinelist[linelist$age > 25 , c(\"date_onset\", \"outcome\", \"age\")]\n\n# Use View() to see the outputs in the RStudio Viewer pane (easier to read) \n# *** Note the capital \"V\" in View() function\nView(linelist[2:20, \"date_onset\"])\n\n# Save as a new object\nnew_table <- linelist[2:20, c(\"date_onset\")] \n# View first 100 rows\nlinelist %>% head(100)\n\n# Show row 5 only\nlinelist %>% filter(row_number() == 5)\n\n# View rows 2 through 20, and three specific columns (note no quotes necessary on column names)\nlinelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)\n# define demo list\nmy_list <- list(\n  # First element in the list is a character vector\n  hospitals = c(\"Central\", \"Empire\", \"Santa Anna\"),\n  \n  # second element in the list is a data frame of addresses\n  addresses   = data.frame(\n    street = c(\"145 Medical Way\", \"1048 Brown Ave\", \"999 El Camino\"),\n    city   = c(\"Andover\", \"Hamilton\", \"El Paso\")\n    )\n  )\nmy_list## $hospitals\n## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\n## \n## $addresses\n##            street     city\n## 1 145 Medical Way  Andover\n## 2  1048 Brown Ave Hamilton\n## 3   999 El Camino  El Paso\nmy_list[1] # this returns the element in class \"list\" - the element name is still displayed## $hospitals\n## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\nmy_list[[1]] # this returns only the (unnamed) character vector## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\nmy_list[[\"hospitals\"]] # you can also index by name of the list element## [1] \"Central\"    \"Empire\"     \"Santa Anna\"\nmy_list[[1]][3] # this returns the third element of the \"hospitals\" character vector## [1] \"Santa Anna\"\nmy_list[[2]][1] # This returns the first column (\"street\") of the address data frame##            street\n## 1 145 Medical Way\n## 2  1048 Brown Ave\n## 3   999 El Camino"},{"path":"basics.html","id":"xóa-đối-tượng","chapter":"3 R Cơ bản","heading":"Xóa đối tượng","text":"Bạn có thể xóa từng đối tượng riêng lẻ khỏi cửa sổ R environment bằng cách để tên của đối tượng cần xóa vào trong hàm rm() (không có dấu ngoặc kép):Bạn có thể xóa tất cả các đối tượng (xóa không gian làm việc của bạn) bằng cách chạy:","code":"\nrm(object_name)\nrm(list = ls(all = TRUE))"},{"path":"basics.html","id":"piping","chapter":"3 R Cơ bản","heading":"3.11 Piping (%>%)","text":"Hai cách tiếp cận chung để làm việc với các đối tượng là:Pipes/tidyverse - pipes chuyển một đối tượng từ hàm này sang hàm khác - tập trung vào hành động chứ không phải đối tượngXác định đối tượng trung gian - một đối tượng được xác định lại nhiều lần - tập trung vào đối tượng","code":""},{"path":"basics.html","id":"pipes","chapter":"3 R Cơ bản","heading":"Pipes","text":"Giải thích một cách đơn giản, toán tử pipe (%>%) chuyển một đầu ra trung gian từ hàm này sang hàm tiếp theo.\nHiểu đơn giản pipe nghĩa là “sau đó”. Nhiều hàm có thể được liên kết với nhau bằng toán tử %>%.Piping nhấn mạnh một chuỗi các hành động, không phải đối tượng mà các hành động đang áp dụngPipes được áp dụng tốt nhất khi một chuỗi hành động phải được thực hiện trên một đối tượngPipes đến từ package magrittr, và đã tự động được thêm vào packages dplyr và tidyversePipes làm cho code sạch hơn, dễ đọc hơn và trực quan hơnĐọc thêm về cách tiếp cận này trong package tidyverse tại đây Hướng dẫnĐây là một ví dụ mô phỏng dùng để sánh, sử dụng các hàm hư cấu để “nướng bánh”. Đầu tiên, phương pháp pipe:Đây là một link khác mô tả công dụng của pipe.Piping không phải là một hàm trong base R. Để sử dụng piping, package magrittr phải được cài đặt và gọi ra trong phiên làm việc hiện tại (điều này thường được thực hiện bằng cách gọi package tidyverse hoặc dplyr). Bạn có thể đọc thêm về piping trong tài liệu magrittr.Lưu ý rằng cũng giống như các lệnh R khác, các pipes có thể được sử dụng để hiển thị kết quả hoặc lưu/lưu lại một đối tượng, tùy thuộc vào toán tử <- được code như thế nào. Xem hai ví dụ dưới đây:%<>%Đây là một “assignment pipe (pipe dùng để gán)” từ package magrittr, package này sẽ pipe một đối tượng theo chiều tiến lên và cũng tái định nghĩa lại đối tượng. Đối tượng cần đứng đầu trong chuỗi pipe. Nó nhanh hơn sử dụng pipe thông thường. Hai lệnh dưới đây là tương đương với nhau:","code":"\n# A fake example of how to bake a cake using piping syntax\n\ncake <- flour %>%       # to define cake, start with flour, and then...\n  add(eggs) %>%   # add eggs\n  add(oil) %>%    # add oil\n  add(water) %>%  # add water\n  mix_together(         # mix together\n    utensil = spoon,\n    minutes = 2) %>%    \n  bake(degrees = 350,   # bake\n       system = \"fahrenheit\",\n       minutes = 35) %>%  \n  let_cool()            # let it cool down\n# Create or overwrite object, defining as aggregate counts by age category (not printed)\nlinelist_summary <- linelist %>% \n  count(age_cat)\n# Print the table of counts in the console, but don't save it\nlinelist %>% \n  count(age_cat)##   age_cat    n\n## 1     0-4 1095\n## 2     5-9 1095\n## 3   10-14  941\n## 4   15-19  743\n## 5   20-29 1073\n## 6   30-49  754\n## 7   50-69   95\n## 8     70+    6\n## 9    <NA>   86\nlinelist <- linelist %>%\n  filter(age > 50)\n\nlinelist %<>% filter(age > 50)"},{"path":"basics.html","id":"định-nghĩa-đối-tượng-trung-gian","chapter":"3 R Cơ bản","heading":"Định nghĩa đối tượng trung gian","text":"Cách tiếp cận này dùng để thay đổi đối tượng/dataframes sẽ phát huy hiệu quả nếu:Bạn cần thao tác trên nhiều đối tượngCác bước trung gian có ý nghĩa cụ thể và xứng đáng tạo các tên đối tượng riêng biệtCác nguy cơ:Tạo đối tượng mới cho mỗi bước có nghĩa là bạn sẽ tạo thêm rất nhiều đối tượng. Nếu bạn sử dụng không cẩn thận, bạn có thể dễ dàng bị nhầm lẫn!Đặt thêm nhiều tên cho nhiều đối tượng có thể gây nhầm lẫnNếu có lỗi thì không dễ để phát hiệnĐặt tên cho từng đối tượng trung gian hoặc ghi đè lên đối tượng gốc hoặc kết hợp tất cả hàm với nhau đều đi kèm với những rủi ro.Dưới đây vẫn là ví dụ mô phỏng quy trình làm “bánh” tương tự như trên, nhưng sử dụng phong cách này:Kết hợp tất cả các hàm với nhau - câu lệnh rất khó đọc:","code":"\n# a fake example of how to bake a cake using this method (defining intermediate objects)\nbatter_1 <- left_join(flour, eggs)\nbatter_2 <- left_join(batter_1, oil)\nbatter_3 <- left_join(batter_2, water)\n\nbatter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)\n\ncake <- bake(batter_4, degrees = 350, system = \"fahrenheit\", minutes = 35)\n\ncake <- let_cool(cake)\n# an example of combining/nesting mutliple functions together - difficult to read\ncake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = \"fahrenheit\", minutes = 35))"},{"path":"basics.html","id":"operators","chapter":"3 R Cơ bản","heading":"3.12 Các toán tử và hàm chính","text":"Mục này sẽ trình bày chi tiết các toán tử trong R, chẳng hạn như :Toán tử định nghĩaToán tử quan hệ (nhỏ hơn, bằng nhau..)Toán tử logic (và, hoặc..)Xử lý missingCác toán tử và hàm toán học (+/-, >, sum(), median(), …)Toán tử %%","code":""},{"path":"basics.html","id":"toán-tử-gán","chapter":"3 R Cơ bản","heading":"Toán tử gán","text":"<-Toán tử gán cơ bản trong R là <-. Chẳng hạn như object_name <- value.\nToán tử gán này cũng có thể được viết là =. Chúng tôi khuyên bạn nên sử dụng <-.\nBạn nên sử dụng dấu cách trong khi viết code với toán tử gán để dễ đọc hơn.<<-Khi Viết hàm, hoặc khi sử dụng R với scipt nguồn, thì bạn có thể cần sử dụng toán tử gán này <<- (từ base R). Toán tử này được sử dụng để định nghĩa một đối tượng trong một hàm lồng trong một hàm khác. Xem thêm tại nguồn tham khảo online này.%<>%Đây là một “pipe gán” từ package magrittr, package này sẽ gán một đối tượng theo chiều tiến lên và cũng định nghĩa lại đối tượng. Pipe gán phải là toán tử đầu tiên trong chuỗi pipe code. Đây là cách viết ngắn gọn, như được trình bày dưới đây là hai ví dụ tương đương với nhau:Đoạn code bên trên tương đương với code dưới đây:%<+%Toán tử này được sử dụng dể thêm dữ liệu vào Cây phả hệ với package ggtree. Xem thêm chương Cây phả hệ hoặc Sách online này.","code":"\nlinelist <- linelist %>% \n  mutate(age_months = age_years * 12)\nlinelist %<>% mutate(age_months = age_years * 12)"},{"path":"basics.html","id":"toán-tử-quan-hệ-và-logic","chapter":"3 R Cơ bản","heading":"Toán tử quan hệ và logic","text":"Toán tử quan hệ sánh các giá trị và thường được sử dụng khi định nghĩa các biến mới và tập con của bộ dữ liệu. Dưới đây là các toán tử quan hệ phổ biến trong R:Các toán tử logic, chẳng hạn như và , thường được sử dụng để kết nối các quan hệ và tạo ra các điều kiện phức tạp hơn. Các biểu thức phức tạp có thể yêu cầu dấu ngoặc đơn () để phân nhóm và thứ tự áp dụng.Ví dụ: chúng ta có một số liệu có tên linelist với hai biến mà chúng tôi muốn sử dụng để minh họa, hep_e_rdt: kết quả xét nghiệm và other_cases_in_hh: những trường hợp khác trong gia đình. Lệnh dưới đây sử dụng hàm case_when() để tạo biến mới case_def như sau:Lưu ý rằng R có phân biệt chữ hoa chữ thường, vì vậy “Positive” khác với “positive”…","code":"\nlinelist_cleaned <- linelist %>%\n  mutate(case_def = case_when(\n    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,\n    rdt_result == \"Positive\"                                 ~ \"Confirmed\",\n    rdt_result != \"Positive\" & other_cases_in_home == \"Yes\"  ~ \"Probable\",\n    TRUE                                                     ~ \"Suspected\"\n  ))"},{"path":"basics.html","id":"giá-trị-missing","chapter":"3 R Cơ bản","heading":"Giá trị Missing","text":"Trong R, giá trị missing được biểu diễn bằng giá trị đặc biệt NA (giá trị “dành riêng cho missing”) (chữ N và viết hoa - không nằm trong dấu ngoặc kép). Nếu dữ liệu bạn nhập vào R bị missing theo cách khác (ví dụ: 99, “Missing”, .), bạn có thể sẽ cần phải mã hóa lại các giá trị đó thành NA. Cách thực hiện việc này được đề cập trong chương Nhập xuất dữ liệu.Để kiểm tra xem một giá trị có phải là NA hay không, sử dụng hàm đặc biệt .na(), kết quả sẽ trả về TRUE hoặc FALSE.Đọc thêm về missing, vô hạn, NULL, và các giá trị không thể trong chương Dữ liệu Missing. Tìm hiểu thêm cách chuyển đổi các giá trị bị missing khi nhập dữ liệu trong chương Nhập xuất dữ liệu.","code":"\nrdt_result <- c(\"Positive\", \"Suspected\", \"Positive\", NA)   # two positive cases, one suspected, and one unknown\nis.na(rdt_result)  # Tests whether the value of rdt_result is NA## [1] FALSE FALSE FALSE  TRUE"},{"path":"basics.html","id":"toán-học-và-thống-kê","chapter":"3 R Cơ bản","heading":"Toán học và thống kê","text":"Tất cả các toán tử và hàm trong chương này đều có sẵn bằng cách sử dụng base R.","code":""},{"path":"basics.html","id":"toán-tử-toán-học","chapter":"3 R Cơ bản","heading":"Toán tử toán học","text":"Chúng thường được sử dụng để thực hiện phép cộng, phép chia, để tạo cột mới, v.v. Dưới đây là các toán tử toán học phổ biến trong R. Việc bạn có đặt dấu cách xung quanh các toán tử hay không là không quan trọng.","code":""},{"path":"basics.html","id":"các-hàm-toán-học","chapter":"3 R Cơ bản","heading":"Các hàm toán học","text":"lưu ý: sử dụng hàm round() và digits = để xác định số chữ số thập phân được hiển thị. Sử dụng hàm signif() để làm tròn đến số chữ số nhất định.","code":""},{"path":"basics.html","id":"ký-hiệu-khoa-học","chapter":"3 R Cơ bản","heading":"Ký hiệu khoa học","text":"Khả năng ký hiệu khoa học được sử dụng phụ thuộc vào giá trị của scipen.Từ tài liệu hướng dẫn của ?options: scipen được áp dụng khi quyết định các giá trị số theo ký hiệu cố định hoặc hàm mũ. Giá trị dương thuộc về ký hiệu cố định còn giá trị âm thuộc về ký hiệu khoa học: ký hiệu cố định sẽ luôn được ưu tiên trừ khi có nhiều chữ số ‘scipen’.Nếu như có rất nhiều số bé cần hiển thị (vd: số 0), mặc định tính năng này sẽ “được bật”. Để “tắt” tính năng ký hiệu khoa học trong phiên làm việc của bạn, hãy thiết lập nó với một số rất lớn, ví dụ:","code":"\n# turn off scientific notation\noptions(scipen=999)"},{"path":"basics.html","id":"làm-tròn","chapter":"3 R Cơ bản","heading":"Làm tròn","text":"NGUY HIỂM: Hàm round() sử dụng “cách làm tròn của ngân hàng” nghĩa là chỉ làm tròn với số .5 nếu số được làm tròn lên là số chẵn. Sử dụng hàm round_half_up() từ package janitor để thống nhất cách làm tròn với giá trị .5. Xem thêm giải thích sau đây","code":"\n# use the appropriate rounding function for your work\nround(c(2.5, 3.5))## [1] 2 4\njanitor::round_half_up(c(2.5, 3.5))## [1] 3 4"},{"path":"basics.html","id":"các-hàm-thống-kê","chapter":"3 R Cơ bản","heading":"Các hàm thống kê","text":"CẨN TRỌNG: Các hàm sau đây sẽ mặc định bao gồm cả giá trị missing khi tính toán. Giá trị missing sẽ trả về kết quả đầu ra chứa NA, trừ khi đối số na.rm = TRUE được xác định khi viết hàm. Nó cũng có thể viết ngắn gọn thành na.rm = T.Notes:*quantile(): x là vectơ số cần khảo sát, và probs = là một vectơ số với các xác suất nằm giữa 0 và 1.0, ví dụ c(0.5, 0.8, 0.85)**summary(): trả về tóm tắt một vectơ số bao gồm giá trị trung bình, trung vị, và các khoảng phân vị thường gặpNGUY HIỂM: Nếu cung cấp một vectơ số cho một trong các hàm trên, hãy đảm bảo các số được đặt trong hàm c() .","code":"\n# If supplying raw numbers to a function, wrap them in c()\nmean(1, 6, 12, 10, 5, 0)    # !!! INCORRECT !!!  ## [1] 1\nmean(c(1, 6, 12, 10, 5, 0)) # CORRECT## [1] 5.666667"},{"path":"basics.html","id":"một-số-hàm-hữu-ích-khác","chapter":"3 R Cơ bản","heading":"Một số hàm hữu ích khác","text":"","code":""},{"path":"basics.html","id":"in","chapter":"3 R Cơ bản","heading":"%in%","text":"Một toán tử rất hữu ích để nhanh chóng đánh giá xem một giá trị có nằm trong một vectơ hoặc một dataframe hay không.Để truy vấn một giá trị không %% một vectơ, hãy đặt dấu chấm (!) phía trước biểu thức logic:%% sẽ rất hữu dụng khi dùng hàm case_when() của package dplyr. Bạn có thể định nghĩa một vectơ trước đó, sau đó tham chiếu đến nó. ví dụ:Lưu ý: Nếu bạn muốn phát hiện một phần của chuỗi, có lẽ việc sử dụng hàm str_detect() từ package stringr, sẽ không chấp nhận một vectơ ký tự kiểu như c(\"1\", \"Yes\", \"yes\", \"y\"). Thay vào đó, nó cần được cung cấp dưới dạng một biểu thức chính quy - một chuối cô đọng với thanh dọc cho phép sánh , chẳng hạn như “1|Yes|yes|y”. Ví dụ, str_detect(hospitalized, \"1|Yes|yes|y\"). Xem thêm chương Ký tự và chuỗi để biết thêm chi tiết.Bạn có thể chuyển đổi một vectơ ký tự thành một biểu thức chính quy được đặt tên bằng lệnh này:","code":"\nmy_vector <- c(\"a\", \"b\", \"c\", \"d\")\n\"a\" %in% my_vector## [1] TRUE\n\"h\" %in% my_vector## [1] FALSE\n# to negate, put an exclamation in front\n!\"a\" %in% my_vector## [1] FALSE\n!\"h\" %in% my_vector## [1] TRUE\naffirmative <- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\n\nlinelist <- linelist %>% \n  mutate(child_hospitaled = case_when(\n    hospitalized %in% affirmative & age < 18 ~ \"Hospitalized Child\",\n    TRUE                                      ~ \"Not\"))\naffirmative <- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\naffirmative## [1] \"1\"   \"Yes\" \"YES\" \"yes\" \"y\"   \"Y\"   \"oui\" \"Oui\" \"Si\"\n# condense to \naffirmative_str_search <- paste0(affirmative, collapse = \"|\")  # option with base R\naffirmative_str_search <- str_c(affirmative, collapse = \"|\")   # option with stringr package\n\naffirmative_str_search## [1] \"1|Yes|YES|yes|y|Y|oui|Oui|Si\""},{"path":"basics.html","id":"lỗi-và-cảnh-báo","chapter":"3 R Cơ bản","heading":"3.13 Lỗi và cảnh báo","text":"Phần này giải thích:Sự khác biệt giữa lỗi và cảnh báoMẹo cú pháp chung để viết code RTrợ giúp viết codeCác lỗi thường gặp và cảnh báo cũng như mẹo khắc phục sự cố có thể được tìm thấy trong chương Các lỗi thường gặp.","code":""},{"path":"basics.html","id":"lỗi-và-cảnh-báo-1","chapter":"3 R Cơ bản","heading":"Lỗi và Cảnh báo","text":"Khi một lệnh được thực thi, cửa sổ R Console có thể hiển thị cho bạn cảnh báo hoặc thông báo lỗi bằng văn bản màu đỏ.Một cảnh báo nghĩa là R đã hoàn thành lệnh của bạn, nhưng phải thực hiện các bước bổ sung hoặc tạo ra kết quả bất thường mà bạn cần lưu ý.Một cảnh báo nghĩa là R đã hoàn thành lệnh của bạn, nhưng phải thực hiện các bước bổ sung hoặc tạo ra kết quả bất thường mà bạn cần lưu ý.Một lỗi nghĩa là R không thể hoàn thành lệnh của bạn.Một lỗi nghĩa là R không thể hoàn thành lệnh của bạn.Tìm manh mối:Thông báo lỗi/cảnh báo thường sẽ bao gồm số dòng xảy ra sự cố.Thông báo lỗi/cảnh báo thường sẽ bao gồm số dòng xảy ra sự cố.Nếu một đối tượng “không xác định được (unknown)” hoặc “không tìm thấy (found)”, có lẽ bạn đã viết sai chính tả, quên gọi một package bằng hàm library(), hoặc quên chạy lại tập lệnh của bạn sau khi thực hiện các thay đổi.Nếu một đối tượng “không xác định được (unknown)” hoặc “không tìm thấy (found)”, có lẽ bạn đã viết sai chính tả, quên gọi một package bằng hàm library(), hoặc quên chạy lại tập lệnh của bạn sau khi thực hiện các thay đổi.Nếu vẫn thất bại, hãy sao chép thông báo lỗi vào Google cùng với một số từ khóa chính - rất có thể ai đó cũng đã gặp lỗi này rồi!","code":""},{"path":"basics.html","id":"mẹo-cú-pháp-chung","chapter":"3 R Cơ bản","heading":"Mẹo cú pháp chung","text":"Một số điều cần nhớ khi viết lệnh trong R, để tránh lỗi và cảnh báo:Luôn đóng dấu ngoặc đơn - mẹo: đếm số lần mở dấu ngoặc đơn “(” và đóng dấu ngoặc đơn “)” cho mỗi đoạn mãTránh để khoảng trắng trong tên cột và đối tượng. Thay vào đó, hãy sử dụng dấu gạch dưới (_) hoặc dấu chấm (.)Theo dõi và nhớ tách các đối số của hàm bằng dấu phẩyR phân biệt chữ hoa và chữ thường, nghĩa là Variable_A khác với variable_A","code":""},{"path":"basics.html","id":"trợ-giúp-viết-code","chapter":"3 R Cơ bản","heading":"Trợ giúp viết code","text":"Bất kỳ tập lệnh nào (RMarkdown hoặc những cái khác) sẽ cung cấp manh mối khi bạn mắc lỗi. Ví dụ: nếu bạn quên viết dấu phẩy ở vị trí cần thiết hoặc quên đóng dấu ngoặc đơn, RStudio sẽ treo cờ trên dòng đó, ở phía bên trái của script, để cảnh báo bạn.","code":""},{"path":"transition-to-R.html","id":"transition-to-R","chapter":"4 Chuyển đổi sang R","heading":"4 Chuyển đổi sang R","text":"Dưới đây, chúng tôi cung cấp một số lời khuyên và tài nguyên nếu bạn đang chuyển đổi sang R.R được giới thiệu vào cuối những năm 1990 và kể từ đó đã phát triển quy mô mạnh mẽ. Khả năng của nó rộng đến mức các lựa chọn thương mại thay thế đã phản ứng với sự phát triển của R để duy trì tính cạnh tranh! (đọc bài viết sánh R, SPSS, SAS, STATA và Python).Hơn thế nữa, R đã dễ học hơn nhiều với 10 năm trước. Trước đây, R nổi tiếng là khó sử dụng cho những người mới bắt đầu. Giờ đây việc này trở nên dễ dàng hơn nhiều với giao diện người dùng thân thiện như RStudio, code trực quan như tidyverse và có nhiều tài nguyên hướng dẫn.Đừng ngần ngại - hãy đến khám phá thế giới của R!","code":""},{"path":"transition-to-R.html","id":"từ-excel","chapter":"4 Chuyển đổi sang R","heading":"4.1 Từ Excel","text":"Chuyển đổi từ Excel trực tiếp sang R hoàn toàn là mục tiêu có thể đạt được. Nó dường như có vẻ khó khăn, nhưng bạn có thể làm được!Sự thật là một người có kỹ năng Excel tốt có thể thực hiện các thao tác nâng cao chỉ trong Excel - ngay cả khi sử dụng các công cụ tạo script như VBA. Excel được sử dụng trên toàn thế giới và là một công cụ cần thiết cho một nhà dịch tễ học. Tuy nhiên, kết hợp nó với R có thể cải thiện và mở rộng đáng kể quy trình công việc của bạn.","code":""},{"path":"transition-to-R.html","id":"lợi-ích","chapter":"4 Chuyển đổi sang R","heading":"Lợi ích","text":"Bạn sẽ thấy rằng việc sử dụng R mang lại những lợi ích lớn trong việc tiết kiệm thời gian, giúp phân tích nhất quán và chính xác hơn, có khả năng tái lập, khả năng chia sẻ và sửa lỗi nhanh hơn. Giống như bất kỳ phần mềm mới nào, bạn phải đầu tư một “đường cong” thời gian học tập để trở nên quen thuộc. Bạn sẽ được mở ra những kĩ năng mới trên một phạm vi rộng đáng kể với R.Excel là một phần mềm phổ biến mà người dùng mới bắt đầu có thể dễ dàng sử dụng để tạo ra các phân tích và sơ đồ hóa đơn giản với các thao tác “trỏ và nhấp”. Trong khi đó, có thể mất vài tuần để trở nên quen thuộc với các chức năng và giao diện của R. Tuy nhiên, R đã phát triển trong những năm gần đây để trở nên thân thiện hơn với người mới bắt đầu.Nhiều quy trình làm việc của Excel phụ thuộc vào trí nhớ và sự lặp lại - đó, có nhiều khả năng xảy ra lỗi. Hơn nữa, nhìn chung, việc làm sạch dữ liệu, phương pháp phân tích và các phương trình được sử dụng đều bị ẩn đi trong trang tính. Có thể cần đến một khoảng thời gian đáng kể để những người mới bắt đầu hiểu trang tính Excel đang làm gì và cách khắc phục sự cố. Với R, tất cả các bước được viết rõ ràng trong script và có thể dễ dàng xem, chỉnh sửa, sửa lỗi và áp dụng cho các bộ dữ liệu khác.Để bắt đầu chuyển đổi từ Excel sang R, bạn phải điều chỉnh tư duy của mình theo một số hướng quan trọng:","code":""},{"path":"transition-to-R.html","id":"tidy-data","chapter":"4 Chuyển đổi sang R","heading":"Tidy data","text":"Sử dụng “tidy” data để máy có thể đọc được thay vì dữ liệu lộn xộn “con người có thể đọc được”. Dưới đây là ba yêu cầu chính đối với “tidy” data”, đã được giải thích trong hướng dẫn này về “tidy” data trong R:Mỗi biến số nằm trên một cộtMỗi quan sát phải nằm trên một hàngMỗi giá trị phải có ô riêngĐối với người dùng Excel - hãy nghĩ đến vai trò của “bảng” Excel trong việc chuẩn hóa dữ liệu và làm cho định dạng trở nên dễ đoán hơn.Một ví dụ về “tidy” data là trường hợp bộ dữ liệu linelist được sử dụng trong cuốn sổ tay này - mỗi biến được chứa trong một cột, mỗi quan sát (mỗi trường hợp) có hàng riêng và mọi giá trị chỉ nằm trong một ô. Dưới đây, bạn có thể xem 50 hàng đầu tiên của bộ dữ liệu linelist:Nguyên nhân chính khiến người dùng gặp phải tình trạng non-tidy data là nhiều bảng tính Excel được thiết kế để ưu tiên con người dễ đọc chứ không phải máy móc/phần mềm dễ đọc.Để giúp bạn thấy sự khác biệt, dưới đây là một số ví dụ mô phỏng về non-tidy data mà ưu tiên khả năng đọc của con người hơn khả năng đọc của máy:Vấn đề: Trong bảng tính ở trên, một số ô đã được ghép với nhau - khiến chúng trở nên khó đọc bởi R. Hàng nào nên được coi là “tiêu đề” không rõ ràng. Từ điển dựa trên màu sắc nằm ở phía bên phải và các giá trị ô được biểu thị bằng màu sắc - điều này cũng không dễ dàng được giải thích bởi R (cũng như những người bị mù màu!). Hơn nữa, các phần thông tin khác nhau được kết hợp thành một ô (nhiều tổ chức đối tác hoạt động trong cùng một khu hoặc trạng thái “TBC” trong cùng ô với “Partner D”).Vấn đề: Trong bảng tính ở trên, có rất nhiều hàng và cột trống trong bộ dữ liệu - điều này sẽ gây phiền toái khi làm sạch trong R. Hơn nữa, tọa độ GPS được trải rộng trên hai hàng cho một trung tâm điều trị nhất định. Một lưu ý nhỏ - tọa độ GPS có hai định dạng khác nhau!Các bộ dữ liệu “tidy” có thể không đọc được bằng mắt người, nhưng chúng giúp việc làm sạch và phân tích dữ liệu dễ dàng hơn rất nhiều! Tidy data có thể được lưu trữ ở nhiều định dạng khác nhau, chẳng hạn như dạng “dọc” hoặc “ngang”“(xem chương về Xoay trục dữ liệu), tuy nhiên các nguyên tắc trên vẫn được tuân thủ.","code":""},{"path":"transition-to-R.html","id":"hàm","chapter":"4 Chuyển đổi sang R","heading":"Hàm","text":"Từ “hàm (function)” trong R có thể mới, nhưng khái niệm này cũng tồn tại trong Excel dưới dạng công thức (formulas). Công thức trong Excel cũng yêu cầu cú pháp chính xác (ví dụ: vị trí của dấu chấm phẩy và dấu ngoặc đơn). Tất cả những gì bạn cần làm là tìm hiểu một vài hàm mới và cách chúng hoạt động cùng nhau trong R.","code":""},{"path":"transition-to-R.html","id":"script","chapter":"4 Chuyển đổi sang R","heading":"Script","text":"Thay vì nhấp vào các biểu tượng và kéo các ô, bạn sẽ viết mọi bước và quy trình thành một “script”. Người dùng Excel có thể quen thuộc với “VBA macros”, thứ mà cũng sử dụng cách tiếp cận script.R script bao gồm các hướng dẫn từng bước. Điều này cho phép bất kỳ đồng nghiệp nào cũng có thể đọc script và dễ dàng xem các bước bạn đã thực hiện. Điều này cũng giúp loại bỏ lỗi hoặc các tính toán không chính xác. Xem phần R cơ bản về script để có thêm các ví dụ.Dưới đây là một ví dụ của một R script:","code":""},{"path":"transition-to-R.html","id":"tài-liệu-liên-quan-đến-chuyển-đổi-từ-excel-sang-r","chapter":"4 Chuyển đổi sang R","heading":"Tài liệu liên quan đến chuyển đổi từ Excel-sang-R","text":"Dưới đây là một vài đường link hướng dẫn giúp bạn chuyển đổi sang R từ Excel:R vs. ExcelCác khóa RStudio trong R cho người dùng Excel","code":""},{"path":"transition-to-R.html","id":"tương-tác-giữa-r-và-excel","chapter":"4 Chuyển đổi sang R","heading":"Tương tác giữa R và Excel","text":"R có khả năng mạnh trong việc nhập các Excel workbook, làm việc với dữ liệu, xuất/lưu tệp Excel và làm việc với các sắc thái của các trang tính Excel.Đúng là một số định dạng Excel có tính thẩm mỹ hơn có thể bị mất trong quá trình chuyển đổi (ví dụ: chữ nghiêng, chữ nằm ngang, v.v.). Nếu quy trình công việc của bạn yêu cầu chuyển tài liệu qua lại giữa R và Excel trong khi vẫn giữ nguyên định dạng Excel ban đầu, hãy thử các package như openxlsx.","code":""},{"path":"transition-to-R.html","id":"từ-stata","chapter":"4 Chuyển đổi sang R","heading":"4.2 Từ Stata","text":"Chuyển đến R từ StataNhiều nhà dịch tễ học được dạy cách sử dụng Stata ngay từ đầu, và có vẻ khó khăn khi chuyển sang R. Tuy nhiên, nếu bạn là một người dùng quen Stata thì việc chuyển sang R chắc chắn sẽ dễ quản lý hơn bạn nghĩ. Mặc dù có một số khác biệt chính giữa Stata và R về cách tạo và sửa đổi dữ liệu, cũng như cách triển khai các chức năng phân tích – sau khi tìm hiểu những khác biệt chính này, bạn sẽ có thể chuyển đổi các kỹ năng của mình.Dưới đây là một số cách chuyển đổi chính giữa Stata và R, điều mà có thể hữu ích khi bạn xem lại hướng dẫn này.Những lưu ý chungThư mục làm việcNhập và xem dữ liệuThao tác dữ liệu cơ bảnPhân tích mô tảMặc dù danh sách này cung cấp một cái nhìn tổng quan về những điều cơ bản trong việc chuyển các lệnh Stata sang R, nhưng nó vẫn chưa đầy đủ. Bạn có thể quan tâm tới nhiều nguồn tài nguyên tuyệt vời khác dành cho người dùng Stata chuyển sang R:https://dss.princeton.edu/training/RStata.pdfhttps://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.htmlhttp://r4stats.com/books/r4stata/","code":""},{"path":"transition-to-R.html","id":"từ-sas","chapter":"4 Chuyển đổi sang R","heading":"4.3 Từ SAS","text":"Chuyển từ SAS sang RSAS thường được sử dụng tại các cơ quan y tế công cộng và các lĩnh vực nghiên cứu học thuật. Mặc dù chuyển đổi sang một ngôn ngữ mới hiếm khi là một quá trình đơn giản, nhưng hiểu được những điểm khác biệt chính giữa SAS và R có thể giúp bạn bắt đầu chuyển hướng ngôn ngữ mới bằng ngôn ngữ mẹ đẻ của mình. Dưới đây là phác thảo các bước chuyển đổi chính trong quản lý dữ liệu và phân tích mô tả giữa SAS và R.Những lưu ý chungThư mục làm việcNhập và xem dữ liệuThao tác dữ liệu cơ bảnPhân tích mô tảMột số tài nguyên hữu ích:R SAS SPSS Users (2011)SAS R, Second Edition (2014)","code":""},{"path":"transition-to-R.html","id":"khả-năng-tương-tác-dữ-liệu","chapter":"4 Chuyển đổi sang R","heading":"4.4 Khả năng tương tác dữ liệu","text":"Xem chương Nhập xuất dữ liệu để biết chi tiết về cách R package rio có thể nhập và xuất các file như file STATA .dta, file SAS .xpt và .sas7bdat, file SPSS .por và .sav và nhiều file khác.","code":""},{"path":"packages-suggested.html","id":"packages-suggested","chapter":"5 Package đề xuất","heading":"5 Package đề xuất","text":"Dưới đây là danh sách các package được đề xuất dành cho các công việc dịch tễ học phổ biến trong R. Bạn có thể sao chép code này, chạy nó và tất cả các package này sẽ cài đặt từ CRAN và tải để sử dụng trong phiên làm việc hiện tại. Nếu một package đã được cài đặt, nó sẽ chỉ được gọi ra để sử dụng.Bạn có thể sửa đổi code với ký hiệu # để loại bỏ bất kỳ packages nào bạn không muốn.Chú ý:Đầu tiên, cần cài đặt package pacman trước khi chạy đoạn code dưới đây. Bạn có thể thực hiện việc này với lệnh install.packages(\"pacman\"). Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, sẽ có thể vừa cài đặt package nếu cần và gọi chúng ra để sử dụng trong phiên làm việc. Bạn cũng có thể gọi package đã được cài đặt với lệnh library() từ base R.Trong đoạn code dưới đây, các packages được bao gồm khi cài đặt/gọi thông qua một package khác được trình bày bằng cách thụt lề và dấu thăng. Ví dụ: ggplot2 được liệt kê bên dưới tidyverse.Nếu nhiều package có các hàm cùng tên, việc đè lên nhau đè lên nhau có thể xảy ra khi hàm từ package được gọi ra sau sẽ được ưu tiên hơn. Đọc thêm trong chương R cơ bản. Cân nhắc sử dụng package conflicted để quản lý các xung đột tương tự.Xem chương R cơ bản mục packages để biết thêm về pacman và ghi đè.Để xem các phiên bản của R, RStudio và R packages được sử dụng trong quá trình viết cuốn sổ tay này, xem chương Biên tập và ghi chú kỹ thuật.","code":""},{"path":"packages-suggested.html","id":"packages-từ-cran","chapter":"5 Package đề xuất","heading":"5.1 Packages từ CRAN","text":"","code":"\n##########################################\n# List of useful epidemiology R packages #\n##########################################\n\n# This script uses the p_load() function from pacman R package, \n# which installs if package is absent, and loads for use if already installed\n\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Packages available from CRAN\n##############################\npacman::p_load(\n     \n     # learning R\n     ############\n     learnr,   # interactive tutorials in RStudio Tutorial pane\n     swirl,    # interactive tutorials in R console\n        \n     # project and file management\n     #############################\n     here,     # file paths relative to R project root folder\n     rio,      # import/export of many types of data\n     openxlsx, # import/export of multi-sheet Excel workbooks \n     \n     # package install and management\n     ################################\n     pacman,   # package install/load\n     renv,     # managing versions of packages when working in collaborative groups\n     remotes,  # install from github\n     \n     # General data management\n     #########################\n     tidyverse,    # includes many packages for tidy data wrangling and presentation\n          #dplyr,      # data management\n          #tidyr,      # data management\n          #ggplot2,    # data visualization\n          #stringr,    # work with strings and characters\n          #forcats,    # work with factors \n          #lubridate,  # work with dates\n          #purrr       # iteration and working with lists\n     linelist,     # cleaning linelists\n     naniar,       # assessing missing data\n     \n     # statistics  \n     ############\n     janitor,      # tables and data cleaning\n     gtsummary,    # making descriptive and statistical tables\n     rstatix,      # quickly run statistical tests and summaries\n     broom,        # tidy up results from regressions\n     lmtest,       # likelihood-ratio tests\n     easystats,\n          # parameters, # alternative to tidy up results from regressions\n          # see,        # alternative to visualise forest plots \n     \n     # epidemic modeling\n     ###################\n     epicontacts,  # Analysing transmission networks\n     EpiNow2,      # Rt estimation\n     EpiEstim,     # Rt estimation\n     projections,  # Incidence projections\n     incidence2,   # Make epicurves and handle incidence data\n     i2extras,     # Extra functions for the incidence2 package\n     epitrix,      # Useful epi functions\n     distcrete,    # Discrete delay distributions\n     \n     \n     # plots - general\n     #################\n     #ggplot2,         # included in tidyverse\n     cowplot,          # combining plots  \n     # patchwork,      # combining plots (alternative)     \n     RColorBrewer,     # color scales\n     ggnewscale,       # to add additional layers of color schemes\n\n     \n     # plots - specific types\n     ########################\n     DiagrammeR,       # diagrams using DOT language\n     incidence2,       # epidemic curves\n     gghighlight,      # highlight a subset\n     ggrepel,          # smart labels\n     plotly,           # interactive graphics\n     gganimate,        # animated graphics \n\n     \n     # gis\n     ######\n     sf,               # to manage spatial data using a Simple Feature format\n     tmap,             # to produce simple maps, works for both interactive and static maps\n     OpenStreetMap,    # to add OSM basemap in ggplot map\n     spdep,            # spatial statistics \n     \n     # routine reports\n     #################\n     rmarkdown,        # produce PDFs, Word Documents, Powerpoints, and HTML files\n     reportfactory,    # auto-organization of R Markdown outputs\n     officer,          # powerpoints\n     \n     # dashboards\n     ############\n     flexdashboard,    # convert an R Markdown script into a dashboard\n     shiny,            # interactive web apps\n     \n     # tables for presentation\n     #########################\n     knitr,            # R Markdown report generation and html tables\n     flextable,        # HTML tables\n     #DT,              # HTML tables (alternative)\n     #gt,              # HTML tables (alternative)\n     #huxtable,        # HTML tables (alternative) \n     \n     # phylogenetics\n     ###############\n     ggtree,           # visualization and annotation of trees\n     ape,              # analysis of phylogenetics and evolution\n     treeio            # to visualize phylogenetic files\n \n)"},{"path":"packages-suggested.html","id":"packages-từ-github","chapter":"5 Package đề xuất","heading":"5.2 Packages từ Github","text":"Dưới đây là các lệnh giúp cài đặt trực tiếp packages từ kho lưu trữ trên Github.Phiên bản phát triển của epicontacts có khả năng tạo cây lây nhiễm với trục x tạm thờiPackage epirhandbook chứa tất cả các dữ liệu minh họa cho sổ tay này và có thể được sử dụng để tải xuống phiên bản ngoại tuyến của sổ tay.","code":"\n# Packages to download from Github (not available on CRAN)\n##########################################################\n\n# Development version of epicontacts (for transmission chains with a time x-axis)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n# The package for this handbook, which includes all the example data  \npacman::p_install_gh(\"appliedepi/epirhandbook\")"},{"path":"r-projects.html","id":"r-projects","chapter":"6 Dự án R","heading":"6 Dự án R","text":"Một dự án R cho phép công việc của bạn được đóng gói trong một thư mục khép kín. Trong dự án, tất cả các tập lệnh, tệp dữ liệu, biểu đồ/kết quả đầu ra và lịch sử có liên quan được lưu trữ trong các thư mục con và quan trọng là - thư mục làm việc là thư mục gốc của dự án.","code":""},{"path":"r-projects.html","id":"gợi-ý-sử-dụng","chapter":"6 Dự án R","heading":"6.1 Gợi ý sử dụng","text":"Một cách phổ biến, hiệu quả và ít rắc rối để sử dụng R là sự kết hợp của 3 thành tố này. Mỗi dự án công việc cụ thể sẽ được lưu trữ trong một dự án R. Từng thành tố được mô tả như dưới đây.Một Dự án R\nMột môi trường làm việc khép kín với các thư mục bao gồm dữ liệu, tập lệnh, các kết quả đầu ra, v.v.\nMột môi trường làm việc khép kín với các thư mục bao gồm dữ liệu, tập lệnh, các kết quả đầu ra, v.v.Package dành cho các đường dẫn tương đối\nĐường dẫn tệp được ghi một cách tương đối dẫn đến thư mục gốc của dự án R - xem chương Nhập xuất dữ liệu để biết thêm chi tiết\nĐường dẫn tệp được ghi một cách tương đối dẫn đến thư mục gốc của dự án R - xem chương Nhập xuất dữ liệu để biết thêm chi tiếtPackage rio để nhập/xuất\nimport() và export() giúp giải quyết tất cả các tệp với phần mở rộng khác nhau (ví dụ: .csv, .xlsx, .png)\nimport() và export() giúp giải quyết tất cả các tệp với phần mở rộng khác nhau (ví dụ: .csv, .xlsx, .png)","code":""},{"path":"r-projects.html","id":"tạo-một-dự-án-r","chapter":"6 Dự án R","heading":"6.2 Tạo một dự án R","text":"Để tạo một dự án R, hãy chọn “New Project” từ menu File.Nếu bạn muốn tạo một thư mục mới cho dự án, hãy chọn “New directory” và cho biết nơi bạn muốn nó được tạo.Nếu bạn muốn tạo dự án trong một thư mục có sẵn, hãy chọn “Existing directory” và trỏ tới đường dẫn thư mục đó.Nếu bạn muốn tạo một bản sao từ kho lưu trữ Github, hãy chọn tùy chọn thứ ba “Version Control” và sau đó chọn “Git”. Xem chương Version control với Git và Github để biết thêm chi tiết.Dự án R bạn tạo ra sẽ có dạng một thư mục chứa tệp .Rproj. Tệp này có thể đóng vai trò là một lối tắt mà bạn sẽ mở dự án của mình. Bạn cũng có thể mở một dự án bằng cách chọn “Open Project” từ menu File. Ngoài ra, ở phía trên bên phải trên của RStudio, bạn sẽ thấy biểu tượng dự án R và menu thả xuống gồm các dự án R có sẵn.Để thoát khỏi một dự án R, hãy mở một dự án mới hoặc đóng dự án (File - Close Project).","code":""},{"path":"r-projects.html","id":"di-chuyển-giữa-các-dự-án","chapter":"6 Dự án R","heading":"Di chuyển giữa các dự án","text":"Để di chuyển giữa các dự án, hãy bấm vào biểu tượng dự án R và menu thả xuống ở phía trên cùng bên phải của RStudio. Bạn sẽ thấy các tùy chọn Close Project, Open Project và danh sách các dự án gần đây.","code":""},{"path":"r-projects.html","id":"thiết-lập","chapter":"6 Dự án R","heading":"Thiết lập","text":"Thông thường, mỗi khi bạn khởi động RStudio nên là một “clean slate - khởi đầu mới” - nghĩa là với không gian làm việc hiện tại không được giữ nguyên với phiên làm việc trước đó. Điều này có nghĩa là các đối tượng và kết quả của bạn sẽ không tồn tại giữa các phiên làm việc (bạn phải tạo lại chúng bằng cách chạy lại scripts của mình). Điều này là tốt, vì nó sẽ buộc bạn phải viết các đoạn code tốt hơn và tránh được lỗi về lâu dài.Để thiết lập RStudio có một “khởi đầu mới” mỗi khi khởi động:Chọn “Project Options” từ menu Tools.Trong tab “General”, thiết lập RStudio không khôi phục .RData vào môi trường làm việc của bạn mỗi khi khởi động, và cũng không lưu môi trường làm việc vào tệp .RData khi kết thúc.","code":""},{"path":"r-projects.html","id":"tổ-chức","chapter":"6 Dự án R","heading":"Tổ chức","text":"Thông thường sẽ có các thư mục con trong dự án của bạn. Hãy cân nhắc đặt tên các thư mục như “data”, “scripts”, “figures”, “presentations”. Bạn có thể thêm các thư mục theo cách thông thường mà bạn sẽ thêm một thư mục mới cho máy tính của mình. Ngoài ra, hãy xem chương Tương tác với thư mục làm việc để tìm hiểu cách tạo thư mục mới bằng lệnh R.","code":""},{"path":"r-projects.html","id":"kiểm-soát-phiên-bản","chapter":"6 Dự án R","heading":"Kiểm soát phiên bản","text":"Hãy cân nhắc sử dụng một hệ thống kiểm soát phiên bản. Nó có thể là một cái gì đó đơn giản như có ngày tháng trên tên của các scripts (ví dụ: “transmission_analysis_2020-10-03.R”) và một thư mục “lưu trữ”. Bạn cũng có thể thêm các đoạn văn bản tiêu đề nhận xét ở đầu mỗi scripts bao gồm các thông tin như mô tả, thẻ, tác giả và nhật ký thay đổi.Một phương pháp phức tạp hơn đó là việc sử dụng Github hoặc một nền tảng tương tự để kiểm soát phiên bản. Xem chương Version control với Git và Github.Một mẹo là bạn có thể tìm kiếm trong toàn bộ dự án hoặc thư mục bằng cách sử dụng công cụ “Find Files” (Edit menu)). Công cụ này có thể tìm kiếm và thậm chí thay thế các chuỗi trên nhiều tệp.","code":""},{"path":"r-projects.html","id":"các-ví-dụ","chapter":"6 Dự án R","heading":"6.3 Các ví dụ","text":"Dưới đây là một vài ví dụ về cách nhập/xuất/lưu trữ sử dụng lệnh () within R projct. bên trong một dự án R. Đọc thêm về package trong chương Nhập xuất dữ liệu.Nhập linelist_raw.xlsx từ thư mục “data” trong dự án R của bạnXuất đối tượng linelist thành tệp “my_linelist.rds” vào thư mục “clean” nằm trong thư mục “data” trong dự án R của bạn.Lưu biểu đồ được gần đây nhất thành tệp “epicurve_2021-02-15.png” nằm trong thư mục “epicurves” của thư mục “outputs” trong dự án R của bạn.","code":"\nlinelist <- import(here(\"data\", \"linelist_raw.xlsx\"))\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.rds\"))\nggsave(here(\"outputs\", \"epicurves\", \"epicurve_2021-02-15.png\"))"},{"path":"r-projects.html","id":"nguồn","chapter":"6 Dự án R","heading":"6.4 Nguồn","text":"Trang web của RStudio về việc sử dụng các dự án R","code":""},{"path":"importing.html","id":"importing","chapter":"7 Nhập xuất dữ liệu","heading":"7 Nhập xuất dữ liệu","text":"Trong chương này, chúng tôi mô tả các cách để định vị, nhập và xuất tệp:Sử dụng package rio để import() và export() linh hoạt nhiều loại tệpSử dụng package rio để import() và export() linh hoạt nhiều loại tệpSử dụng package để định vị tệp liên quan đến dự án R gốc - để ngăn ngừa sự phức tạp nhiều đường dẫn tệp chỉ dành riêng cho một máy tínhSử dụng package để định vị tệp liên quan đến dự án R gốc - để ngăn ngừa sự phức tạp nhiều đường dẫn tệp chỉ dành riêng cho một máy tínhCác tình huống nhập dữ liệu thường gặp:\nTừ một Trang tính Excel\nCó tiêu đề sắp xếp lộn xộn và cần bỏ qua một số hàng\nTừ trang tính của Google\nTừ dữ liệu được đăng lên các trang web\nVới APIs\nNhập tệp gần đây nhất\nCác tình huống nhập dữ liệu thường gặp:Từ một Trang tính ExcelCó tiêu đề sắp xếp lộn xộn và cần bỏ qua một số hàngTừ trang tính của GoogleTừ dữ liệu được đăng lên các trang webVới APIsNhập tệp gần đây nhấtNhập dữ liệu thủ côngNhập dữ liệu thủ côngCác loại tệp R đặc trưng ví dụ như RDS và RDataCác loại tệp R đặc trưng ví dụ như RDS và RDataXuất/lưu tệp và biểu đồXuất/lưu tệp và biểu đồ","code":""},{"path":"importing.html","id":"tổng-quan","chapter":"7 Nhập xuất dữ liệu","heading":"7.1 Tổng quan","text":"Khi bạn nhập một “dataset (bộ dữ liệu)” vào R, bạn thường cần tạo ra một đối tượng data frame mới trong môi trường R và định nghĩa nó là tệp được nhập (ví dụ: Excel, CSV, TSV, RDS), từ trong các thư mục của bạn tại một đường dẫn/địa chỉ tệp nhất định.Bạn có thể nhập/xuất nhiều loại tệp, bao gồm cả những tệp được tạo bởi các chương trình thống kê khác (SAS, STATA, SPSS). Bạn cũng có thể kết nối với các cơ sở dữ liệu liên quan.R thậm chí còn có các định dạng dữ liệu riêng:Một tệp RDS (.rds) lưu trữ một đối tượng R đơn lẻ, chẳng hạn như một data frame. Chúng hữu ích trong việc lưu trữ dữ liệu đã được làm sạch, vì chúng giữ lại kiểu dữ liệu cho các cột R. Đọc thêm trong mục này.Một tệp RData (.Rdata) có thể được sử dụng để lưu trữ nhiều đối tượng hoặc thậm chí là một không gian làm việc trong R hoàn chỉnh. Đọc thêm trong mục này.","code":""},{"path":"importing.html","id":"package-rio","chapter":"7 Nhập xuất dữ liệu","heading":"7.2 Package rio","text":"Package R chúng tôi gợi ý là: rio. Tên “rio” là chữ viết tắt của “R /O” (dữ liệu đầu vào (input)/kết quả đầu ra (output)).Hàm import() và export() có thể xử lý nhiều loại tệp khác nhau (ví dụ: .xlsx, .csv, .rds, .tsv). Khi bạn cung cấp đường dẫn tệp đến một trong các hàm này (bao gồm cả đuôi file mở rộng như “.csv”), rio sẽ đọc phần mở rộng và sử dụng đúng công cụ để nhập hoặc xuất tệp.Giải pháp thay thế cho việc sử dụng rio là sử dụng các hàm từ nhiều package khác, mỗi package cụ thể cho một loại tệp. Ví dụ như, read.csv() (base R), read.xlsx() (package openxlsx) và write_csv() (package readr), v.v… Những lựa chọn thay thế này có thể khó nhớ, trong khi sử dụng import() và export() từ rio rất dễ dàng.Các hàm import() và export() của rio sử dụng package và lệnh phù hợp cho một tệp nhất định, dựa trên phần mở rộng của tệp đó. Xem phần cuối của chương này để xem bảng đầy đủ về các package/hàm rio sử dụng trong nền. Hàm này cũng có thể được sử dụng để nhập các tệp STATA, SAS và SPSS trong hàng tá các loại tệp khác.Nhập/xuất shapefiles đòi hỏi sử dụng các package khác, được mô tả cụ thể trong chương GIS cơ bản.","code":""},{"path":"importing.html","id":"here","chapter":"7 Nhập xuất dữ liệu","heading":"7.3 Package here","text":"Package và hàm () của nó giúp R dễ dàng biết nơi tìm và lưu tệp của bạn - về bản chất, nó xây dựng đường dẫn tệp.Được sử dụng cùng với dự án R, cho phép bạn mô tả vị trí các tệp trong dự án R của bạn trong thư mục gốc (root directory) của dự án R (thư mục cấp cao nhất). Điều này hữu ích khi dự án R có thể được chia sẻ hoặc truy cập bởi nhiều người dùng/máy tính. Package này ngăn ngừa sự phức tạp các đường dẫn tệp là duy nhất trên các máy tính khác nhau (ví dụ: \"C:/Users/Laura/Documents...\") bằng cách “khởi động (starting)” đường dẫn tệp ở thư mục chung cho tất cả người dùng (dự án R gốc).Đây là cách () làm việc trong một dự án R:Khi package được tải lần đầu tiên trong dự án R, nó đặt một tệp nhỏ có tên là “.” trong thư mục gốc dự án R của bạn như là một “điểm chuẩn” hoặc “mỏ neo”Trong script của bạn, để tham chiếu một tệp trong các thư mục con của dự án R, bạn sử dụng hàm () để tạo đường dẫn tệp liên quan đến thư mục gốc (anchor)Để tạo đường dẫn tệp, viết tên các thư mục bên ngoài thư mục gốc, trong dấu ngoặc kép, được phân tách bằng dấu phẩy, cuối cùng kết thúc bằng tên và phần mở rộng của tệp như được trình bày dưới đâyCác đường dẫn tệp () có thể được sử dụng cả để nhập và xuất dữ liệuVí dụ, dưới đây, một đường dẫn tệp được tạo bởi hàm () đang được cung cấp cho hàm import()Lệnh (\"data\", \"linelists\", \"ebola_linelist.xlsx\") trên thực tế đang cung cấp đường dẫn tệp đầy đủ mà là duy nhất cho máy tính của người dùng:Ưu điểm là lệnh () được R sử dụng có thể chạy thành công trên bất kỳ máy tính nào truy cập vào dự án R.MẸO: Nếu bạn không chắc gốc “.” được đặt ở đâu, hãy chạy lệnh () với dấu ngoặc đơn trống.Đọc thêm về package tại đường dẫn này.","code":"\nlinelist <- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx\""},{"path":"importing.html","id":"đường-dẫn-tệp","chapter":"7 Nhập xuất dữ liệu","heading":"7.4 Đường dẫn tệp","text":"Khi nhập hoặc xuất dữ liệu, bạn phải cung cấp một đường dẫn tệp. Bạn có thể thực hiện thao tác này bằng một trong ba cách sau:Khuyên dùng: cung cấp một đường dẫn tệp “tương đối” bằng package hereCung cấp đường dẫn tệp “đầy đủ” / “tuyệt đối”Chọn tệp theo cách thủ công","code":""},{"path":"importing.html","id":"đường-dẫn-tệp-tương-đối","chapter":"7 Nhập xuất dữ liệu","heading":"Đường dẫn tệp “tương đối”","text":"Trong R, đường dẫn tệp “tương đối” bao gồm đường dẫn tệp mà liên quan đến phần gốc của dự án R. Chúng cho phép nhiều đường dẫn tệp đơn giản hơn có thể làm việc trên nhiều máy tính khác nhau (ví dụ: nếu dự án R nằm trên bộ nhớ dùng chung hoặc được gửi qua thư điện tử). Như đã được mô tả ở trên, đường dẫn tệp tương đối được tạo ra dễ dàng bằng cách sử dụng package .Dưới đây là một ví dụ về đường dẫn tệp tương đối được tạo bằng package (). Chúng tôi giả sử công việc nằm trong một dự án R có chứa một thư mục con “data” và bên trong nó là thư mục con “linelists”, trong đó có tệp .xlsx được quan tâm.","code":"\nlinelist <- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))"},{"path":"importing.html","id":"đường-dẫn-tệp-tuyệt-đối","chapter":"7 Nhập xuất dữ liệu","heading":"Đường dẫn tệp “tuyệt đối”","text":"Đường dẫn tệp tuyệt đối hay “đầy đủ” có thể được cung cấp cho các hàm như import() nhưng chúng “dễ đứt gãy” bởi vì chúng là duy nhất đối với các máy tính của những người dùng khác nhau, và đó không được khuyến khích sử dụng.Dưới đây là một ví dụ về đường dẫn tệp tuyệt đối, trong máy tính của Laura có một thư mục “analysis”, tiếp theo là thư mục con “data” và bên trong là thư mục con “linelists”, trong đó có tệp .xlsx được quan tâm.Một vài điều cần lưu ý về đường dẫn tệp tuyệt đối:Tránh sử dụng đường dẫn tệp tuyệt đối vì chúng sẽ bị đứt gãy nếu script được chạy trên một máy tính khácSử dụng dấu gạch chéo tiến (/), như trong ví dụ trên (lưu ý: đây KHÔNG phải là kiểu mặc định đối với đường dẫn tệp trong Windows)Đường dẫn tệp bắt đầu với hai dấu gạch chéo (ví dụ: “//…”) sẽ có khả năng không được R nhận ra và tạo ra lỗi. Hãy cân nhắc chuyển công việc của bạn sang ổ đĩa “có tên” hoặc “có chữ” bắt đầu bằng một chữ cái (ví dụ: “J:” hoặc “C:”). Xem chương về Tương tác với thư mục làm việc để biết thêm chi tiết về vấn đề này.Một tình huống mà đường dẫn tệp tuyệt đối có thể thích hợp là khi bạn muốn nhập một tệp từ bộ nhớ dùng chung có cùng đường dẫn tệp đầy đủ cho tất cả người dùng.MẸO: Để nhanh chóng chuyển đổi tất cả \\ thành /, hãy bôi đen đoạn code cần chuyển, sử dụng Ctrl + F (trong Windows) và tích vào tùy chọn “selection”, sau đó sử dụng chức năng thay thế (replace) để chuyển đổi chúng.","code":"\nlinelist <- import(\"C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx\")"},{"path":"importing.html","id":"chọn-tệp-theo-cách-thủ-công","chapter":"7 Nhập xuất dữ liệu","heading":"Chọn tệp theo cách thủ công","text":"Bạn có thể nhập dữ liệu theo cách thủ công thông qua một trong các phương pháp sau:Từ cửa sổ Environment trong RStudio, nhấp vào “Import Dataset” và chọn loại dữ liệuNhấp vào File / Import Dataset / (chọn loại dữ liệu)Để lựa chọn thủ công bằng code, hãy sử dụng lệnh file.choose() trong base R (để trống dấu ngoặc đơn) để kích hoạt sự xuất hiện của một cửa sổ pop-cho phép người dùng chọn tệp theo cách thủ công từ máy tính của họ. Ví dụ:MẸO: Cửa sổ pop-có thể xuất hiện SAU cửa sổ RStudio của bạn.","code":"\n# Manual selection of a file. When this command is run, a POP-UP window will appear. \n# The file path selected will be supplied to the import() command.\n\nmy_data <- import(file.choose())"},{"path":"importing.html","id":"nhập-dữ-liệu","chapter":"7 Nhập xuất dữ liệu","heading":"7.5 Nhập dữ liệu","text":"Sử dụng lệnh import() để nhập một bộ dữ liệu khá đơn giản. Chỉ cần cung cấp đường dẫn của tệp (bao gồm tên và phần mở rộng của tệp) trong dấu ngoặc kép. Nếu sử dụng hàm () để xây dựng đường dẫn tệp, hãy làm theo hướng dẫn ở bên trên. Dưới đây là một vài ví dụ:Nhập một tệp csv nằm trong “thư mục làm việc (working directory)” của bạn hoặc trong thư mục gốc của dự án R:Nhập sheet đầu tiên của Excel workbook, được đặt trong thư mục con “data” và “linelists” của dự án R (đường dẫn tệp được tạo bằng hàm ()):Nhập một data frame (một tệp .rds ) sử dụng đường dẫn tệp tuyệt đối:","code":"\nlinelist <- import(\"linelist_cleaned.csv\")\nlinelist <- import(here(\"data\", \"linelists\", \"linelist_cleaned.xlsx\"))\nlinelist <- import(\"C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds\")"},{"path":"importing.html","id":"trang-tính-excel-cụ-thể","chapter":"7 Nhập xuất dữ liệu","heading":"Trang tính Excel cụ thể","text":"Theo mặc định, nếu bạn cung cấp một Excel workbook (.xlsx) để nhập bằng hàm import(), trang tính đầu tiên của workbook sẽ được nhập. Nếu bạn muốn nhập một trang tính cụ thể, hãy cụ thể tên trang tính vào đối số =. Ví dụ:Nếu sử dụng hàm () để cung cấp một đường dẫn tương đối đến hàm import(), bạn vẫn có thể chỉ ra một trang tính cụ thể bằng cách thêm đối số = sau dấu đóng ngoặc của hàm ().Để xuất một data frame từ R sang một trang tính Excel và phần còn lại của Excel workbook không thay đổi, bạn sẽ phải nhập, chỉnh sửa và xuất với một package thay thế chuyên biệt cho mục đích này, chẳng hạn như openxlsx. Xem thêm thông tin trong chương về Tương tác với thư mục làm việc hoặc tại trang github này.Nếu Excel workbook của bạn có phần mở rộng là .xlsb (định dạng nhị phân của Excel workbook) bạn có thể sẽ không nhập được bằng package rio. Hãy cân nhắc lưu lại tệp dưới dạng .xlsx hoặc sử dụng một package như readxlsb, là package được xây dựng cho kiểu tệp này.","code":"\nmy_data <- import(\"my_excel_file.xlsx\", which = \"Sheetname\")# Demonstration: importing a specific Excel sheet when using relative pathways with the 'here' package\nlinelist_raw <- import(here(\"data\", \"linelist.xlsx\"), which = \"Sheet1\")`  "},{"path":"importing.html","id":"import_missing","chapter":"7 Nhập xuất dữ liệu","heading":"Giá trị missing","text":"Bạn có thể muốn xác định (các) giá trị nào trong bộ dữ liệu của mình nên được coi là missing. Như đã giải thích trong chương về Dữ liệu missing, giá trị cho dữ liệu missing trong R là NA, nhưng có thể bộ dữ liệu bạn muốn nhập vào sử dụng giá trị 99, “Missing” hoặc chỉ là khoảng trống ký tự ““.Sử dụng đối số na = để (nhập) import() và cung cấp (các) giá trị trong dấu ngoặc kép (ngay cả khi chúng là các số). Bạn có thể chỉ định nhiều giá trị bằng cách gộp chúng trong một vectơ, bằng cách sử dụng c() như được trình bày dưới đây.Tại đây, giá trị “99” trong bộ dữ liệu đã nhập được coi là missing và được chuyển đổi thành NA trong R.Còn ở đây, bất kỳ giá trị nào là “Missing”, “” (ô trống) hoặc ” ” (khoảng trắng) trong bộ dữ liệu đã nhập đều được chuyển đổi thành NA trong R.","code":"\nlinelist <- import(here(\"data\", \"my_linelist.xlsx\"), na = \"99\")\nlinelist <- import(here(\"data\", \"my_linelist.csv\"), na = c(\"Missing\", \"\", \" \"))"},{"path":"importing.html","id":"bỏ-qua-một-số-hàng","chapter":"7 Nhập xuất dữ liệu","heading":"Bỏ qua một số hàng","text":"Đôi khi, bạn có thể không muốn nhập một hàng dữ liệu. Bạn có thể thực hiện thao tác này với đối số skip = nếu sử dụng hàm import() từ package rio trên tệp .xlsx hoặc .csv. Cung cấp số hàng bạn muốn bỏ qua.Không may là hàm skip = chỉ chấp nhận một giá trị số nguyên, không chấp nhận một khoảng (ví dụ: “2:10” sẽ không hoạt động). Để bỏ qua việc nhập các hàng cụ thể không liên tiếp từ trên cùng, hãy cân nhắc nhập nhiều lần và sử dụng hàm bind_rows() từ dplyr. Hãy xem ví dụ dưới đây về việc chỉ bỏ qua hàng thứ 2.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\", skip = 1)  # does not import header row"},{"path":"importing.html","id":"quản-lý-hàng-tiêu-đề-thứ-hai","chapter":"7 Nhập xuất dữ liệu","heading":"Quản lý hàng tiêu đề thứ hai","text":"Đôi khi, dữ liệu của bạn có thể có hàng thứ hai, với chức năng như là “từ điển dữ liệu” như hình dưới đây. Trường hợp này có thể xảy ra vấn đề vì nó có thể dẫn đến việc tất cả các cột được nhập vào dưới dạng kiểu “ký tự (character)”.Dưới đây là một ví dụ về kiểu bộ dữ liệu này (với hàng đầu tiên là từ điển dữ liệu).","code":""},{"path":"importing.html","id":"xóa-hàng-tiêu-đề-thứ-hai","chapter":"7 Nhập xuất dữ liệu","heading":"Xóa hàng tiêu đề thứ hai","text":"Để bỏ hàng tiêu đề thứ hai, bạn có thể sẽ cần nhập dữ liệu hai lần.Nhập dữ liệu vào để lấy tên các cột chính xácNhập lại dữ liệu, bỏ qua hai hàng đầu tiên (hàng tiêu đề và hàng thứ hai)Liên kết dataframe đã xóa bỏ 2 hàng đầu tiên với tên cột chính xác ở bước 1Đối số chính xác được sử dụng để liên kết các tên cột tùy thuộc vào loại tệp dữ liệu (.csv, .tsv, .xlsx, v.v.). Điều này là rio sử dụng các hàm khác nhau cho các loại tệp khác nhau (xem bảng ở trên).Đối với tệp Excel: (col_names =)Đối với tệp CSV: (col.names =)Tùy chọn sao lưu - thay đổi tên cột dưới dạng một lệnh riêng biệt","code":"\n# import first time; store the column names\nlinelist_raw_names <- import(\"linelist_raw.xlsx\") %>% names()  # save true column names\n\n# import second time; skip row 2, and assign column names to argument col_names =\nlinelist_raw <- import(\"linelist_raw.xlsx\",\n                       skip = 2,\n                       col_names = linelist_raw_names\n                       ) \n# import first time; sotre column names\nlinelist_raw_names <- import(\"linelist_raw.csv\") %>% names() # save true column names\n\n# note argument for csv files is 'col.names = '\nlinelist_raw <- import(\"linelist_raw.csv\",\n                       skip = 2,\n                       col.names = linelist_raw_names\n                       ) \n# assign/overwrite headers using the base 'colnames()' function\ncolnames(linelist_raw) <- linelist_raw_names"},{"path":"importing.html","id":"tạo-từ-điển-dữ-liệu","chapter":"7 Nhập xuất dữ liệu","heading":"Tạo từ điển dữ liệu","text":"Thông tin thêm! Nếu bạn có hàng thứ hai là từ điển dữ liệu, bạn có thể dễ dàng tạo từ điển dữ liệu thích hợp từ nó. Mẹo này được tham khảo từ bài đăng này.","code":"\ndict <- linelist_2headers %>%             # begin: linelist with dictionary as first row\n  head(1) %>%                             # keep only column names and first dictionary row                \n  pivot_longer(cols = everything(),       # pivot all columns to long format\n               names_to = \"Column\",       # assign new column names\n               values_to = \"Description\")"},{"path":"importing.html","id":"kết-hợp-hai-hàng-tiêu-đề","chapter":"7 Nhập xuất dữ liệu","heading":"Kết hợp hai hàng tiêu đề","text":"Trong một số trường hợp khi bộ dữ liệu thô của bạn có hai hàng tiêu đề (hoặc cụ thể hơn, hàng dữ liệu thứ 2 là tiêu đề phụ), bạn có thể sẽ muốn “kết hợp” chúng hoặc thêm các giá trị trong hàng tiêu đề thứ hai vào hàng tiêu đề đầu tiên.Lệnh dưới đây sẽ xác định tên cột của data frame là sự kết hợp (dán với nhau) của các tiêu đề (đúng) đầu tiên với giá trị ngay bên dưới (trong hàng đầu tiên).","code":"\nnames(my_data) <- paste(names(my_data), my_data[1, ], sep = \"_\")"},{"path":"importing.html","id":"trang-tính-google","chapter":"7 Nhập xuất dữ liệu","heading":"Trang tính Google","text":"Bạn có thể nhập dữ liệu từ một trang tính Google trực tuyến với package googlesheet4 và bằng cách xác thực quyền truy cập của bạn vào trang tính.Dưới đây là một trang tính Google minh họa được nhập và lưu. Lệnh này có thể yêu cầu xác thực tài khoản Google của bạn. Làm theo lời nhắc và cửa sổ bật lên trong trình duyệt Internet của bạn để cấp cho các package Tidyverse API quyền chỉnh sửa, tạo và xóa trang tính của bạn trong Google Drive.Trang tính dưới đây “có thể được xem bởi bất kỳ ai có liên kết” và bạn có thể thử nhập trang tính đó.Trang tính cũng có thể được nhập chỉ bằng ID của sheet, một phần ngắn hơn của URL:Một package khác, googledrive cung cấp các hàm hữu ích để viết, chỉnh sửa và xóa các trang tính Google. Ví dụ: các hàm được sử dụng gs4_create() và sheet_write() đều được tìm thấy trong package này.Dưới đây là một số hướng dẫn trực tuyến hữu ích khác:hướng dẫn nhập Google sheet cơ bảnhướng dẫn chi tiết hơntương tác giữa googlesheets4 và tidyverse","code":"\npacman::p_load(\"googlesheets4\")\nGsheets_demo <- read_sheet(\"https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0\")\nGsheets_demo <- read_sheet(\"1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY\")"},{"path":"importing.html","id":"nhập-xuất-tách-kết-hợp---nhiều-tệp","chapter":"7 Nhập xuất dữ liệu","heading":"7.6 Nhập, xuất, tách, kết hợp - nhiều tệp","text":"Xem chương về Lặp, vòng lặp, và danh sách để biết ví dụ về cách nhập và kết hợp nhiều tệp hoặc nhiều Excel workbook. Chương này cũng có các ví dụ về cách chia một data frame thành các phần và xuất từng phần riêng biệt hoặc dưới dạng các trang tính được đặt tên trong một Excel workbook.","code":""},{"path":"importing.html","id":"import_github","chapter":"7 Nhập xuất dữ liệu","heading":"7.7 Nhập từ Github","text":"Nhập dữ liệu trực tiếp từ Github vào R có thể rất dễ dàng hoặc có thể yêu cầu một vài bước - tùy thuộc vào loại tệp. Dưới đây là một số cách tiếp cận:","code":""},{"path":"importing.html","id":"tệp-csv","chapter":"7 Nhập xuất dữ liệu","heading":"Tệp CSV","text":"Có thể dễ dàng nhập tệp .csv trực tiếp từ Github vào R bằng lệnh R.Đi tới repo Github, tìm tệp quan tâm và nhấp vào tệp đóNhấp vào nút “Raw” (sau đó bạn sẽ thấy dữ liệu csv “thô”, như được hiển thị bên dưới)Sao chép URL (địa chỉ web)Đặt URL trong dấu ngoặc kép trong lệnh R import()","code":""},{"path":"importing.html","id":"tệp-xlsx","chapter":"7 Nhập xuất dữ liệu","heading":"Tệp XLSX","text":"Bạn có thể không xem được dữ liệu “Thô” cho một số tệp (ví dụ: .xlsx, .rds, .nwk, .shp)Đi tới repo Github, tìm tệp quan tâm và nhấp vào tệp đóNhấp vào nút “Download”, như được hiển thị bên dướiLưu tệp trên máy tính của bạn và nhập tệp đó vào R","code":""},{"path":"importing.html","id":"shapefiles","chapter":"7 Nhập xuất dữ liệu","heading":"Shapefiles","text":"Các Shapefiles có nhiều tệp thành phần phụ, mỗi tệp có một phần mở rộng khác nhau. Một tệp sẽ có phần mở rộng “.shp”, nhưng những tệp khác có thể là “.dbf”, “.prj”, v.v. Để tải xuống shapefiles từ Github, bạn sẽ cần tải xuống từng tệp thành phần phụ riêng lẻ và lưu chúng trong cùng một thư mục trên máy tính của bạn. Trong Github, nhấp vào từng tệp riêng lẻ và tải chúng xuống bằng cách nhấp vào nút “Download”.Một khi được lưu vào máy tính, bạn có thể nhập định dạng tệp như được trình bày trong chương GIS cơ bản bằng cách sử dụng hàm st_read() từ package sf. Bạn chỉ cần cung cấp đường dẫn tệp và tên của tệp “.shp” - miễn là các tệp liên quan khác nằm trong cùng một thư mục trên máy tính của bạn.Dưới đây, bạn có thể thấy shapefiles tên “sl_adm3” bao gồm nhiều tệp như thế nào - mỗi tệp phải được tải xuống từ Github.","code":""},{"path":"importing.html","id":"nhập-dữ-liệu-thủ-công","chapter":"7 Nhập xuất dữ liệu","heading":"7.8 Nhập dữ liệu thủ công","text":"","code":""},{"path":"importing.html","id":"nhập-theo-hàng","chapter":"7 Nhập xuất dữ liệu","heading":"Nhập theo hàng","text":"Sử dụng hàm tribble của package tibble từ tidyverse (tài liệu tham khảo trực tuyến).Lưu ý cách tiêu đề cột bắt đầu bằng dấu ngã (~). Cũng lưu ý rằng mỗi cột chỉ được chứa một nhóm dữ liệu (ký tự, số, v.v.). Bạn có thể sử dụng các tab, khoảng cách và hàng mới để làm cho việc nhập dữ liệu trực quan và dễ đọc hơn. Khoảng trắng không quan trọng giữa các giá trị, nhưng mỗi hàng được biểu thị bằng một dòng code mới. Ví dụ:Và giờ chúng ta hiển thị bộ dữ liệu mới:","code":"\n# create the dataset manually by row\nmanual_entry_rows <- tibble::tribble(\n  ~colA, ~colB,\n  \"a\",   1,\n  \"b\",   2,\n  \"c\",   3\n  )"},{"path":"importing.html","id":"nhập-theo-cột","chapter":"7 Nhập xuất dữ liệu","heading":"Nhập theo cột","text":"Vì data frame bao gồm các vectơ (cột dọc), cách tiếp cận cơ bản để tạo data frame thủ công trong R yêu cầu bạn phải tạo từng cột và sau đó liên kết chúng lại với nhau. Điều này có thể phản trực quan trong dịch tễ học, vì chúng ta thường nghĩ về dữ liệu của mình theo hàng (như trên).CHÚ Ý: Tất cả các vectơ phải có cùng độ dài (cùng số giá trị).Các vectơ sau đó có thể được liên kết với nhau bằng cách sử dụng lệnh data.frame():Và giờ chúng ta hiển thị bộ dữ liệu mới:","code":"\n# define each vector (vertical column) separately, each with its own name\nPatientID <- c(235, 452, 778, 111)\nTreatment <- c(\"Yes\", \"No\", \"Yes\", \"Yes\")\nDeath     <- c(1, 0, 1, 0)\n# combine the columns into a data frame, by referencing the vector names\nmanual_entry_cols <- data.frame(PatientID, Treatment, Death)"},{"path":"importing.html","id":"dán-từ-clipboard","chapter":"7 Nhập xuất dữ liệu","heading":"Dán từ clipboard","text":"Nếu bạn sao chép dữ liệu từ nơi khác và có nó trong clipboard (bộ nhớ tạm), bạn có thể thử một trong hai cách dưới đây:Từ package clipr, bạn có thể sử dụng hàm read_clip_tbl() để nhập dưới dạng data frame hoặc chỉ cần hàm read_clip() để nhập dưới dạng một vectơ ký tự. Trong cả hai trường hợp, hãy để trống dấu ngoặc đơn.Bạn cũng có thể dễ dàng xuất sang clipboard của hệ thống bằng clipr. Xem mục bên dưới về Xuất dữ liệu.Ngoài ra, bạn có thể sử dụng lệnh read.table() từ base R với file = \"clipboard\") để nhập dưới dạng data frame:","code":"\nlinelist <- clipr::read_clip_tbl()  # imports current clipboard as data frame\nlinelist <- clipr::read_clip()      # imports as character vector\ndf_from_clipboard <- read.table(\n  file = \"clipboard\",  # specify this as \"clipboard\"\n  sep = \"t\",           # separator could be tab, or commas, etc.\n  header=TRUE)         # if there is a header row"},{"path":"importing.html","id":"nhập-tệp-gần-đây-nhất","chapter":"7 Nhập xuất dữ liệu","heading":"7.9 Nhập tệp gần đây nhất","text":"Thường thì bạn có thể nhận được các bản cập nhật hàng ngày cho bộ dữ liệu của mình. Trong trường hợp này, bạn sẽ muốn viết code mà nhập tệp gần đây nhất. Dưới đây, chúng tôi trình bày hai cách để tiếp cận điều này:Chọn tệp dựa trên ngày trong tên tệpChọn tệp dựa trên metadata (siêu dữ liệu - là dạng dữ liệu mô tả thông tin chi tiết về dữ liệu) của tệp (lần sửa đổi cuối cùng)","code":""},{"path":"importing.html","id":"ngày-trong-tên-tệp","chapter":"7 Nhập xuất dữ liệu","heading":"Ngày trong tên tệp","text":"Cách tiếp cận này dựa trên ba cơ sở:Bạn tin tưởng ngày tháng trong tên tệpNgày tháng ở dạng số và thường xuất hiện ở cùng một định dạng (ví dụ: năm rồi tháng rồi ngày)Không có số nào khác trong tên tệpChúng tôi sẽ giải thích từng bước và sau đó cho bạn thấy cách chúng được kết hợp ở phần cuối.Đầu tiên, sử dụng dir() từ base R để chỉ trích xuất tên tệp cho mỗi tệp trong thư mục quan tâm. Xem chương về Tương tác với thư mục làm việc để biết thêm chi tiết về dir(). Trong ví dụ này, thư mục quan tâm là thư mục “linelists” trong thư mục “example” chứa trong thư mục “data” của dự án R.Một khi bạn có vectơ chứa các tên này, bạn có thể trích xuất ngày với chúng bằng cách áp dụng hàm str_extract() từ stringr với việc sử dụng biểu thức chính quy sau đây. Nó giúp trích xuất bất kỳ số nào trong tên tệp (bao gồm bất kỳ ký tự nào khác ở giữa như dấu gạch ngang hoặc dấu gạch chéo). Bạn có thể đọc thêm về stringr trong chương Ký tự và chuỗi.Giả sử ngày thường được viết theo cùng một định dạng ngày (ví dụ: Năm rồi Tháng rồi Ngày) và năm có 4 chữ số, bạn có thể sử dụng các hàm chuyển đổi linh hoạt của lubridate (ymd(), dmy(), mdy()) để chuyển đổi chúng thành ngày. Đối với các hàm này, dấu gạch ngang, dấu cách hoặc dấu gạch chéo không quan trọng, quan trọng chỉ là thứ tự của các số. Đọc thêm trong chương Làm việc với ngày tháng.Sau đó, hàm base R .max() có thể được sử dụng để trả về vị trí chỉ mục (ví dụ: 1, 2, 3,…) của giá trị ngày lớn nhất. Tệp mới nhất được xác định chính xác là tệp thứ 6 - “case_linelist_2020-10-08.xlsx”.Nếu chúng ta tổng hợp tất cả các lệnh này, code hoàn chỉnh có thể trông giống như bên dưới. Lưu ý rằng dấu . ở dòng cuối cùng thay thế cho đối tượng được truyền vào hàm trước đó. Tại thời điểm đó, giá trị chỉ đơn giản là số 6. Giá trị này được đặt trong dấu ngoặc kép để trích xuất phần tử thứ 6 của vectơ tên tệp được tạo bởi dir().Bây giờ bạn có thể sử dụng tên này để hoàn thiện đường dẫn tệp tương đối, với hàm ():Và bây giờ bạn có thể nhập tệp mới nhất:","code":"\nlinelist_filenames <- dir(here(\"data\", \"example\", \"linelists\")) # get file names from folder\nlinelist_filenames                                              # print## [1] \"20201007linelist.csv\"          \"case_linelist_2020-10-02.csv\"  \"case_linelist_2020-10-03.csv\"  \"case_linelist_2020-10-04.csv\"  \"case_linelist_2020-10-05.csv\" \n## [6] \"case_linelist_2020-10-08.xlsx\" \"case_linelist20201006.csv\"\nlinelist_dates_raw <- stringr::str_extract(linelist_filenames, \"[0-9].*[0-9]\") # extract numbers and any characters in between\nlinelist_dates_raw  # print## [1] \"20201007\"   \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\" \"2020-10-08\" \"20201006\"\nlinelist_dates_clean <- lubridate::ymd(linelist_dates_raw)\nlinelist_dates_clean## [1] \"2020-10-07\" \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\" \"2020-10-08\" \"2020-10-06\"\nindex_latest_file <- which.max(linelist_dates_clean)\nindex_latest_file## [1] 6\n# load packages\npacman::p_load(\n  tidyverse,         # data management\n  stringr,           # work with strings/characters\n  lubridate,         # work with dates\n  rio,               # import / export\n  here,              # relative file paths\n  fs)                # directory interactions\n\n# extract the file name of latest file\nlatest_file <- dir(here(\"data\", \"example\", \"linelists\")) %>%  # file names from \"linelists\" sub-folder          \n  str_extract(\"[0-9].*[0-9]\") %>%                  # pull out dates (numbers)\n  ymd() %>%                                        # convert numbers to dates (assuming year-month-day format)\n  which.max() %>%                                  # get index of max date (latest file)\n  dir(here(\"data\", \"example\", \"linelists\"))[[.]]              # return the filename of latest linelist\n\nlatest_file  # print name of latest file## [1] \"case_linelist_2020-10-08.xlsx\"\nhere(\"data\", \"example\", \"linelists\", latest_file) \n# import\nimport(here(\"data\", \"example\", \"linelists\", latest_file)) # import "},{"path":"importing.html","id":"sử-dụng-thông-tin-tệp","chapter":"7 Nhập xuất dữ liệu","heading":"Sử dụng thông tin tệp","text":"Nếu tệp của bạn không có ngày trong tên của chúng (hoặc bạn không tin tưởng vào những ngày đó), bạn có thể thử trích xuất ngày sửa đổi cuối cùng từ siêu dữ liệu tệp. Sử dụng các hàm từ package fs để kiểm tra thông tin siêu dữ liệu cho từng tệp, bao gồm thời gian sửa đổi cuối cùng và đường dẫn tệp.Dưới đây, chúng tôi cung cấp thư mục quan tâm tới hàm dir_info() của package fs. Trong trường hợp này, thư mục quan tâm nằm trong dự án R trong thư mục “data”, thư mục con “example” và thư mục con thư mục này “linelists”. Kết quả là một data frame với một dòng cho mỗi tệp và các cột cho modification_time, path, v.v. Bạn có thể xem ví dụ trực quan về điều này trong chương về Tương tác với thư mục làm việc.Chúng ta có thể sắp xếp data frame này của các tệp theo cột với modification_time, và sau đó chỉ giữ lại hàng trên cùng/mới nhất (tệp) với head()của base R. Sau đó, chúng ta có thể trích xuất đường dẫn tệp của tệp mới nhất này chỉ với hàm pull() của dplyr trên path cột. Cuối cùng, chúng ta có thể chuyển đường dẫn tệp này đến import(). Tệp đã nhập được lưu dưới dạng latest_file.","code":"\nlatest_file <- dir_info(here(\"data\", \"example\", \"linelists\")) %>%  # collect file info on all files in directory\n  arrange(desc(modification_time)) %>%      # sort by modification time\n  head(1) %>%                               # keep only the top (latest) file\n  pull(path) %>%                            # extract only the file path\n  import()                                  # import the file"},{"path":"importing.html","id":"import_api","chapter":"7 Nhập xuất dữ liệu","heading":"7.10 API","text":"Một “Giao diện lập trình tự động (Automated Programming Interface)” (API) có thể được sử dụng để yêu cầu trực tiếp dữ liệu từ một trang web. API là một tập hợp các quy tắc cho phép một ứng dụng phần mềm tương tác với một ứng dụng phần mềm khác. Khách hàng (bạn) gửi một “yêu cầu (request)” và nhận được một “phản hồi (response)” có chứa nội dung. Các package R httr và jsonlite có thể hỗ trợ quá trình này.Mỗi trang web hỗ trợ API sẽ có tài liệu và chi tiết cụ thể riêng để làm quen. Một số trang web công khai API và cho phép có thể được truy cập bởi bất kỳ ai. Những nền tảng khác, chẳng hạn như nền tảng có ID người dùng và thông tin đăng nhập, yêu cầu xác thực để truy cập dữ liệu của họ.Không cần phải nói, để nhập dữ liệu qua API thì cần phải có kết nối internet. Chúng tôi sẽ đưa ra các ví dụ ngắn gọn về việc sử dụng API để nhập dữ liệu và liên kết bạn với các tài nguyên khác.Lưu ý: Hãy nhớ lại rằng dữ liệu có thể được đăng trên một trang web không có API, điều này có thể dễ dàng truy xuất hơn. Ví dụ: một tệp CSV đã đăng có thể được truy cập chỉ bằng cách cung cấp URL của trang web để import() như được mô tả trong mục nhập từ Github.","code":""},{"path":"importing.html","id":"http-request","chapter":"7 Nhập xuất dữ liệu","heading":"HTTP request","text":"Trao đổi API thường được thực hiện thông qua một HTTP request. HTTP là Giao thức truyền siêu văn bản (Hypertext Transfer Protocol) và là định dạng cơ bản của giao thức yêu cầu (request)/phản hồi (response) giữa máy khách và máy chủ. Đầu vào và đầu ra chính xác có thể khác nhau tùy thuộc vào loại API nhưng quy trình là giống nhau - “Request” (thường là HTTP request) từ người dùng, thường chứa một truy vấn, theo sau là “Response”, chứa thông tin trạng thái về request và có thể là nội dung được yêu cầu.Dưới đây là một số thành phần của một HTTP request:URL của điểm cuối API“Method (Phương thức)” (hoặc “Verb (Động từ)”)Các tiêu đềPhần thânHTTP request “method” là hành động bạn muốn thực hiện. Hai phương thức HTTP phổ biến nhất là GET và POST nhưng những phương thức khác có thể bao gồm PUT, DELETE, PATCH, v.v. Khi nhập dữ liệu vào R, rất có thể bạn sẽ sử dụng GET.Sau request của bạn, máy tính của bạn sẽ nhận được “phản hồi” ở định dạng tương tự như những gì bạn đã gửi, bao gồm URL, trạng thái HTTP (Trạng thái 200 là thứ bạn muốn!), loại tệp, kích thước và nội dung mong muốn. Sau đó, bạn sẽ cần phân tích cú pháp phản hồi này và biến nó thành một data frame khả thi trong môi trường R của bạn.","code":""},{"path":"importing.html","id":"package","chapter":"7 Nhập xuất dữ liệu","heading":"Package","text":"Package httr hoạt động tốt để xử lý các yêu cầu HTTP trong R. Nó đòi hỏi ít kiến thức về API Web và có thể được sử dụng bởi những người ít quen thuộc với thuật ngữ phát triển phần mềm. Ngoài ra, nếu phản hồi HTTP là .json, bạn có thể sử dụng jsonlite để phân tích cú pháp phản hồi.","code":"\n# load packages\npacman::p_load(httr, jsonlite, tidyverse)"},{"path":"importing.html","id":"dữ-liệu-công-khai","chapter":"7 Nhập xuất dữ liệu","heading":"Dữ liệu công khai","text":"Dưới đây là một ví dụ về một HTTP request, được mượn từ một hướng dẫn từ Phòng thí nghiệm Dữ liệu Trafford. Trang web này chứa một số tài nguyên khác để tìm hiểu và các bài tập về API.Tình huống: Chúng ta muốn nhập một danh sách các cửa hàng thức ăn nhanh ở thành phố Trafford, Vương quốc Anh. Dữ liệu có thể được truy cập từ API của Cơ quan Tiêu chuẩn Thực phẩm, cơ quan cung cấp dữ liệu xếp hạng vệ sinh thực phẩm cho Vương quốc Anh.Dưới đây là các thông số cho yêu cầu của chúng tôi:Phương thức HTTP: GETURL của điểm cuối API: http://api.ratings.food.gov.uk/EstablishmentsCác thông số đã chọn: tên, địa chỉ, kinh độ, vĩ độ, businessTypeId, ratingKey, localAuthorityIdCác tiêu đề: “x-api-version”, 2(Các) Định dạng dữ liệu: JSON, XMLTài liệu: http://api.ratings.food.gov.uk/helpR code sẽ như sau:Bây giờ bạn có thể làm sạch và sử dụng data frame có tên response, với mỗi hàng là một cơ sở thức ăn nhanh.","code":"\n# prepare the request\npath <- \"http://api.ratings.food.gov.uk/Establishments\"\nrequest <- GET(url = path,\n             query = list(\n               localAuthorityId = 188,\n               BusinessTypeId = 7844,\n               pageNumber = 1,\n               pageSize = 5000),\n             add_headers(\"x-api-version\" = \"2\"))\n\n# check for any server error (\"200\" is good!)\nrequest$status_code\n\n# submit the request, parse the response, and convert to a data frame\nresponse <- content(request, as = \"text\", encoding = \"UTF-8\") %>%\n  fromJSON(flatten = TRUE) %>%\n  pluck(\"establishments\") %>%\n  as_tibble()"},{"path":"importing.html","id":"yêu-cầu-xác-thực","chapter":"7 Nhập xuất dữ liệu","heading":"Yêu cầu xác thực","text":"Một số API yêu cầu xác thực - để bạn chứng minh mình là ai và có thể truy cập vào dữ liệu bị hạn chế. Để nhập những dữ liệu này, trước tiên bạn có thể cần sử dụng phương thức POST để cung cấp tên người dùng, mật khẩu hoặc code. Điều này sẽ trả về một mã thông báo truy cập, có thể được sử dụng cho các yêu cầu phương thức GET tiếp theo để truy xuất dữ liệu mong muốn.Dưới đây là một ví dụ về truy vấn dữ liệu từ Go.Data, một công cụ điều tra ổ dịch. Go.Data sử dụng một API cho tất cả các tương tác giữa giao diện người dùng web và các ứng dụng điện thoại thông minh được sử dụng để thu thập dữ liệu. Go.Data được sử dụng trên khắp thế giới. Bởi vì dữ liệu các vụ dịch là nhạy cảm và bạn nên là người duy nhất có thể truy cập vào dữ liệu vụ dịch của mình, nên việc xác thực là bắt buộc.Dưới đây là một số code R mẫu sử dụng httr và jsonlite để kết nối với API Go.Data để nhập dữ liệu liên hệ truy vết từ vụ dịch của bạn.CẨN TRỌNG: Nếu bạn đang nhập một lượng lớn dữ liệu từ một API yêu cầu xác thực, nó có thể hết thời gian chờ. Để tránh điều này, hãy truy xuất lại access_token trước mỗi yêu cầu API GET và thử sử dụng các bộ lọc hoặc giới hạn trong truy vấn.MẸO: Lệnh fromJSON() từ package jsonlite không hoàn toàn không - lồng ghép vào lần đầu tiên nó được chạy, vì vậy bạn vẫn có thể có danh sách các hàng trong phần kết quả của mình. Bạn sẽ cần phải bỏ lồng ghép thêm cho một số biến nhất định; tùy thuộc vào cách .json của bạn được lồng ghép vào nhau. Để xem thêm thông tin về điều này, hãy xem tài liệu về package jsonlite, chẳng hạn như flatten() function.Để biết thêm chi tiết, hãy xem tài liệu trên LoopBack Explorer, chương Truy vết tiếp xúc hoặc các mẹo API trên Go.Data Github repositoryBạn có thể đọc thêm về httr trong gói lệnh herePhần này cũng đã được trình bày trong hướng dẫn này và hướng dẫn này.","code":"\n# set credentials for authorization\nurl <- \"https://godatasampleURL.int/\"           # valid Go.Data instance url\nusername <- \"username\"                          # valid Go.Data username \npassword <- \"password\"                          # valid Go,Data password \noutbreak_id <- \"xxxxxx-xxxx-xxxx-xxxx-xxxxxxx\"  # valid Go.Data outbreak ID\n\n# get access token\nurl_request <- paste0(url,\"api/oauth/token?access_token=123\") # define base URL request\n\n# prepare request\nresponse <- POST(\n  url = url_request,  \n  body = list(\n    username = username,    # use saved username/password from above to authorize                               \n    password = password),                                       \n    encode = \"json\")\n\n# execute request and parse response\ncontent <-\n  content(response, as = \"text\") %>%\n  fromJSON(flatten = TRUE) %>%          # flatten nested JSON\n  glimpse()\n\n# Save access token from response\naccess_token <- content$access_token    # save access token to allow subsequent API calls below\n\n# import outbreak contacts\n# Use the access token \nresponse_contacts <- GET(\n  paste0(url,\"api/outbreaks/\",outbreak_id,\"/contacts\"),          # GET request\n  add_headers(\n    Authorization = paste(\"Bearer\", access_token, sep = \" \")))\n\njson_contacts <- content(response_contacts, as = \"text\")         # convert to text JSON\n\ncontacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # flatten JSON to tibble"},{"path":"importing.html","id":"xuất-dữ-liệu","chapter":"7 Nhập xuất dữ liệu","heading":"7.11 Xuất dữ liệu","text":"","code":""},{"path":"importing.html","id":"với-package-rio","chapter":"7 Nhập xuất dữ liệu","heading":"Với package rio","text":"Với rio, bạn có thể sử dụng lệnh export() theo cách tương tự với import(). Đầu tiên, cung cấp tên của đối tượng R bạn muốn lưu (ví dụ: linelist), sau đó trong dấu ngoặc kép đặt đường dẫn tệp nơi bạn muốn lưu tệp, bao gồm tên tệp mong muốn và phần mở rộng tệp. Ví dụ:Thao tác này lưu data frame linelist dưới dạng một Excel workbook vào thư mục làm việc/thư mục gốc của dự án R:Bạn có thể lưu cùng một data frame dưới dạng tệp csv bằng cách thay đổi phần mở rộng. Ví dụ, chúng tôi cũng lưu nó vào một đường dẫn tệp được tạo bằng ():","code":"\nexport(linelist, \"my_linelist.xlsx\") # will save to working directory\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.csv\"))"},{"path":"importing.html","id":"tới-clipboard","chapter":"7 Nhập xuất dữ liệu","heading":"Tới clipboard","text":"Để xuất khung dữ liệu sang “clipboard” của máy tính (để sau đó dán vào một phần mềm khác như Excel, Google Spreadsheets, v.v.), bạn có thể sử dụng write_clip() từ package clipr.","code":"\n# export the linelist data frame to your system's clipboard\nclipr::write_clip(linelist)"},{"path":"importing.html","id":"import_rds","chapter":"7 Nhập xuất dữ liệu","heading":"7.12 Tệp RDS","text":"Giống như .csv, .xlsx, v.v., bạn cũng có thể xuất/lưu các R data frame dưới dạng tệp .rds. Đây là định dạng tệp dành riêng cho R và rất hữu ích nếu bạn biết mình sẽ làm việc lại với dữ liệu đã xuất trong R.Các nhóm của cột được lưu trữ, vì vậy bạn không cần phải làm sạch lại khi chúng được nhập (với Excel hoặc thậm chí là tệp CSV, điều này có thể khiến bạn đau đầu!). Nó cũng là một tệp nhỏ hơn, hữu ích cho việc xuất và nhập nếu bộ dữ liệu của bạn lớn.Ví dụ: nếu bạn làm việc trong nhóm Dịch tễ học và cần gửi tệp cho nhóm GIS để lập bản đồ và họ cũng sử dụng R, chỉ cần gửi tệp .rds cho họ! Sau đó, tất cả các nhóm cột được giữ lại và có ít việc phải xử lý hơn.","code":"\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.rds\"))"},{"path":"importing.html","id":"import_rdata","chapter":"7 Nhập xuất dữ liệu","heading":"7.13 Tệp và danh sách Rdata","text":"Tệp .Rdata có thể lưu trữ nhiều đối tượng R - ví dụ: nhiều data frame, kết quả mô hình, danh sách, v.v. Điều này có thể rất hữu ích để hợp nhất hoặc chia sẻ nhiều dữ liệu của bạn cho một dự án nhất định.Trong ví dụ dưới đây, nhiều đối tượng R được lưu trữ trong tệp “my_objects.Rdata” đã xuất:Lưu ý: nếu bạn đang thử nhập một danh sách, hãy sử dụng import_list() từ rio để nhập nó với cấu trúc và nội dung gốc hoàn chỉnh.","code":"\nrio::export(my_list, my_dataframe, my_vector, \"my_objects.Rdata\")\nrio::import_list(\"my_list.Rdata\")"},{"path":"importing.html","id":"lưu-biểu-đồ","chapter":"7 Nhập xuất dữ liệu","heading":"7.14 Lưu biểu đồ","text":"Hướng dẫn về cách lưu các biểu đồ, chẳng hạn như các biểu đồ được tạo bởi ggplot(), được thảo luận sâu trong chương ggplot cơ bản.Tóm lại, chạy lệnh ggsave(\"my_plot_filepath_and_name.png\") sau khi biểu đồ của bạn. Bạn có thể cung cấp một đối tượng biểu đồ đã lưu cho đối số plot = hoặc chỉ cần xác định đường dẫn tệp đích (với phần mở rộng tệp) để lưu biểu đồ được hiển thị gần đây nhất. Bạn cũng có thể kiểm soát width =, height =, units = và dpi =.Cách để lưu đồ thị mạng lưới (network graph), chẳng hạn như cây lây nhiễm, được đề cập trong chương Chuỗi lây nhiễm.","code":""},{"path":"importing.html","id":"tài-nguyên-học-liệu","chapter":"7 Nhập xuất dữ liệu","heading":"7.15 Tài nguyên học liệu","text":"R Data Import/Export ManualR 4 Data Science chapter data importggsave() documentationDưới đây là một bảng, lấy từ rio vignette trực tuyến. Đối với mỗi loại dữ liệu, nó hiển thị: phần mở rộng tệp dự kiến, package rio sử dụng để nhập hoặc xuất dữ liệu và trả lời chức năng này có được bao gồm trong phiên bản rio được cài đặt mặc định hay không.","code":"                   |"},{"path":"cleaning.html","id":"cleaning","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8 Làm sạch số liệu và các hàm quan trọng","text":"Chương này trình bày các bước phổ biến được sử dụng trong quá trình “làm sạch” bộ dữ liệu và cũng giải thích việc sử dụng các hàm quản lý dữ liệu thiết yếu trong R.Để giải thích rõ hơn quá trình làm sạch dữ liệu, chương này bắt đầu từ cách nhập bộ dữ liệu thô có tên linelist và tiến hành từng bước trong quá trình làm sạch. Trong code R, quy trình này được biểu thị dưới dạng một chuỗi “pipe”, tham chiếu đến toán tử “pipe” %>% để chuyển tiếp từ thao tác này sang thao tác tiếp theo trong cùng một bộ dữ liệu.","code":""},{"path":"cleaning.html","id":"các-hàm-quan-trọng","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Các hàm quan trọng","text":"Cuốn sách này nhấn mạnh việc sử dụng các hàm từ hệ sinh thái của package tidyverse. Các hàm thiết yếu trong R trình bày trong chương này được liệt kê dưới đây.Nhiều hàm thuộc về package dplyr, mà cung cấp các hàm dạng “verb” để giải quyết các thách thức trong thao tác xử lý dữ liệu (tên package được viết đầy đủ là “data frame-plier. dplyr là một phần trong hệ sinh thái của package tidyverse (mà bao gồm các package khác như ggplot2, tidyr, stringr, tibble, purrr, magrittr, và forcats).Nếu bạn muốn xem các hàm này sánh với các câu lệnh trong Stata hoặc SAS, hãy xem chương Chuyển đổi sang R.Bạn cũng có thể gặp một framework quản lý dữ liệu khác từ package data.table trong R với các toán tử như := và thường xuyên sử dụng dấu ngoặc [ ]. Cách tiếp cận và cú pháp này được giải thích ngắn gọn trong chương Data Table.","code":""},{"path":"cleaning.html","id":"thuật-ngữ","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Thuật ngữ","text":"Trong cuốn sách này, chúng tôi quy ước chung “cột” và “hàng” thay cho “biến” và “quan sát”. Như đã giải thích trong phần dẫn trên “dữ liệu gọn gàng - tidy data”, hầu hết các bộ dữ liệu dịch tễ-thống kê đều có cấu trúc gồm các hàng, cột và giá trị.Variables (biến) chứa các giá trị đo lường cùng một thuộc tính cơ bản (như nhóm tuổi, kết quả hoặc ngày bắt đầu). Observations (quan sát) chứa tất cả các giá trị được đo trên cùng một đơn vị (ví dụ: một người, địa điểm hoặc mẫu phòng thí nghiệm). Vì vậy, những khía cạnh này có thể khó xác định một cách hữu hình hơn.Trong bộ dữ liệu “tidy”, mỗi cột là một biến, mỗi hàng là một quan sát và mỗi ô là một giá trị duy nhất. Tuy nhiên, một số bộ dữ liệu bạn gặp phải sẽ không giống với mô tả này - bộ dữ liệu định dạng “wide (ngang)” có thể có một biến số được chia thành nhiều cột (xem ví dụ trong chương Xoay trục dữ liệu). Tương tự như vậy, các quan sát có thể được chia thành nhiều hàng.Cuốn sách này tập trung về quản lý và biến đổi dữ liệu, đó, việc đề cập đến cấu trúc dữ liệu cụ thể của các hàng và cột sẽ thích hợp hơn là các quan sát và biến vốn khá trừu tượng. Các trường hợp ngoại lệ chủ yếu xảy ra trong các chương về phân tích dữ liệu, nơi bạn sẽ thấy nhiều tham chiếu hơn đến các biến và quan sát.","code":""},{"path":"cleaning.html","id":"quy-trình-làm-sạch","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.1 Quy trình làm sạch","text":"Chương này tiến hành các bước làm sạch điển hình, bằng cách thêm chúng tuần tự vào một chuỗi pipe.Trong phân tích dịch tễ học và xử lý dữ liệu, các bước làm sạch thường được thực hiện tuần tự, liên kết với nhau. Trong R, việc này thường được thực hiện dưới dạng một “pipeline - đường ống” làm sạch, trong đó bộ dữ liệu thô được chuyển tiếp hoặc “dẫn” từ bước làm sạch này sang bước làm sạch khác.Các chuỗi như vậy sử dụng các hàm dạng “verb” trong package dplyr và toán tử pipe %>% trong package magrittr. Chuỗi pipe bắt đầu từ dữ liệu “thô” (“linelist_raw.xlsx”) và kết thúc bằng bộ dữ liệu “sạch” trên R (linelist) có thể được sử dụng, lưu, xuất, v.v.Trong quy trình làm sạch dữ liệu, thứ tự của các bước là quan trọng. Các bước làm sạch có thể bao gồm:Nhập dữ liệuLàm sạch hoặc đổi tên cộtLoại bỏ trùng lặpTạo và chuyển đổi cột (ví dụ: mã hóa lại hoặc chuẩn hóa các giá trị)Lọc hoặc thêm hàng","code":""},{"path":"cleaning.html","id":"gọi-package","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.2 Gọi package","text":"Đoạn code này trình bày cách gọi các package cần thiết cho phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt package nếu cần và gọi package ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() sẵn có trong base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.","code":"\npacman::p_load(\n  rio,        # importing data  \n  here,       # relative file pathways  \n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # age_categories() function\n  tidyverse   # data management and visualization\n)"},{"path":"cleaning.html","id":"nhập-dữ-liệu-1","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.3 Nhập dữ liệu","text":"","code":""},{"path":"cleaning.html","id":"nhập","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Nhập","text":"Ở đây, chúng ta sẽ nhập tệp tin Excel “thô” bằng cách sử dụng hàm import() từ package rio. Package rio có thể xử lý linh hoạt nhiều loại tệp tin (ví dụ: .xlsx, .csv, .tsv, .rds. Xem chương về Nhập xuất dữ liệu để biết thêm thông tin và mẹo về các tình huống bất thường (ví dụ: loại bỏ hàng, thiết lập giá trị trống, nạp trang tính Google, v.v.).Nếu bạn muốn hiểu rõ hơn, hãy tải xuống tệp dữ liệu linelist “thô” (với file dạng .xlsx).Nếu bộ dữ liệu của bạn quá lớn và mất nhiều thời gian để nhập, sẽ hữu ích khi bạn đặt lệnh nhập dữ liệu riêng biệt với chuỗi pipe và dữ liệu “thô” sẽ được lưu thành một tệp riêng biệt. Điều này cũng cho phép dễ dàng sánh giữa phiên bản gốc và phiên bản đã làm sạch.Dưới đây, chúng ta nạp một tệp Excel thô và lưu nó dưới dạng dataframe linelist_raw. Chúng tôi giả định rằng tệp này nằm trong thư mục làm việc của bạn hoặc thư mục gốc của dự án R và vì vậy không có thư mục con nào được chỉ định trong đường dẫn tệp.Bạn có thể xem 50 hàng đầu tiên của bộ dữ liệu bên dưới. Lưu ý: hàm head(n) trong base R cho phép bạn chỉ xem n hàng đầu tiên trong R console.","code":"\nlinelist_raw <- import(\"linelist_raw.xlsx\")"},{"path":"cleaning.html","id":"đánh-giá","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Đánh giá","text":"Bạn có thể sử dụng hàm skim() từ package skimr để có cái nhìn tổng quan về toàn bộ bộ dữ liệu (xem chương Bảng mô tả để biết thêm thông tin). Các cột được tóm tắt theo phân lớp/định dạng như ký tự và số. Lưu ý: “POSIXct” là một loại phân lớp ngày thô (xem chương Làm việc với ngày tháng.Table 8.1: Data summaryVariable type: characterVariable type: numericVariable type: POSIXct","code":"\nskimr::skim(linelist_raw)"},{"path":"cleaning.html","id":"tên-cột","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.4 Tên cột","text":"Trong R, tên cột là “tiêu đề” hoặc giá trị “trên đỉnh” của một cột. Chúng được sử dụng để tham chiếu đến các cột trong đoạn code và đóng vai trò như một nhãn mặc định trong các bảng biểu.Các phần mềm thống kê khác như SAS và STATA sử dụng “nhãn” là tên cột phiên bản dài hơn khi , cùng tồn tại song song với tên cột. Mặc dù R cung cấp tính năng thêm nhãn của cột vào dữ liệu, nhưng điều này hầu hết không được nhấn mạnh trong thực tế. Để đặt tên cột “dễ nhìn” cho các bảng biểu, người ta thường điều chỉnh hiển thị của chúng trong các lệnh vẽ biểu đồ để tạo ra kết quả (ví dụ: tiêu đề trục hoặc chú giải của một biểu đồ hoặc tiêu đề cột trong bảng - xem thêm mục scales trong chương Các tips với ggplot và chương Trình bày bảng). Nếu bạn muốn gán nhãn cột trong dữ liệu, hãy đọc thêm tài liệu trực tuyến tại đây và tại đây.Vì tên cột trong R được sử dụng rất thường xuyên, vì vậy chúng phải có cú pháp “sạch”. Chúng tôi đề xuất những tiêu chí sau:Tên ngắnKhông có khoảng trắng (thay thế bằng dấu gạch dưới_)Không có ký tự lạ (&, #, <, >, …)Thống nhất cách định danh (vd: toàn bộ tên cột ngày như date_onset, date_report, date_death…)Tên các cột trong linelist_raw được bên dưới bằng cách sử dụng hàm names() từ base R. Ban đầu chúng ta có thể thấy rằng:Một số tên chứa khoảng trắng (vd: infection date)Một số mẫu tên khác nhau được sử dụng cho biến ngày (date onset và infection date)Phải có một tiêu đề được hợp nhất ở hai cột cuối cùng trong tệp .xlsx. Chúng tôi biết điều này vì tên của hai cột được hợp nhất (“merge_header”) được R gán cho cột đầu tiên và cột thứ hai được gán tên giữ chỗ “… 28” (vì lúc đó nó trống và là cột thứ 28).CHÚ Ý: Để tham chiếu tên một cột có chứa khoảng trắng, hãy bao quanh tên cột bằng dấu huyền, ví dụ: linelist$` '\\x60infection date\\x60'`. Lưu ý là trên bàn phím, dấu huyền (`) được phân biệt với dấu ngoặc đơn (’).","code":"\nnames(linelist_raw)##  [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"      \"hosp date\"       \"date_of_outcome\" \"outcome\"         \"gender\"          \"hospital\"       \n## [10] \"lon\"             \"lat\"             \"infector\"        \"source\"          \"age\"             \"age_unit\"        \"row_num\"         \"wt_kg\"           \"ht_cm\"          \n## [19] \"ct_blood\"        \"fever\"           \"chills\"          \"cough\"           \"aches\"           \"vomit\"           \"temp\"            \"time_admission\"  \"merged_header\"  \n## [28] \"...28\""},{"path":"cleaning.html","id":"làm-sạch-tự-động","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Làm sạch tự động","text":"Hàm clean_names() từ package janitor chuẩn hóa tên cột và biến chúng thành duy nhất bằng cách thực hiện như sau:Chuyển đổi tất cả các tên cột thành chỉ bao gồm dấu gạch dưới, số và chữ cáiCác ký tự có dấu được chuyển ngữ sang dạng ASCII (ví dụ: o tiếng Đức với âm sắc trở thành “o”, “enye” tiếng Tây Ban Nha trở thành “n”)Tùy chọn viết hoa cho tên cột mới có thể được chỉ định bằng cách sử dụng đối số case = (mặc định là “snake”, các lựa chọn thay thế bao gồm “sentence”, “title”, “small_camel”…)Bạn có thể chỉ định các tên thay thế cụ thể bằng cách cung cấp một vectơ tới đố số replace = (ví dụ: replace = c(onset = \"date_of_onset\"))Đây là một hướng dẫn trực tuyếnSau đây, quy trình làm sạch bắt đầu bằng cách sử dụng hàm clean_names() trên bộ dữ liệu linelist thô.LƯU Ý: Tên cột cuối cùng “… 28” đã được đổi thành “x28”.","code":"\n# pipe the raw dataset through the function clean_names(), assign result as \"linelist\"  \nlinelist <- linelist_raw %>% \n  janitor::clean_names()\n\n# see the new column names\nnames(linelist)##  [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"      \"hosp_date\"       \"date_of_outcome\" \"outcome\"         \"gender\"          \"hospital\"       \n## [10] \"lon\"             \"lat\"             \"infector\"        \"source\"          \"age\"             \"age_unit\"        \"row_num\"         \"wt_kg\"           \"ht_cm\"          \n## [19] \"ct_blood\"        \"fever\"           \"chills\"          \"cough\"           \"aches\"           \"vomit\"           \"temp\"            \"time_admission\"  \"merged_header\"  \n## [28] \"x28\""},{"path":"cleaning.html","id":"làm-sạch-tên-cột-thủ-công","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Làm sạch tên cột thủ công","text":"Việc đặt tên lại các cột theo cách thủ công thường là cần thiết, ngay cả sau bước chuẩn hóa ở trên. Dưới đây, việc đổi tên được thực hiện bằng cách sử dụng hàm rename() từ package dplyr, như một phần của quy trình. rename() sử dụng cú pháp NEW = OLD - tên cột mới được đặt trước tên cột cũ.Dưới đây, một lệnh đổi tên được thêm vào quy trình làm sạch. Các khoảng trắng đã được thêm vào một cách chọn lọc để căn chỉnh code dễ đọc hơn.Bây giờ bạn có thể thấy rằng tên các cột đã được thay đổi:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \n##  [8] \"gender\"               \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                 \n## [15] \"age_unit\"             \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"                \"chills\"              \n## [22] \"cough\"                \"aches\"                \"vomit\"                \"temp\"                 \"time_admission\"       \"merged_header\"        \"x28\""},{"path":"cleaning.html","id":"thay-đối-tên-cột-theo-vị-trí","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Thay đối tên cột theo vị trí","text":"Bạn cũng có thể đổi tên theo vị trí cột, thay vì tên cột, ví dụ:","code":"\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)"},{"path":"cleaning.html","id":"đổi-tên-bằng-hàm-select-và-summarise","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Đổi tên bằng hàm select() và summarise()","text":"Như một lối tắt, bạn cũng có thể đổi tên các cột bằng hàm select() và summarise() thuộc package dplyr. Hàm select() được sử dụng để chỉ giữ một số cột nhất định (sẽ được đề cập sau trong chương này). Hàm summarise() được đề cập trong các chương Nhóm dữ liệu và Bảng mô tả. Các hàm này cũng sử dụng định dạng new_name = old_name. Đây là một ví dụ:","code":"\nlinelist_raw %>% \n  select(# NEW name             # OLD name\n         date_infection       = `infection date`,    # rename and KEEP ONLY these columns\n         date_hospitalisation = `hosp date`)"},{"path":"cleaning.html","id":"các-thách-thức-khác","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Các thách thức khác","text":"","code":""},{"path":"cleaning.html","id":"cột-trống-tên-trên-file-excel","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Cột trống tên trên file Excel","text":"R không thể nhận diện các cột trong bộ dữ liệu mà không có tên cột (tiêu đề). Vì vậy, nếu bạn nhập một bộ dữ liệu Excel có dữ liệu nhưng không có tiêu đề cột, R sẽ điền vào các tiêu đề đó mặc định như “… 1” hoặc “… 2”. Phần số đại diện cho số cột (ví dụ: nếu cột thứ 4 trong bộ dữ liệu không có tiêu đề, thì R sẽ mặc định đặt tên là “… 4”).Bạn có thể làm sạch các tên cột này theo cách thủ công bằng cách tham chiếu số vị trí của chúng (xem ví dụ ở trên) hoặc tên được chỉ định của chúng (linelist_raw$...1).","code":""},{"path":"cleaning.html","id":"hợp-nhất-tên-cột-và-ô-excel","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Hợp nhất tên cột và ô Excel","text":"Các ô được hợp nhất trong file Excel là một sự cố thường xảy ra khi nhận dữ liệu. Như đã giải thích trong chương Chuyển đổi sang R, các ô được hợp nhất có thể dễ nhìn cho con người đọc dữ liệu, nhưng không phải là “cấu trúc dữ liệu cơ bản” và gây ra nhiều vấn đề cho máy khi nhận diện dữ liệu. R không thể chứa các ô đã hợp nhất.Nhắc nhở người nhập liệu rằng dữ liệu có thể đọc được bởi con người không giống với dữ liệu mà máy có thể đọc được. Hãy cố gắng đào tạo người dùng về các nguyên tắc về dữ liệu tidy. Nếu có thể, hãy cố gắng thay đổi quy trình để dữ liệu có định dạng gọn gàng hơn mà không hợp nhất các ô.Mỗi biến phải là một cột riêng biệtMỗi quan sát phải là một dòng riêng biệtMỗi giá trị phải là một ô riêng biệtKhi sử dụng hàm import() của package rio, giá trị trong một ô đã hợp nhất sẽ được gán cho ô đầu tiên và các ô tiếp theo sẽ trống.Một giải pháp để xử lý các ô đã hợp nhất là nạp dữ liệu bằng hàm readWorkbook() từ package openxlsx. Thiết lập đối số fillMergedCells = TRUE. Điều này cho phép giá trị trong ô hợp nhất được tham chiếu cho tất cả các ô nằm trong phạm vi hợp nhất.NGUY HIỂM: Nếu các tên cột được hợp nhất với readWorkbook(), có thể sẽ trả về tên cột trùng lặp, mà bạn sẽ cần phải sửa một cách thủ công - R không làm việc được với các tên cột trùng lặp! Bạn có thể đặt lại tên cho chúng bằng cách tham chiếu vị trí của chúng (ví dụ: cột 5), như được giải thích trong mục làm sạch tên cột thủ công.","code":"\nlinelist_raw <- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)"},{"path":"cleaning.html","id":"chọn-hoặc-đổi-vị-trí-cột","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.5 Chọn hoặc đổi vị trí cột","text":"Sử dụng hàm select() từ package dplyr để chọn các cột bạn muốn giữ lại và sắp xếp lại thứ tự của chúng trong bộ dữ liệu.CẨN TRỌNG: Trong các ví dụ dưới đây, bộ dữ liệu linelist được điều chỉnh với hàm select() và được hiển thị, nhưng không được lưu. Việc này được sử dụng phục vụ mục đích mô tả. Tên cột đã sửa đổi được ra bằng cách chuyển tiếp bộ dữ liệu tới hàm names().Dưới đây là TẤT CẢ các tên cột trong bộ dữ liệu linelist tại thời điểm làm sạch:","code":"\nnames(linelist)##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \n##  [8] \"gender\"               \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                 \n## [15] \"age_unit\"             \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"                \"chills\"              \n## [22] \"cough\"                \"aches\"                \"vomit\"                \"temp\"                 \"time_admission\"       \"merged_header\"        \"x28\""},{"path":"cleaning.html","id":"giữ-cột","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Giữ cột","text":"Giữ lại những cột mong muốnViết tên cột cần giữ trong hàm select(), không có dấu ngoặc kép. Kết quả trả về sẽ xuất hiện trong bộ dữ liệu theo thứ tự mà bạn cung cấp. Lưu ý rằng nếu bạn chỉ định một cột không tồn tại, R sẽ báo lỗi (xem cách sử dụng hàm any_of() bên dưới nếu bạn không muốn gặp lỗi trong trường hợp này).","code":"\n# linelist dataset is piped through select() command, and names() prints just the column names\nlinelist %>% \n  select(case_id, date_onset, date_hospitalisation, fever) %>% \n  names()  # display the column names## [1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\" \"fever\""},{"path":"cleaning.html","id":"clean_tidyselect","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Hàm trợ giúp “tidyselect”","text":"Các hàm trợ giúp này được xây dựng để giúp bạn dễ dàng chỉ định các cột cần giữ, loại bỏ hoặc chuyển đổi. Chúng nằm trong package tidyselect, thuộc hệ sinh thái tidyverse và làm cơ sở cho cách chọn cột trong các hàm dplyr.Ví dụ: nếu bạn muốn sắp xếp lại các cột, hàm everything() là một hàm hữu ích để biểu thị “tất cả các cột khác chưa được đề cập”. Lệnh dưới đây di chuyển các cột date_onset và date_hospitalisation lên cột đầu tiên (bên trái) của bộ dữ liệu, nhưng vẫn giữ tất cả các cột khác sau đó. Lưu ý rằng hàm everything() được viết bằng dấu ngoặc đơn trống:Dưới đây là các hàm trợ giúp “tidyselect” khác cũng hoạt động trong các hàm dplyr như select(), across(), và summarise():everything() - tất cả các cột khác chưa được đề cậpeverything() - tất cả các cột khác chưa được đề cậplast_col() - cột cuối cùnglast_col() - cột cuối cùngwhere() - áp dụng một hàm cho tất cả các cột và chọn những cột trả về giá trị TRUEwhere() - áp dụng một hàm cho tất cả các cột và chọn những cột trả về giá trị TRUEcontains() - cột chứa một chuỗi ký tự\nVí dụ: select(contains(\"time\"))\ncontains() - cột chứa một chuỗi ký tựVí dụ: select(contains(\"time\"))starts_with() - khớp với các tiền tố được chỉ định\nVí dụ: select(starts_with(\"date_\"))\nstarts_with() - khớp với các tiền tố được chỉ địnhVí dụ: select(starts_with(\"date_\"))ends_with() - khớp với các hậu tố được chỉ định\nVí dụ: select(ends_with(\"_post\"))\nends_with() - khớp với các hậu tố được chỉ địnhVí dụ: select(ends_with(\"_post\"))matches() - để áp dụng một mệnh đề chính quy (regex)\nVí dụ: select(matches(\"[pt]al\"))\nmatches() - để áp dụng một mệnh đề chính quy (regex)Ví dụ: select(matches(\"[pt]al\"))num_range() - một khoảng số học như x01, x02, x03num_range() - một khoảng số học như x01, x02, x03any_of() - khớp NẾU cột tồn tại nhưng không báo lỗi nếu không tìm thấy\nVí dụ: select(any_of(date_onset, date_death, cardiac_arrest))\nany_of() - khớp NẾU cột tồn tại nhưng không báo lỗi nếu không tìm thấyVí dụ: select(any_of(date_onset, date_death, cardiac_arrest))Ngoài ra, sử dụng các toán tử bình thường như c() để liệt kê danh sách cột, hoặc : cho các cột liên tiếp, ! cho đối lập, & cho VÀ, và | cho HOẶC.Sử dụng () để cụ thể tiêu chí logic cho các cột. Nếu đưa một hàm vào trong (), hãy nhớ không bao gồm dấu ngoặc đơn trống của hàm đó. Câu lệnh bên dưới chọn các cột kiểu Số.Sử dụng contains() để chọn các cột trong đó tên cột chứa một chuỗi ký tự được chỉ định. ends_with() và starts_with() cung cấp thêm các lựa chọn khác nhau.Hàm matches() hoạt động tương tự như hàm contains() nhưng có thể được cung cấp một biểu thức chính quy (xem chương Ký tự và chuỗi), chẳng hạn như nhiều chuỗi được phân tách bằng toán tự trong dấu ngoặc đơn:CẨN TRỌNG: Nếu tên cột mà bạn đưa ra không tồn tại trong dữ liệu, máy có thể báo lỗi và dừng code của bạn. Cân nhắc sử dụng hàm any_of() để trích dẫn các cột có thể hoặc không thể tồn tại, đặc biệt hữu ích trong các lựa chọn loại trừ (loại bỏ).Chỉ có một trong các cột này tồn tại, nhưng không có lỗi được báo và code sẽ tiếp tục các bước trong quy trình làm sạch.","code":"\n# move date_onset and date_hospitalisation to beginning\nlinelist %>% \n  select(date_onset, date_hospitalisation, everything()) %>% \n  names()##  [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"              \"generation\"           \"date_infection\"       \"date_outcome\"         \"outcome\"             \n##  [8] \"gender\"               \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                 \n## [15] \"age_unit\"             \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"fever\"                \"chills\"              \n## [22] \"cough\"                \"aches\"                \"vomit\"                \"temp\"                 \"time_admission\"       \"merged_header\"        \"x28\"\n# select columns that are class Numeric\nlinelist %>% \n  select(where(is.numeric)) %>% \n  names()## [1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"      \"ht_cm\"      \"ct_blood\"   \"temp\"\n# select columns containing certain characters\nlinelist %>% \n  select(contains(\"date\")) %>% \n  names()## [1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"\n# searched for multiple character matches\nlinelist %>% \n  select(matches(\"onset|hosp|fev\")) %>%   # note the OR symbol \"|\"\n  names()## [1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"             \"fever\"\nlinelist %>% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %>% \n  names()## [1] \"date_onset\""},{"path":"cleaning.html","id":"xóa-cột","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Xóa cột","text":"Chỉ ra cột nào cần loại bỏ bằng cách đặt biểu tượng dấu trừ “-” ở phía trước tên cột (ví dụ: select(-outcome)) hoặc một vectơ tên các cột (như bên dưới). Tất cả các cột khác sẽ được giữ nguyên.Bạn cũng có thể xóa một cột bằng cú pháp trong base R, bằng cách định nghĩa nó là NULL. Ví dụ:","code":"\nlinelist %>% \n  select(-c(date_onset, fever:vomit)) %>% # remove date_onset and all columns from fever to vomit\n  names()##  [1] \"case_id\"              \"generation\"           \"date_infection\"       \"date_hospitalisation\" \"date_outcome\"         \"outcome\"              \"gender\"              \n##  [8] \"hospital\"             \"lon\"                  \"lat\"                  \"infector\"             \"source\"               \"age\"                  \"age_unit\"            \n## [15] \"row_num\"              \"wt_kg\"                \"ht_cm\"                \"ct_blood\"             \"temp\"                 \"time_admission\"       \"merged_header\"       \n## [22] \"x28\"\nlinelist$date_onset <- NULL   # deletes column with base R syntax "},{"path":"cleaning.html","id":"hoạt-động-độc-lập","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Hoạt động độc lập","text":"select() cũng có thể được sử dụng như một lệnh độc lập (không bắt buộc trong chuỗi các bước làm sạch). Trong trường hợp này, đối số đầu tiên trong bộ dữ liệu gốc sẽ được tham chiếu.","code":"\n# Create a new linelist with id and age-related columns\nlinelist_age <- select(linelist, case_id, contains(\"age\"))\n\n# display the column names\nnames(linelist_age)## [1] \"case_id\"  \"age\"      \"age_unit\""},{"path":"cleaning.html","id":"thêm-vào-quy-trình-làm-sạch","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Thêm vào quy trình làm sạch","text":"Trong bộ dữ liệu linelist_raw, có một vài cột chúng ta không cần: row_num, merged_header, và x28. Chúng ta xóa chúng bằng lệnh select() trong chuỗi các bước làm sạch như sau:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n\n    # remove column\n    select(-c(row_num, merged_header, x28))"},{"path":"cleaning.html","id":"loại-bỏ-trùng-lặp","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.6 Loại bỏ trùng lặp","text":"Xem chương Loại bỏ trùng lặp để biết các tùy chọn mở rộng về cách loại bỏ dữ liệu trùng lặp. Chỉ một ví dụ rất đơn giản về cách loại bỏ hàng trùng lặp được trình bày ở chương này.Package dplyr cung cấp hàm distinct(). Hàm này kiểm tra tất cả các hàng và rút gọn bộ dữ liệu cho chỉ còn các hàng là duy nhất. Nghĩa là, nó loại bỏ 100% các hàng trùng lặp.Khi đánh giá các hàng trùng lặp, hàm này sẽ thực hiện trên các cột được chỉ định - mặc định nó sẽ xem xét tất cả các cột. Như trình bày trong chương loại bỏ trùng lặp, bạn có thể điều chỉnh phạm vi cột để việc khảo sát tính duy nhất của các hàng sẽ chỉ được đánh giá trong phạm vi một số cột nhất định.Trong ví dụ đơn giản này, chúng ta chỉ cần thêm câu lệnh trống distinct() vào chuỗi các bước làm sạch. Điều này đảm bảo không có hàng nào là bản sao 100% của các hàng khác (được đánh giá trên tất cả các cột).Chúng ta bắt đầu với nrow(linelist) hàng trong bộ linelist.Sau khi loại bỏ trùng lặp, thì bộ dữ liệu mới có nrow(linelist) hàng. Bất kỳ hàng nào bị xóa cũng có thể là 100% bản sao của các hàng khác.Dưới đây, lệnh distinct() được thêm vào quy trình làm sạch:","code":"\nlinelist <- linelist %>% \n  distinct()\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n    \n    # de-duplicate\n    distinct()"},{"path":"cleaning.html","id":"tạo-và-biến-đổi-cột","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.7 Tạo và biến đổi cột","text":"Chúng tôi khuyến khích sử dụng hàm mutate() trong package dplyr để thêm một cột mới hoặc để sửa đổi một cột sẵn có.Dưới đây là một ví dụ về tạo cột mới với hàm mutate(). Cú pháp là: mutate(new_column_name = value transformation)Trong Stata, điều này tương tự như lệnh generate, nhưng hàm mutate() trong R còn có thể được sử dụng để điều chỉnh cột đã tồn tại.","code":""},{"path":"cleaning.html","id":"tạo-cột-mới","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Tạo cột mới","text":"Tính năng cơ bản nhất của hàm mutate() là để tạo một cột mới, có thể thấy trong ví dụ dưới đây. Nó tạo một cột mới new_col trong đó giá trị trong mỗi hàng đều là 10.Bạn cũng có thể tham chiếu các giá trị trong các cột khác, để thực hiện phép tính toán. Dưới đây, cột mới bmi được tạo để tính chỉ số khối cơ thể (BMI) cho mỗi trường hợp - như được tính bằng công thức BMI = kg/m^2, sử dụng cột ht_cm và cột wt_kg.Nếu tạo nhiều cột mới, hãy tách riêng từng cột bằng dấu phẩy và dòng mới. Dưới đây là các ví dụ về tạo các cột mới, bao gồm một cột mà chứa các giá trị từ các cột khác được kết hợp bằng hàm str_glue() từ package stringr (xem chương Ký tự và chuỗi).Kiểm tra các cột mới. Đối với mục tiêu minh họa, chỉ các cột mới và các cột được sử dụng để tạo cột mới được hiển thị:MẸO: Một biến thể của hàm mutate() là hàm transmute(). Hàm này thêm một cột mới giống như mutate(), nhưng cũng bỏ/xóa tất cả các cột khác mà bạn không đề cập trong dấu ngoặc đơn của hàm.","code":"\nlinelist <- linelist %>% \n  mutate(new_col = 10)\nlinelist <- linelist %>% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\nnew_col_demo <- linelist %>%                       \n  mutate(\n    new_var_dup    = case_id,             # new column = duplicate/copy another existing column\n    new_var_static = 7,                   # new column = all values the same\n    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # new column = pasting together values from other columns\n    ) %>% \n  select(case_id, hospital, date_hospitalisation, contains(\"new\"))        # show only new columns, for demonstration purposes\n# HIDDEN FROM READER\n# removes new demo columns created above\n# linelist <- linelist %>% \n#   select(-contains(\"new_var\"))"},{"path":"cleaning.html","id":"chuyển-đổi-kiểu-dữ-liệu-của-cột","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Chuyển đổi kiểu dữ liệu của cột","text":"Các cột chứa giá trị là ngày tháng, số hoặc giá trị logic (TRUE/FALSE) sẽ chỉ hoạt động như mong đợi nếu chúng được phân loại chính xác. Có sự khác biệt giữa “2” của phân lớp ký tự và 2 của phân lớp số!Có nhiều cách để thiết lập kiểu dữ liệu cho cột trong các lệnh nhập, nhưng chúng thường phức tạp. Xem chương R cơ bản về các lớp đối tượng để tìm hiểu thêm về cách chuyển đổi phân lớp đối tượng và cột.Đầu tiên, hãy kiểm tra các cột quan trọng để xem chúng đã đúng định dạng chính xác chưa. Chúng ta có thể phát hiện điều này ngay từ khi chúng ta chạy lệnh skim().Hiện tại, kiểu của cột age là dạng ký tự. Để thực hiện các phân tích định lượng, chúng ta cần những giá trị số này được nhận biết là dạng số!Phân lớp của cột date_onset cũng là ký tự! Để thực hiện phân tích, những cột ngày này phải được nhận biết là dạng ngày tháng!Để giải quyết vấn đề này, hãy sử dụng hàm mutate() để định dạng và chuyển đổi lại một cột. Chúng ta giữ nguyên cột đó và định dạng lại sang một phân lớp khác. Sau đây là một ví dụ cơ bản, chuyển đổi hoặc đảm bảo rằng cột age là phân lớp dạng số:Theo cách tương tự, bạn có thể sử dụng hàm .character() và hàm .logical(). Để chuyển đổi sang kiểu Factor, bạn có thể sử dụng hàm factor() từ base R hoặc hàm as_factor() từ package forcats. Đọc thêm ở chương Factors.Bạn phải cẩn thận khi chuyển đổi sang phân lớp Ngày. Một số phương pháp được giải thích rõ hơn ở chương Làm việc với ngày tháng. Thông thường, tất cả các giá trị ngày ban đầu phải ở cùng một định dạng cần chuyển đổi để có thể sử dụng (ví dụ: “MM/DD/YYYY” hoặc “DD MM YYYY”). Sau khi chuyển đổi thành thành phân lớp Ngày, hãy kiểm tra dữ liệu của bạn để xác nhận rằng mỗi giá trị đã được chuyển đổi chính xác.","code":"\nclass(linelist$age)## [1] \"character\"\nclass(linelist$date_onset)## [1] \"character\"\nlinelist <- linelist %>% \n  mutate(age = as.numeric(age))"},{"path":"cleaning.html","id":"dữ-liệu-được-nhóm","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Dữ liệu được nhóm","text":"Nếu bộ dữ liệu của bạn đã được nhóm (xem chương Nhóm dữ liệu), hàm mutate() có thể hoạt động khác với khi bộ dữ liệu không được nhóm. Bất kỳ hàm tổng hợp nào, như mean(), median(), max(), v.v. sẽ tính theo nhóm, không phải theo tất cả các hàng.Đọc thêm về cách sử dụng hàm mutate() trên các bộ dữ liệu được nhóm ở tài liệu về mutate trong package tidyverse.","code":"\n# age normalized to mean of ALL rows\nlinelist %>% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# age normalized to mean of hospital group\nlinelist %>% \n  group_by(hospital) %>% \n  mutate(age_norm = age / mean(age, na.rm=T))"},{"path":"cleaning.html","id":"clean_across","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Biến đổi nhiều cột","text":"Thông thường, để viết mã ngắn gọn, bạn muốn áp dụng cùng một biến đổi trên nhiều cột cùng một lúc. Một cách biến đổi có thể được áp dụng trên nhiều cột cùng một lúc bằng cách sử dụng hàm across() từ package dplyr (cũng trong package tidyverse). Hàm across() có thể được sử dụng với bất kỳ hàm nào trong packe dplyr, nhưng thường được sử dụng với hàm select(), mutate(), filter(), hoặc summarise(). Xem cách sử dụng hàm summarise() trong chương Bảng mô tả.Chỉ định các cột bằng đối số .cols = và các hàm được sử dụng bằng .fns =. Bất kỳ đối số bổ sung nào để cung cấp cho hàm .fns đều có thể được bao gồm sau dấu phẩy, vẫn nằm trong hàm across().","code":""},{"path":"cleaning.html","id":"lựa-chọn-cột-với-hàm-across","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Lựa chọn cột với hàm across()","text":"Chỉ định các cột tới đối số .cols =. Bạn có thể đặt tên cho chúng một cách riêng lẻ hoặc sử dụng các hàm trợ giúp “tidyselect”. Cụ thể hàm tới đối số .fns =. Lưu ý rằng cách sử dụng hàm được trình bày bên dưới, hàm được viết mà không có dấu ngoặc đơn ().Ở đây, phép biến đổi .character() được áp dụng cho tên cột cụ thể trong hàm across().Các hàm trợ giúp “tidyselect” có sẵn để hỗ trợ bạn trong việc chỉ định các cột. Chúng được trình bày chi tiết ở trên trong mục Chọn và sắp xếp thứ tự cột, bao gồm: everything(), last_col(), (), starts_with(), ends_with(), contains(), matches(), num_range() và any_of().Đây là một ví dụ về cách thay đổi tất cả các cột thành phân lớp dạng ký tự:Chuyển đổi tất cả các cột thành dạng ký tự có tên chứa chuỗi ký tự “date” (lưu ý vị trí của dấu phẩy và dấu ngoặc đơn):Dưới đây, một ví dụ về việc thay đổi các cột hiện là phân lớp POSIXct (một kiểu dữ liệu ngày tháng thô hiển thị mốc thời gian) - hay nói cách khác, khi hàm .POSIXct() đánh giá là TRUE. Sau đó, chúng ta muốn áp dụng hàm .Date() cho các cột này để chuyển đổi chúng thành kiểu Ngày thông thường.Lưu ý rằng trong hàm across(), chúng tôi cũng sử dụng hàm () tương tự như hàm .POSIXct được đánh giá là TRUE hoặc FALSE.Lưu ý rằng hàm .POSIXct() là từ package lubridate. Các hàm “” tương tự khác như .character(), .numeric(), và .logical() thì thuộc base R","code":"\nlinelist <- linelist %>% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n#to change all columns to character class\nlinelist <- linelist %>% \n  mutate(across(.cols = everything(), .fns = as.character))\n#to change all columns to character class\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\nlinelist <- linelist %>% \n  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))"},{"path":"cleaning.html","id":"hàm-across","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Hàm across()","text":"Bạn có thể đọc tài liệu với hàm ?across để biết chi tiết về cách sử dụng hàm across(). Một vài điểm tóm tắt: có một số cách để chỉ định (các) hàm để thực hiện trên một cột và bạn thậm chí có thể tự chỉ định các hàm riêng của mình:Bạn có thể cung cấp tên hàm đứng một mình (ví dụ: mean hoặc .character)Bạn có thể cung cấp tên hàm đứng một mình (ví dụ: mean hoặc .character)Bạn có thể cung cấp hàm theo phong cách purrr (ví dụ: ~ mean(.x, na.rm = TRUE)) (xem chương Lặp, vòng lặp, và danh sách)Bạn có thể cung cấp hàm theo phong cách purrr (ví dụ: ~ mean(.x, na.rm = TRUE)) (xem chương Lặp, vòng lặp, và danh sách)Bạn có thể chỉ định nhiều hàm bằng cách cung cấp danh sách (ví dụ: list(mean = mean, n_miss = ~ sum(.na(.x))).\nNếu bạn cung cấp nhiều hàm, nhiều cột được chuyển đổi sẽ được trả về dựa trên mỗi cột ban đầu, với các tên duy nhất theo định dạng col_fn. Bạn có thể điều chỉnh cách đặt tên các cột mới với đối số .names = bằng cách sử dụng cú pháp glue (xem chương Ký tự và chuỗi) trong đó {.col} và {.fn} được viết tắt cho cột và hàm đầu vào.\nBạn có thể chỉ định nhiều hàm bằng cách cung cấp danh sách (ví dụ: list(mean = mean, n_miss = ~ sum(.na(.x))).Nếu bạn cung cấp nhiều hàm, nhiều cột được chuyển đổi sẽ được trả về dựa trên mỗi cột ban đầu, với các tên duy nhất theo định dạng col_fn. Bạn có thể điều chỉnh cách đặt tên các cột mới với đối số .names = bằng cách sử dụng cú pháp glue (xem chương Ký tự và chuỗi) trong đó {.col} và {.fn} được viết tắt cho cột và hàm đầu vào.Dưới đây là một số tài nguyên trực tuyến về cách sử dụng hàm across(): creator Hadley Wickham’s thoughts/rationale","code":""},{"path":"cleaning.html","id":"hàm-coalesce","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Hàm coalesce()","text":"Hàm dplyr này tìm giá trị không bị thiếu đầu tiên tại mỗi vị trí. Nó “điền vào” các giá trị còn thiếu với giá trị có sẵn đầu tiên theo thứ tự bạn chỉ định.Đây là một ví dụ ngoài phạm vi của bộ dữ liệu: Giả sử bạn có hai vectơ, một vectơ chứa thông tin về làng nơi bệnh nhân được phát hiện và một vectơ chứa thông tin làng nơi bệnh nhân cư trú . Bạn có thể sử dụng hàm coalesce() để chọn giá trị không bị thiếu đầu tiên cho mỗi biến số:Điều này hoạt động tương tự nếu bạn cung cấp các cột trong bộ dữ liệu: đối với mỗi hàng, hàm sẽ gán giá trị cột mới với giá trị không bị thiếu đầu tiên trong các cột bạn đã cung cấp (theo thứ tự được cung cấp).Đây là một ví dụ về thao tác “theo hàng (row-wise)”. Để biết các phép tính theo hàng phức tạp hơn, hãy xem chương bên dưới về Tính toán theo hàng.","code":"\nvillage_detection <- c(\"a\", \"b\", NA,  NA)\nvillage_residence <- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage <- coalesce(village_detection, village_residence)\nvillage    # print## [1] \"a\" \"b\" \"a\" \"d\"\nlinelist <- linelist %>% \n  mutate(village = coalesce(village_detection, village_residence))"},{"path":"cleaning.html","id":"toán-lũy-tích","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Toán lũy tích","text":"Nếu bạn muốn một cột thể hiện tổng tích lũy/trung bình/tối thiểu/tối đa, v.v. như đánh giá các hàng của bộ dữ liệu cho đến thời điểm đó, hãy sử dụng các hàm sau:cumsum() trả về tổng tích lũy, như được hiển thị bên dưới:Điều này có thể được sử dụng trong bộ dữ liệu khi tạo một cột mới. Ví dụ: để tính toán số ca lũy tích mỗi ngày trong một đợt bùng dịch, hãy xem xét đoạn code như sau:Dưới đây là 10 hàng đầu tiên:Xem chương Đường cong dịch bệnh để biết cách lập biểu đồ các trường hợp mới mắc tích lũy với epicurve.Xem thêm:cumsum(), cummean(), cummin(), cummax(), cumany(), cumall()","code":"\nsum(c(2,4,15,10))     # returns only one number## [1] 31\ncumsum(c(2,4,15,10))  # returns the cumulative sum at each step## [1]  2  6 21 31\ncumulative_case_counts <- linelist %>%  # begin with case linelist\n  count(date_onset) %>%                 # count of rows per day, as column 'n'   \n  mutate(cumulative_cases = cumsum(n))  # new column, of the cumulative sum at each row\nhead(cumulative_case_counts, 10)##    date_onset n cumulative_cases\n## 1  2012-04-15 1                1\n## 2  2012-05-05 1                2\n## 3  2012-05-08 1                3\n## 4  2012-05-31 1                4\n## 5  2012-06-02 1                5\n## 6  2012-06-07 1                6\n## 7  2012-06-14 1                7\n## 8  2012-06-21 1                8\n## 9  2012-06-24 1                9\n## 10 2012-06-25 1               10"},{"path":"cleaning.html","id":"sử-dụng-base-r","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Sử dụng base R","text":"Để định nghĩa một cột mới (hoặc tái định nghĩa lại một cột) bằng cách sử dụng base R, hãy viết tên của bộ dữ liệu, được liên kết với $, vào tên cột mới (hoặc cột được sửa đổi). Sử dụng toán tử gán <- để xác định (các) giá trị mới. Hãy nhớ rằng khi sử dụng base R, bạn phải chỉ định tên bộ dữ liệu trước tên cột (ví dụ: dataframe$column). Đây là một ví dụ về cách tạo cột bmi bằng cách sử dụng base R:","code":"linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)"},{"path":"cleaning.html","id":"thêm-vào-chuỗi-pipe","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Thêm vào chuỗi pipe","text":"Dưới đây, một cột mới được thêm vào chuỗi pipe và một số phân lớp được chuyển đổi.","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    # add new column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% \n  \n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) "},{"path":"cleaning.html","id":"mã-hóa-lại-giá-trị","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.8 Mã hóa lại giá trị","text":"Dưới đây là một số tình huống mà bạn cần mã hóa lại (thay đổi) các giá trị:để chỉnh sửa một giá trị cụ thể (ví dụ: một ngày có năm hoặc định dạng không chính xác)để hợp nhất các giá trị được viết sai chính tảđể tạo một cột chứa giá trị phân loại mớiđể tạo một cột chứa danh mục số mới (ví dụ: danh mục độ tuổi)","code":""},{"path":"cleaning.html","id":"giá-trị-cụ-thể","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Giá trị cụ thể","text":"Để thay đổi các giá trị theo cách thủ công, bạn có thể sử dụng hàm recode() bên trong hàm mutate().Hãy tưởng tượng có một ngày không bình thường trong dữ liệu (ví dụ: “2014-14-15”): bạn có thể sửa ngày theo cách thủ công trong dữ liệu thô hoặc, bạn có thể ghi thay đổi trong chuỗi các bước làm sạch thông qua mutate() và recode(). Cách thứ hai sẽ rõ ràng hơn và có thể được tái lập lại cho bất kỳ ai khác muốn hiểu hoặc lặp lại phân tích của bạn.Dòng mutate() ở trên có thể được đọc là: “biến đổi cột date_onset bằng với cột date_onset sau khi được mã hóa lại để GIÁ TRỊ CŨ được đổi thành GIÁ TRỊ MỚI”. Lưu ý rằng cú pháp (CŨ = MỚI) này của hàm recode() ngược lại với hầu hết các cú pháp trong R (mới = cũ). Cộng đồng phát triển R đang làm việc để sửa đổi điều này.Sau đây là một ví dụ khác về việc mã hóa lại nhiều giá trị trong một cột.Trong bộ dữ liệu linelist, các giá trị trong cột “hospital” phải được làm sạch. Có một số cách viết khác nhau và nhiều giá trị bị thiếu.Lệnh recode() bên dưới tái định nghĩa lại cột “hospital” theo cột hiện tại “hospital”, nhưng với các thay đổi mã hóa được chỉ định. Đừng quên dấu phẩy sau mỗi dòng mã hóa lại!Bây giờ chúng ta thấy các cách viết trong cột hospital đã được sửa chữa và hợp nhất:MẸO: Số lượng khoảng trắng trước và sau dấu bằng không quan trọng. Hãy làm cho code của bạn dễ đọc hơn bằng cách căn chỉnh dấu = cho tất cả hoặc hầu hết các hàng. Ngoài ra, hãy cân nhắc thêm hàng bình luận để làm rõ cho người đọc biết bên nào CŨ và bên nào MỚI.MẸO: Đôi khi tồn tại một giá trị ký tự trống trong bộ dữ liệu (không được nhận dạng là giá trị missing của R - NA). Bạn có thể tham chiếu giá trị này bằng hai dấu ngoặc kép không có khoảng trắng ở giữa (““).","code":"\n# fix incorrect values                   # old value       # new value\nlinelist <- linelist %>% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\ntable(linelist$hospital, useNA = \"always\")  # print table of all unique values, including missing  ## \n##                      Central Hopital                     Central Hospital                           Hospital A                           Hospital B \n##                                   11                                  457                                  290                                  289 \n##                     Military Hopital                    Military Hospital                     Mitylira Hopital                    Mitylira Hospital \n##                                   32                                  798                                    1                                   79 \n##                                Other                         Port Hopital                        Port Hospital St. Mark's Maternity Hospital (SMMH) \n##                                  907                                   48                                 1756                                  417 \n##   St. Marks Maternity Hopital (SMMH)                                 <NA> \n##                                   11                                 1512\nlinelist <- linelist %>% \n  mutate(hospital = recode(hospital,\n                     # for reference: OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\ntable(linelist$hospital, useNA = \"always\")## \n##                     Central Hospital                           Hospital A                           Hospital B                    Military Hospital \n##                                  468                                  290                                  289                                  910 \n##                                Other                        Port Hospital St. Mark's Maternity Hospital (SMMH)                                 <NA> \n##                                  907                                 1804                                  428                                 1512"},{"path":"cleaning.html","id":"theo-logic","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Theo logic","text":"Dưới đây, chúng ta trình bày cách mã hóa lại các giá trị trong một cột bằng cách sử dụng logic và điều kiện:Sử dụng hàm replace(), ifelse() và if_else() cho logic đơn giảnSử dụng hàm case_when() cho logic phức tạp","code":""},{"path":"cleaning.html","id":"logic-đơn-giản","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Logic đơn giản","text":"","code":""},{"path":"cleaning.html","id":"replace","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"replace()","text":"Để mã hóa lại với các tiêu chí logic đơn giản, bạn có thể sử dụng hàm replace() bên trong hàm mutate(). replace() là một hàm từ base R. Sử dụng một điều kiện logic để cụ thể các hàng cần thay đổi. Cú pháp chung là:mutate(col_to_change = replace(col_to_change, criteria rows, new value)).Một tình huống phổ biến để sử dụng replace() là chỉ thay đổi một giá trị trong một hàng, bằng cách sử dụng định danh hàng duy nhất. Dưới đây, giới tính được thay đổi thành “Female” trong hàng mà cột case_id có giá trị là “2195”.Lệnh tương tự sử dụng cú pháp trong base R và dấu ngoặc vuông [] ở bên dưới. Nó có nội dung là “Thay đổi giá trị của cột gender trong bộ dữ liệu linelist (đối với các hàng mà cột case_id của linelist có giá trị ‘2195’) thành ‘Female’”.","code":"\n# Example: change gender of one specific observation to \"Female\" \nlinelist <- linelist %>% \n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\"))\nlinelist$gender[linelist$case_id == \"2195\"] <- \"Female\""},{"path":"cleaning.html","id":"ifelse-và-if_else","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"ifelse() và if_else()","text":"Một cách khác áp dụng cho logic đơn giản là hàm ifelse() và hàm tương tự là if_else(). Tuy nhiên, trong hầu hết các trường hợp để mã hóa lại, cách rõ ràng hơn là sử dụng hàm case_when() (chi tiết bên dưới). Câu lệnh “else” này là các phiên bản đơn giản hóa của câu lệnh lập trình và else. Cú pháp chung là:ifelse(condition, value return condition evaluates TRUE, value return condition evaluates FALSE)Dưới đây, cột source_known được định nghĩa. Giá trị của nó trong một hàng được đặt thành “known” nếu giá trị của hàng trong cột source không bị thiếu. Nếu thiếu giá trị trong cột source, thì giá trị trong source_known được đặt thành “unknown”.if_else() là một phiên bản đặc biệt từ package dplyr để xử lý ngày tháng. Lưu ý rằng nếu giá trị ‘true’ là một ngày thì giá trị ‘false’ cũng phải đủ điều kiện là một ngày, đó sử dụng giá trị đặc biệt NA_real_ thay vì chỉ NA.Tránh lồng ghép nhiều lệnh ifelse với nhau… thay vào đó hãy sử dụng case_when()! case_when() dễ đọc hơn và bạn sẽ mắc ít lỗi hơn.Ngoài phạm vi của bộ dữ liệu, nếu bạn muốn một đối tượng được sử dụng trong code của mình chuyển đổi giá trị của nó, hãy xem xét sử dụng hàm switch() từ base R.","code":"\nlinelist <- linelist %>% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n# Create a date of death column, which is NA if patient has not died.\nlinelist <- linelist %>% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))"},{"path":"cleaning.html","id":"clean_case_when","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Logic phức tạp","text":"Sử dụng case_when() của package dplyr nếu bạn đang mã hóa lại thành nhiều nhóm mới hoặc nếu bạn cần sử dụng các câu lệnh logic phức tạp để mã hóa lại các giá trị. Hàm này đánh giá mọi hàng trong bộ dữ liệu, đánh giá xem các hàng có đáp ứng các tiêu chí đã chỉ định hay không và chỉ định giá trị mới chính xác.Câu lệnh case_when() bao gồm hai cấu phần là Bên tay Phải (RHS) và Bên tay Trái (LHS) được phân tách bằng “dấu ngã” ~. Các tiêu chí logic nằm ở phía bên trái và các giá trị tương ứng nằm ở phía bên phải của mỗi mệnh đề. Các mệnh đề được phân tách bằng dấu phẩy.Ví dụ: chúng tôi sử dụng cột age và age_unit để tạo cột age_years:Khi mỗi hàng trong dữ liệu được đánh giá, các tiêu chí được áp dụng/đánh giá theo thứ tự đã viết trong case_when() - từ trên xuống dưới. Nếu tiêu chí hàng đầu đánh giá là TRUE cho một hàng nhất định, giá trị Bên tay phải sẽ được chỉ định và các tiêu chí còn lại thậm chí không được kiểm tra cho hàng đó. Vì vậy, tốt nhất là bạn nên viết các tiêu chí cụ thể nhất trước và cuối cùng là tiêu chí chung chung.Dọc theo những dòng đó, trong mệnh đề cuối cùng của bạn, hãy đặt TRUE ở phía bên trái để ghi lại bất kỳ hàng nào không đáp ứng bất kỳ tiêu chí nào trước đó. Phía bên phải của câu lệnh này có thể được gán một giá trị như “kiểm tra tôi! (check )” hoặc missing.NGUY HIỂM: Các giá trị ở phía bên phải đều phải cùng một phần lớp - số, ký tự, ngày tháng, lôgic, v.v. Để gán giá trị thiếu (NA), bạn có thể cần sử dụng các biến thể đặc biệt của NA như NA_character_, NA_real_ (cho số hoặc POSIX) và .Date(NA). Đọc thêm trong chương Làm việc với ngày tháng.","code":"\nlinelist <- linelist %>% \n  mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # if age is given in years\n            age_unit == \"months\" ~ age/12,    # if age is given in months\n            is.na(age_unit)      ~ age,       # if age unit is missing, assume years\n            TRUE                 ~ NA_real_)) # any other circumstance, assign missing"},{"path":"cleaning.html","id":"giá-trị-missing-1","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Giá trị missing","text":"Dưới đây là các hàm đặc biệt để xử lý các giá trị bị thiếu trong khi làm sạch dữ liệu.Xem chương về Dữ liệu Missing để biết thêm các mẹo chi tiết về xác định và xử lý các giá trị bị thiếu. Ví dụ, hàm .na() kiểm tra một cách logic sự thiếu giá trị.replace_na()Để thay đổi các giá trị bị thiếu (NA) thành một giá trị cụ thể, chẳng hạn như “Missing”, hãy sử dụng hàm replace_na() trong hàm mutate() trong package dplyr. Lưu ý rằng điều này được sử dụng theo cách tương tự như hàm recode ở trên - tên của biến phải được lặp lại trong replace_na().fct_explicit_na()Đây là một hàm từ package forcats. Package forcats xử lý các cột dạng Factor. Factor là cách của R để xử lý các giá trị có thứ tự như c(\"First\", \"Second\", \"Third\") hoặc để thiết lập thứ tự cho các giá trị (ví dụ: bệnh viện) xuất hiện trong bảng và biểu đồ. Xem chương Factors.Nếu dữ liệu của bạn là kiểu Factor và bạn đang cố gắng chuyển giá trị NA thành “Missing” bằng cách sử dụng hàm replace_na(), bạn sẽ gặp lỗi này: invalid factor level, NA generated. Bạn đã cố gắng thêm “Missing” làm giá trị, trong khi nó đã không được xác định là một thứ bậc trong cột Factor, và câu lệnh bị từ chối.Cách dễ nhất để giải quyết vấn đề này là sử dụng hàm forcats fct_explicit_na() để chuyển đổi một cột thành kiểu Factor và chuyển đổi các giá trị NA thành ký tự “(Missing)”.Một giải pháp thay thế chậm hơn sẽ là thêm thứ bậc cho cột Factor bằng cách sử dụng hàm fct_expand() và sau đó chuyển đổi các giá trị bị thiếu.na_if()Để chuyển đổi một giá trị cụ thể thành NA, hãy sử dụng hàm na_if() trong package dplyr. Hàm này thực hiện thao tác ngược lại với hàm replace_na(). Trong ví dụ bên dưới, bất kỳ giá trị nào bị “Missing” trong cột hospital đều được chuyển đổi thành NA.Lưu ý: na_if() không thể sử dụng cho điều kiện logic (ví dụ: “values > 99”) - hãy sử dụng replace() hoặc case_when() cho điều này:","code":"\nlinelist <- linelist %>% \n  mutate(hospital = replace_na(hospital, \"Missing\"))\nlinelist %>% \n  mutate(hospital = fct_explicit_na(hospital))\nlinelist <- linelist %>% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n# Convert temperatures above 40 to NA \nlinelist <- linelist %>% \n  mutate(temp = replace(temp, temp > 40, NA))\n\n# Convert onset dates earlier than 1 Jan 2000 to missing\nlinelist <- linelist %>% \n  mutate(date_onset = replace(date_onset, date_onset > as.Date(\"2000-01-01\"), NA))"},{"path":"cleaning.html","id":"từ-điển-làm-sạch","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Từ điển làm sạch","text":"Sử dụng package linelist trong R và hàm clean_variable_spelling() để làm sạch bộ dữ liệu bằng từ điển làm sạch. linelist là một package được phát triển bởi RECON - R Epidemics Consortium.Tạo từ điển làm sạch với 3 cột:\nCột “từ” (giá trị không chính xác)\nCột “tới” (giá trị chính xác)\nMột cột chỉ định cột cho các thay đổi sẽ được áp dụng (hoặc “.global” để áp dụng cho tất cả các cột)\nTạo từ điển làm sạch với 3 cột:Cột “từ” (giá trị không chính xác)Cột “tới” (giá trị chính xác)Một cột chỉ định cột cho các thay đổi sẽ được áp dụng (hoặc “.global” để áp dụng cho tất cả các cột)Lưu ý: các mục từ điển .global sẽ bị ghi đè bởi các mục từ điển theo cột cụ thể.Nạp tệp từ điển vào R. Ví dụ này có thể được tải xuống theo hướng dẫn trong chương Tải sách và dữ liệu.Chuyển bộ dữ liệu linelist ban đầu đến hàm clean_variable_spelling(), xác định wordlists = là bộ dữ liệu từ điển làm sạch. Đối số spelling_vars = có thể được sử dụng để chỉ định cột nào trong từ điển tham chiếu đến các cột khác (cột thứ 3 theo mặc định) hoặc có thể được đặt thành NULL để từ điển áp dụng cho tất cả các cột dạng ký tự và phân loại. Lưu ý rằng hàm này có thể mất nhiều thời gian để chạy.Bây giờ, hãy cuộn sang bên phải để xem các giá trị đã thay đổi như thế nào - đặc biệt là gender (chữ thường thành chữ hoa) và tất cả các cột triệu chứng đã được chuyển từ có/không thành 1/0.Lưu ý rằng tên cột của bạn trong từ điển làm sạch phải tương ứng với tên tại thời điểm trong script làm sạch của bạn. Xem tài liệu tham khảo trực tuyến về package linelist để biết thêm chi tiết.","code":"\ncleaning_dict <- import(\"cleaning_dict.csv\")\nlinelist <- linelist %>% \n  linelist::clean_variable_spelling(\n    wordlists = cleaning_dict,\n    spelling_vars = \"col\",        # dict column containing column names, defaults to 3rd column in dict\n  )"},{"path":"cleaning.html","id":"thêm-vào-chuỗi-làm-sạch","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Thêm vào chuỗi làm sạch","text":"Dưới đây, một số cột mới và biến đổi cột được thêm vào chuỗi các bước làm sạch.","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n  \n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n   # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n   ###################################################\n\n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))"},{"path":"cleaning.html","id":"num_cats","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.9 Biến danh mục số","text":"Ở đây chúng tôi mô tả một số cách tiếp cận đặc biệt để tạo cột dạng danh mục từ các cột dạng số. Các ví dụ phổ biến bao gồm danh mục độ tuổi, nhóm giá trị trong phòng thí nghiệm, v.v. Ở đây chúng ta sẽ thảo luận:age_categories(), từ package epikitcut(), từ base Rcase_when()Chia khoảng phân vị với quantile() ntile()","code":""},{"path":"cleaning.html","id":"đánh-giá-phân-phối","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Đánh giá phân phối","text":"Trong ví dụ này, chúng tôi sẽ tạo một cột age_cat bằng cách sử dụng cột age_years.Trước tiên, hãy kiểm tra phân phối dữ liệu của bạn để đưa ra các điểm cắt thích hợp. Xem chương ggplot cơ bản.CẨN TRỌNG: Đôi khi, các biến số sẽ được nhập vào dưới dạng kiểu “ký tự”. Điều này xảy ra nếu có các ký tự không phải số trong một số giá trị, ví dụ: có bản ghi nhập “2 tháng” cho biến tuổi hoặc (tùy thuộc vào cài đặt ngôn ngữ R của bạn) nếu dấu phẩy được sử dụng cho số thập phân (ví dụ: “4,5”nghĩa là bốn năm rưỡi).","code":"\n#check the class of the linelist variable age\nclass(linelist$age_years)## [1] \"numeric\"\n# examine the distribution\nhist(linelist$age_years)\nsummary(linelist$age_years, na.rm=T)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.04   23.00   84.00     107"},{"path":"cleaning.html","id":"age_categories","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"age_categories()","text":"Với package epikit, bạn có thể sử dụng hàm age_categories() để dễ dàng phân loại và gắn nhãn các cột dạng số (lưu ý: hàm này cũng có thể được áp dụng cho các biến ngoài biến tuổi). Như một “phần thưởng”, cột trả về tự động là một cột dạng factor có thứ tự.Dưới đây là các yêu cầu đầu vào:Một vectơ (cột) dạng sốĐối sốc breakers = - cung cấp một vectơ dạng số của các điểm cắt cho các phân nhóm mới.Đầu tiên, ví dụ đơn giản nhất:Các giá trị cắt bạn chỉ định mặc định là các giới hạn thấp hơn - nghĩa là chúng được đưa vào nhóm “cao hơn”/các nhóm “mở” ở phía dưới/bên trái. Như trình bày dưới đây, bạn có thể thêm 1 vào mỗi giá trị cắt để đạt được các nhóm mà được “mở” ở trên cùng/bên phải.Bạn có thể điều chỉnh cách hiển thị nhãn bằng separator =. Giá trị mặc định là “-”Bạn có thể điều chỉnh cách xử lý các số ở hàng đầu, với đối số ceiling =. Thiết lập mức giới hạn cắt trên với ceiling = TRUE. Trong cách sử dụng này, giá trị cắt cao nhất được cung cấp là “ceiling” và danh mục “XX+” không được tạo. Bất kỳ giá trị nào trên giá trị cắt cao nhất (hoặc upper =, nếu được xác định) đều được phân loại là NA. Dưới đây là một ví dụ với ceiling = TRUE, đó không có danh mục nào là XX + và các giá trị trên 70 (giá trị cắt cao nhất) được chỉ định là NA.Ngoài ra, thay vì dùng breakers =, bạn có thể sử dụng hàm lower =, upper =, và =:lower = Mức giới hạn thấp nhất bạn muốn xem xét - mặc định là 0upper = Mức giới hạn cao nhất bạn muốn xem xétby = Khoảng cách “năm” giữa các nhómXem thêm trang trợ giúp của hàm để biết thêm chi tiết (nhập ?age_categories trong R console).","code":"\n# Simple example\n################\npacman::p_load(epikit)                    # load package\n\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(             # create new column\n      age_years,                            # numeric column to make groups from\n      breakers = c(0, 5, 10, 15, 20,        # break points\n                   30, 40, 50, 60, 70)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  <NA> \n##  1227  1223  1048   827  1216   597   251    78    27     7   107\n# Include upper ends for the same categories\n############################################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  <NA> \n##  1469  1195  1040   770  1149   547   231    70    24     6   107\n# With ceiling set to TRUE\n##########################\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 is ceiling, all above become NA\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  <NA> \n##  1227  1223  1048   827  1216   597   251    78    28   113\nlinelist <- linelist %>% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")## \n##   0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  <NA> \n##  2450  1875  1216   597   251    78    27     6     1     0     0   107"},{"path":"cleaning.html","id":"cut","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"cut()","text":"Hàm cut() trong base R là một thay thế cho hàm age_categories(), nhưng tôi nghĩ bạn sẽ thấy lý tại sao hàm age_categories() được phát triển để đơn giản hóa quá trình này. Một số khác biệt đáng chú ý với hàm age_categories() là:Bạn không cần cài đặt/gọi package khácBạn có thể chỉ định xem các nhóm được mở/đóng ở bên phải/bên tráiBạn cần phải cung cấp nhãn chính xácNếu bạn muốn 0 được thêm vào trong nhóm thấp nhất, bạn cần phải cụ thể điều nàyCú pháp cơ bản trong cut() trước tiên là cung cấp cột dạng số cần xử lý (age_years), sau đó là đối số break, một vectơ dạng số c() bao gồm các điểm cắt. Sử dụng cut(), kết quả trả về là cột kiểu factor có thứ tự.Mặc định, việc phân loại xảy ra sao cho phía bên phải/phía trên là “mở” và có tính dung nạp (và phía bên trái/phía dưới là “đóng” hoặc tách biệt). Cách vận hành của hàm này ngược lại với hàm age_categories(). Các nhãn mặc định sử dụng ký hiệu “(,B]”, có nghĩa là không được bao gồm nhưng B thì có. Đảo ngược hành động này bằng cách cung cấp đối số right = TRUE.đó, theo mặc định, các giá trị “0” bị loại trừ khỏi nhóm thấp nhất và được phân loại là NA! Giá trị “0” có thể là trẻ sơ sinh được mã hóa là 0 tuổi, vì vậy hãy thật thận trọng! Để thay đổi điều này, hãy thêm argument include.lowest = TRUE để mọi giá trị “0” sẽ được đưa vào nhóm thấp nhất. Nhãn được tạo tự động cho danh mục thấp nhất sau đó sẽ là “[],B]”. Lưu ý rằng nếu bạn thêm include.lowest = TRUE và right = TRUE, hành động này bây giờ sẽ áp dụng cho điểm cắt giá trị cao nhất và phân loại, không phải điểm thấp nhất.Bạn có thể cung cấp một vectơ nhãn tùy chỉnh bằng cách sử dụng argument labels =. Vì chúng được viết theo cách thủ công, hãy rất cẩn thận để đảm bảo chúng chính xác! Kiểm tra bằng cách lập bảng chéo, như được mô tả bên dưới.Dưới đây là một ví dụ về hàm cut() được áp dụng cho biến age_years để tạo biến age_cat mới:Kiểm tra đoạn code của bạn!!! Hãy chắc chắn rằng mỗi giá trị độ tuổi đã được chỉ định đúng danh mục bằng cách lập bảng chéo giữa các cột số và danh mục. Kiểm tra việc gán các giá trị ranh giới (ví dụ: 15, nếu các danh mục lân cận là 10-15 và 16-20).Gán nhãn giá trị NABạn có thể muốn gán nhãn cho các giá trị NA chẳng hạn như “Missing”. Bởi vì cột mới có kiểu Factor (số giá trị bị hạn chế), bạn không thể chỉ đơn giản thay đổi nó bằng replace_na(), vì giá trị này sẽ không được chấp nhận. Thay vào đó, hãy sử dụng hàm fct_explicit_na() từ package forcats như được giải thích trong chương Factors.Tạo nhanh điểm cắt và dán nhãnĐể nhanh chóng tạo điểm cắt và gắn nhãn vectơ, hãy thực hành như bên dưới. Xem chương R cơ bản về hàm seq() và rep().Đọc thêm về hàm cut() trong trang Trợ giúp của hàm bằng cách nhập ?cut trong R console.","code":"\n# Create new variable, by cutting the numeric age variable\n# lower break is excluded but upper break is included in each category\nlinelist <- linelist %>% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # include 0 in lowest group\n      ))\n\n# tabulate the number of observations per group\ntable(linelist$age_cat, useNA = \"always\")## \n##    [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100]     <NA> \n##     1469     1195     1040      770     1149      778       94        6      107\n# Cross tabulation of the numeric and category columns. \ntable(\"Numeric Values\" = linelist$age_years,   # names specified in table for clarity.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # don't forget to examine NA values##                     Categories\n## Numeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70] (70,100] <NA>\n##   0                    136      0       0       0       0       0       0        0    0\n##   0.0833333333333333     1      0       0       0       0       0       0        0    0\n##   0.25                   2      0       0       0       0       0       0        0    0\n##   0.333333333333333      6      0       0       0       0       0       0        0    0\n##   0.416666666666667      1      0       0       0       0       0       0        0    0\n##   0.5                    6      0       0       0       0       0       0        0    0\n##   0.583333333333333      3      0       0       0       0       0       0        0    0\n##   0.666666666666667      3      0       0       0       0       0       0        0    0\n##   0.75                   3      0       0       0       0       0       0        0    0\n##   0.833333333333333      1      0       0       0       0       0       0        0    0\n##   0.916666666666667      1      0       0       0       0       0       0        0    0\n##   1                    275      0       0       0       0       0       0        0    0\n##   1.5                    2      0       0       0       0       0       0        0    0\n##   2                    308      0       0       0       0       0       0        0    0\n##   3                    246      0       0       0       0       0       0        0    0\n##   4                    233      0       0       0       0       0       0        0    0\n##   5                    242      0       0       0       0       0       0        0    0\n##   6                      0    241       0       0       0       0       0        0    0\n##   7                      0    256       0       0       0       0       0        0    0\n##   8                      0    239       0       0       0       0       0        0    0\n##   9                      0    245       0       0       0       0       0        0    0\n##   10                     0    214       0       0       0       0       0        0    0\n##   11                     0      0     220       0       0       0       0        0    0\n##   12                     0      0     224       0       0       0       0        0    0\n##   13                     0      0     191       0       0       0       0        0    0\n##   14                     0      0     199       0       0       0       0        0    0\n##   15                     0      0     206       0       0       0       0        0    0\n##   16                     0      0       0     186       0       0       0        0    0\n##   17                     0      0       0     164       0       0       0        0    0\n##   18                     0      0       0     141       0       0       0        0    0\n##   19                     0      0       0     130       0       0       0        0    0\n##   20                     0      0       0     149       0       0       0        0    0\n##   21                     0      0       0       0     158       0       0        0    0\n##   22                     0      0       0       0     149       0       0        0    0\n##   23                     0      0       0       0     125       0       0        0    0\n##   24                     0      0       0       0     144       0       0        0    0\n##   25                     0      0       0       0     107       0       0        0    0\n##   26                     0      0       0       0     100       0       0        0    0\n##   27                     0      0       0       0     117       0       0        0    0\n##   28                     0      0       0       0      85       0       0        0    0\n##   29                     0      0       0       0      82       0       0        0    0\n##   30                     0      0       0       0      82       0       0        0    0\n##   31                     0      0       0       0       0      68       0        0    0\n##   32                     0      0       0       0       0      84       0        0    0\n##   33                     0      0       0       0       0      78       0        0    0\n##   34                     0      0       0       0       0      58       0        0    0\n##   35                     0      0       0       0       0      58       0        0    0\n##   36                     0      0       0       0       0      33       0        0    0\n##   37                     0      0       0       0       0      46       0        0    0\n##   38                     0      0       0       0       0      45       0        0    0\n##   39                     0      0       0       0       0      45       0        0    0\n##   40                     0      0       0       0       0      32       0        0    0\n##   41                     0      0       0       0       0      34       0        0    0\n##   42                     0      0       0       0       0      26       0        0    0\n##   43                     0      0       0       0       0      31       0        0    0\n##   44                     0      0       0       0       0      24       0        0    0\n##   45                     0      0       0       0       0      27       0        0    0\n##   46                     0      0       0       0       0      25       0        0    0\n##   47                     0      0       0       0       0      16       0        0    0\n##   48                     0      0       0       0       0      21       0        0    0\n##   49                     0      0       0       0       0      15       0        0    0\n##   50                     0      0       0       0       0      12       0        0    0\n##   51                     0      0       0       0       0       0      13        0    0\n##   52                     0      0       0       0       0       0       7        0    0\n##   53                     0      0       0       0       0       0       4        0    0\n##   54                     0      0       0       0       0       0       6        0    0\n##   55                     0      0       0       0       0       0       9        0    0\n##   56                     0      0       0       0       0       0       7        0    0\n##   57                     0      0       0       0       0       0       9        0    0\n##   58                     0      0       0       0       0       0       6        0    0\n##   59                     0      0       0       0       0       0       5        0    0\n##   60                     0      0       0       0       0       0       4        0    0\n##   61                     0      0       0       0       0       0       2        0    0\n##   62                     0      0       0       0       0       0       1        0    0\n##   63                     0      0       0       0       0       0       5        0    0\n##   64                     0      0       0       0       0       0       1        0    0\n##   65                     0      0       0       0       0       0       5        0    0\n##   66                     0      0       0       0       0       0       3        0    0\n##   67                     0      0       0       0       0       0       2        0    0\n##   68                     0      0       0       0       0       0       1        0    0\n##   69                     0      0       0       0       0       0       3        0    0\n##   70                     0      0       0       0       0       0       1        0    0\n##   72                     0      0       0       0       0       0       0        1    0\n##   73                     0      0       0       0       0       0       0        3    0\n##   76                     0      0       0       0       0       0       0        1    0\n##   84                     0      0       0       0       0       0       0        1    0\n##   <NA>                   0      0       0       0       0       0       0        0  107\nlinelist <- linelist %>% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(\n    age_years,\n    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n    right = FALSE,\n    include.lowest = TRUE,        \n    labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n    # make missing values explicit\n    age_cat = fct_explicit_na(\n      age_cat,\n      na_level = \"Missing age\")  # you can specify the label\n  )    \n\n# table to view counts\ntable(linelist$age_cat, useNA = \"always\")## \n##         0-4         5-9       10-14       15-19       20-29       30-49       50-69      70-100 Missing age        <NA> \n##        1227        1223        1048         827        1216         848         105           7         107           0\n# Make break points from 0 to 90 by 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Make labels for the above categories, assuming default cut() settings\nage_labels = paste0(age_seq + 1, \"-\", age_seq + 5)\nage_labels\n\n# check that both vectors are the same length\nlength(age_seq) == length(age_labels)"},{"path":"cleaning.html","id":"chia-khoảng-phân-vị","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Chia khoảng phân vị","text":"Theo cách hiểu thông thường, “phân vị” hoặc “phần trăm” thường đề cập đến một giá trị dưới ngưỡng tỷ lệ đang được đề cập. Ví dụ: phân vị thứ thứ 95 của biến độ tuổi trong linelist sẽ là các độ tuổi dưới 95% độ tuổi.Tuy nhiên, trong cách nói thông thường, “tứ phân vị” và “thập phân vị” cũng có thể đề cập đến phân nhóm dữ liệu được chia đều thành 4 hoặc 10 nhóm (lưu ý sẽ có thêm một điểm cắt với số nhóm).Để nhận biết điểm cắt của khoảng phân vị, bạn có thể sử dụng hàm quantile() từ package stats trong base R. Bạn cung cấp một vectơ số (ví dụ: một cột trong bộ dữ liệu) và vectơ các giá trị xác suất số từ 0 đến 1. Các điểm cắt được trả về dưới dạng một vectơ số. Đọc thêm chi tiết các phương pháp thống kê bằng cách nhập ?quantile.Nếu vectơ số đầu vào của bạn có bất kỳ giá trị nào bị thiếu, tốt nhất nên thiết lập na.rm = TRUEThiết lậpnames = FALSE để lấy một vectơ số chưa được đặt tênBạn có thể sử dụng kết quả của quantile() làm điểm cắt trong age_categories() hoặc cut(). Dưới đây, chúng ta tạo một cột deciles mới bằng cách sử dụng hàm cut() trong đó các dấu ngắt được xác định bằng cách sử dụng hàm quantiles() trên cột age_years. Sau đó, chúng ta hiển thị kết quả bằng hàm tabyl() từ package janitor để bạn có thể xem tỷ lệ phần trăm (xem chương Bảng mô tả). Lưu ý rằng chúng không chính xác là 10% trong mỗi nhóm.","code":"\nquantile(linelist$age_years,               # specify numeric vector to work on\n  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want\n  na.rm = TRUE)                            # ignore missing values ##  0% 25% 50% 75% 90% 95% \n##   0   6  13  23  33  41\nlinelist %>%                                # begin with linelist\n  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years\n    breaks = quantile(                      # define cut breaks using quantile()\n      age_years,                               # operate on age_years\n      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1\n      na.rm = TRUE),                           # ignore missing values\n    include.lowest = TRUE)) %>%             # for cut() include age 0\n  janitor::tabyl(deciles)                   # pipe to table to display##  deciles   n    percent valid_percent\n##    [0,2] 748 0.11319613    0.11505922\n##    (2,5] 721 0.10911017    0.11090601\n##    (5,7] 497 0.07521186    0.07644978\n##   (7,10] 698 0.10562954    0.10736810\n##  (10,13] 635 0.09609564    0.09767728\n##  (13,17] 755 0.11425545    0.11613598\n##  (17,21] 578 0.08746973    0.08890940\n##  (21,26] 625 0.09458232    0.09613906\n##  (26,33] 596 0.09019370    0.09167820\n##  (33,84] 648 0.09806295    0.09967697\n##     <NA> 107 0.01619249            NA"},{"path":"cleaning.html","id":"nhóm-có-khoảng-đều","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Nhóm có khoảng đều","text":"Một công cụ khác để tạo nhóm dạng số là hàm ntile() trong package dplyr, cố gắng chia dữ liệu của bạn thành n nhóm có khoảng cách đều - nhưng lưu ý rằng không giống như với quantile(), cùng một giá trị có thể xuất hiện trong nhiều nhóm. Cung cấp vectơ số và sau đó là số lượng nhóm. Các giá trị trong cột mới được tạo chỉ là nhóm “số” (ví dụ: 1 đến 10), không phải phạm vi giá trị như khi sử dụng hàm cut().","code":"\n# make groups with ntile()\nntile_data <- linelist %>% \n  mutate(even_groups = ntile(age_years, 10))\n\n# make table of counts and proportions by group\nntile_table <- ntile_data %>% \n  janitor::tabyl(even_groups)\n  \n# attach min/max values to demonstrate ranges\nntile_ranges <- ntile_data %>% \n  group_by(even_groups) %>% \n  summarise(\n    min = min(age_years, na.rm=T),\n    max = max(age_years, na.rm=T)\n  )## Warning in min(age_years, na.rm = T): no non-missing arguments to min; returning Inf## Warning in max(age_years, na.rm = T): no non-missing arguments to max; returning -Inf\n# combine and print - note that values are present in multiple groups\nleft_join(ntile_table, ntile_ranges, by = \"even_groups\")##  even_groups   n    percent valid_percent min  max\n##            1 651 0.09851695    0.10013844   0    2\n##            2 650 0.09836562    0.09998462   2    5\n##            3 650 0.09836562    0.09998462   5    7\n##            4 650 0.09836562    0.09998462   7   10\n##            5 650 0.09836562    0.09998462  10   13\n##            6 650 0.09836562    0.09998462  13   17\n##            7 650 0.09836562    0.09998462  17   21\n##            8 650 0.09836562    0.09998462  21   26\n##            9 650 0.09836562    0.09998462  26   33\n##           10 650 0.09836562    0.09998462  33   84\n##           NA 107 0.01619249            NA Inf -Inf"},{"path":"cleaning.html","id":"case_when","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"case_when()","text":"Có thể sử dụng hàm case_when() từ dplyr để tạo biến danh mục từ cột số, tuy nhiên điều này được thực hiện dễ dàng hơn với hàm age_categories() từ epikit hoặc cut() vì chúng sẽ tự động tạo ra một biến factor có thứ tự.Nếu sử dụng case_when(), vui lòng xem lại cách sử dụng thích hợp như đã mô tả trước đó trong mục Mã hóa lại giá trị. Cũng lưu ý rằng tất cả các giá trị bên tay phải phải thuộc cùng một kiểu. đó, nếu bạn muốn giá trị NA ở phía bên phải, bạn nên viết “Missing” hoặc sử dụng giá trị NA đặc biệt là NA_character_.","code":""},{"path":"cleaning.html","id":"thêm-vào-chuỗi-làm-sạch-1","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Thêm vào chuỗi làm sạch","text":"Dưới đây, code để tạo hai cột phân loại tuổi được thêm vào chuỗi các bước làm sạch:","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################   \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))"},{"path":"cleaning.html","id":"thêm-hàng","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.10 Thêm hàng","text":"","code":""},{"path":"cleaning.html","id":"thêm-từng-hàng-một","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Thêm từng hàng một","text":"Việc thêm từng hàng một theo cách thủ công là rất nhàm chán nhưng có thể được thực hiện với hàm add_row() từ package dplyr. Hãy nhớ rằng mỗi cột chỉ được chứa các giá trị của một phân lớp (ký tự, số, lôgic, v.v.). Vì vậy, khi thêm một hàng cần chú ý tới điều này.Sử dụng .và .. để cụ thể vị trí của hàng bạn muốn thêm. .= 3 sẽ cho phép hàng mới được thêm trước hàng thứ 3 hiện tại. Mặc định thì hàng sẽ được thêm vào dòng cuối cùng. Các cột không được chỉ định sẽ được để trống (NA).Số thứ tự hàng mới có thể trông lạ (“… 23”) nhưng số thứ tự hàng trong các hàng tồn tại trước đó đã thay đổi. Vì vậy, nếu sử dụng lệnh hai lần, hãy kiểm tra/thử việc chèn một cách cẩn thận.Nếu một phân lớp bạn cung cấp không hoạt động, bạn sẽ thấy báo lỗi như sau:(khi chèn một hàng có giá trị ngày tháng, hãy nhớ đặt thông tin .Date() ví dụ như .Date(\"2020-10-10\")).","code":"\nlinelist <- linelist %>% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)Error: Can't combine ..1$infection date <date> and ..2$infection date <character>."},{"path":"cleaning.html","id":"nối-các-hàng","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Nối các hàng","text":"Để kết hợp các bộ dữ liệu với nhau bằng cách liên kết các hàng của một bộ dữ liệu này với phần cuối bộ dữ liệu khác, bạn có thể sử dụng hàm bind_rows() từ dplyr. Điều này được giải thích chi tiết hơn trong chương Nối dữ liệu.","code":""},{"path":"cleaning.html","id":"lọc-hàng","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.11 Lọc hàng","text":"Bước làm sạch điển hình sau khi bạn đã làm sạch các cột và các giá trị được mã hóa lại đó là lọc bộ dữ liệu cho các hàng cụ thể bằng cách sử dụng hàm filter() trong package dplyr.Trong hàm filter(), hãy cụ thể điều kiện logic phải là giá trị TRUE cho một hàng được giữ trong bộ dữ liệu. Dưới đây chúng tôi trình bày cách lọc hàng dựa trên điều kiện logic đơn giản và phức tạp.","code":""},{"path":"cleaning.html","id":"lọc-đơn-giản","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Lọc đơn giản","text":"Ví dụ đơn giản này định nghĩa lại bộ dữ liệu linelist, đã lọc các hàng để đáp ứng điều kiện logic. Chỉ những hàng mà câu lệnh logic trong dấu ngoặc đơn đánh giá là TRUE mới được giữ lại.Trong ví dụ này, câu lệnh logic là gender == \"f\", được hỏi liệu giá trị trong cột gender có bằng “f” (phân biệt chữ hoa chữ thường) hay không.Trước khi bộ lọc được áp dụng, số hàng trong linelist là nrow(linelist).Sau khi bộ lọc được áp dụng, số hàng trong linelist là linelist %>% filter(gender == \"f\") %>% nrow().","code":"\nlinelist <- linelist %>% \n  filter(gender == \"f\")   # keep only rows where gender is equal to \"f\""},{"path":"cleaning.html","id":"lọc-bỏ-các-giá-trị-missing","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Lọc bỏ các giá trị missing","text":"Một điều khá phổ biến là bạn muốn lọc bỏ các hàng có giá trị missing. Hãy bỏ qua cách lọc cổ điển filter(!.na(column) & !.na(column)) và thay vào đó, hãy sử dụng hàm drop_na() trong package tidyr được xây dựng để tùy chỉnh cho mục đích này. Nếu chạy với dấu ngoặc trống, nó sẽ loại bỏ các hàng có bất kỳ giá trị nào bị missing. Ngoài ra, bạn có thể cung cấp tên của các cột cụ thể sẽ được đánh giá về mức độ missing hoặc sử dụng các hàm trợ giúp “tidyselect” như được mô tả ở trên.Xem chương về Dữ liệu Missing để biết nhiều kỹ thuật phân tích và quản lý dữ liệu missing.","code":"\nlinelist %>% \n  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years"},{"path":"cleaning.html","id":"lọc-bằng-số-thứ-tự-của-hàng","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Lọc bằng số thứ tự của hàng","text":"Trong một data frame hoặc tibble, mỗi hàng thường sẽ có một “số thứ tự” (khi xem trong R Viewer) xuất hiện ở bên trái của cột đầu tiên. Bản thân nó không phải là một cột trong dữ liệu, nhưng nó có thể được sử dụng trong câu lệnh filter().Để lọc dựa trên “số thứ tự của hàng”, bạn có thể sử dụng hàm dplyr row_number() với “dấu ngoặc đơn mở” như một phần của câu lệnh lọc logic. Thường thì bạn sẽ sử dụng toán tử %% và một dãy số như một phần của câu lệnh logic đó, như được trình bày bên dưới. Để xem N hàng đầu tiên, bạn cũng có thể sử dụng hàm đặc biệt head() trong package dplyr.Bạn cũng có thể chuyển đổi số thứ tự hàng thành cột bằng cách sử dụng hàm tibble rownames_to_column() (không viết bất kỳ ký tự nào trong dấu ngoặc đơn).","code":"\n# View first 100 rows\nlinelist %>% head(100)     # or use tail() to see the n last rows\n\n# Show row 5 only\nlinelist %>% filter(row_number() == 5)\n\n# View rows 2 through 20, and three specific columns\nlinelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)"},{"path":"cleaning.html","id":"lọc-phức-tạp","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Lọc phức tạp","text":"Các câu lệnh logic phức tạp hơn có thể được xây dựng bằng cách sử dụng các toán tử ngoặc đơn ( ), HOẶC |, PHỦ ĐỊNH !, %%, và VÀ &. Dưới đây là một ví dụ:Lưu ý: Bạn có thể sử dụng ! trước một mệnh đề logic để phủ định nó. Ví dụ, !.na(column) trả về giá trị TRUE nếu cột đó không bị thiếu giá trị. Tương tự như vậy !column %% c(\"\", \"b\", \"c\") trả về kết quả là TRUE nếu giá trị cột không có trong vectơ.","code":""},{"path":"cleaning.html","id":"kiểm-tra-dữ-liệu","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Kiểm tra dữ liệu","text":"Dưới đây là một dòng lệnh đơn giản để tạo biểu đồ các ngày bắt đầu. Chúng ta thấy rằng có một đợt bùng phát nhỏ thứ hai từ năm 2012-2013 cũng được bao gồm trong tập bộ liệu thô này. Trong các phân tích, chúng ta muốn xóa các bản ghi từ đợt bùng phát sớm.","code":"\nhist(linelist$date_onset, breaks = 50)"},{"path":"cleaning.html","id":"cách-lọc-và-xử-lý-các-giá-trị-số-và-ngày-bị-missing","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Cách lọc và xử lý các giá trị số và ngày bị missing","text":"Chúng ta có thể chỉ lọc theo date_onset đến những hàng sau tháng 6 năm 2013 không? Lưu ý! Việc áp dụng code filter(date_onset > .Date(\"2013-06-01\"))) sẽ xóa bất kỳ hàng nào trong đợt dịch sau đó có ngày bắt đầu bị thiếu!NGUY HIỂM: Việc lọc với điều kiện lớn hơn (>) hoặc nhỏ hơn (<) một ngày hoặc số có thể loại bỏ bất kỳ hàng nào có giá trị bị thiếu (NA)! Điều này là NA được coi là giá trị lớn hoặc nhỏ vô hạn.(Xem chương Làm việc với ngày tháng để biết thêm thông tin về cách xử lý với ngày tháng và package lubridate)","code":""},{"path":"cleaning.html","id":"thiết-kế-bộ-lọc","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Thiết kế bộ lọc","text":"Lập một bảng chéo để đảm bảo rằng chúng ta chỉ loại bỏ các hàng cần loại bỏ:Liệu chúng ta có thể lọc theo tiêu chí nào khác để loại bỏ đợt bùng phát đầu tiên (trong năm 2012 & 2013) khỏi bộ dữ liệu? Chúng ta thấy rằng:Vụ dịch đầu tiên năm 2012 & 2013 xảy ra tại Hospital , Hospital B, tại Port Hospital cũng có 10 trường hợp mắc.Hospital & B không có ca bệnh nào trong đợt dịch thứ hai, nhưng Port Hospital thì có.Chúng ta muốn loại bỏ:Các dòng nrow(linelist %>% filter(hospital %% c(\"Hospital \", \"Hospital B\") | date_onset < .Date(\"2013-06-01\"))) bắt đầu vào năm 2012 và 2013 tại Hospital , B hoặc Port Hospital:\nLoại trừ các hàng nrow(linelist %>% filter(date_onset < .Date(\"2013-06-01\"))) bắt đầu vào năm 2012 và 2013\nLoại trừ các hàng nrow(linelist %>% filter(hospital %% c('Hospital ', 'Hospital B') & .na(date_onset))) từ Hospital và B với các giá trị ngày bị thiếu\nKhông loại bỏ các dòng khác nrow(linelist %>% filter(!hospital %% c('Hospital ', 'Hospital B') & .na(date_onset))) bị thiếu ngày bắt đầu.\nCác dòng nrow(linelist %>% filter(hospital %% c(\"Hospital \", \"Hospital B\") | date_onset < .Date(\"2013-06-01\"))) bắt đầu vào năm 2012 và 2013 tại Hospital , B hoặc Port Hospital:Loại trừ các hàng nrow(linelist %>% filter(date_onset < .Date(\"2013-06-01\"))) bắt đầu vào năm 2012 và 2013Loại trừ các hàng nrow(linelist %>% filter(hospital %% c('Hospital ', 'Hospital B') & .na(date_onset))) từ Hospital và B với các giá trị ngày bị thiếuKhông loại bỏ các dòng khác nrow(linelist %>% filter(!hospital %% c('Hospital ', 'Hospital B') & .na(date_onset))) bị thiếu ngày bắt đầu.Chúng ta bắt đầu với linelist bằng câu lệnh nrow(linelist). Đây là toàn bộ câu lệnh lọc của chúng ta:Khi chúng ta lập lại bảng chéo, chúng ta thấy rằng Hospital & B bị loại bỏ hoàn toàn, và 10 trường hợp của Port Hospital từ năm 2012 & 2013 bị loại bỏ và tất cả các giá trị khác đều tương tự - đúng như ý chúng ta muốn.Nhiều biểu thức có thể được bao hàm trong một lệnh lọc (được phân tách bằng dấu phẩy) hoặc bạn luôn có thể viết chúng riêng biệt và nối tiếp nhau trong chuỗi các bước làm sạch để rõ ràng hơn.Ghi chú: một số độc giả có thể nhận thấy rằng sẽ dễ dàng hơn nếu chỉ lọc theo date_hospitalisation vì nó hoàn chỉnh 100% mà không có giá trị nào bị thiếu. Đây là sự thật. Nhưng date_onset được sử dụng cho mục đích thể hiện sự phức tạp của việc lọc.","code":"\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\n## Hospital                               2012 2013 2014 2015 <NA>\n##   Central Hospital                        0    0  351   99   18\n##   Hospital A                            229   46    0    0   15\n##   Hospital B                            227   47    0    0   15\n##   Military Hospital                       0    0  676  200   34\n##   Missing                                 0    0 1117  318   77\n##   Other                                   0    0  684  177   46\n##   Port Hospital                           9    1 1372  347   75\n##   St. Mark's Maternity Hospital (SMMH)    0    0  322   93   13\n##   <NA>                                    0    0    0    0    0\nlinelist <- linelist %>% \n  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B\n  filter(date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)## [1] 6019\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values##                                       YearOnset\n## Hospital                               2014 2015 <NA>\n##   Central Hospital                      351   99   18\n##   Military Hospital                     676  200   34\n##   Missing                              1117  318   77\n##   Other                                 684  177   46\n##   Port Hospital                        1372  347   75\n##   St. Mark's Maternity Hospital (SMMH)  322   93   13\n##   <NA>                                    0    0    0"},{"path":"cleaning.html","id":"độc-lập","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Độc lập","text":"Việc lọc cũng có thể được thực hiện như một lệnh độc lập (không phải là một phần của chuỗi các bước làm sạch). Giống như các hàm dplyr khác, trong trường hợp này, đối số đầu tiên phải chính là bộ dữ liệu.Bạn cũng có thể sử dụng base R để chia nhỏ dữ liệu bằng cách sử dụng dấu ngoặc đểm tham chiếu tới [hàng, cột] mà bạn muốn giữ lại.","code":"\n# dataframe <- filter(dataframe, condition(s) for rows to keep)\n\nlinelist <- filter(linelist, !is.na(case_id))\n# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)\n\nlinelist <- linelist[!is.na(case_id), ]"},{"path":"cleaning.html","id":"xem-nhanh-các-bản-ghi","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Xem nhanh các bản ghi","text":"Thường thì bạn muốn xem nhanh một vài bản ghi, chỉ cho một vài cột. Hàm View() trong base R sẽ hiển thị một khung dữ liệu để xem trong RStudio.Xem linelist trong RStudio:Dưới đây là hai ví dụ về việc xem các ô cụ thể (hàng cụ thể và cột cụ thể):Với hàm filter() và select() trong dplyr:Với hàm View(), chuyển tiếp bộ dữ liệu đến hàm filter() để giữ các hàng nhất định và sau đó select() để giữ các cột nhất định. Ví dụ, để xem xét ngày khởi phát và nhập viện của 3 trường hợp cụ thể:Bạn có thể đạt được điều tương tự với cú pháp trong base R, sử dụng dấu ngoặc [ ] cho tập hợp con bạn muốn xem.","code":"\nView(linelist)\nView(linelist %>%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %>%\n       select(date_onset, date_hospitalisation))\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])"},{"path":"cleaning.html","id":"thêm-vào-chuỗi-làm-sạch-2","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"Thêm vào chuỗi làm sạch","text":"","code":"\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist <- linelist_raw %>%\n    \n    # standardize column name syntax\n    janitor::clean_names() %>% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %>% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %>% \n  \n    # de-duplicate\n    distinct() %>% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %>% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %>% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %>% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %>% \n  \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset > as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))"},{"path":"cleaning.html","id":"tính-toán-theo-hàng","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.12 Tính toán theo hàng","text":"Nếu bạn muốn thực hiện một phép tính trong một hàng, bạn có thể sử dụng hàm rowwise() từ dplyr. Xem chi tiết tại row-wise calculations.\nVí dụ: code này sử dụng hàm rowwise() và sau đó tạo một cột mới là tổng số cột triệu chứng được chứa giá trị “có”, cho mỗi hàng trong linelist. Các cột được cụ thể trong hàm sum() theo tên trong vectơ c(). Hàm rowwise() về cơ bản là một hình thức group_by() đặc biệt, vì vậy tốt nhất bạn nên sử dụng ungroup() khi bạn hoàn tất (trong chương Nhóm dữ liệu).Khi bạn chỉ định cột để đánh giá, bạn có thể muốn sử dụng các hàm trợ giúp “tidyselect” như được mô tả trong mục select() của chương này. Bạn chỉ cần thực hiện một điều chỉnh (vì bạn đang không sử dụng chúng bên trong một hàm của dplyr như select() hoặc summarise()).Đặt tiêu chí đặc tả cột trong hàm dplyr là c_across(). Điều này là hàm c_across (tài liệu) được thiết kế để hoạt động cụ thể với hàm rowwise(). Ví dụ, như đoạn code sau:Áp dụng rowwise() nên bước tiếp theo (sum()) được áp dụng trong mỗi hàng (không tính tổng toàn bộ các cột)Tạo cột mới num_NA_dates, được xác định cho mỗi hàng là số cột (có tên chứa “ngày tháng”) mà .na() trả về giá trị TRUE (nghĩa là chúng bị thiếu dữ liệu)ungroup() để loại bỏ ảnh hưởng của rowwise() cho các bước tiếp theoBạn cũng có thể cung cấp các hàm khác, chẳng hạn như max() để lấy ngày mới nhất hoặc gần đây nhất cho mỗi hàng:","code":"\nlinelist %>%\n  rowwise() %>%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %>% \n  ungroup() %>% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # for display## # A tibble: 5,888 x 6\n##    fever chills cough aches vomit num_symptoms\n##    <chr> <chr>  <chr> <chr> <chr>        <int>\n##  1 no    no     yes   no    yes              2\n##  2 <NA>  <NA>   <NA>  <NA>  <NA>            NA\n##  3 <NA>  <NA>   <NA>  <NA>  <NA>            NA\n##  4 no    no     no    no    no               0\n##  5 no    no     yes   no    yes              2\n##  6 no    no     yes   no    yes              2\n##  7 <NA>  <NA>   <NA>  <NA>  <NA>            NA\n##  8 no    no     yes   no    yes              2\n##  9 no    no     yes   no    yes              2\n## 10 no    no     yes   no    no               1\n## # ... with 5,878 more rows\nlinelist %>%\n  rowwise() %>%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %>% \n  ungroup() %>% \n  select(num_NA_dates, contains(\"date\")) # for display## # A tibble: 5,888 x 5\n##    num_NA_dates date_infection date_onset date_hospitalisation date_outcome\n##           <int> <date>         <date>     <date>               <date>      \n##  1            1 2014-05-08     2014-05-13 2014-05-15           NA          \n##  2            1 NA             2014-05-13 2014-05-14           2014-05-18  \n##  3            1 NA             2014-05-16 2014-05-18           2014-05-30  \n##  4            1 2014-05-04     2014-05-18 2014-05-20           NA          \n##  5            0 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n##  6            0 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n##  7            0 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n##  8            0 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n##  9            1 NA             2014-06-05 2014-06-06           2014-06-18  \n## 10            1 NA             2014-06-05 2014-06-07           2014-06-09  \n## # ... with 5,878 more rows\nlinelist %>%\n  rowwise() %>%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %>% \n  ungroup() %>% \n  select(latest_date, contains(\"date\"))  # for display## # A tibble: 5,888 x 5\n##    latest_date date_infection date_onset date_hospitalisation date_outcome\n##    <date>      <date>         <date>     <date>               <date>      \n##  1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \n##  2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \n##  3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \n##  4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \n##  5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n##  6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n##  7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n##  8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n##  9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \n## 10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \n## # ... with 5,878 more rows"},{"path":"cleaning.html","id":"sắp-xếp","chapter":"8 Làm sạch số liệu và các hàm quan trọng","heading":"8.13 Sắp xếp","text":"Sử dụng hàm dplyr arrange() để sắp xếp thứ tự các hàng theo giá trị cột.Đơn giản hãy liệt kê các cột theo thứ tự mà chúng cần được sắp xếp. Thêm .by_group = TRUE nếu bạn muốn việc sắp xếp xảy ra trước bất kỳ hành động nhóm dữ liệu nào được áp dụng trong dữ liệu (xem chương Nhóm dữ liệu).Mặc định, cột sẽ được sắp xếp theo thứ tự “tăng dần” (áp dụng cho cột số và cả cột ký tự). Bạn có thể sắp xếp một biến theo thứ tự “giảm dần” bằng cách đặt tên biến trong hàm desc().Việc sắp xếp dữ liệu với hàm arrange() đặc biệt hữu ích khi Trình bày bảng, sử dụng hàm slice() để lấy các hàng “trên cùng” trên mỗi nhóm hoặc thiết lập thứ tự danh mục theo thứ tự xuất hiện.Ví dụ: để sắp xếp các hàng trong linelist theo hospital, sau đó theo date_onset thứ tự giảm dần, chúng ta sẽ thực hiện như sau:","code":"\nlinelist %>% \n   arrange(hospital, desc(date_onset))"},{"path":"dates.html","id":"dates","chapter":"9 Làm việc với ngày tháng","heading":"9 Làm việc với ngày tháng","text":"Làm việc với trường ngày trên R cần nhiều sự tỉ mỉ hơn là làm việc với các lớp đối tượng khác. Dưới đây, chúng tôi giới thiệu một số công cụ và ví dụ để các thao tác trở nên dễ dàng hơn. Thật may mắn, trường ngày có thể biến đổi một cách dễ dàng với một bộ packages như lubridate.Khi nhập dữ liệu thô, R thường diễn giải trường ngày dưới dạng các ký tự - điều này có nghĩa là chúng không thể được sử dụng cho các thao tác chung như tạo chuỗi thời gian và tính toán khoảng thời gian. Để làm cho vấn đề trở nên khó hơn một chút, có nhiều cách để định dạng ngày và bạn cần thao tác để R nhận biết từng phần của biến ngày mô tả cái gì (tháng, ngày, giờ, v.v.).Ngày trong R có kiểu đối tượng riêng - kiểu Date. Nên lưu ý rằng cũng có một kiểu khác lưu trữ đối tượng với định dạng ngày và giờ. Đối tượng ngày giờ được chính thức định dạng ở kiểu POSIXt, POSIXct, và/hoặc POSIXlt sự khác biệt không quá quan trọng). Các đối tượng này được định dạng một cách không chính thức là kiểu datetime.Điều quan trọng là giúp R nhận ra khi một cột chứa thông tin ngày tháng.Ngày là một kiểu đối tượng và khó để có thể làm việc.Ở đây chúng tôi trình bày một số cách để chuyển đổi các cột ngày thành kiểu dữ liệu Ngày tiêu chuẩn.","code":""},{"path":"dates.html","id":"chuẩn-bị","chapter":"9 Làm việc với ngày tháng","heading":"9.1 Chuẩn bị","text":"","code":""},{"path":"dates.html","id":"gọi-packages","chapter":"9 Làm việc với ngày tháng","heading":"Gọi packages","text":"Đoạn code này hiển thị tải các package cần thiết để sử dụng. Trong tài liệu này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, mà có thể cài đặt package nếu cần thiết và gọi package để sử dụng. Bạn cũng có thể gọi và cài đặt package với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.","code":"\n# Checks if package is installed, installs if necessary, and loads package for current session\n\npacman::p_load(\n  lubridate,  # general package for handling and converting dates  \n  linelist,   # has function to \"guess\" messy dates\n  aweek,      # another option for converting dates to weeks, and weeks to dates\n  zoo,        # additional date/time functions\n  tidyverse,  # data management and visualization  \n  rio)        # data import/export"},{"path":"dates.html","id":"nhập-dữ-liệu-2","chapter":"9 Làm việc với ngày tháng","heading":"Nhập dữ liệu","text":"Chúng ta sẽ nhập bộ dữ liệu với các ca bệnh từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải xuống dữ liệu để thực hành theo từng bước, hãy xem hướng dẫn ở chương Tải sách và dữ liệu. Chúng ta giả định rằng tệp dữ liệu đã nằm trong thư mục làm việc của bạn nên bạn không cần chỉ định thư mục con trong đường dẫn này.","code":"\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"dates.html","id":"ngày-hiện-tại","chapter":"9 Làm việc với ngày tháng","heading":"9.2 Ngày hiện tại","text":"Bạn có thể lấy ngày “hệ thống” hiện tại hoặc ngày giờ hệ thống của máy tính bằng cách thực hiện như sau với base R.Với package lubridate, chúng cũng có thể trả về giá trị tương ứng với hàm today() và now(). Hàm date() sẽ trả về giá trị ngày và giờ hiện tại với ngày trong tuần và tháng.","code":"\n# get the system date - this is a DATE class\nSys.Date()## [1] \"2021-10-06\"\n# get the system time - this is a DATETIME class\nSys.time()## [1] \"2021-10-06 15:28:28 CEST\""},{"path":"dates.html","id":"chuyển-đổi-sang-ngày","chapter":"9 Làm việc với ngày tháng","heading":"9.3 Chuyển đổi sang Ngày","text":"Sau khi nạp tập dữ liệu vào R, giá trị cột ngày có thể trông giống như “1989/12/30”, “05/06/2014” hoặc “13 Jan 2020”. Trong những trường hợp này, R có thể vẫn coi các giá trị trong cột có định dạng ký tự. R cần được hướng dẫn rằng các giá trị này là ngày… và định dạng của ngày là gì (phần nào là Ngày, phần nào là tháng, phần nào là Năm, v.v.).Sau khi hướng dẫn, R chuyển đổi các giá trị này thành kiểu Ngày. Trong nền, R sẽ lưu trữ ngày tháng dưới dạng số (số ngày tính từ ngày “gốc” ngày 1 tháng 1 năm 1970). Bạn sẽ không phải làm việc với định dạng ngày-số thường xuyên, tuy nhiên điều này cho phép R coi ngày là các biến liên tục và cho phép các hoạt động đặc biệt như tính toán khoảng cách giữa các ngày.Mặc định, các giá trị của phân lớp Ngày trong R được hiển thị là YYYY-MM-DD. Sau chương này chúng ta sẽ thảo luận về cách thay đổi cách hiển thị giá trị ngày tháng.Dưới đây, chúng tôi trình bày hai cách để chuyển đổi một cột từ dạng ký tự sang kiểu Ngày tiêu chuẩn.MẸO: Bạn có thể kiểm tra kiểu ngày hiện tại của cột bằng hàm class() trong base R, ví dụ như class(linelist$date_onset).","code":""},{"path":"dates.html","id":"base-r","chapter":"9 Làm việc với ngày tháng","heading":"base R","text":".Date() là hàm chuẩn của base R để chuyển đổi một đối tượng hoặc cột thành kiểu Ngày (lưu ý viết hoa chữ “D”).Sử dụng hàm .Date() yêu cầu:Bạn làm rõ định dạng hiện tại của ngày ở dạng văn bản gốc hoặc ngày gốc nếu biến ngày được cung cấp dưới dạng số (xem mục ngày tháng trong Excel)Nếu hàm được áp dụng trên cột dạng văn bản, tất cả các giá trị ngày phải có cùng một định dạng chính xác (nếu không như vậy, hãy thử hàm guess_dates() từ package linelist)Trước tiên, hãy kiểm tra kiểu của cột với hàm class() trong base R. Nếu bạn không chắc chắn hoặc phân vân về kiểu dữ liệu của cột (vd: bạn thấy “POSIXct”, v.v.) dễ dàng nhất là chuyển đổi cột thành kiểu văn bản với hàm .character(), và sau đó chuyển đổi nó thành kiểu Ngày.Thứ hai, trong hàm .Date(), sử dụng đối số format = để cho R biết định dạng hiện tại của các cấu phần trong biến ngày - những ký tự nào đề cập đến tháng, ngày và năm và cách chúng được phân tách. Nếu các giá trị của bạn đã ở một trong các định dạng ngày chuẩn của R (“YYYY-MM-DD” hoặc “YYYY/MM/DD”) thì đối số format = là không cần thiết.Để format =, hãy cung cấp một chuỗi ký tự (trong dấu ngoặc kép) đại diện cho định dạng ngày hiện tại bằng cách sử dụng các chữ viết tắt đặc biệt “strptime” dưới đây. Ví dụ: nếu ngày ký tự của bạn hiện ở định dạng “DD / MM / YYYY”, như “24/04/1968”, bạn hãy sử dụng đối số format = \"%d/%m/%Y\" để chuyển đổi các giá trị này. Đặt định dạng trong dấu ngoặc kép là cần thiết. Và đừng quên bất kỳ dấu gạch chéo hoặc dấu gạch ngang nào!Hầu hết các từ viết tắt của “strptime” được liệt kê dưới đây. Bạn có thể xem danh sách đầy đủ bằng cách chạy lệnh ?strptime.%d = Thứ tự ngày trong tháng (5, 17, 28, v.v.)\n%j = Thứ tự ngày trong năm (theo lịch Julian, ngày từ 001-366)\n%= Ngày trong tuần viết tắt (Mon, Tue, Wed, v.v.)\n%= Ngày trong tuần viết đầy đủ (Monday, Tuesday, v.v.)\n%w = Thứ tự ngày trong tuần (0-6, Chủ Nhật là 0)\n%u = Thứ tự ngày trong tuần (1-7, Thứ hai là 1)\n%W = Thứ tự của tuần trong năm (00-53, Thứ Hai là đầu tuần)\n%U = Thứ tự của tuần trong năm (01-53, Chủ Nhật là ngày bắt đầu tuần)\n%m = Thứ tự của tháng trong năm (vd: 01, 02, 03, 04)\n%b = Tháng viết tắt (Jan, Feb, v.v.)\n%B = Tháng viết đầy đủ (January, February, v.v.)\n%y = năm 2 chữ số (vd: 89)\n%Y = năm 4 chữ số (vd: 1989)\n%H = giờ (đồng hồ 24h)\n%M = phút\n%S = giây\n%z = offset GMT\n%Z = Múi giờ (dạng ký tự)MẸO: Đối số format = của hàm .Date() sẽ không cho R biết định dạng ngày theo cách bạn muốn, nhưng hơn hết nó giúp xác định thành phần ngày trong cột trước khi bạn chạy dòng lệnh.MẸO: Hãy chắc chắn rằng đối số format = bạn có sử dụng các ký tự ngăn cách ngày tháng (vd: /, -, hoặc khoảng trắng) trong cột ngày hiện tại của bạn.Khi các giá trị nằm trong phân lớp Ngày tiêu chuẩn, R sẽ mặc định hiển thị chúng ở định dạng chuẩn, đó là YYYY-MM-DD.","code":"\n# Convert to class date\nlinelist <- linelist %>% \n  mutate(date_onset = as.Date(date_of_onset, format = \"%d/%m/%Y\"))"},{"path":"dates.html","id":"lubridate","chapter":"9 Làm việc với ngày tháng","heading":"lubridate","text":"Việc chuyển đổi các đối tượng dạng tự thành Ngày tháng có thể được thực hiện dễ dàng hơn bằng cách sử dụng package lubridate. Đây là một package thuộc hệ sinh thái tidyverse được thiết kế để giúp làm việc với ngày và giờ đơn giản và nhất quán hơn với base R. Vì những lý này, package lubridate thường được coi là package tiêu chuẩn vàng cho ngày và giờ và được khuyến khích sử dụng bất cứ khi nào làm việc với chúng.Package lubridate cung cấp một số hàm trợ giúp khác nhau được thiết kế để chuyển đổi các đối tượng dạng ký tự thành ngày tháng một cách trực quan và dễ dàng hơn là định dạng bằng hàm .Date(). Các hàm này dành riêng cho định dạng ngày tháng, nhưng cho phép nhiều kiểu dấu phân tách và từ đồng nghĩa của ngày tháng (vd: 01 với Jan với January) - chúng được đặt tên theo chữ viết tắt của các định dạng ngày.Hàm ymd() có thể chuyển đổi linh hoạt các giá trị ngày được cung cấp dưới dạng năm, sau đó là tháng, và ngày.Hàm mdy() có thể chuyển đổi linh hoạt các giá trị ngày được cung cấp dưới dạng tháng, ngày, và năm.Hàm dmy() có thể chuyển đổi linh hoạt các giá trị ngày được cung cấp dưới dạng ngày, tháng, và năm.Nếu sử dụng piping, việc chuyển đổi cột dạng ký tự thành ngày tháng với lubridate có thể trông như thế này:Sau khi hoàn tất, bạn có thể chạy hàm class() để xác minh lại kiểu dữ liệu của cộtKhi các giá trị nằm trong phân lớp Ngày tiêu chuẩn, R sẽ mặc định hiển thị chúng ở định dạng chuẩn, đó là YYYY-MM-DD.Lưu ý rằng các hàm trên sử dụng tốt nhất với thông tin về năm có 4 chữ số. Thông tin về năm có 2 chữ số có thể tạo ra các kết quả không mong muốn, bởi vì lubridate sẽ cố gắng đoán và lấy thông tin về thế kỷ.Để chuyển đổi thông tin về năm 2 chữ số thành 4 chữ số (tất cả trong cùng một thế kỷ), bạn có thể chuyển thành dạng ký tự và sau đó kết hợp các chữ số hiện có với một tiền tố sử dụng hàm str_glue() từ package stringr (xem chương Ký tự và chuỗi). Sau đó chuyển đổi sang dạng ngày.","code":"\n# install/load lubridate \npacman::p_load(lubridate)\n# read date in year-month-day format\nymd(\"2020-10-11\")## [1] \"2020-10-11\"\nymd(\"20201011\")## [1] \"2020-10-11\"\n# read date in month-day-year format\nmdy(\"10/11/2020\")## [1] \"2020-10-11\"\nmdy(\"Oct 11 20\")## [1] \"2020-10-11\"\n# read date in day-month-year format\ndmy(\"11 10 2020\")## [1] \"2020-10-11\"\ndmy(\"11 October 2020\")## [1] \"2020-10-11\"\nlinelist <- linelist %>%\n  mutate(date_onset = lubridate::dmy(date_onset))\n# Check the class of the column\nclass(linelist$date_onset)  \ntwo_digit_years <- c(\"15\", \"15\", \"16\", \"17\")\nstr_glue(\"20{two_digit_years}\")## 2015\n## 2015\n## 2016\n## 2017"},{"path":"dates.html","id":"kết-hợp-các-cột","chapter":"9 Làm việc với ngày tháng","heading":"Kết hợp các cột","text":"Bạn có thể sử dụng các hàm make_date() và make_datetime() trong package lubridate để kết hợp nhiều cột dạng số thành một cột ngày. Ví dụ: nếu bạn có các cột kiểu số như onset_day, onset_month, và onset_year trong data frame linelist:","code":"\nlinelist <- linelist %>% \n  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))"},{"path":"dates.html","id":"ngày-tháng-trong-excel","chapter":"9 Làm việc với ngày tháng","heading":"9.4 Ngày tháng trong Excel","text":"Về cơ bản, hầu hết phần mềm lưu trữ thông tin ngày tháng dưới dạng số. R lưu trữ ngày bắt đầu từ ngày 1 tháng 1 năm 1970. đó, nếu bạn chạy hàm .numeric(.Date(\"1970-01-01)), bạn sẽ nhận được kết quả là 0.Microsoft Excel lưu trữ ngày tháng có nguồn gốc là ngày 30 tháng 12 năm 1899 (hệ điều hành Windows) hoặc ngày 1 tháng 1 năm 1904 (hệ điều hành Mac), tùy thuộc vào hệ điều hành của bạn. Xem hướng dẫn của Microsoft để biết thêm thông tin.Ngày trong Excel thường nạp vào R dưới dạng các giá trị số thay vì dưới dạng ký tự. Nếu tập dữ liệu bạn đã nhập từ Excel hiển thị ngày tháng dưới dạng số hoặc ký tự như “41369”… hãy sử dụng hàm .Date() (hoặc hàm as_date() của lubridate) để chuyển đổi, nhưng thay vì cung cấp một “định dạng” như trên, hãy cung cấp ngày gốc trên Excel tới đối số origin =.Điều này sẽ không hoạt động nếu ngày Excel được lưu trữ trong R dưới dạng một kiểu ký tự, vì vậy hãy đảm bảo rằng các số được lữu trữ ở kiểu Số!LƯU Ý: Bạn nên cung cấp định dạng ngày ở định dạng mặc định của R (“YYYY-MM-DD”).","code":"\n# An example of providing the Excel 'origin date' when converting Excel number dates\ndata_cleaned <- data %>% \n  mutate(date_onset = as.numeric(date_onset)) %>%   # ensure class is numeric\n  mutate(date_onset = as.Date(date_onset, origin = \"1899-12-30\")) # convert to date using Excel origin"},{"path":"dates.html","id":"ngày-lộn-xộn","chapter":"9 Làm việc với ngày tháng","heading":"9.5 Ngày lộn xộn","text":"Hàm guess_dates() từ package linelist cố gắng nhận diện một cột ngày tháng “lộn xộn” chứa ngày tháng ở nhiều định dạng khác nhau và chuyển đổi ngày tháng sang định dạng chuẩn. Bạn có thể đọc thêm tài liệu trực tuyến về guess_dates(). Nếu hàm guess_dates() chưa có trên CRAN của R phiên bản 4.0.2, hãy thử cài đặt theo cách sau pacman::p_load_gh(\"reconhub/linelist\").Ví dụ: hàm guess_dates sẽ nhận diện một vectơ gồm các ngày chứa ký tự như sau “03 Jan 2018”, “07/03/1982”, và “08/20/85” và chuyển đổi chúng thành định dạng Ngày tiêu chuẩn như: 2018-01-03, 1982-03-07, và 1985-08-20.Một số tùy chọn đối số cho hàm guess_dates() mà bạn có thể đưa vào là:error_tolerance - Tỷ lệ thông tin nhập không thể được xác định là ngày được chấp nhận (mặc định là 0,1 hoặc 10%)last_date - ngày hợp lệ cuối cùng (mặc định là ngày hiện tại)first_date - ngày hợp lệ đầu tiên. Giá trị mặc định là năm mươi năm trước last_date.","code":"\nlinelist::guess_dates(c(\"03 Jan 2018\",\n                        \"07/03/1982\",\n                        \"08/20/85\"))## [1] \"2018-01-03\" \"1982-03-07\" \"1985-08-20\"# An example using guess_dates on the column dater_onset\nlinelist <- linelist %>%                 # the dataset is called linelist\n  mutate(\n    date_onset = linelist::guess_dates(  # the guess_dates() from package \"linelist\"\n      date_onset,\n      error_tolerance = 0.1,\n      first_date = \"2016-01-01\"\n    )"},{"path":"dates.html","id":"làm-việc-với-kiểu-dữ-liệu-ngày-giờ","chapter":"9 Làm việc với ngày tháng","heading":"9.6 Làm việc với kiểu dữ liệu ngày-giờ","text":"Như đã đề cập ở trước, R cũng hỗ trợ kiểu dữ liệu datetime - là một cột chứa thông tin ngày và giờ. Bởi vì với kiểu dữ liệu Date, chúng cần được chuyển đổi từ các đối tượng kiểu character thành kiểu datetime.","code":""},{"path":"dates.html","id":"chuyển-đổi-ngày-giờ","chapter":"9 Làm việc với ngày tháng","heading":"Chuyển đổi ngày giờ","text":"Một đối tượng datetime được định dạng phần ngày trước, sau đó là phần thời gian - ví dụ: 01 Jan 2020, 16:30. Cũng như ngày, có nhiều cách có thể được định dạng và có nhiều cấp độ chính xác (giờ, phút, giây) có thể sử dụng.Thật may mắn, các hàm hỗ trợ trong lubridate cũng tồn tại để giúp chuyển đổi thông tin dạng chuỗi này thành các đối tượng dạng datetime. Các hàm này là phần mở rộng của các hàm ngày, với hàm _h (chỉ cung cấp giờ), hàm _hm (cung cấp giờ và phút), hoặc hàm _hms (cung cấp giờ, phút và giây) được thêm vào cuối cùng (vd: dmy_hms()). Chúng có thể được sử dụng như sau:Chuyển đổi datetime chỉ có giờ thành đối tượng datetimeChuyển đổi datetime với giờ và phút thành đối tượng datetimeChuyển đổi datetime với giờ, phút và giây sang đối tượng datetimeBạn có thể cung cấp múi giờ nhưng nó bị bỏ qua. Xem các phần sau trong chương này về múi giờ.Khi làm việc với một data frame, các cột ngày và giờ có thể được kết hợp để tạo cột ngày-giờ bằng cách sử dụng hàm str_glue() từ package stringr và các hàm của package lubridate. Xem chương Ký tự và chuỗi để biết thêm chi tiết về stringr.Trong ví dụ này, bộ dữ liệu linelist có một cột ở định dạng “giờ:phút”. Để chuyển đổi thành ngày giờ, chúng tôi làm theo một số bước:Tạo một cột thời gian nhập viện “sạch” với các giá trị bị thiếu được điền bằng trung vị cột. Chúng ta làm điều này bởi vì lubridate sẽ không hoạt động trên các giá trị missing. Kết hợp nó với cột date_hospitalisation, sau đó sử dụng hàm ymd_hm() để chuyển đổi.","code":"\nymd_h(\"2020-01-01 16hrs\")## [1] \"2020-01-01 16:00:00 UTC\"\nymd_h(\"2020-01-01 4PM\")## [1] \"2020-01-01 16:00:00 UTC\"\ndmy_hm(\"01 January 2020 16:20\")## [1] \"2020-01-01 16:20:00 UTC\"\nmdy_hms(\"01 January 2020, 16:20:40\")## [1] \"2020-01-20 16:20:40 UTC\"\nmdy_hms(\"01 January 2020, 16:20:40 PST\")## [1] \"2020-01-20 16:20:40 UTC\"# packages\npacman::p_load(tidyverse, lubridate, stringr)\n\n# time_admission is a column in hours:minutes\nlinelist <- linelist %>%\n  \n  # when time of admission is not given, assign the median admission time\n  mutate(\n    time_admission_clean = ifelse(\n      is.na(time_admission),         # if time is missing\n      median(time_admission),        # assign the median\n      time_admission                 # if not missing keep as is\n  ) %>%\n  \n    # use str_glue() to combine date and time columns to create one character column\n    # and then use ymd_hm() to convert it to datetime\n  mutate(\n    date_time_of_admission = str_glue(\"{date_hospitalisation} {time_admission_clean}\") %>% \n      ymd_hm()\n  )"},{"path":"dates.html","id":"chỉ-chuyển-đổi-thời-gian","chapter":"9 Làm việc với ngày tháng","heading":"Chỉ chuyển đổi thời gian","text":"Nếu dữ liệu của bạn chỉ chứa thời gian dạng ký tự (giờ và phút), bạn có thể chuyển đổi và thao tác chúng bằng cách sử dụng hàm strptime() từ base R. Ví dụ: để phân biệt sự khác biệt giữa hai loại thời gian này:Tuy nhiên, lưu ý rằng nếu không có giá trị ngày được cung cấp, phần mềm sẽ giả định là ngày hôm nay. Để kết hợp chuỗi ngày và giờ với nhau, hãy thử cách sử dụng stringr đã được nói ở phần bên trên. Đọc thêm về strptime() tại đây.Để chuyển đổi các số có một chữ số thành hai chữ số (ví dụ: để “độn thêm” giờ hoặc phút với các số 0 ở đầu để đạt được 2 chữ số), hãy xem phần “Độ dài chuỗi ký tự” trong chương Ký tự và chuỗi.","code":"\n# raw character times\ntime1 <- \"13:45\" \ntime2 <- \"15:20\"\n\n# Times converted to a datetime class\ntime1_clean <- strptime(time1, format = \"%H:%M\")\ntime2_clean <- strptime(time2, format = \"%H:%M\")\n\n# Difference is of class \"difftime\" by default, here converted to numeric hours \nas.numeric(time2_clean - time1_clean)   # difference in hours## [1] 1.583333"},{"path":"dates.html","id":"thời-gian-chính-xác","chapter":"9 Làm việc với ngày tháng","heading":"Thời gian chính xác","text":"Bạn có thể trích xuất các phần tử của thời gian với các hàm hour(), minute(), hoặc second() từ lubridate.Đây là một ví dụ về trích xuất giờ và sau đó phân loại theo từng phần trong ngày. Chúng ta bắt đầu với cột time_admission, có kiểu ký tự ở định dạng “HH:MM”. Đầu tiên, hàm strptime() được sử dụng như mô tả ở trên để chuyển đổi các ký tự thành kiểu ngày giờ. Sau đó, giờ được trích xuất với hàm hour(), trả về một số từ 0-24. Cuối cùng, cột time_period được tạo bằng cách sử dụng logic với hàm case_when() để phân loại các dòng thành các buổi Sáng / Chiều / Tối / Đêm dựa trên giờ được nhập liệu.Để tìm hiểu thêm về hàm case_when(), hãy xem chương Làm sạch số liệu và các hàm quan trọng.","code":"\nlinelist <- linelist %>%\n  mutate(hour_admit = hour(strptime(time_admission, format = \"%H:%M\"))) %>%\n  mutate(time_period = case_when(\n    hour_admit > 06 & hour_admit < 12 ~ \"Morning\",\n    hour_admit >= 12 & hour_admit < 17 ~ \"Afternoon\",\n    hour_admit >= 17 & hour_admit < 21 ~ \"Evening\",\n    hour_admit >=21 | hour_admit <= 6 ~ \"Night\"))"},{"path":"dates.html","id":"làm-việc-với-ngày","chapter":"9 Làm việc với ngày tháng","heading":"9.7 Làm việc với ngày","text":"lubridate cũng có thể được sử dụng cho nhiều chức năng khác, chẳng hạn như trích xuất các phần tử của ngày/ngày-giờ, tính toán ngày dạng số học, hoặc tính toán khoảng cách giữa ngày với ngàyỞ đây chúng tôi tạo ra một ngày mẫu để sử dụng cho các ví dụ:","code":"\n# create object of class Date\nexample_date <- ymd(\"2020-03-01\")"},{"path":"dates.html","id":"trích-xuất-các-cấu-phần-của-ngày","chapter":"9 Làm việc với ngày tháng","heading":"Trích xuất các cấu phần của ngày","text":"Bạn có thể trích xuất các cấu phần phổ biến như tháng, ngày, ngày trong tuần:Bạn cũng có thể trích xuất các cấu phần thời gian từ một đối tượng hoặc cột có kiểu datetime. Điều này có thể hữu ích nếu bạn muốn xem phân phối của thời gian nhập viện.Có một số tùy chọn để trích xuất tuần. Xem thêm ở mục tuần Dịch tễ học bên dưới.Lưu ý rằng nếu bạn đang tìm cách hiển thị ngày theo một cách nhất định (ví dụ: “Jan 2020” hoặc “Thursday 20 March” hoặc “Week 20, 1977”), bạn có thể thực hiện điều này linh hoạt hơn như được mô tả trong mục Hiển thị ngày.","code":"\nmonth(example_date)  # month number## [1] 3\nday(example_date)    # day (number) of the month## [1] 1\nwday(example_date)   # day number of the week (1-7)## [1] 1\nexample_datetime <- ymd_hm(\"2020-03-01 14:45\")\n\nhour(example_datetime)     # extract hour\nminute(example_datetime)   # extract minute\nsecond(example_datetime)   # extract second"},{"path":"dates.html","id":"tính-toán-ngày","chapter":"9 Làm việc với ngày tháng","heading":"Tính toán ngày","text":"Bạn có thể thêm số ngày hoặc tuần nhất định bằng cách sử dụng các hàm tương ứng từ package lubridate.","code":"\n# add 3 days to this date\nexample_date + days(3)## [1] \"2020-03-04\"\n# add 7 weeks and subtract two days from this date\nexample_date + weeks(7) - days(2)## [1] \"2020-04-17\""},{"path":"dates.html","id":"khoảng-ngày","chapter":"9 Làm việc với ngày tháng","heading":"Khoảng ngày","text":"Sự khác biệt giữa các ngày có thể được tính bằng:Đảm bảo cả hai trường ngày đều thuộc phân lớp ngày tiêu chuẩnSử dụng phép trừ để trả về khoảng chênh lệch “difftime” giữa hai ngàyNếu cần thiết, hãy chuyển đổi kết quả thành phân lớp dạng số để thực hiện các phép tính toán học tiếp theoDưới đây là khoảng thời gian giữa hai ngày được tính toán và hiển thị. Bạn có thể tìm các khoảng thời gian bằng cách sử dụng ký hiệu trừ “minus” trên các giá trị dạng Ngày tiêu chuẩn. Tuy nhiên, lưu ý rằng phân lớp của giá trị trả về là “difftime” như được hiển thị bên dưới và phải được chuyển đổi thành dạng số.Để thực hiện các thao tác tiếp theo trên “difftime”, hãy chuyển nó thành dạng số với hàm .numeric().Tất cả điều này có thể được kết hợp với nhau để xử lý dữ liệu - ví dụ:Trong bối cảnh của bộ dữ liệu, nếu thiếu một trong hai giá trị ngày ở trên, thì thao tác này sẽ không thực hiện thành công. Điều này sẽ tạo ra một kết quả là NA thay vì là một giá trị số. Khi sử dụng các cột này để tính toán, hãy chắc chắn rằng bạn thiết lập đối số na.rm = là TRUE. Ví dụ:","code":"\n# find the interval between this date and Feb 20 2020 \noutput <- example_date - ymd(\"2020-02-20\")\noutput    # print## Time difference of 10 days\nclass(output)## [1] \"difftime\"\npacman::p_load(lubridate, tidyverse)   # load packages\n\nlinelist <- linelist %>%\n  \n  # convert date of onset from character to date objects by specifying dmy format\n  mutate(date_onset = dmy(date_onset),\n         date_hospitalisation = dmy(date_hospitalisation)) %>%\n  \n  # filter out all cases without onset in march\n  filter(month(date_onset) == 3) %>%\n    \n  # find the difference in days between onset and hospitalisation\n  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)\n# calculate the median number of days to hospitalisation for all cases where data are available\nmedian(linelist_delay$days_onset_to_hosp, na.rm = T)"},{"path":"dates.html","id":"hiển-thị-ngày","chapter":"9 Làm việc với ngày tháng","heading":"9.8 Hiển thị ngày","text":"Một khi ngày tháng đã được định dạng đúng kiểu, bạn thường muốn chúng hiển thị theo nhiều cách khác nhau, ví dụ: hiển thị là “Monday 05 January” thay vì “2018-01-05”. Bạn cũng có thể muốn điều chỉnh hiển thị để nhóm các dòng theo các yếu tố ngày - ví dụ: nhóm theo tháng-năm.","code":""},{"path":"dates.html","id":"format","chapter":"9 Làm việc với ngày tháng","heading":"format()","text":"Điều chỉnh hiển thị ngày với hàm format() từ base R. Hàm này chấp nhận một chuỗi ký tự (trong dấu ngoặc kép) xác định rõ định dạng đầu ra mong muốn bằng chữ viết tắt “%” strptime (cú pháp tương tự như được sử dụng trong hàm .Date()). Dưới đây là các từ viết tắt phổ biến.Lưu ý: việc sử dụng hàm format() sẽ chuyển đổi các giá trị thành kiểu ký tự, vì vậy điều này thường được sử dụng ở cuối phân tích hoặc chỉ cho mục đích hiển thị! Bạn có thể xem danh sách đầy đủ bằng cách chạy lệnh ?strptime.%d = Thứ tự ngày trong tháng (5, 17, 28, v.v.)\n%j = Thứ tự ngày trong năm (theo lịch Julian, ngày từ 001-366)\n%= Ngày trong tuần viết tắt (Mon, Tue, Wed, v.v.)\n%= Ngày trong tuần viết đầy đủ (Monday, Tuesday, v.v.)\n%w = Thứ tự ngày trong tuần (0-6, Chủ Nhật là 0)\n%u = Thứ tự ngày trong tuần (1-7, Thứ hai là 1)\n%W = Thứ tự của tuần trong năm (00-53, Thứ Hai là đầu tuần)\n%U = Thứ tự của tuần trong năm (01-53, Chủ Nhật là ngày bắt đầu tuần)\n%m = Thứ tự của tháng trong năm (vd: 01, 02, 03, 04)\n%b = Tháng viết tắt (Jan, Feb, v.v.)\n%B = Tháng viết đầy đủ (January, February, v.v.)\n%y = năm 2 chữ số (vd: 89)\n%Y = năm 4 chữ số (vd: 1989)\n%H = giờ (đồng hồ 24h)\n%M = phút\n%S = giây\n%z = offset GMT\n%Z = Múi giờ (dạng ký tự)Ví dụ về định dạng ngày hôm nay:Lưu ý rằng nếu sử dụng hàm str_glue(), hãy lưu ý rằng các nội dung lẽ ra nên để trong dấu ngoặc kép thì bạn chỉ nên sử dụng dấu ngoặc đơn (như trên).","code":"\n# today's date, with formatting\nformat(Sys.Date(), format = \"%d %B %Y\")## [1] \"06 October 2021\"\n# easy way to get full date and time (default formatting)\ndate()## [1] \"Wed Oct 06 15:28:30 2021\"\n# formatted combined date, time, and time zone using str_glue() function\nstr_glue(\"{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}\")## Wednesday, October 06 2021, +0000  UTC, 15:28:30\n# Using format to display weeks\nformat(Sys.Date(), \"%Y Week %W\")## [1] \"2021 Week 40\""},{"path":"dates.html","id":"tháng-năm","chapter":"9 Làm việc với ngày tháng","heading":"Tháng-Năm","text":"Để chuyển đổi cột Ngày sang định dạng Tháng-năm, chúng tôi khuyên bạn nên sử dụng hàm .yearmon() từ package zoo. Nó giúp chuyển đổi từ định dạng ngày thành định dạng “yearmon” và giữ lại thứ tự thích hợp. Ngược lại, sử dụng hàm format(column, \"%Y %B\") sẽ chuyển đổi giá trị thành kiểu Ký tự và sẽ sắp xếp các giá trị theo thứ tự bảng chữ cái (không chính xác).Dưới đây, một cột yearmonth mới được tạo ra từ cột date_onset, sử dụng hàm .yearmon(). Thứ tự mặc định (đúng) của các giá trị kết quả được hiển thị trong bảng.Ngược lại, bạn có thể thấy sử dụng hàm format() chỉ có thể giúp đạt được định dạng hiển thị mong muốn, nhưng sẽ không có thứ tự chính xác.Lưu ý: nếu bạn đang làm việc với hàm ggplot() và chỉ muốn điều chỉnh chỉ hiển thị ngày, bạn chỉ cần cung cấp định dạng strptime là đủ tới đối số date_labels = của hàm scale_x_date() - bạn có thể sử dụng \"%b %Y\" hoặc \"%Y %b\". Xem thêm chương Các tips với ggplot.Package zoo cũng cung cấp hàm .yearqtr(), và bạn có thể sử dụng hàm scale_x_yearmon() khi sử dụng hàm ggplot().","code":"\n# create new column \ntest_zoo <- linelist %>% \n     mutate(yearmonth = zoo::as.yearmon(date_onset))\n\n# print table\ntable(test_zoo$yearmon)## \n## Apr 2014 May 2014 Jun 2014 Jul 2014 Aug 2014 Sep 2014 Oct 2014 Nov 2014 Dec 2014 Jan 2015 Feb 2015 Mar 2015 Apr 2015 \n##        7       64      100      226      528     1070     1112      763      562      431      306      277      186\n# create new column\ntest_format <- linelist %>% \n     mutate(yearmonth = format(date_onset, \"%b %Y\"))\n\n# print table\ntable(test_format$yearmon)## \n## Apr 2014 Apr 2015 Aug 2014 Dec 2014 Feb 2015 Jan 2015 Jul 2014 Jun 2014 Mar 2015 May 2014 Nov 2014 Oct 2014 Sep 2014 \n##        7      186      528      562      306      431      226      100      277       64      763     1112     1070"},{"path":"dates.html","id":"dates_epi_wks","chapter":"9 Làm việc với ngày tháng","heading":"9.9 Tuần dịch tễ học","text":"","code":""},{"path":"dates.html","id":"lubridate-1","chapter":"9 Làm việc với ngày tháng","heading":"lubridate","text":"Xem chương Nhóm dữ liệu để biết thêm các ví dụ mở rộng về nhóm dữ liệu theo ngày. Dưới đây chúng tôi mô tả ngắn gọn cách nhóm dữ liệu theo tuần.Thông thường, chúng tôi khuyên bạn nên sử dụng hàm floor_date() từ package lubridate, với đối số unit = \"week\". Điều này làm tròn ngày cần xử lý thành ngày “bắt đầu” của tuần, như được xác định bởi đối số week_start =. Ngày bắt đầu của tuần mặc định là 1 (đối với Thứ Hai) nhưng bạn có thể chỉ định bất kỳ ngày nào trong tuần làm ngày bắt đầu (ví dụ: 7 đối với Chủ Nhật). Hàm floor_date() rất linh hoạt và có thể sử dụng để làm tròn xuống các đơn vị thời gian khác bằng cách thiết lập đối số unit = bằng “giây”, “phút”, “giờ”, “ngày”, “tháng”, hoặc “năm”.Giá trị trả về là ngày bắt đầu trong tuần, với kiểu dữ liệu Ngày. Kiểu dữ liệu này rất hữu ích khi vẽ biểu đồ, vì nó sẽ dễ dàng sử dụng và sắp xếp chính xác trong hàm ggplot().Nếu bạn chỉ quan tâm đến việc điều chỉnh ngày để hiển thị theo tuần trong biểu đồ, hãy xem mục Hiển thị ngày trong chương này. Ví dụ: khi vẽ đồ thị một đường cong dịch tễ, bạn có thể định dạng hiển thị ngày bằng cách sử dụng cú pháp strptime “%”. Ví dụ, sử dụng “%Y-%W” hoặc “%Y-%U” để trả về giá trị năm và số tuần (tương ứng với bắt đầu tuần vào ngày thứ Hai hoặc Chủ nhật).","code":""},{"path":"dates.html","id":"đếm-theo-tuần","chapter":"9 Làm việc với ngày tháng","heading":"Đếm theo tuần","text":"Xem chương Nhóm dữ liệu để được giải thích kỹ hơn về cách nhóm dữ liệu với hàm count(), group_by(), và summarise(). Dưới đây là một ví dụ ngắn gọn.Tạo cột ‘tuần’ mới với hàm mutate(), sử dụng hàm floor_date() với đối số unit = \"week\"Đếm số lượng dòng (quan sát) mỗi tuần với hàm count(); lọc ra bất kỳ trường hợp nào bị thiếu ngàyKết thúc với hàm complete() từ package tidyr để đảm bảo rằng tất cả các tuần đều xuất hiện trong dữ liệu - ngay cả những tuần không có dòng/ quan sát nào. Theo mặc định, giá trị đếm cho bất kỳ hàng “mới” nào sẽ là NA, nhưng bạn có thể đặt chúng bằng 0 với đối số fill =, mà điều này kỳ vọng cho một danh sách tên (bên dưới, n là tên của cột đếm).Đây là các hàng đầu tiên của kết quả bộ dữ liệu:","code":"\n# Make aggregated dataset of weekly case counts\nweekly_counts <- linelist %>% \n  drop_na(date_onset) %>%             # remove cases missing onset date\n  mutate(weekly_cases = floor_date(   # make new column, week of onset\n    date_onset,\n    unit = \"week\")) %>%            \n  count(weekly_cases) %>%           # group data by week and count rows per group (creates column 'n')\n  tidyr::complete(                  # ensure all weeks are present, even those with no cases reported\n    weekly_cases = seq.Date(          # re-define the \"weekly_cases\" column as a complete sequence,\n      from = min(weekly_cases),       # from the minimum date\n      to = max(weekly_cases),         # to the maxiumum date\n      by = \"week\"),                   # by weeks\n    fill = list(n = 0))             # fill-in NAs in the n counts column with 0"},{"path":"dates.html","id":"các-thay-thế-cho-tuần-dịch-tễ-học","chapter":"9 Làm việc với ngày tháng","heading":"Các thay thế cho tuần dịch tễ học","text":"Lưu ý là package lubridate cũng có các hàm week(), epiweek(), và isoweek(), mỗi hàm có ngày bắt đầu khác nhau một chút và các sắc thái khác nhau. Mặc dù nói chung, hàm floor_date() là tất cả những gì bạn cần. Đọc thêm về các hàm này bằng cách gõ ?week ở cửa sổ console hoặc đọc tài liệu tại đây.Bạn có thể cân nhắc sử dụng package aweek để thiết lập tuần dịch tễ học. Bạn có thể đọc thêm về nó ở trang web của RECON. Nó có các hàm date2week() và week2date() trong đó bạn có thể đặt ngày bắt đầu tuần với week_start = \"Monday\". Package này là dễ sử dụng nhất nếu bạn muốn hiển thị “tuần” theo kiểu đầu ra (vd: “2020-W12”). Một ưu điểm khác của aweek là khi áp dụng hàm date2week() cho cột ngày, cột trả về (định dạng tuần) sẽ tự động thuộc kiểu Factor và bao gồm các cấp độ cho tất cả các tuần trong khoảng thời gian (điều này tránh thêm bước complete() được mô tả ở trên). Tuy nhiên, aweek không có chức năng làm tròn ngày thành các đơn vị thời gian khác như tháng, năm, v.v.Một giải pháp thay thế khác cho chuỗi thời gian cũng hoạt động tốt để hiển thị định dạng “tuần” (“2020 W12”) là hàm yearweek() từ package tsibble, như được minh họa trong chương Chuỗi thời gian và phát hiện ổ dịch.","code":""},{"path":"dates.html","id":"chuyển-đổi-múi-ngày-giờ","chapter":"9 Làm việc với ngày tháng","heading":"9.10 Chuyển đổi múi ngày giờ","text":"Khi dữ liệu hiển thị ở các múi giờ khác nhau, điều quan trọng là phải chuẩn hóa dữ liệu này thành một múi giờ thống nhất. Điều này có thể gây ra một thách thức lớn hơn nữa, vì thành phần múi giờ của dữ liệu phải được mã hóa theo cách thủ công trong hầu hết các trường hợp.Trong R, mỗi đối tượng datetime có một cấu phần múi giờ. Mặc định, tất cả các đối tượng datetime sẽ mang múi giờ địa phương của máy tính đang sử dụng - điều này thường đặc trưng cho một vị trí chứ không phải tự đặt tên cho múi giờ đó, vì múi giờ thường sẽ thay đổi ở các vị trí phụ thuộc vào thời gian chiếu sáng. Không thể bù trừ chính xác cho các múi giờ mà không có cấu phần thời gian trong biến ngày, vì mốc trong cột ngày đại diện không thể được quy cho một thời gian cụ thể và đó không thể tính toán hợp lý sự chuyển đổi thời gian bằng giờĐể xử lý múi giờ, có một số hàm trợ giúp trong lubridate có thể được sử dụng để thay đổi múi giờ của đối tượng datetime từ múi giờ địa phương sang các múi giờ khác. Múi giờ được đặt bằng cách gán múi giờ cơ sở dữ liệu tz hợp lệ cho đối tượng datetime. Bạn có thể tìm thấy danh sách những thứ này tại đây - nếu vị trí bạn đang sử dụng dữ liệu không có trong danh sách này, các múi giờ của thành phố lớn lân cận có thể được sử dụng thay thế.https://en.wikipedia.org/wiki/List_of_tz_database_time_zonesĐiều này có vẻ trừu tượng và thường không cần thiết nếu người dùng không làm việc trên các múi giờ.","code":"\n# assign the current time to a column\ntime_now <- Sys.time()\ntime_now## [1] \"2021-10-06 15:28:31 CEST\"\n# use with_tz() to assign a new timezone to the column, while CHANGING the clock time\ntime_london_real <- with_tz(time_now, \"Europe/London\")\n\n# use force_tz() to assign a new timezone to the column, while KEEPING the clock time\ntime_london_local <- force_tz(time_now, \"Europe/London\")\n\n\n# note that as long as the computer that was used to run this code is NOT set to London time,\n# there will be a difference in the times \n# (the number of hours difference from the computers time zone to london)\ntime_london_real - time_london_local## Time difference of -1 hours"},{"path":"dates.html","id":"phép-toán-về-khoảng-thời-gian","chapter":"9 Làm việc với ngày tháng","heading":"9.11 Phép toán về khoảng thời gian","text":"lead() và lag() là các hàm thuộc package dplyr giúp tìm các giá trị trước đó (lagged) hoặc tiếp theo (leading) trong một vectơ - thường là vectơ số hoặc ngày. Điều này rất hữu ích khi thực hiện các phép tính về sự thay đổi / chênh lệch giữa các đơn vị thời gian.Giả sử bạn muốn tính toán sự khác biệt trong trường hợp giữa tuần hiện tại và tuần trước đó. Dữ liệu ban đầu được cung cấp theo số lượng hàng tuần như dưới đây.Khi sử dụng hàm lag() hoặc lead(), thứ tự của các dòng trong khung dữ liệu là rất quan trọng! - chú ý xem ngày/số của bạn tăng dần hay giảm dầnĐầu tiên, tạo một cột mới chứa giá trị của tuần trước đó (lagged).Kiểm soát số lượng đơn vị trước/sau với n = (phải là số nguyên không âm)Sử dụng default = để xác định giá trị được đặt trong các dòng không tồn tại (vd: hàng đầu tiên không có giá trị lagged). Mặc định, nó là NA.Sử dụng order_by = TRUE nếu các dòng không được sắp xếp theo cột tham chiếuTiếp theo, tạo một cột mới khác biệt với hai cột đang tham chiếu:Bạn có thể đọc thêm về hàm lead() và lag() trong tài liệu này hoặc gõ ?lag vào cửa sổ console.","code":"\ncounts <- counts %>% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1))\ncounts <- counts %>% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1),\n         case_diff = cases_wk - cases_prev_wk)"},{"path":"dates.html","id":"nguồn-1","chapter":"9 Làm việc với ngày tháng","heading":"9.12 Nguồn","text":"lubridate tidyverse pagelubridate RStudio cheatsheet\nR Data Science page dates timesOnline tutorial\nDate formats","code":""},{"path":"characters-strings.html","id":"characters-strings","chapter":"10 Ký tự và chuỗi","heading":"10 Ký tự và chuỗi","text":"Chương này trình bày việc sử dụng package stringr để đánh giá và xử lý các giá trị ký tự (“chuỗi”).Các hàm kết hợp, thiết lập thứ tự, phân tách, sắp xếp - str_c(), str_glue(), str_order(), str_split()Các hàm kết hợp, thiết lập thứ tự, phân tách, sắp xếp - str_c(), str_glue(), str_order(), str_split()Làm sạch và chuẩn hóa\nCác hàm điều chỉnh độ dài ký tự - str_pad(), str_trunc(), str_wrap()\nCác hàm thay đổi chữ hoa/chữ thường - str_to_upper(), str_to_title(), str_to_lower(), str_to_sentence()\nLàm sạch và chuẩn hóaCác hàm điều chỉnh độ dài ký tự - str_pad(), str_trunc(), str_wrap()Các hàm thay đổi chữ hoa/chữ thường - str_to_upper(), str_to_title(), str_to_lower(), str_to_sentence()Các hàm đánh giá và trích xuất vị trí - str_length(), str_sub(), word()Các hàm đánh giá và trích xuất vị trí - str_length(), str_sub(), word()Các hàm làm việc với patterns\nPhát hiện và định vị - str_detect(), str_subset(), str_match(), str_extract()\nSửa đổi và thay thế - str_sub(), str_replace_all()\nCác hàm làm việc với patternsPhát hiện và định vị - str_detect(), str_subset(), str_match(), str_extract()Sửa đổi và thay thế - str_sub(), str_replace_all()Biểu thức chính quy (“regex”)Biểu thức chính quy (“regex”)Để dễ hiển thị, hầu hết các code ví dụ đều mô phỏng trên một vectơ ngắn dạng ký tự đã được xác định, tuy nhiên chúng có thể dễ dàng áp dụng trên một cột trong bộ dữ liệu.Package stringr vignette đã cung cấp nhiều ý tưởng cho chương này.","code":""},{"path":"characters-strings.html","id":"chuẩn-bị-1","chapter":"10 Ký tự và chuỗi","heading":"10.1 Chuẩn bị","text":"","code":""},{"path":"characters-strings.html","id":"gọi-packages-1","chapter":"10 Ký tự và chuỗi","heading":"Gọi packages","text":"Cài đặt hoặc gọi package stringr và các packages tidyverse khác.","code":"\n# install/load packages\npacman::p_load(\n  stringr,    # many functions for handling strings\n  tidyverse,  # for optional data manipulation\n  tools)      # alternative for converting to title case"},{"path":"characters-strings.html","id":"nhập-dữ-liệu-3","chapter":"10 Ký tự và chuỗi","heading":"Nhập dữ liệu","text":"Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị bên dưới.","code":"\n# import case linelist \nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"characters-strings.html","id":"hợp-nhất-tách-và-sắp-xếp","chapter":"10 Ký tự và chuỗi","heading":"10.2 Hợp nhất, tách, và sắp xếp","text":"Chương này bao gồm:Sử dụng hàm str_c(), str_glue(), và unite() để ghép nối ký tựSử dụng hàm str_order() để sắp xếp ký tựSử dụng hàm str_split() và separate() để phân tách ký tự","code":""},{"path":"characters-strings.html","id":"kết-hợp-các-chuỗi-ký-tự","chapter":"10 Ký tự và chuỗi","heading":"Kết hợp các chuỗi ký tự","text":"Để kết hợp hoặc nối nhiều chuỗi ký tự thành một chuỗi ký tự, chúng tôi khuyên bạn nên sử dụng hàm str_c từ stringr. Nếu bạn có các giá trị ký tự riêng biệt để kết hợp, đơn giản chỉ cần cung cấp chúng dưới dạng đối số, được phân tách bằng dấu phẩy.Đối số sep = chèn một giá dạng trị ký tự vào giữa mỗi đối số ký tự bạn cung cấp (ví dụ: chèn dấu phẩy, dấu cách hoặc dòng mới \"\\n\")Đối số collapse = có liên quan nếu bạn đang nhập nhiều vectơ làm đối số cho hàm str_c(). Nó được sử dụng để tách các phần tử của một vectơ kết quả, sao cho vectơ kết quả chỉ là một phần tử chứa ký tự dài.Ví dụ dưới đây cho thấy sự kết hợp của hai vectơ thành một (tên và họ). Một ví dụ tương tự khác có thể là các phạm vi địa chính và số lượng trường hợp. Trong ví dụ này:Giá trị sep = xuất hiện giữa từng họ và tênGiá trị collapse = xuất hiện giữa tên từng ngườiLưu ý: Tùy thuộc vào trường hợp hiển thị mong muốn, khi một chuỗi kết hợp như vậy với các dòng mới, bạn có thể cần phải đặt toàn bộ cụm từ trong hàm cat() để các dòng mới được đúng cách:","code":"\nstr_c(\"String1\", \"String2\", \"String3\")## [1] \"String1String2String3\"\nstr_c(\"String1\", \"String2\", \"String3\", sep = \", \")## [1] \"String1, String2, String3\"\nfirst_names <- c(\"abdul\", \"fahruk\", \"janice\") \nlast_names  <- c(\"hussein\", \"akinleye\", \"okeke\")\n\n# sep displays between the respective input strings, while collapse displays between the elements produced\nstr_c(first_names, last_names, sep = \" \", collapse = \";  \")## [1] \"abdul hussein;  fahruk akinleye;  janice okeke\"\n# For newlines to print correctly, the phrase may need to be wrapped in cat()\ncat(str_c(first_names, last_names, sep = \" \", collapse = \";\\n\"))## abdul hussein;\n## fahruk akinleye;\n## janice okeke"},{"path":"characters-strings.html","id":"chuỗi-động","chapter":"10 Ký tự và chuỗi","heading":"Chuỗi động","text":"Sử dụng hàm str_glue() để chèn đoạn code động của R vào chuỗi ký tự. Đây là một hàm hữu dụng để tạo tiêu đề biểu đồ động, như được mô tả dưới đây:Tất cả nội dung nằm giữa dấu ngoặc kép str_glue(\"\")Bất kỳ đoạn code động hoặc tham chiếu nào đến các giá trị được xác định trước đều được đặt trong dấu ngoặc nhọn {}, bên trong dấu ngoặc kép. Có thể có nhiều dấu ngoặc nhọn trong cùng một câu lệnh str_glue().Để hiển thị dấu ngoặc kép “, hãy sử dụng dấu ngoặc đơn bên trong dấu ngoặc kép (ví dụ: khi cung cấp định dạng ngày - xem ví dụ bên dưới)Mẹo: Bạn có thể sử dụng \\n để bắt buộc xuống một dòng mớiMẹo: Bạn có thể sử dụng hàm format() để điều chỉnh hiển thị ngày và sử dụng hàm Sys.Date() để hiển thị ngày hiện tại.Một ví dụ đơn giản về tiêu đề biểu đồ động:Một định dạng thay thế là sử dụng trình giữ chỗ (placeholder) bên trong dấu ngoặc kép và chỉ định chúng trong các đối số ở phía sau trong hàm str_glue() như bên dưới. Việc này sẽ làm tăng tính tường minh cho code nếu phần văn bản dài.Kéo từ bộ dữ liệuĐôi khi, sẽ rất hữu ích khi lấy dữ liệu từ một bộ dữ liệu và dán chúng lại với nhau theo trình tự. Dưới đây là một ví dụ về bộ dữ liệu. Chúng ta sẽ sử dụng cách này để có một phát biểu tóm tắt về các khu vực pháp lý, cũng như số ca mắc mới và tổng số ca.Sử dụng hàm str_glue_data(), được thiết kế để lấy dữ liệu từ các quan sát của bộ dữ liệu:Kết hợp các chuỗi ký tự trên các dòngNếu bạn đang cố gắng để “gộp” các giá trị trong một cột của bộ dữ liệu, ví dụ: kết hợp các giá trị từ nhiều hàng thành một hàng bằng cách gắn chúng với nhau cùng ký tự phân cách, hãy xem thêm ở chương Loại bỏ trùng lặp mục “gộp” các giá trị.Một bộ dữ liệu thành một dòngBạn có thể tạo ra dãy thông tin chỉ trong một dòng bằng cách sử dụng lệnh str_c() (cụ thể tên bộ dữ liệu và tên cột), đồng thời cung cấp các đối số sep = và collapse =.Bạn có thể thêm đoạn tiền tố “New Cases:” vào đầu dòng thông tin bằng cách đặt trong hàm str_c() (nếu “New Cases:” nằm trong hàm str_c() ban đầu thì nó sẽ xuất hiện nhiều lần).","code":"\nstr_glue(\"Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.\")## Data include 5888 cases and are current to 06 Oct 2021.\nstr_glue(\"Linelist as of {current_date}.\\nLast case hospitalized on {last_hospital}.\\n{n_missing_onset} cases are missing date of onset and not shown\",\n         current_date = format(Sys.Date(), '%d %b %Y'),\n         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),\n         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))\n         )## Linelist as of 06 Oct 2021.\n## Last case hospitalized on 30 Apr 2015.\n## 256 cases are missing date of onset and not shown\n# make case data frame\ncase_table <- data.frame(\n  zone        = c(\"Zone 1\", \"Zone 2\", \"Zone 3\", \"Zone 4\", \"Zone 5\"),\n  new_cases   = c(3, 0, 7, 0, 15),\n  total_cases = c(40, 4, 25, 10, 103)\n  )\ncase_table %>% \n  str_glue_data(\"{zone}: {new_cases} ({total_cases} total cases)\")## Zone 1: 3 (40 total cases)\n## Zone 2: 0 (4 total cases)\n## Zone 3: 7 (25 total cases)\n## Zone 4: 0 (10 total cases)\n## Zone 5: 15 (103 total cases)\nstr_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \")## [1] \"Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\nstr_c(\"New Cases: \", str_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \"))## [1] \"New Cases: Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\""},{"path":"characters-strings.html","id":"str_unite","chapter":"10 Ký tự và chuỗi","heading":"Hợp nhất các cột","text":"Trong bộ dữ liệu, việc tập hợp các giá trị dạng ký tự từ nhiều cột lại với nhau có thể thực hiện bằng cách dùng hàm unite() từ package tidyr. Tính năng này ngược lại với hàm separate().Đầu tiên, cần tên của cột mới. Sau đó, cần tên của các cột mà bạn muốn hợp nhất.Mặc định, dấu ngăn cách được sử dụng trong cột hợp nhất là dấu gạch dưới _, nhưng có thể được thay đổi bằng đối số sep =.remove = loại bỏ các cột ban đầu ra khỏi bộ dữ liệu (mặc định là TRUE)na.rm = loại bỏ các giá trị bị thiếu trong khi hợp nhất (mặc định là FALSE)Dưới đây, chúng tôi xác định một bộ dữ liệu ngắn để minh họa:Đây là bộ dữ liệu mẫu:Dưới đây, chúng tôi hợp nhất ba cột triệu chứng:","code":"\ndf <- data.frame(\n  case_ID = c(1:6),\n  symptoms  = c(\"jaundice, fever, chills\",     # patient 1\n                \"chills, aches, pains\",        # patient 2 \n                \"fever\",                       # patient 3\n                \"vomiting, diarrhoea\",         # patient 4\n                \"bleeding from gums, fever\",   # patient 5\n                \"rapid pulse, headache\"),      # patient 6\n  outcome = c(\"Recover\", \"Death\", \"Death\", \"Recover\", \"Recover\", \"Recover\"))\ndf_split <- separate(df, symptoms, into = c(\"sym_1\", \"sym_2\", \"sym_3\"), extra = \"merge\")## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 2 rows [3, 4].\ndf_split %>% \n  unite(\n    col = \"all_symptoms\",         # name of the new united column\n    c(\"sym_1\", \"sym_2\", \"sym_3\"), # columns to unite\n    sep = \", \",                   # separator to use in united column\n    remove = TRUE,                # if TRUE, removes input cols from the data frame\n    na.rm = TRUE                  # if TRUE, missing values are removed before uniting\n  )##   case_ID                all_symptoms outcome\n## 1       1     jaundice, fever, chills Recover\n## 2       2        chills, aches, pains   Death\n## 3       3                       fever   Death\n## 4       4         vomiting, diarrhoea Recover\n## 5       5 bleeding, from, gums, fever Recover\n## 6       6      rapid, pulse, headache Recover"},{"path":"characters-strings.html","id":"tách-chuỗi","chapter":"10 Ký tự và chuỗi","heading":"Tách chuỗi","text":"Để tách một chuỗi ký tự dựa trên một quy luật, hãy sử dụng hàm str_split(). Hàm này đánh giá (các) chuỗi ký tự và trả về danh sách list các vectơ ký tự chứa các giá trị mới được tách.Ví dụ đơn giản dưới đây đánh giá một chuỗi ký tự và chia nó thành ba phần. Mặc định, hàm trả về một đối tượng kiểu danh sách list với một phần tử (một vectơ ký tự) cho mỗi chuỗi được cung cấp ban đầu. Nếu simplify = TRUE nó trả về một ma trận ký tự.Trong ví dụ này, một chuỗi ký tự được cung cấp và hàm trả về một danh sách có một phần tử - một vectơ ký tự chứa ba giá trị.Nếu kết quả được lưu, thì bạn có thể truy cập giá trị phân chia thứ n bằng cú pháp dấu ngoặc vuông. Để truy cập vào một giá trị cụ thể, bạn có thể sử dụng cú pháp như sau: the_returned_object[[1]][2], sẽ truy cập giá trị thứ hai từ chuỗi ký tự được đánh giá thứ nhất (“fever”). Xem thêm ở chương R Cơ bản để biết thêm chi tiết về cách truy vấn các phần tử.Nếu nhiều chuỗi ký tự được sử dụng trong hàm str_split(), sẽ có nhiều hơn một phần tử trong danh sách trả về.Thay vào đó, để trả về “ma trận chuỗi ký tự”, có thể sẽ hữu ích nếu tạo cột trong bộ dữ liệu, đặt đối số simplify = TRUE như trình bày dưới đây:Bạn cũng có thể điều chỉnh số phần tách ra với đối số n =. Ví dụ dưới đây giới hạn số phần tách ra là 2. Bất kỳ dấu phẩy nào khác vẫn sẽ nằm trong giá trị thứ hai.Lưu ý - các kết quả tương tự có thể đạt được với hàm str_split_fixed(), trong đó bạn không dùng đối số simplify mà thay vào đó phải chỉ định số cột (n).","code":"\nstr_split(string = \"jaundice, fever, chills\",\n          pattern = \",\")## [[1]]\n## [1] \"jaundice\" \" fever\"   \" chills\"\npt1_symptoms <- str_split(\"jaundice, fever, chills\", \",\")\n\npt1_symptoms[[1]][2]  # extracts 2nd value from 1st (and only) element of the list## [1] \" fever\"\nsymptoms <- c(\"jaundice, fever, chills\",     # patient 1\n              \"chills, aches, pains\",        # patient 2 \n              \"fever\",                       # patient 3\n              \"vomiting, diarrhoea\",         # patient 4\n              \"bleeding from gums, fever\",   # patient 5\n              \"rapid pulse, headache\")       # patient 6\n\nstr_split(symptoms, \",\")                     # split each patient's symptoms## [[1]]\n## [1] \"jaundice\" \" fever\"   \" chills\" \n## \n## [[2]]\n## [1] \"chills\" \" aches\" \" pains\"\n## \n## [[3]]\n## [1] \"fever\"\n## \n## [[4]]\n## [1] \"vomiting\"   \" diarrhoea\"\n## \n## [[5]]\n## [1] \"bleeding from gums\" \" fever\"            \n## \n## [[6]]\n## [1] \"rapid pulse\" \" headache\"\nstr_split(symptoms, \",\", simplify = TRUE)##      [,1]                 [,2]         [,3]     \n## [1,] \"jaundice\"           \" fever\"     \" chills\"\n## [2,] \"chills\"             \" aches\"     \" pains\" \n## [3,] \"fever\"              \"\"           \"\"       \n## [4,] \"vomiting\"           \" diarrhoea\" \"\"       \n## [5,] \"bleeding from gums\" \" fever\"     \"\"       \n## [6,] \"rapid pulse\"        \" headache\"  \"\"\nstr_split(symptoms, \",\", simplify = TRUE, n = 2)##      [,1]                 [,2]            \n## [1,] \"jaundice\"           \" fever, chills\"\n## [2,] \"chills\"             \" aches, pains\" \n## [3,] \"fever\"              \"\"              \n## [4,] \"vomiting\"           \" diarrhoea\"    \n## [5,] \"bleeding from gums\" \" fever\"        \n## [6,] \"rapid pulse\"        \" headache\"\nstr_split_fixed(symptoms, \",\", n = 2)"},{"path":"characters-strings.html","id":"tách-cột","chapter":"10 Ký tự và chuỗi","heading":"Tách cột","text":"Nếu bạn đang cố gắng chia tách cột trong bộ dữ liệu, cách tốt nhất là sử dụng hàm separate() từ package dplyr. Nó được sử dụng để chia một cột ký tự thành các cột khác nhau.Giả sử chúng ta có một bộ dữ liệu đơn giản df (được xác định và hợp nhất trong unite section) chứa một cột case_ID , một cột dạng ký tự có nhiều triệu chứng và một cột outcome. Mục tiêu của chúng ta là tách cột symptoms thành nhiều cột - mỗi cột chứa một triệu chứng.Giả sử dữ liệu được đưa vào hàm separate(), trước tiên hãy chọn ra cột sẽ được phân tách. Sau đó, cung cấp thông tin tới đối số = dưới dạng vectơ c( ) có chứa tên các cột mới, như được trình bày dưới đây.Dấu phân cách trong sep = có thể là một ký tự hoặc một số (được hiểu là vị trí ký tự cần tách)Dấu phân cách trong sep = có thể là một ký tự hoặc một số (được hiểu là vị trí ký tự cần tách)Mặc định là remove = FALSE, xóa cột đầu vào ban ban đầuMặc định là remove = FALSE, xóa cột đầu vào ban ban đầuMặc định là convert = FALSE, các ký tự “NA” sẽ thành NAMặc định là convert = FALSE, các ký tự “NA” sẽ thành NAextra = kiểm soát điều gì sẽ xảy ra nếu có nhiều giá trị được tạo bởi sự phân tách nhiều hơn các cột mới được đặt tên.\nextra = \"warn\" có nghĩa là bạn sẽ thấy một cảnh báo nhưng nó sẽ loại bỏ các giá trị thừa (mặc định là vậy)\nextra = \"drop\" có nghĩa là các giá trị thừa sẽ bị loại bỏ mà không có cảnh báo\nextra = \"merge\" sẽ chỉ phân tách thành số cột mới được liệt kê trong - thiết lập này sẽ bảo toàn tất cả dữ liệu của bạn\nextra = kiểm soát điều gì sẽ xảy ra nếu có nhiều giá trị được tạo bởi sự phân tách nhiều hơn các cột mới được đặt tên.extra = \"warn\" có nghĩa là bạn sẽ thấy một cảnh báo nhưng nó sẽ loại bỏ các giá trị thừa (mặc định là vậy)extra = \"drop\" có nghĩa là các giá trị thừa sẽ bị loại bỏ mà không có cảnh báoextra = \"merge\" sẽ chỉ phân tách thành số cột mới được liệt kê trong - thiết lập này sẽ bảo toàn tất cả dữ liệu của bạnDưới đây là một ví dụ về extra = \"merge\" - không có dữ liệu nào bị mất. Hai cột mới được xác định nhưng bất kỳ triệu chứng thứ ba nào sẽ quy về trong cột mới thứ hai:Khi sử dụng lệnh extra = \"drop\" mặc định như bên dưới, một cảnh báo sẽ được đưa ra nhưng triệu chứng thứ ba bị mất:CẨN TRỌNG: Nếu bạn không cung cấp đủ giá trị cho các cột mới, dữ liệu của bạn có thể bị cắt bớt .","code":"\n# third symptoms combined into second new column\ndf %>% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\", extra = \"merge\")## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].##   case_ID              sym_1          sym_2 outcome\n## 1       1           jaundice  fever, chills Recover\n## 2       2             chills   aches, pains   Death\n## 3       3              fever           <NA>   Death\n## 4       4           vomiting      diarrhoea Recover\n## 5       5 bleeding from gums          fever Recover\n## 6       6        rapid pulse       headache Recover\n# third symptoms are lost\ndf %>% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\")## Warning: Expected 2 pieces. Additional pieces discarded in 2 rows [1, 2].## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].##   case_ID              sym_1      sym_2 outcome\n## 1       1           jaundice      fever Recover\n## 2       2             chills      aches   Death\n## 3       3              fever       <NA>   Death\n## 4       4           vomiting  diarrhoea Recover\n## 5       5 bleeding from gums      fever Recover\n## 6       6        rapid pulse   headache Recover"},{"path":"characters-strings.html","id":"sắp-xếp-theo-thứ-tự-bảng-chữ-cái","chapter":"10 Ký tự và chuỗi","heading":"Sắp xếp theo thứ tự bảng chữ cái","text":"Một số chuỗi ký tự có thể được sắp xếp theo thứ tự bảng chữ cái. Hàm str_order() trả về thứ tự của các phần tử, trong khi hàm str_sort() trả về các chuỗi theo thứ tự đó.Để sử dụng một bảng chữ cái khác, hãy thêm đối số locale =. Xem danh sách đầy đủ các locales bằng cách gõ stringi::stri_locale_list() trong cửa sổ R console.","code":"\n# strings\nhealth_zones <- c(\"Alba\", \"Takota\", \"Delta\")\n\n# return the alphabetical order\nstr_order(health_zones)## [1] 1 3 2\n# return the strings in alphabetical order\nstr_sort(health_zones)## [1] \"Alba\"   \"Delta\"  \"Takota\""},{"path":"characters-strings.html","id":"các-hàm-base-r","chapter":"10 Ký tự và chuỗi","heading":"Các hàm base R","text":"Các hàm phổ biến của base R là paste() và paste0() nối các vectơ sau khi chuyển đổi tất cả các cấu phần thành ký tự. Chúng hoạt động tương tự như str_c() nhưng cú pháp được cho là phức tạp hơn - đó là trong ngoặc thì mỗi phần được phân tách bằng một dấu phẩy. Các cấu phần là ký tự dạng văn bản (trong dấu ngoặc kép) hoặc các đối tượng được xác định trước (không có dấu ngoặc kép). Ví dụ:Đối số sep = và collapse = có thể được cụ thể. Hàm paste() chỉ đơn giản dán paste0() vớ đối số mặc định sep = \" \" (một khoảng trắng).","code":"\nn_beds <- 10\nn_masks <- 20\n\npaste0(\"Regional hospital needs \", n_beds, \" beds and \", n_masks, \" masks.\")## [1] \"Regional hospital needs 10 beds and 20 masks.\""},{"path":"characters-strings.html","id":"làm-sạch-và-chuẩn-hóa","chapter":"10 Ký tự và chuỗi","heading":"10.3 Làm sạch và chuẩn hóa","text":"","code":""},{"path":"characters-strings.html","id":"thay-đổi-chữ-hoachữ-thường","chapter":"10 Ký tự và chuỗi","heading":"Thay đổi chữ hoa/chữ thường","text":"Thông thường thì người ta cần phải thay đổi cách viết thường/viết hoa của một giá trị dạng chuỗi ký tự, ví dụ như tên địa danh. Hãy sử dụng hàm str_to_upper(), str_to_lower(), và str_to_title() từ stringr, như dưới đây:Sử dụng base R, bạn cũng có thể thực hiện điều trên với hàm toupper(), tolower().Định dạng tiêu đềBiến đổi chuỗi ký tự sao cho mỗi từ được viết hoa có thể thực hiện được với hàm str_to_title():Sử dụng hàm toTitleCase() từ package tools để chuyển đổi nhiều kiểu viết hoa hơn (các từ như “”, “” và “” không cần viết hoa).Bạn cũng có thể sử dụng hàm str_to_sentence(), chỉ viết hoa chữ cái đầu tiên của chuỗi ký tự.","code":"\nstr_to_upper(\"California\")## [1] \"CALIFORNIA\"\nstr_to_lower(\"California\")## [1] \"california\"\nstr_to_title(\"go to the US state of california \")## [1] \"Go To The Us State Of California \"\ntools::toTitleCase(\"This is the US state of california\")## [1] \"This is the US State of California\"\nstr_to_sentence(\"the patient must be transported\")## [1] \"The patient must be transported\""},{"path":"characters-strings.html","id":"str_pad","chapter":"10 Ký tự và chuỗi","heading":"Độ dài chuỗi ký tự","text":"Sử dụng hàm str_pad() để thêm các ký tự vào một chuỗi, với độ dài tối thiểu. Mặc định, khoảng trắng sẽ được thêm vào, nhưng bạn cũng có thể chèn các ký tự khác bằng cách sử dụng đối số pad =.Ví dụ: để chèn thêm số bằng các số 0 ở đầu (chẳng hạn như giờ hoặc phút), bạn có thể chèn số có độ dài tối thiểu là 2 với pad = \"0\".","code":"\n# ICD codes of differing length\nICD_codes <- c(\"R10.13\",\n               \"R10.819\",\n               \"R17\")\n\n# ICD codes padded to 7 characters on the right side\nstr_pad(ICD_codes, 7, \"right\")## [1] \"R10.13 \" \"R10.819\" \"R17    \"\n# Pad with periods instead of spaces\nstr_pad(ICD_codes, 7, \"right\", pad = \".\")## [1] \"R10.13.\" \"R10.819\" \"R17....\"\n# Add leading zeros to two digits (e.g. for times minutes/hours)\nstr_pad(\"4\", 2, pad = \"0\") ## [1] \"04\"\n# example using a numeric column named \"hours\"\n# hours <- str_pad(hours, 2, pad = \"0\")"},{"path":"characters-strings.html","id":"cắt-chuỗi-ký-tự","chapter":"10 Ký tự và chuỗi","heading":"Cắt chuỗi ký tự","text":"Hàm str_trunc() thiết lập độ dài tối đa cho mỗi chuỗi ký tự. Nếu một chuỗi vượt quá độ dài này, nó sẽ bị xén (rút ngắn) và kết thúc bằng một dấu ba chấm (…) ám chỉ rằng chuỗi đó chưa hiển thị hết các ký tự. Lưu ý rằng dấu ba chấm được tính toán phụ thuộc vào độ dài. Các ký tự dấu ba chấm có thể được thay đổi bằng đối số ellipsis =. Đối số tùy chọn side = làm rõ vị trí mà dấu ba chấm sẽ xuất hiện trong chuỗi bị cắt ngắn (bên “trái”, “phải” hoặc “giữa”).","code":"\noriginal <- \"Symptom onset on 4/3/2020 with vomiting\"\nstr_trunc(original, 10, \"center\")## [1] \"Symp...ing\""},{"path":"characters-strings.html","id":"chuẩn-hóa-độ-dài","chapter":"10 Ký tự và chuỗi","heading":"Chuẩn hóa độ dài","text":"Sử dụng hàm str_trunc() để thiết lập độ dài tối đa, sau đó sử dụng hàm str_pad() để tăng thêm độ dài cho các chuỗi rất ngắn sao cho bằng độ dài tiêu chuẩn. Trong ví dụ dưới đây, độ dài tối đa là 6 (một ký tự bị cắt giảm), và sau đó một giá trị rất ngắn được đệm thêm để đạt được độ dài chuỗi là 6.","code":"\n# ICD codes of differing length\nICD_codes   <- c(\"R10.13\",\n                 \"R10.819\",\n                 \"R17\")\n\n# truncate to maximum length of 6\nICD_codes_2 <- str_trunc(ICD_codes, 6)\nICD_codes_2## [1] \"R10.13\" \"R10...\" \"R17\"\n# expand to minimum length of 6\nICD_codes_3 <- str_pad(ICD_codes_2, 6, \"right\")\nICD_codes_3## [1] \"R10.13\" \"R10...\" \"R17   \""},{"path":"characters-strings.html","id":"xóa-khoảng-trắng-đầucuối","chapter":"10 Ký tự và chuỗi","heading":"Xóa khoảng trắng đầu/cuối","text":"Sử dụng hàm str_trim() để xóa khoảng trắng, dòng mới (\\n) hoặc tabs (\\t) ở các phía của chuỗi đầu vào. Thêm \"right\" \"left\", hoặc \"\" vào lệnh để xác định phía nào cần cắt (ví dụ: str_trim(x, \"right\").","code":"\n# ID numbers with excess spaces on right\nIDs <- c(\"provA_1852  \", # two excess spaces\n         \"provA_2345\",   # zero excess spaces\n         \"provA_9460 \")  # one excess space\n\n# IDs trimmed to remove excess spaces on right side only\nstr_trim(IDs)## [1] \"provA_1852\" \"provA_2345\" \"provA_9460\""},{"path":"characters-strings.html","id":"xóa-khoảng-trắng-lặp-lại-phía-trong","chapter":"10 Ký tự và chuỗi","heading":"Xóa khoảng trắng lặp lại phía trong","text":"Sử dụng hàm str_squish() để loại bỏ các khoảng trắng lặp lại bên trong một chuỗi. Ví dụ, để chuyển đổi khoảng trắng lặp thành khoảng trắng đơn. Điều này cũng sẽ loại bỏ dấu cách, dòng mới hoặc tab ở phía bên ngoài chuỗi như giống như hàm str_trim().Gõ ?str_trim, ?str_pad vào cửa sổ R console để biết thêm chi tiết.","code":"\n# original contains excess spaces within string\nstr_squish(\"  Pt requires   IV saline\\n\") ## [1] \"Pt requires IV saline\""},{"path":"characters-strings.html","id":"gói-lại-thành-đoạn-văn-bản","chapter":"10 Ký tự và chuỗi","heading":"Gói lại thành đoạn văn bản","text":"Sử dụng hàm str_wrap() để gói một đoạn văn bản dài không có cấu trúc thành một đoạn văn có cấu trúc với độ dài các dòng là cố định. Cần xác định độ dài lý tưởng cho mỗi dòng và áp dụng một thuật toán để chèn thêm dòng mới (\\n) vào trong đoạn văn bản, như ví dụ bên dưới.Hàm cat() trong base R có thể xử lý toàn bộ câu lệnh trên để trả kết quả, hiển thị các dòng mới được thêm vào.","code":"\npt_course <- \"Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020.\"\n\nstr_wrap(pt_course, 40)## [1] \"Symptom onset 1/4/2020 vomiting chills\\nfever. Pt saw traditional healer in\\nhome village on 2/4/2020. On 5/4/2020\\npt symptoms worsened and was admitted\\nto Lumta clinic. Sample was taken and pt\\nwas transported to regional hospital on\\n6/4/2020. Pt died at regional hospital\\non 7/4/2020.\"\ncat(str_wrap(pt_course, 40))## Symptom onset 1/4/2020 vomiting chills\n## fever. Pt saw traditional healer in\n## home village on 2/4/2020. On 5/4/2020\n## pt symptoms worsened and was admitted\n## to Lumta clinic. Sample was taken and pt\n## was transported to regional hospital on\n## 6/4/2020. Pt died at regional hospital\n## on 7/4/2020."},{"path":"characters-strings.html","id":"xử-lý-theo-vị-trí","chapter":"10 Ký tự và chuỗi","heading":"10.4 Xử lý theo vị trí","text":"","code":""},{"path":"characters-strings.html","id":"tách-chuỗi-theo-vị-trí-ký-tự","chapter":"10 Ký tự và chuỗi","heading":"Tách chuỗi theo vị trí ký tự","text":"Sử dụng hàm str_sub() để trả về một phần của chuỗi. Hàm chứa 3 đối số chính là:các vector ký tựvị trí bắt đầuvị trí kết thúcMột vài lưu ý về số thứ tự vị trí:Nếu số thứ tự vị trí là số dương, vị trí được xử lý bắt đầu từ vị trí cuối cùng bên trái của chuỗi.Nếu số thứ tự vị trí là số âm, vị trí được xử lý bắt đầu từ vị trí cuối cùng bên phải của chuỗi.Số thứ tự vị trí được bao gồm.Các vị trí vượt quá chuỗi sẽ bị cắt bớt (loại bỏ).Dưới đây là một số ví dụ được áp dụng cho chuỗi ký tự “pneumonia”:","code":"\n# start and end third from left (3rd letter from left)\nstr_sub(\"pneumonia\", 3, 3)## [1] \"e\"\n# 0 is not present\nstr_sub(\"pneumonia\", 0, 0)## [1] \"\"\n# 6th from left, to the 1st from right\nstr_sub(\"pneumonia\", 6, -1)## [1] \"onia\"\n# 5th from right, to the 2nd from right\nstr_sub(\"pneumonia\", -5, -2)## [1] \"moni\"\n# 4th from left to a position outside the string\nstr_sub(\"pneumonia\", 4, 15)## [1] \"umonia\""},{"path":"characters-strings.html","id":"tách-theo-vị-trí-từ","chapter":"10 Ký tự và chuỗi","heading":"Tách theo vị trí từ","text":"Để tách ‘từ’ thứ n, hãy sử dụng hàm word() cũng thuộc package stringr. Đầu tiên, xác định (các) chuỗi ký tự, sau đó là vị trí từ đầu tiên cần trích xuất và vị trí từ cuối cùng để trích xuất.Mặc định, dấu phân cách giữa các ‘từ’ được giả định là khoảng trắng, trừ khi được chỉ định cách khác bằng đối số sep = (ví dụ: sep = \"_\" khi các từ được phân tách bằng dấu gạch dưới)","code":"\n# strings to evaluate\nchief_complaints <- c(\"I just got out of the hospital 2 days ago, but still can barely breathe.\",\n                      \"My stomach hurts\",\n                      \"Severe ear pain\")\n\n# extract 1st to 3rd words of each string\nword(chief_complaints, start = 1, end = 3, sep = \" \")## [1] \"I just got\"       \"My stomach hurts\" \"Severe ear pain\""},{"path":"characters-strings.html","id":"thay-thế-theo-vị-trí-ký-tự","chapter":"10 Ký tự và chuỗi","heading":"Thay thế theo vị trí ký tự","text":"Hàm str_sub() được ghép nối với toán tử gán (<-) có thể được sử dụng để sửa đổi một phần của chuỗi ký tự:Một ví dụ áp dụng cho nhiều chuỗi (ví dụ: một cột). Lưu ý sự mở rộng về độ dài của từ “HIV”.","code":"\nword <- \"pneumonia\"\n\n# convert the third and fourth characters to X \nstr_sub(word, 3, 4) <- \"XX\"\n\n# print\nword## [1] \"pnXXmonia\"\nwords <- c(\"pneumonia\", \"tubercolosis\", \"HIV\")\n\n# convert the third and fourth characters to X \nstr_sub(words, 3, 4) <- \"XX\"\n\nwords## [1] \"pnXXmonia\"    \"tuXXrcolosis\" \"HIXX\""},{"path":"characters-strings.html","id":"đánh-giá-độ-dài-chuỗi","chapter":"10 Ký tự và chuỗi","heading":"Đánh giá độ dài chuỗi","text":"Ngoài ra, có thể sử dụng hàm nchar() từ base R","code":"\nstr_length(\"abc\")## [1] 3"},{"path":"characters-strings.html","id":"quy-luật-chuỗi","chapter":"10 Ký tự và chuỗi","heading":"10.5 Quy luật chuỗi","text":"Nhiều hàm stringr được sử dụng để nhận diện, định vị, trích xuất, khớp, thay thế và phân tách dựa trên một pattern - quy luật được chỉ định. .","code":""},{"path":"characters-strings.html","id":"nhận-diện-quy-luật","chapter":"10 Ký tự và chuỗi","heading":"Nhận diện quy luật","text":"Sử dụng hàm str_detect() như bên dưới để phát hiện sự hiện diện/sự vắng mặt của một quy luật trong chuỗi. Đầu tiên, hãy cung cấp cho chuỗi hoặc vectơ cần tìm tới hàm (string =), sau đó là quy luật tìm kiếm (pattern =). Lưu ý rằng theo mặc định thì tìm kiếm phân biệt chữ hoa chữ thường!Đối số negate = có thể được bao gồm và đặt thành TRUE nếu bạn muốn tìm một quy luật KHÔNG xuất hiện.Để bỏ qua chữ hoa / chữ thường, hãy đặt pattern trong hàm regex(), và bên trong hàm regex() hãy thêm đối số ignore_case = TRUE (hoặc viết tắt là T).Khi hàm str_detect() được áp dụng cho một vectơ ký tự hoặc một cột trong bộ dữ liệu, nó sẽ trả về giá trị TRUE hoặc FALSE cho mỗi giá trị.Nếu bạn cần đếm giá trị TRUE, chỉ cần đơn giản tính tổng bằng hàm sum() kết quả đầu ra. Nó sẽ đếm số lượng giá trị TRUE.Để tìm kiếm bao gồm nhiều cụm từ, hãy nhóm chúng bằng ký tự (|) bên trong đối số pattern = như được trình bày dưới đây:Nếu bạn cần xây dựng một danh sách dài gồm các cụm từ cần tìm kiếm, bạn có thể kết hợp chúng bằng cách sử dụng hàm str_c() và sep = |, sau đó chỉ định nó là một đối tượng dạng ký tự, và sau đó tham chiếu vector một cách ngắn gọn hơn. Ví dụ dưới đây bao gồm các cụm từ tìm kiếm bao gồm các nghề nghiệp có thể sử dụng cho các nhà cung cấp dịch vụ y tế tuyến đầu.Lệnh này trả về số lượng nghề nghiệp mà chứa bất kỳ một trong các cụm từ tìm kiếm dành cho nhà cung cấp dịch vụ y tế tuyến đầu (occupation_med_frontline):Các hàm tìm kiếm chuỗi trong Base RHàm grepl() trong base R hoạt động tương tự như hàm str_detect(), trong đó nó tìm kiếm các kết quả phù hợp với một quy luật và trả về một vectơ logic. Cú pháp cơ bản đó là grepl(pattern, strings_to_search, ignore.case = FALSE, ...). Một ưu điểm đó là đối số ignore.case dễ viết hơn (không cần có sự tham gia của hàm regex()).Tương tự như vậy, các hàm sub() và gsub() của base R hoạt động tương tự như hàm str_replace(). Cú pháp cơ bản đó là: gsub(pattern, replacement, strings_to_search, ignore.case = FALSE). sub() sẽ thay thế trường hợp đầu tiên của pattern, trong khi gsub() sẽ thay thế tất cả các trường hợp của pattern.","code":"\nstr_detect(string = \"primary school teacher\", pattern = \"teach\")## [1] TRUE\nstr_detect(string = \"primary school teacher\", pattern = \"teach\", negate = TRUE)## [1] FALSE\nstr_detect(string = \"Teacher\", pattern = regex(\"teach\", ignore_case = T))## [1] TRUE\n# a vector/column of occupations \noccupations <- c(\"field laborer\",\n                 \"university professor\",\n                 \"primary school teacher & tutor\",\n                 \"tutor\",\n                 \"nurse at regional hospital\",\n                 \"lineworker at Amberdeen Fish Factory\",\n                 \"physican\",\n                 \"cardiologist\",\n                 \"office worker\",\n                 \"food service\")\n\n# Detect presence of pattern \"teach\" in each string - output is vector of TRUE/FALSE\nstr_detect(occupations, \"teach\")##  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\nsum(str_detect(occupations, \"teach\"))## [1] 1\nsum(str_detect(string = occupations, pattern = \"teach|professor|tutor\"))## [1] 3\n# search terms\noccupation_med_frontline <- str_c(\"medical\", \"medicine\", \"hcw\", \"healthcare\", \"home care\", \"home health\",\n                                \"surgeon\", \"doctor\", \"doc\", \"physician\", \"surgery\", \"peds\", \"pediatrician\",\n                               \"intensivist\", \"cardiologist\", \"coroner\", \"nurse\", \"nursing\", \"rn\", \"lpn\",\n                               \"cna\", \"pa\", \"physician assistant\", \"mental health\",\n                               \"emergency department technician\", \"resp therapist\", \"respiratory\",\n                                \"phlebotomist\", \"pharmacy\", \"pharmacist\", \"hospital\", \"snf\", \"rehabilitation\",\n                               \"rehab\", \"activity\", \"elderly\", \"subacute\", \"sub acute\",\n                                \"clinic\", \"post acute\", \"therapist\", \"extended care\",\n                                \"dental\", \"dential\", \"dentist\", sep = \"|\")\n\noccupation_med_frontline## [1] \"medical|medicine|hcw|healthcare|home care|home health|surgeon|doctor|doc|physician|surgery|peds|pediatrician|intensivist|cardiologist|coroner|nurse|nursing|rn|lpn|cna|pa|physician assistant|mental health|emergency department technician|resp therapist|respiratory|phlebotomist|pharmacy|pharmacist|hospital|snf|rehabilitation|rehab|activity|elderly|subacute|sub acute|clinic|post acute|therapist|extended care|dental|dential|dentist\"\nsum(str_detect(string = occupations, pattern = occupation_med_frontline))## [1] 2"},{"path":"characters-strings.html","id":"chuyển-đổi-dấu-phẩy-thành-dấu-chấm","chapter":"10 Ký tự và chuỗi","heading":"Chuyển đổi dấu phẩy thành dấu chấm","text":"Sau đây là một ví dụ về việc sử dụng hàm gsub() để chuyển đổi dấu phẩy thành dấu chấm trong một vectơ dạng số. Điều này có thể hữu ích nếu dữ liệu của bạn bắt nguồn từ nhiều nơi trên thế giới ngoài Hoa Kỳ hoặc Vương quốc Anh.Hàm gsub() ở bên trong đầu tiên hoạt động trên đối tượng lengths để chuyển đổi bất kỳ dấu chấm nào thành không có khoảng trắng ““. Ký tự dấu chấm”.” phải được “đi liền” với hai dấu gạch chéo để biểu thị một dấu chấm, bởi vì “.” trong biểu thức chính quy có nghĩa là “bất kỳ ký tự nào”. Sau đó, kết quả (chỉ có dấu phẩy) được chuyển tiếp đến hàm gsub() bên ngoài trong đó dấu phẩy được thay thế bằng dấu chấm.","code":"\nlengths <- c(\"2.454,56\", \"1,2\", \"6.096,5\")\n\nas.numeric(gsub(pattern = \",\",                # find commas     \n                replacement = \".\",            # replace with periods\n                x = gsub(\"\\\\.\", \"\", lengths)  # vector with other periods removed (periods escaped)\n                )\n           )                                  # convert outcome to numeric"},{"path":"characters-strings.html","id":"thay-thế-toàn-bộ","chapter":"10 Ký tự và chuỗi","heading":"Thay thế toàn bộ","text":"Sử dụng hàm str_replace_all() như là một công cụ “find replace (tìm kiếm và thay thế)”. Đầu tiên, cung cấp các chuỗi ký tự sẽ được đánh giá tới đối số string =, sau đó là quy luật sẽ được thay thế vào đối số pattern =, và sau đó là giá trị thay thế vào replacement =. Ví dụ dưới đây thay thế tất cả các trường hợp “dead” bằng “deceased”. Lưu ý, phân biệt chữ hoa chữ thường.Lưu ý:Để thay thế một pattern cho NA, sử dụng hàm str_replace_na().Hàm str_replace() thay thế duy nhất trường hợp đầu tiên của pattern trong mỗi chuỗi ký tự.","code":"\noutcome <- c(\"Karl: dead\",\n            \"Samantha: dead\",\n            \"Marco: not dead\")\n\nstr_replace_all(string = outcome, pattern = \"dead\", replacement = \"deceased\")## [1] \"Karl: deceased\"      \"Samantha: deceased\"  \"Marco: not deceased\""},{"path":"characters-strings.html","id":"nhận-diện-logic","chapter":"10 Ký tự và chuỗi","heading":"Nhận diện logic","text":"Bên trong hàm case_when()str_detect() thường được sử dụng trong hàm case_when() (từ dplyr). Hãy coi occupations là một cột trong bộ linelist. Hàm mutate() dưới đây tạo một cột mới gọi là is_educator bằng cách sử dụng logic có điều kiện bởi case_when(). Xem thêm ở chương về làm sạch dữ liệu để hiểu hơn về hàm case_when().Xin nhắc lại, điều quan trọng là phải thêm tiêu chí loại trừ vào điều kiện logic (negate = F):","code":"\ndf <- df %>% \n  mutate(is_educator = case_when(\n    # term search within occupation, not case sensitive\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\",\n                     ignore_case = TRUE))              ~ \"Educator\",\n    # all others\n    TRUE                                               ~ \"Not an educator\"))df <- df %>% \n  # value in new column is_educator is based on conditional logic\n  mutate(is_educator = case_when(\n    \n    # occupation column must meet 2 criteria to be assigned \"Educator\":\n    # it must have a search term AND NOT any exclusion term\n    \n    # Must have a search term\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\", ignore_case = T)) &              \n    \n    # AND must NOT have an exclusion term\n    str_detect(occupations,\n               regex(\"admin\", ignore_case = T),\n               negate = TRUE                        ~ \"Educator\"\n    \n    # All rows not meeting above criteria\n    TRUE                                            ~ \"Not an educator\"))"},{"path":"characters-strings.html","id":"định-vị-vị-trí-pattern","chapter":"10 Ký tự và chuỗi","heading":"Định vị vị trí pattern","text":"Để xác định vị trí đầu tiên của một pattern, hãy sử dụng hàm str_locate(). Nó xuất ra vị trí bắt đầu và kết thúc.Giống như các hàm str khác, có một phiên bản “_all” (str_locate_all()) sẽ trả về vị trí của tất cả các phiên bản của pattern trong mỗi chuỗi. Kết quả này xuất ra dưới dạng danh sách list.","code":"\nstr_locate(\"I wish\", \"sh\")##      start end\n## [1,]     5   6\nphrases <- c(\"I wish\", \"I hope\", \"he hopes\", \"He hopes\")\n\nstr_locate(phrases, \"h\" )     # position of *first* instance of the pattern##      start end\n## [1,]     6   6\n## [2,]     3   3\n## [3,]     1   1\n## [4,]     4   4\nstr_locate_all(phrases, \"h\" ) # position of *every* instance of the pattern## [[1]]\n##      start end\n## [1,]     6   6\n## \n## [[2]]\n##      start end\n## [1,]     3   3\n## \n## [[3]]\n##      start end\n## [1,]     1   1\n## [2,]     4   4\n## \n## [[4]]\n##      start end\n## [1,]     4   4"},{"path":"characters-strings.html","id":"trích-xuất-kết-quả-ghép-cặp","chapter":"10 Ký tự và chuỗi","heading":"Trích xuất kết quả ghép cặp","text":"str_extract_all() trả về các patterns được matching, sẽ hữu dụng nhất khi bạn cung cấp một vài patterns thông qua điều kiện “”. Ví dụ: tìm trong vectơ chuỗi nghề nghiệp (xem tab trước) các từ “teach”, “prof” hoặc “tutor”.str_extract_all() trả về một danh sách list chứa tất cả các kết quả ghép cặp cho mỗi chuỗi được đánh giá. Xem dưới đây ta thấy occupation 3 có hai pattern được tìm thấy.str_extract() chỉ trích xuất kết quả ghép cặp đầu tiên trong mỗi chuỗi được xem xét, tạo ra một vectơ ký tự với một phần tử cho mỗi chuỗi được xem xét. Nó trả về giá trị NA khi không có giá trị nào được tìm thấy. Các giá trị NA có thể được loại bỏ bằng cách đặt vectơ trả về trong hàm na.exclude(). Lưu ý đoạn khớp nối thứ hai của occupation 3 không được hiển thị.","code":"\nstr_extract_all(occupations, \"teach|prof|tutor\")## [[1]]\n## character(0)\n## \n## [[2]]\n## [1] \"prof\"\n## \n## [[3]]\n## [1] \"teach\" \"tutor\"\n## \n## [[4]]\n## [1] \"tutor\"\n## \n## [[5]]\n## character(0)\n## \n## [[6]]\n## character(0)\n## \n## [[7]]\n## character(0)\n## \n## [[8]]\n## character(0)\n## \n## [[9]]\n## character(0)\n## \n## [[10]]\n## character(0)\nstr_extract(occupations, \"teach|prof|tutor\")##  [1] NA      \"prof\"  \"teach\" \"tutor\" NA      NA      NA      NA      NA      NA"},{"path":"characters-strings.html","id":"tập-hợp-con-và-số-lượng","chapter":"10 Ký tự và chuỗi","heading":"Tập hợp con và số lượng","text":"Bao gồm hàm str_subset() và str_count().str_subset() trả về các giá trị thực có chứa pattern:str_count() trả về một vectơ số: số lần một cụm từ tìm kiếm xuất hiện trong mỗi giá trị được xem xét.","code":"\nstr_subset(occupations, \"teach|prof|tutor\")## [1] \"university professor\"           \"primary school teacher & tutor\" \"tutor\"\nstr_count(occupations, regex(\"teach|prof|tutor\", ignore_case = TRUE))##  [1] 0 1 2 1 0 0 0 0 0 0"},{"path":"characters-strings.html","id":"nhóm-regex","chapter":"10 Ký tự và chuỗi","heading":"Nhóm Regex","text":"ĐANG ĐƯỢC XÂY DỰNG","code":""},{"path":"characters-strings.html","id":"các-ký-tự-đặc-biệt","chapter":"10 Ký tự và chuỗi","heading":"10.6 Các ký tự đặc biệt","text":"Dấu gạch chéo ngược \\ để bỏ quaDấu gạch chéo ngược \\ được sử dụng “để bỏ qua” nghĩa của ký tự tiếp theo. Bằng cách này, dấu gạch chéo ngược có thể được sử dụng để hiển thị dấu ngoặc kép bên trong các dấu ngoặc kép khác (\\\") - dấu ngoặc kép ở giữa sẽ không “phá vỡ” các dấu ngoặc kép xung quanh.Lưu ý - đó, nếu bạn muốn hiển thị một dấu gạch chéo ngược, bạn phải ngắt nghĩa của nó bằng một dấu gạch chéo ngược khác. Vì vậy, bạn phải viết hai dấu gạch chéo ngược \\\\ để chỉ hiển thị một.Các ký tự đặc biệtGõ ?\"'\" trong cửa sổ R Console để hiển thị danh sách đầy đủ các ký tự đặc biệt (nó sẽ xuất hiện trong cửa sổ Help của RStudio).","code":""},{"path":"characters-strings.html","id":"biểu-thức-chính-quy-regex","chapter":"10 Ký tự và chuỗi","heading":"10.7 Biểu thức chính quy (regex)","text":"","code":""},{"path":"characters-strings.html","id":"regex-và-các-ký-tự-đặc-biệt","chapter":"10 Ký tự và chuỗi","heading":"10.8 Regex và các ký tự đặc biệt","text":"Biểu thức chính quy, hoặc “regex”, là một ngôn ngữ ngắn gọn để mô tả các patterns trong chuỗi ký tự. Nếu bạn không quen với nó, một biểu thức chính quy có thể trông giống như một ngôn ngữ ngoài hành tinh. Ở đây chúng tôi cố lột tả ngôn ngữ này dễ hiểu hơnPhần lớn nội dung mục này được tham khảo từ hướng dẫn này và cheatsheet này. Chúng tôi tóm tắt một cách chọn lọc ở đây khi biết rằng cuốn ebook này có thể được xem bởi những người không có quyền truy cập internet để có thể xem các hướng dẫn khác.Một biểu thức chính quy thường được áp dụng để trích xuất các pattern cụ thể từ văn bản “không có cấu trúc” - ví dụ: ghi chú y tế, khiếu nại, tiền sử bệnh tật hoặc các cột văn bản khác trong bộ dữ liệu.Có bốn công cụ cơ bản mà người ta có thể sử dụng để tạo một biểu thức chính quy cơ bản:Bộ ký tựSiêu ký tựBộ định lượngNhómBộ ký tựBộ ký tự, là một cách thể hiện các tùy chọn liệt kê phù hợp với ký tự gốc, trong dấu ngoặc. Vì vậy, mọi kết quả khớp sẽ được đánh dấu nếu tìm thấy bất kỳ ký tự nào trong dấu ngoặc trong chuỗi. Ví dụ, để tìm các nguyên âm, người ta có thể sử dụng bộ ký tự này: “[aeiou]”. Một số bộ ký tự phổ biến khác là:Các bộ ký tự có thể được kết hợp trong một dấu ngoặc vuông (không có khoảng trắng!), chẳng hạn như \"[-Za-z]\" (bất kỳ chữ cái viết hoa hoặc viết thường nào), hoặc một ví dụ khác \"[t-z0-5]\" (từ t viết thường đến z HOẶC số 0 đến 5).Siêu ký tựCác siêu ký tự là cách viết tắt của các bộ ký tự. Một số điều quan trọng được liệt kê dưới đây:Bộ định lượngThông thường, bạn không muốn tìm kiếm kết quả phù hợp chỉ trên một ký tự. Bộ định lượng cho phép bạn chỉ định độ dài của các chữ cái/số để cho phép ghép nối.Bộ định lượng là các số được viết trong dấu ngoặc nhọn { } sau ký tự mà chúng đang định lượng, ví dụ:\"{2}\" sẽ trả về trường hợp hai chữ cái viết hoa.\"{2,4}\" sẽ trả về các trường hợp từ hai đến bốn chữ cái viết hoa (không đặt dấu cách!).\"{2,}\" sẽ trả về các trường hợp từ hai hoặc nhiều hơn chữ cái viết hoa.\"+\" sẽ trả về các trường hợp từ một hoặc nhiều hơn chữ cái viết hoa (nhóm được mở rộng cho đến khi gặp một ký tự khác).Bắt đầu bằng dấu hoa thị * để trả về không hoặc nhiều hơn kết quả phù hợp (hữu ích nếu bạn không chắc chắn pattern có sẵn)Sử dụng ký hiệu dấu cộng + như một bộ định lượng, việc khớp sẽ xảy ra cho tới khi gặp ký tự khác. Ví dụ, biểu thứ này sẽ trả về tất cả các từ (ký tự alpha: \"[-Za-z]+\"Khi bộ định lượng {2} được sử dụng, chỉ các cặp chữ liên tiếp được trả về. Hai cặp được xác định trong AAAA.Khi bộ định lượng {2,4} được sử dụng, các nhóm chữ liên tiếp có độ dài từ hai đến bốn được trả về.Với bộ định lượng +, các nhóm của một hoặc nhiều hơn được trả về:Vị trí tương đốiNhững biểu thức dưới đây yêu cầu cho những thứ đứng trước hoặc theo sau một mẫu. Ví dụ, để trích xuất câu, “two numbers followed period” (\"\"). (?<=\\.)\\s(?=[-Z])NhómViệc bắt các nhóm trong biểu thức chính quy là một cách để kết quả trả về có tổ chức hơn khi trích xuất.Ví dụ về RegexDưới đây là một văn bản tự sử dụng làm ví dụ. Chúng ta sẽ cố gắng trích xuất thông tin hữu ích từ nó bằng cách sử dụng cụm từ tìm kiếm theo biểu thức chính quy.Biểu thức sau đây khớp với tất cả các từ (bất kỳ ký tự nào cho đến khi gặp thứ không phải ký tự, chẳng hạn như dấu cách):Biểu thức \"[0-9]{1,2}\" khớp với các số liên tiếp có độ dài 1 hoặc 2 chữ số. Nó cũng có thể được viết là \"\\\\d{1,2}\", hoặc \"[:digit:]{1,2}\".Bạn có thể xem danh sách hữu ích về các biểu thức regex và các mẹo trên trang 2 của cheatsheet nàyBạn cũng có thể xem tutorial này.","code":"\n# test string for quantifiers\ntest <- \"A-AA-AAA-AAAA\"\nstr_extract_all(test, \"A{2}\")## [[1]]\n## [1] \"AA\" \"AA\" \"AA\" \"AA\"\nstr_extract_all(test, \"A{2,4}\")## [[1]]\n## [1] \"AA\"   \"AAA\"  \"AAAA\"\nstr_extract_all(test, \"A+\")## [[1]]\n## [1] \"A\"    \"AA\"   \"AAA\"  \"AAAA\"\nstr_extract_all(test, \"\")## [[1]]\n##  [1] \"A\" \"-\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"A\"\npt_note <- \"Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute.\"\nstr_extract_all(pt_note, \"[A-Za-z]+\")## [[1]]\n##  [1] \"Patient\"     \"arrived\"     \"at\"          \"Broward\"     \"Hospital\"    \"emergency\"   \"ward\"        \"at\"          \"on\"          \"Patient\"     \"presented\"  \n## [12] \"with\"        \"radiating\"   \"abdominal\"   \"pain\"        \"from\"        \"LR\"          \"quadrant\"    \"Patient\"     \"skin\"        \"was\"         \"pale\"       \n## [23] \"cool\"        \"and\"         \"clammy\"      \"Patient\"     \"temperature\" \"was\"         \"degrees\"     \"farinheit\"   \"Patient\"     \"pulse\"       \"rate\"       \n## [34] \"was\"         \"bpm\"         \"and\"         \"thready\"     \"Respiratory\" \"rate\"        \"was\"         \"per\"         \"minute\"\nstr_extract_all(pt_note, \"[0-9]{1,2}\")## [[1]]\n##  [1] \"18\" \"00\" \"6\"  \"12\" \"20\" \"05\" \"99\" \"8\"  \"10\" \"0\"  \"29\""},{"path":"characters-strings.html","id":"nguồn-2","chapter":"10 Ký tự và chuỗi","heading":"10.9 Nguồn","text":"Bạn có thể tìm thấy trang tham khảo cho các hàm stringr tại đâyMột vignette về stringr có thể được tìm thấy tại đây","code":""},{"path":"factors.html","id":"factors","chapter":"11 Factors","heading":"11 Factors","text":"Trong R, factors là một kiểu dữ liệu cho phép sắp xếp các danh mục với một tập hợp các giá trị có thể chấp nhận.Thông thường, bạn sẽ chuyển đổi một cột từ dạng ký tự hoặc dạng số thành dạng factor khi bạn muốn sắp xếp một thứ tự đặc biệt cho các giá trị (“levels”) để chúng không hiển thị mặc định theo thứ tự bảng chữ cái trong các biểu đồ và bảng. Một cách sử dụng phổ biến khác của factor là chuẩn hóa các chú thích của biểu đồ để chúng không thay đổi nếu một giá trị tạm thời không có trong dữ liệu.Chương này giới thiệu cách sử dụng các hàm từ package forcats (tên viết tắt của “categorical variables”) và một số hàm base R. Chúng tôi cũng đề cập đến việc sử dụng lubridate và aweek cho các trường hợp factor đặc biệt liên quan đến tuần dịch tễ học.Bạn có thể tìm thấy danh sách đầy đủ các hàm của package forcats trực tuyến tại đường link này. Sau đây, chúng tôi sẽ chỉ trình bày một số hàm phổ biến nhất.","code":""},{"path":"factors.html","id":"chuẩn-bị-2","chapter":"11 Factors","heading":"11.1 Chuẩn bị","text":"","code":""},{"path":"factors.html","id":"gọi-packages-2","chapter":"11 Factors","heading":"Gọi packages","text":"Đoạn code dưới đây hiển thị cách gọi các package cần thiết cho việc phân tích. Trong sách này, chúng tôi nhấn mạnh đến việc sử dụng hàm p_load() từ package pacman, giúp cài đặt package nếu nó chưa được cài và gọi nó ra cho phiên làm việc. Bạn cũng có thể gọi các package đã được cài đặt bằng hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.","code":"\npacman::p_load(\n  rio,           # import/export\n  here,          # filepaths\n  lubridate,     # working with dates\n  forcats,       # factors\n  aweek,         # create epiweeks with automatic factor levels\n  janitor,       # tables\n  tidyverse      # data mgmt and viz\n  )"},{"path":"factors.html","id":"nhập-dữ-liệu-4","chapter":"11 Factors","heading":"Nhập dữ liệu","text":"Chúng ta sẽ nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Để tiện muốn theo dõi, bấm để tải bộ dữ liệu linelist “đã được làm sạch” (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (hàm có thể áp dụng với nhiều loại dữ liệu như .xlsx, .rds, .csv - Xem chương Nhập xuất dữ liệu để biết thêm chi tiết).","code":"\n# import your dataset\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"factors.html","id":"fct_newcat","chapter":"11 Factors","heading":"Thêm biến danh mục mới","text":"Trong chương này, chúng tôi sẽ minh họa một trường hợp thường gặp, đó là tạo ra một biến danh mục mới.Lưu ý rằng khi bạn chuyển đổi một cột dạng số thành dạng factor, bạn sẽ không thể thực hiện các tính toán thống kê đối với dữ liệu dạng số trên cột đó nữa.","code":""},{"path":"factors.html","id":"tạo-biến","chapter":"11 Factors","heading":"Tạo biến","text":"Chúng ta sẽ sử dụng một biến có sẵn, tên là days_onset_hosp (số ngày, tính từ khi bắt đầu có triệu chứng cho đến khi nhập viện) và tạo một biến mới có tên delay_cat bằng cách phân loại các giá trị trong mỗi hàng của biến có sẵn đó thành một số nhóm khác nhau. Chúng ta sẽ thực hiện việc này bằng hàm case_when() trong package dplyr, hàm này sẽ giúp áp dụng tuần tự các tiêu chí logic (phía bên phải) cho mỗi giá trị của biễn có sẵn và trả về giá trị bên trái tương ứng ở biến mới delay_cat. Đọc thêm về case_when() tại chương Làm sạch số liệu và các hàm quan trọng.","code":"\nlinelist <- linelist %>% \n  mutate(delay_cat = case_when(\n    # criteria                                   # new value if TRUE\n    days_onset_hosp < 2                        ~ \"<2 days\",\n    days_onset_hosp >= 2 & days_onset_hosp < 5 ~ \"2-5 days\",\n    days_onset_hosp >= 5                       ~ \">5 days\",\n    is.na(days_onset_hosp)                     ~ NA_character_,\n    TRUE                                       ~ \"Check me\"))  "},{"path":"factors.html","id":"thứ-tự-mặc-định-của-các-giá-trị","chapter":"11 Factors","heading":"Thứ tự mặc định của các giá trị","text":"Khi sử dụng hàm case_when(), biến mới delay_cat tạo ra sẽ là một biến danh mục với kiểu dữ liệu là ký tự - chưa phải là một factor. đó, trong bảng tần suất dưới đây, chúng ta thấy rằng các giá trị xuất hiện theo thứ tự mặc định của bảng chữ cái, điều này không có nhiều ý nghĩa trực quan:Tương tự như vậy, nếu chúng ta tạo biểu đồ cột, các giá trị cũng xuất hiện theo thứ tự này trên trục x (xem chương ggplot cơ bản để hiểu thêm về package ggplot2 - package giúp trực quan hóa dữ liệu phổ biến nhất trong R).","code":"\ntable(linelist$delay_cat, useNA = \"always\")## \n##  <2 days  >5 days 2-5 days     <NA> \n##     2990      602     2040      256\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))"},{"path":"factors.html","id":"chuyển-đổi-sang-factor","chapter":"11 Factors","heading":"11.2 Chuyển đổi sang factor","text":"Để chuyển đổi một biến dạng ký tự hoặc dạng số sang dạng factor, bạn có thể sử dụng bất kỳ hàm nào trong package forcats (nhiều hàm được nêu chi tiết tại mục dưới đây). Các biến sẽ chuyển đổi sang dạng factor và sau đó cũng thực hiện hoặc sắp xếp theo một thứ tự nhất định của các levels - ví dụ: hàm fct_relevel() cho phép bạn chỉ định thứ tự levels theo cách thủ công. Hàm as_factor() chỉ đơn giản là chuyển đổi biến sang dạng factor mà không có thêm bất kỳ chức năng nào khác.Hàm factor() trong base R chuyển đổi một biến thành factor và cho phép bạn tự sắp xếp thứ tự của các nhóm giá trị, dưới dạng một vectơ ký tự của đối số levels =.Dưới đây, chúng tôi sử dụng hàm mutate() và hàm fct_relevel() để chuyển đối biến có sẵn delay_cat từ dạng ký tự sang dạng factor. Biến delay_cat đã được tạo ở phần Chuẩn bị bên trên.Các “giá trị” duy nhất trong biến số được gọi là các “thứ bậc” của biến factor. Các thứ bậc này được sắp xếp theo một trật tự nhất định và có thể được ra bằng hàm levels() từ base R, hoặc bạn có thể xem nó bằng một bảng đếm thông qua hàm table()từ base R, hoặc hàm tabyl() từ package janitor. Trật tự này sẽ được hiển thị theo thứ tự của bảng chữ cái. Lưu ý rằng NA không được xem là một thứ bậc trong factor.Hàm fct_relevel() có thêm chức năng cho phép bạn có thể tự sắp xếp trật tự của các thứ bậc trong factor. Đơn giản, bạn chỉ cần viết các thứ bậc theo thứ tự bạn muốn, để chúng trong dấu ngoặc kép, được phân tách bằng dấu phẩy, như được hiển thị bên dưới. Lưu ý rằng chính tả phải khớp chính xác với tên các thứ bậc. Nếu bạn muốn tạo các thứ bậc không tồn tại trong dữ liệu, hãy sử dụng hàm fct_expand() nhé.Bây giờ chúng ta có thể thấy rằng các thứ bậc đã được sắp xếp theo một thứ tự hợp lý.Bây giờ trật tự các cột trong biểu đồ cũng trực quan hơn.","code":"\nlinelist <- linelist %>%\n  mutate(delay_cat = fct_relevel(delay_cat))\nlevels(linelist$delay_cat)## [1] \"<2 days\"  \">5 days\"  \"2-5 days\"\nlinelist <- linelist %>%\n  mutate(delay_cat = fct_relevel(delay_cat, \"<2 days\", \"2-5 days\", \">5 days\"))\nlevels(linelist$delay_cat)## [1] \"<2 days\"  \"2-5 days\" \">5 days\"\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))"},{"path":"factors.html","id":"thêm-hoặc-xóa-thứ-bậc","chapter":"11 Factors","heading":"11.3 Thêm hoặc xóa thứ bậc","text":"","code":""},{"path":"factors.html","id":"fct_add","chapter":"11 Factors","heading":"Thêm thứ bậc","text":"Nếu bạn cần thêm thứ bậc trong factor, bạn có thể sử dụng hàm fct_expand(). Bạn chỉ cần viết tên biến và theo sau là tên các thứ bậc mới (phân tách bằng dấu phẩy). Bằng cách lập bảng, chúng ta có thể thấy các thứ bậc mới xuất hiện và chưa nhận giá trị nào. Bạn có thể sử dụng hàm table() trong base R, hoặc hàm tabyl() trong package janitor:Lưu ý: Package forcats có thể dễ dàng thêm các giá trị missing (NA) như là một thứ bậc. Bạn có thể xem thêm tại mục Giá trị Missing dưới đây.","code":"\nlinelist %>% \n  mutate(delay_cat = fct_expand(delay_cat, \"Not admitted to hospital\", \"Transfer to other jurisdiction\")) %>% \n  tabyl(delay_cat)   # print table##                       delay_cat    n    percent valid_percent\n##                         <2 days 2990 0.50781250     0.5308949\n##                        2-5 days 2040 0.34646739     0.3622159\n##                         >5 days  602 0.10224185     0.1068892\n##        Not admitted to hospital    0 0.00000000     0.0000000\n##  Transfer to other jurisdiction    0 0.00000000     0.0000000\n##                            <NA>  256 0.04347826            NA"},{"path":"factors.html","id":"xóa-thứ-bậc","chapter":"11 Factors","heading":"Xóa thứ bậc","text":"Nếu bạn sử dụng hàm fct_drop(), các thứ bậc “không được sử dụng” và không có quan sát nào sẽ bị loại bỏ khỏi factors. Thứ bậc mà chúng ta đã thêm ở trên (“admitted hospital”) có tồn tại nhưng thực tế không có dòng nào chứa giá trị này. Vì vậy, chúng sẽ bị loại bỏ khỏi biến factor của chúng ta bằng cách sử dụng hàm fct_drop() như sau:","code":"\nlinelist %>% \n  mutate(delay_cat = fct_drop(delay_cat)) %>% \n  tabyl(delay_cat)##  delay_cat    n    percent valid_percent\n##    <2 days 2990 0.50781250     0.5308949\n##   2-5 days 2040 0.34646739     0.3622159\n##    >5 days  602 0.10224185     0.1068892\n##       <NA>  256 0.04347826            NA"},{"path":"factors.html","id":"fct_adjust","chapter":"11 Factors","heading":"11.4 Thay đổi trật tự của các thứ bậc","text":"Package forcats cung cấp các hàm hữu ích để dễ dàng thay đổi trật tự của các thứ bậc trong một biến kiểu factor (sau khi một biến số được định nghĩa là một factor):Các hàm trong package này có thể được áp dụng cho biến dạng factor trong hai trường hợp dưới đây:Đối với cột trong một data frame, thông thường, việc thay đổi sẽ được giữ nguyên cho các lần sử dụng dữ liệu tiếp theoTrong một biểu đồ, sự thay đổi trật tự chỉ được áp dụng cho biểu đồ đó","code":""},{"path":"factors.html","id":"thay-đổi-thủ-công","chapter":"11 Factors","heading":"Thay đổi thủ công","text":"Hàm này được sử dụng để thay đổi trật tự của các thứ bậc trong một biến dạng factor theo cách thủ công. Nếu hàm này được sử dụng trên một biến dạng khác, không phải factor, hàm sẽ giúp chuyển biến đó sang dạng factor trước.Trong dấu ngoặc đơn trước tiên điền tên của biến factor, sau đó điền:Tất cả các thứ bậc trong biến factor mà bạn mong muốn thay đổi trật tự (dưới dạng vector ký tự c()), hoặcChỉ một giá trị thứ bậc với vị trí tương ứng mong muốn, sử dụng đối số =Dưới đây là một ví dụ về chuyển biến delay_cat thành dạng factor (mặc dù biến này đã ở dạng Factor rồi) và sắp xếp lại các thứ bậc theo thứ tự mong muốn.Nếu bạn chỉ muốn chỉ định vị trí cho một thứ bậc, bạn có thể dùng hàm fct_relevel() và sử dụng đối số = để chỉ định một giá trị thứ bậc với vị trí tương ứng mong muốn. Ví dụ: lệnh dưới đây chuyển thứ bậc “<2 days” sang vị trí thứ hai:","code":"\n# re-define level order\nlinelist <- linelist %>% \n  mutate(delay_cat = fct_relevel(delay_cat, c(\"<2 days\", \"2-5 days\", \">5 days\")))\n# re-define level order\nlinelist %>% \n  mutate(delay_cat = fct_relevel(delay_cat, \"<2 days\", after = 1)) %>% \n  tabyl(delay_cat)"},{"path":"factors.html","id":"đối-với-biểu-đồ","chapter":"11 Factors","heading":"Đối với biểu đồ","text":"Các lệnh trong package forcats có thể được sử dụng để thay đổi trật tự của biến trong data frame hoặc trong biểu đồ. Bằng cách sử dụng các lệnh để “gói” tên biến vào trong các lệnh vẽ biểu đồ của package ggplot(), bạn có thể dảo ngược/thay đổi một trật tự có sẵn của biến. Sự thay đổi này chỉ áp dụng trong biểu đồ đang vẽ.Dưới đây, hai biểu đồ đều được vẽ bởi hàm ggplot() (xem thêm tại chương ggplot cơ bản). Trong biểu đồ đầu tiên, biến delay_cat được vẽ trên trục x của biểu đồ với thứ tự các thứ bậc là mặc định trong dữ liệu linelist. Trong biểu đồ thứ hai, biến được đặt trong bởi hàm fct_relevel() và trật tự của các thứ bậc đã được sắp xếp lại.Lưu ý rằng, ở biểu đồ thứ hai, tiêu đề mặc định của trục x được hiện khá phức tạp - bạn có thể sử tiêu đề này bằng đối số labs() trong ggplot2.","code":"\n# Alpha-numeric default order - no adjustment within ggplot\nggplot(data = linelist)+\n    geom_bar(mapping = aes(x = delay_cat))\n\n# Factor level order adjusted within ggplot\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c(\"<2 days\", \"2-5 days\", \">5 days\"))))"},{"path":"factors.html","id":"đảo-ngược-thứ-tự","chapter":"11 Factors","heading":"Đảo ngược thứ tự","text":"Bạn sẽ thường xuyên cần đảo ngược trật tự của các thứ bậc trong một biến. Đơn giản, bạn chỉ cần thêm tên biến vào bên trong hàm fct_rev().Lưu ý rằng, nếu bạn chỉ muốn đảo ngược thứ tự trong một biểu đồ chứ không phải thứ tự của biến đó, bạn có thể thực hiện điều đó với hàm guides() (Xem thêm tại chương Các tips với ggplot).","code":""},{"path":"factors.html","id":"theo-tần-suất","chapter":"11 Factors","heading":"Theo tần suất","text":"Để sắp xếp trật tự các thứ bậc theo tần suất mà nó xuất hiện trong dữ liệu, hãy sử dụng hàm fct_infreq(). Tất cả các giá trị mising (NA) sẽ tự động được đưa xuống cuối, trừ khi chúng được chuyển sang một thứ bậc khác (xem thêm ở mục này). Bạn có thể đảo ngược trật tự bằng cách thêm hàm fct_rev() vào câu lệnh.Hàm này có thể được sử dụng trong ggplot(), như hình bên dưới.","code":"\n# ordered by frequency\nggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by frequency\")\n\n# reversed frequency\nggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Reverse of order by frequency\")"},{"path":"factors.html","id":"theo-sự-xuất-hiện","chapter":"11 Factors","heading":"Theo sự xuất hiện","text":"Sử dụng hàm fct_inorder() để thiết lập thứ bậc tương tự với thứ tự xuất hiện của các giá trị trong dữ liệu, bắt đầu từ hàng đầu tiên. Điều này có thể hữu ích nếu trước đó bạn đã cẩn thận sắp xếp dữ liệu trong data frame bằng hàm arrange(), sau đó sử dụng điều này để đặt trật tự các thứ bậc của biến facror.","code":""},{"path":"factors.html","id":"theo-thống-kê-tóm-tắt-của-một-cột-khác","chapter":"11 Factors","heading":"Theo thống kê tóm tắt của một cột khác","text":"Bạn có thể sử dụng hàm fct_reorder() để sắp xếp các thứ bậc của một biến theo thống kê tóm tắt của một biến khác. Về mặt trực quan, điều này có cho kết quả là các biểu đồ như ý bạn, có các cột/điểm lên hoặc xuống theo một chiều trong toàn bộ biểu đồ.Trong các ví dụ bên dưới, trục x là delay_cat, và trục y là ct_blood (giá trị ngưỡng chu kỳ). Biểu đồ hộp (Box plot) hiển thị phân bố của giá trị CT theo nhóm delay_cat. Chúng ta cần sắp xếp các hộp theo thứ tự tăng dần của giá trị trung vị CT của nhóm.Trong ví dụ đầu tiên bên dưới, các thứ bậc được sắp xếp một cách mặc định. Bạn có thể thấy các chiều cao của hộp bị lộn xộn và không theo bất kỳ thứ tự cụ thể nào. Trong ví dụ thứ hai, cột delay_cat (được sắp xếp theo trục x) đã được viết lệnh với hàm fct_reorder(), cột ct_blood được đưa ra làm đối số thứ hai và “trung vị” được đưa ra làm đối số thứ ba (bạn cũng có thể sử dụng “max”, “mean”, “min”, v.v.). đó, thứ tự các thứ bậc của biến delay_cat bây giờ sẽ phản ánh các giá trị trung vị CT tăng dần theo nhóm delay_cat. Điều này được trình bày trong biểu đồ thứ hai - các hộp đã được sắp xếp lại theo chiều tăng dần. Lưu ý giá trị missing NA sẽ luôn xuất hiện ở cuối, trừ khi được chuyển đổi thành một thứ bậc khác.Lưu ý trong ví dụ bên trên không có bước nào được yêu cầu cần thực hiện trước khi gọi hàm ggplot() - việc nhóm và tính toán đều được thực hiện bên trong hàm ggplot.","code":"\n# boxplots ordered by original factor levels\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = delay_cat,\n        y = ct_blood, \n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by original alpha-numeric levels\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n# boxplots ordered by median CT value\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = fct_reorder(delay_cat, ct_blood, \"median\"),\n        y = ct_blood,\n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by median CT value in group\")+\n  theme_classic()+\n  theme(legend.position = \"none\")"},{"path":"factors.html","id":"theo-giá-trị-cuối","chapter":"11 Factors","heading":"Theo giá trị cuối","text":"Sử dụng hàm fct_reorder2() cho biểu đồ đường theo nhóm. Hàm sẽ sắp xếp thứ tự xuất hiện các nhóm (bao gồm cả phần chú giải) dọc theo biểu đồ. Nói về mặt kỹ thuật, nó “sắp xếp theo các giá trị y tương ứng với các giá trị x lớn nhất.”Ví dụ, nếu bạn có các dòng hiển thị số lượng trường hợp theo bệnh viện và thời gian, bạn có thể áp dụng hàm fct_reorder2() cho đối số color = trong aes(), sao cho thứ tự của các bệnh viện xuất hiện trong phần chú giải tương đương với thứ tự xuất hiện của các đường trong biểu đồ. Đọc thêm trong tài liệu trực tuyến sau đây.","code":"\nepidemic_data <- linelist %>%         # begin with the linelist   \n    filter(date_onset < as.Date(\"2014-09-21\")) %>%    # cut-off date, for visual clarity\n    count(                                            # get case counts per week and by hospital\n      epiweek = lubridate::floor_date(date_onset, \"week\"),  \n      hospital                                            \n    ) \n  \nggplot(data = epidemic_data)+                       # start plot\n  geom_line(                                        # make lines\n    aes(\n      x = epiweek,                                  # x-axis epiweek\n      y = n,                                        # height is number of cases per week\n      color = fct_reorder2(hospital, epiweek, n)))+ # data grouped and colored by hospital, with factor order by height at end of plot\n  labs(title = \"Factor levels (and legend display) by line height at end of plot\",\n       color = \"Hospital\")                          # change legend title"},{"path":"factors.html","id":"fct_missing","chapter":"11 Factors","heading":"11.5 Giá trị Missing","text":"Nếu có giá trị missing NA trong biến factor của bạn, bạn có thể dễ dàng chuyển đổi chúng thành một thứ bậc được đặt tên với hàm fct_explicit_na(). Giá trị missing NA được chuyển đổi thành “(Missing)” mặc định sẽ được xếp cuối cùng. Bạn có thể điều chỉnh tên thứ bậc bằng đối số na_level =.Ví dụ dưới đây được thực hiện trên biến delay_cat và một bảng được bằngtabyl()với các giá trị missing NA được chuyển thành “Missing delay”.","code":"\nlinelist %>% \n  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing delay\")) %>% \n  tabyl(delay_cat)##      delay_cat    n    percent\n##       2-5 days 2040 0.34646739\n##        <2 days 2990 0.50781250\n##        >5 days  602 0.10224185\n##  Missing delay  256 0.04347826"},{"path":"factors.html","id":"kết-hợp-các-thứ-bậc-trong-biến-factor","chapter":"11 Factors","heading":"11.6 Kết hợp các thứ bậc trong biến factor","text":"","code":""},{"path":"factors.html","id":"kết-hợp-thủ-công","chapter":"11 Factors","heading":"Kết hợp thủ công","text":"Bạn có thể điều chỉnh cách hiển thị của các thứ bậc theo cách thủ công với hàm fct_recode(). Điều này giống như hàm recode() trong package dplyr (xem thêm tại chương Làm sạch số liệu và các hàm quan trọng), nhưng nó cho phép tạo các thứ bậc mới trong factor. Nếu bạn đơn giản chỉ sử dụng hàm recode() trên một factor, các giá trị được mã hóa mới sẽ bị từ chối trừ khi chúng đã được đặt ở thứ bậc cho phép.Công cụ này cũng có thể được sử dụng để “kết hợp” các thứ bậc trong factor, bằng cách gán cho nhiều thứ bậc cùng một giá trị được mã hóa lại. Bạn cần cẩn thận để không bị mất thông tin! Cân nhắc thực hiện các bước kết hợp này trong một biến mới (không ghi đè lên biến hiện tại).Hàm fct_recode() có cú pháp khác với hàm recode(). Hàm recode() sử dụng câu lệnh OLD = NEW, trong khi hàm fct_recode() sửu dụng câu lệnh NEW = OLD.Những thứ bậc sẵn có của biến delay_cat như sau:Để tạo một thứ bậc mới, bạn sử dụng câu lệnh sau fct_recode(column, \"new\" = \"old\", \"new\" = \"old\", \"new\" = \"old\") và ra như sau:Ở đây các thứ bậc cũ được kết hợp theo cách thủ công với fct_recode(). Lưu ý rằng không có lỗi phát sinh khi tạo thứ bậc mới “Less tham 5 days”.","code":"\nlevels(linelist$delay_cat)## [1] \"<2 days\"  \"2-5 days\" \">5 days\"\nlinelist %>% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 2 days\" = \"<2 days\",\n    \"2 to 5 days\"      = \"2-5 days\",\n    \"More than 5 days\" = \">5 days\")) %>% \n  tabyl(delay_cat)##         delay_cat    n    percent valid_percent\n##  Less than 2 days 2990 0.50781250     0.5308949\n##       2 to 5 days 2040 0.34646739     0.3622159\n##  More than 5 days  602 0.10224185     0.1068892\n##              <NA>  256 0.04347826            NA\nlinelist %>% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 5 days\" = \"<2 days\",\n    \"Less than 5 days\" = \"2-5 days\",\n    \"More than 5 days\" = \">5 days\")) %>% \n  tabyl(delay_cat)##         delay_cat    n    percent valid_percent\n##  Less than 5 days 5030 0.85427989     0.8931108\n##  More than 5 days  602 0.10224185     0.1068892\n##              <NA>  256 0.04347826            NA"},{"path":"factors.html","id":"rút-gọn-thành-other","chapter":"11 Factors","heading":"Rút gọn thành “Other”","text":"Bạn có thể sử dụng hàm fct_other() để gán các thứ bậc của factor theo cách thủ công cho thứ bậc “”. Dưới đây, tất cả các thứ bậc trong biến hospital, ngoại trừ “Port Hospital” và “Central Hospital”, được gộp chung thành “”. Bạn có thể cung cấp một vectơ để giữ keep =, hoặc loại bỏ drop =. Bạn có thể thay đổi cách hiển thị của thứ bậc “” bằng hàm other_level =.","code":"\nlinelist %>%    \n  mutate(hospital = fct_other(                      # adjust levels\n    hospital,\n    keep = c(\"Port Hospital\", \"Central Hospital\"),  # keep these separate\n    other_level = \"Other Hospital\")) %>%            # All others as \"Other Hospital\"\n  tabyl(hospital)                                   # print table##          hospital    n    percent\n##  Central Hospital  454 0.07710598\n##     Port Hospital 1762 0.29925272\n##    Other Hospital 3672 0.62364130"},{"path":"factors.html","id":"rút-gọn-theo-tần-suất","chapter":"11 Factors","heading":"Rút gọn theo tần suất","text":"Bạn có thể tự động kết hợp các thứ bậc trong biến factor có tần suất ít nhất bằng cách sử dụng hàm fct_lump().Để “gộp” nhiều giá trị tần suất thấp lại thành một nhóm khác “”, hãy thực hiện một trong các thao tác sau:Đặt n = là số nhóm bạn muốn giữ. n thứ bậc có tần suất nhiều nhất sẽ được giữ nguyên và tất cả các cấp độ khác sẽ kết hợp thành nhóm “”.Đặt prop = là ngưỡng tỷ lệ cho các thứ bậc bạn muốn giữ ở trên. Tất cả các giá trị khác sẽ kết hợp thành nhóm “”.Bạn có thể thay đổi cách hiển thị của thứ bậc “” bằng hàm other_level =. Dưới đây, tất cả các giá trị ngoài hai bệnh viện phổ biến nhất đều được kết hợp thành nhóm “Hospital”.","code":"\nlinelist %>%    \n  mutate(hospital = fct_lump(                      # adjust levels\n    hospital,\n    n = 2,                                          # keep top 2 levels\n    other_level = \"Other Hospital\")) %>%            # all others as \"Other Hospital\"\n  tabyl(hospital)                                   # print table##        hospital    n   percent\n##         Missing 1469 0.2494905\n##   Port Hospital 1762 0.2992527\n##  Other Hospital 2657 0.4512568"},{"path":"factors.html","id":"hiển-thị-tất-cả-thứ-bậc","chapter":"11 Factors","heading":"11.7 Hiển thị tất cả thứ bậc","text":"Một lợi ích của việc sử dụng factors là chuẩn hóa sự xuất hiện của các chú thích trong biểu đồ và bảng, bất kể giá trị nào thực sự có trong tập dữ liệu.Nếu bạn đang chuẩn bị nhiều bảng biểu (ví dụ: cho nhiều khu vực pháp lý), bạn sẽ muốn các chú giải và bảng xuất hiện giống hệt nhau ngay cả với các mức độ hoàn thành dữ liệu hoặc thành phần dữ liệu khác nhau.","code":""},{"path":"factors.html","id":"trong-biểu-đồ","chapter":"11 Factors","heading":"Trong biểu đồ","text":"Trong hàm vẽ biểu đồ ggplot (), chỉ cần thêm đối số drop = FALSE trong hàm liên quan scale_xxxx(). Tất cả các thứ bậc trong biến factor sẽ được hiển thị, bất kể chúng có trong dữ liệu hay không. Nếu các thứ bậc trong biến factor của bạn được hiển thị bằng cách sử dụng fill =, thì trong scale_fill_discrete (), bạn cần thêm drop = FALSE, như được trình bày bên dưới. Nếu các thứ bậc trong biến factor của bạn được hiển thị với x = (đến trục x) color = hoặc size =, bạn sẽ cung cấp chúng tới scale_color_discrete() hoặc scale_size_discrete().Ví dụ này là một biểu đồ cột chồng của nhóm tuổi, theo bệnh viện. Việc thêm scale_fill_discrete (drop = FALSE) đảm bảo rằng tất cả các nhóm tuổi đều xuất hiện trong chú giải, ngay cả khi không có trong dữ liệu.","code":"\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +\n  scale_fill_discrete(drop = FALSE)+                        # show all age groups in the legend, even those not present\n  labs(\n    title = \"All age groups will appear in legend, even if not present in data\")"},{"path":"factors.html","id":"trong-bảng","chapter":"11 Factors","heading":"Trong bảng","text":"Cả hàm table() trong base R và hàm tabyl() trong package janitor đều sẽ hiển thị tất cả các thứ bậc trong factor (ngay cả các thứ bậc không sử dụng).Nếu bạn sử dụng hàm count() hoặc summarise() từ package dplyr để tạo bảng, hãy thêm đối số .drop = FALSE để hiển thị số lượng cho tất cả các thứ bậc trong factor ngay cả các thứ bậc không sử dụng.Đọc thêm tại chương Bảng mô tả,hoặc tại các link sau scale_discrete documentation, hoặc count() documentation. Bạn có thể tìm các ví dụ khác tại chương Truy vết tiếp xúc.","code":""},{"path":"factors.html","id":"tuần-dịch-tễ","chapter":"11 Factors","heading":"11.8 Tuần dịch tễ","text":"Vui lòng xem phần thảo luận đầy đủ về cách tạo các tuần dịch tễ trong chương Nhóm dữ liệu.\nVui lòng xem chương Làm việc với ngày tháng để biết các mẹo về cách tạo và định dạng các tuần dịch tễ học.","code":""},{"path":"factors.html","id":"tuần-dịch-tễ-trong-biểu-đồ","chapter":"11 Factors","heading":"Tuần dịch tễ trong biểu đồ","text":"Nếu mục tiêu của bạn là tạo các tuần dịch tễ học để hiển thị trong một biểu đồ, bạn có thể thực hiện việc này đơn giản với hàm floor_date() trong package lubridate, như được giải thích trong chương Nhóm dữ liệu. Các giá trị trả về sẽ thuộc loại Ngày tháng với định dạng YYYY-MM-DD. Nếu bạn sử dụng cột này trong một biểu đồ, ngày tháng sẽ tự nhiên được sắp xếp chính xác và bạn không cần phải lo lắng về thứ bậc hoặc chuyển đổi sang dạng factor. Xem biểu đồ histogram trong hàm ggplot() về các ngày khởi phát bên dưới.Trong cách tiếp cận này, bạn có thể điều chỉnh việc hiển thị của ngày tháng trên trục với scale_x_date(). Xem thêm tại trang Đường cong dịch bệnh để biết thêm thông tin. Bạn có thể chỉ định định dạng hiển thị date_labels = cho đối số scale_x_date(). Sử dụng “% Y” để đại diện cho năm có 4 chữ số và “% W” hoặc “% U” để đại diện cho số tuần (các tuần thứ Hai hoặc Chủ Nhật tương ứng).","code":"\nlinelist %>% \n  mutate(epiweek_date = floor_date(date_onset, \"week\")) %>%  # create week column\n  ggplot()+                                                  # begin ggplot\n  geom_histogram(mapping = aes(x = epiweek_date))+           # histogram of date of onset\n  scale_x_date(date_labels = \"%Y-W%W\")                       # adjust disply of dates to be YYYY-WWw"},{"path":"factors.html","id":"tuần-dịch-tễ-trong-dữ-liệu","chapter":"11 Factors","heading":"Tuần dịch tễ trong dữ liệu","text":"Tuy nhiên, nếu mục đích của bạn với biến factor không phải để lập biểu đồ, bạn có thể tiếp cận theo một trong hai cách:Để kiểm soát tốt việc hiển thị, hãy chuyển đổi cột lubridate tuần dịch tễ (YYYY-MM-DD) sang định dạng hiển thị mong muốn (YYYY-WWw) trong chính data frame, rồi chuyển đổi nó thành dạng factor.Đầu tiên, sử dụng hàm format() từ base R để chuyển đổi hiển thị ngày từ hiển thị YYYY-MM-DD sang hiển thị YYYY-Www (xem thêm tại chương Làm việc với ngày tháng). Trong quá trình này, kiểu của biến số sẽ được chuyển đổi thành ký tự. Sau đó, chuyển đổi từ kiểu ký tự sang kiểu Factor với hàm factor().Nguy hiểm: Nếu bạn đặt các tuần trước các năm (“Www-YYYY”) (“%W-%Y”), thứ tự các thứ bậc sẽ sắp xếp mặc định theo bảng chữ cái và điều này là không chính xác (ví dụ: 01-2015 sẽ là trước 35-2014). Bạn có thể cần phải điều chỉnh thứ tự theo cách thủ công, đây sẽ là một quá trình dài khó khăn .Để hiển thị nhanh theo mặc định, sử dụng hàm date2week() trong package aweek. Bạn có thể đặt ngày theo hàm week_start =, và nếu bạn đặt đối số factor = TRUE thì cột đầu ra là một factor có thứ tự. Factor sẽ bao gồm các thứ bậc cho tất cả các tuần có thể có trong khoảng thời gian - ngay cả khi không có trường hợp nào xuất hiện trong tuần đó.Xem chương Làm việc với ngày tháng để biết thêm thông tin về package aweek. Nó cũng cung cấp thông tin về hàm đảo ngược week2date().","code":"\nlinelist <- linelist %>% \n  mutate(epiweek_date = floor_date(date_onset, \"week\"),       # create epiweeks (YYYY-MM-DD)\n         epiweek_formatted = format(epiweek_date, \"%Y-W%W\"),  # Convert to display (YYYY-WWw)\n         epiweek_formatted = factor(epiweek_formatted))       # Convert to factor\n\n# Display levels\nlevels(linelist$epiweek_formatted)##  [1] \"2014-W13\" \"2014-W14\" \"2014-W15\" \"2014-W16\" \"2014-W17\" \"2014-W18\" \"2014-W19\" \"2014-W20\" \"2014-W21\" \"2014-W22\" \"2014-W23\" \"2014-W24\" \"2014-W25\" \"2014-W26\" \"2014-W27\"\n## [16] \"2014-W28\" \"2014-W29\" \"2014-W30\" \"2014-W31\" \"2014-W32\" \"2014-W33\" \"2014-W34\" \"2014-W35\" \"2014-W36\" \"2014-W37\" \"2014-W38\" \"2014-W39\" \"2014-W40\" \"2014-W41\" \"2014-W42\"\n## [31] \"2014-W43\" \"2014-W44\" \"2014-W45\" \"2014-W46\" \"2014-W47\" \"2014-W48\" \"2014-W49\" \"2014-W50\" \"2014-W51\" \"2015-W00\" \"2015-W01\" \"2015-W02\" \"2015-W03\" \"2015-W04\" \"2015-W05\"\n## [46] \"2015-W06\" \"2015-W07\" \"2015-W08\" \"2015-W09\" \"2015-W10\" \"2015-W11\" \"2015-W12\" \"2015-W13\" \"2015-W14\" \"2015-W15\" \"2015-W16\"\ndf <- linelist %>% \n  mutate(epiweek = date2week(date_onset, week_start = \"Monday\", factor = TRUE))\n\nlevels(df$epiweek)"},{"path":"factors.html","id":"nguồn-tham-khảo","chapter":"11 Factors","heading":"11.9 Nguồn tham khảo","text":"R trong Khoa học dữ liệu, chương factorsaweek package vignette","code":""},{"path":"pivoting.html","id":"pivoting","chapter":"12 Xoay trục dữ liệu","heading":"12 Xoay trục dữ liệu","text":"Khi quản lý dữ liệu, xoay trục có thể được hiểu là đề cập đến một trong hai quy trình:Tạo bảng dữ liệu tổng hợp (pivot tables), là bảng thống kê tóm tắt dữ liệu từ một bảng dữ liệu lớn hơn.Chuyển đổi một bảng từ định dạng dọc sang định dạng ngang hoặc ngược lại.Trong chương này, chúng ta sẽ tập trung vào định nghĩa thứ hai. Định nghĩa thứ nhất là một bước quan trọng trong phân tích dữ liệu và được đề cập ở những chương khác như trong chương Nhóm dữ liệu và Bảng mô tả.Chương này thảo luận về các định dạng của dữ liệu. Sẽ rất hữu ích khi biết ý tưởng về “dữ liệu gọn gàng”, trong đó mỗi biến có cột riêng, mỗi quan sát có hàng riêng và mỗi giá trị có ô riêng. Bạn có thể tìm thêm thông tin về chủ đề này tại bản trực tuyến của sách R Data Science.","code":""},{"path":"pivoting.html","id":"chuẩn-bị-3","chapter":"12 Xoay trục dữ liệu","heading":"12.1 Chuẩn bị","text":"","code":""},{"path":"pivoting.html","id":"gọi-package-1","chapter":"12 Xoay trục dữ liệu","heading":"Gọi package","text":"Đoạn code này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ pacman, cài đặt package nếu cần và gọi ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.","code":"\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  tidyverse)    # data management + ggplot2 graphics"},{"path":"pivoting.html","id":"nhập-dữ-liệu-5","chapter":"12 Xoay trục dữ liệu","heading":"Nhập dữ liệu","text":"","code":""},{"path":"pivoting.html","id":"dữ-liệu-số-trường-hợp-sốt-rét","chapter":"12 Xoay trục dữ liệu","heading":"Dữ liệu số trường hợp sốt rét","text":"Trong chương này, chúng ta sẽ sử dụng một bộ dữ liệu giả định về các trường hợp ghi nhận sốt rét hàng ngày, theo cơ sở y tế và nhóm tuổi. Để tiện theo dõi, bấm vào đây để tải tệp tin (tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (xử lý nhiều loại tệp tin như .xlsx; .csv; .rds - xem chương Nhập xuất dữ liệu để biết thêm chi tiết).Dưới đây là 50 hàng đầu tiên được hiển thị.","code":"\n# Import data\ncount_data <- import(\"malaria_facility_count_data.rds\")"},{"path":"pivoting.html","id":"bộ-dữ-liệu-các-trường-hợp-linelist","chapter":"12 Xoay trục dữ liệu","heading":"Bộ dữ liệu các trường hợp linelist","text":"Trong phần cuối của chương này, chúng ta cũng sẽ sử dụng tập dữ liệu mô phỏng về các trường hợp từ một vụ dịch Ebola. Để tiện theo dõi, bấm vào đây để tải bộ dữ liệu linelist “đã làm sạch” (tệp .rds). Nạp dữ liệu bằng hàm import() từ package rio (package này chấp nhận nhiều loại tệp tin dạng .xlsx; .csv; .rds - xem chương Nhập xuất dữ liệu để biết thêm chi tiết).","code":"\n# import your dataset\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"pivoting.html","id":"định-dạng-dữ-liệu-từ-ngang-sang-dọc","chapter":"12 Xoay trục dữ liệu","heading":"12.2 Định dạng dữ liệu từ “ngang-sang-dọc”","text":"","code":""},{"path":"pivoting.html","id":"định-dạng-ngang","chapter":"12 Xoay trục dữ liệu","heading":"Định dạng “ngang”","text":"Dữ liệu thường được nhập và lưu trữ ở định dạng “ngang” - nghĩa là các đặc điểm hoặc phản hồi của chủ thể được lưu trữ trong một hàng duy nhất. Mặc dù điều này có thể hữu ích cho việc hiển thị, tuy nhiên chưa phải là lý tưởng cho một số phân tích.Chúng ta hãy lấy bộ dữ liệu count_data đã nhắc đến trong phần Chuẩn bị ở trên để làm ví dụ. Bạn có thể thấy rằng mỗi hàng đại diện cho một “cơ sở y tế-ngày (facility-day)”. Số lượng trường hợp thực tế (các cột ngoài cùng bên phải) được lưu trữ ở định dạng “ngang”, nghĩa là thông tin cho mọi nhóm tuổi trong một cơ sở y tế-ngày nhất định được lưu trữ trong một hàng.Mỗi quan sát trong bộ dữ liệu này đề cập đến số lượng ca sốt rét tại một trong 65 cơ sở y tế vào một ngày cụ thể, trong khoảng từ count_data$data_date %>% min() đến count_data$data_date %>% max(). Các cơ sở này nằm ở một tỉnh Province (North) và bốn quận District (Spring, Bolo, Dingo và Barnard). Bộ dữ liệu cung cấp số lượng tổng thể của các ca bệnh sốt rét, cũng như số lượng cụ thể theo độ tuổi ở mỗi nhóm trong ba nhóm tuổi - <4 tuổi, 5-14 tuổi và từ 15 tuổi trở lên.Dữ liệu “ngang” như vậy không tuân theo tiêu chuẩn “dữ liệu gọn gàng”, bởi vì tiêu đề cột không thực sự đại diện cho “biến” - chúng đại diện cho các giá trị của biến giả định là “nhóm tuổi” .Định dạng kiểu này có thể hữu ích để trình bày thông tin trong bảng hoặc để nhập dữ liệu (ví dụ: trong Excel) từ các biểu mẫu báo cáo ca bệnh (CRFs). Tuy nhiên, trong quá trình phân tích, những dữ liệu này thường phải được chuyển đổi sang định dạng “dọc” để phù hợp hơn với các tiêu chuẩn về “dữ liệu gọn gàng”. Package vẽ biểu đồ ggplot2 trong R nói riêng hoạt động tốt nhất khi dữ liệu ở định dạng “dọc”.Trực quan hóa tổng số lượng ca sốt rét theo thời gian không gây khó khăn gì với dữ liệu ở định dạng hiện tại:Tuy nhiên, điều gì sẽ xảy ra nếu chúng ta muốn hiển thị các đóng góp một cách tương đối của từng nhóm tuổi vào tổng số này? Trong trường hợp này, chúng ta cần đảm bảo rằng biến quan tâm (nhóm tuổi), xuất hiện trong bộ dữ liệu trong một cột duy nhất có thể được chuyển tiếp tới đối số aes() “mapping aesthetics” trong ggplot2.","code":"\nggplot(count_data) +\n  geom_col(aes(x = data_date, y = malaria_tot), width = 1)"},{"path":"pivoting.html","id":"pivot_longer","chapter":"12 Xoay trục dữ liệu","heading":"pivot_longer()","text":"Hàm pivot_longer() trong tidyr giúp biến đổi dữ liệu thành định dạng “dọc”. tidyr là một package con trong hệ sinh thái tidyverse của R.Hàm này chấp nhận sử dụng nhiều cột cùng thực hiện biến đổi (cụ thể với cols =). đó, nó chỉ có thể hoạt động trên một phần của bộ dữ liệu. Điều này rất hữu ích cho bộ dữ liệu về sốt rét, vì chúng ta chỉ muốn xoay trục các cột số ca bệnh.Trong quá trình này, kết quả trả về hai cột “mới” - một cột có các danh mục (tên cột cũ) và một cột chứa các giá trị tương ứng (ví dụ: số lượng ca bệnh). Bạn có thể chấp nhận tên mặc định của cột mới hoặc có thể tùy chỉnh bằng names_to = và values_to =, tương ứng.Hãy cùng xem hàm pivot_longer() hoạt động như thế nào …","code":""},{"path":"pivoting.html","id":"xoay-trục-tiêu-chuẩn","chapter":"12 Xoay trục dữ liệu","heading":"Xoay trục tiêu chuẩn","text":"Chúng ta muốn sử dụng hàm pivot_longer() trong package tidyr để chuyển đổi dữ liệu từ “ngang” sang định dạng “dọc”. Cụ thể, để chuyển đổi bốn cột dạng số có dữ liệu về số lượng ca sốt rét thành hai cột mới: một cột chứa nhóm tuổi và một cột chứa các giá trị tương ứng.Lưu ý rằng bộ dữ liệu mới được tạo (df_long) có nhiều hàng hơn (12.152 với 3.038); bộ dữ liệu đã trở nên “dài hơn”. Trên thực tế, bộ dữ liệu đã dài hơn gấp bốn lần, bởi vì mỗi hàng trong tập dữ liệu ban đầu hiện đại diện cho bốn hàng trong df_long, một hàng cho mỗi quan sát số lượng ca sốt rét (<4 tuổi, 5-14 tuổi, 15+ tuổi và tổng số).Ngoài việc dài hơn, bộ dữ liệu mới có ít cột hơn (8 với 10), vì dữ liệu trước đây được lưu trữ trong bốn cột (những cột bắt đầu bằng tiền tố malaria_), hiện được lưu trữ chỉ trong hai cột.Vì tên của bốn cột này đều bắt đầu bằng tiền tố malaria_, chúng ta có thể sử dụng hàm “tidyselect” starts_with() để đạt được kết quả tương tự (xem chương Làm sạch số liệu và các hàm quan trọng để biết thêm về các hàm trợ giúp này).hoặc sử dụng vị trí cột:hoặc sử dụng khoảng tên cột:Hai cột mới này được đặt tên mặc định là name và value, nhưng chúng ta có thể ghi đè các giá trị mặc định này để cung cấp tên cột có ý nghĩa hơn, có thể giúp ghi nhớ dễ dàng đặc điểm các giá trị được lưu trữ bên trong, bằng cách sử dụng các đối số names_to và values_to. Hãy sử dụng tên age_group và counts:Bây giờ chúng ta có thể chuyển tiếp bộ dữ liệu mới này tới ggplot2, và định vị cột mới count với trục y và cột mới age_group tới độ số fill = (màu bên trong cột). Việc này giúp hiển thị số lượng ca bệnh sốt rét trong một biểu đồ cột chồng, theo nhóm tuổi:Kiểm tra biểu đồ mới này và sánh với biểu đồ chúng ta đã tạo trước đó - hãy xem điều gì đã xảy ra?Chúng ta đã gặp phải một vấn đề phổ biến khi tổng hợp dữ liệu giám sát - chúng ta cũng đã gộp tổng số từ cột malaria_tot, vì vậy độ lớn của mỗi thanh trong biểu đồ cao gấp đôi với bình thường.Chúng ta có thể xử lý vấn đề này theo một số cách. Chúng ta có thể đơn giản lọc bỏ tổng số này ra khỏi bộ dữ liệu trước khi chuyển tới ggplot():Ngoài ra, chúng ta có thể đã loại bỏ biến này khi chúng ta chạy lệnh pivot_longer(), bằng cách đó có thể giữ biến đó trong bộ dữ liệu như một biến riêng biệt. Hãy xem cách mà giá trị của biến này “mở rộng” để lấp đầy các hàng mới.","code":"\ndf_long <- count_data %>% \n  pivot_longer(\n    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)\n  )\n\ndf_long\n# provide column with a tidyselect helper function\ncount_data %>% \n  pivot_longer(\n    cols = starts_with(\"malaria_\")\n  )## # A tibble: 12,152 x 8\n##    location_name data_date  submitted_date Province District newid name             value\n##    <chr>         <date>     <date>         <chr>    <chr>    <int> <chr>            <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_0-4     11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_5-14    12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_15      23\n##  4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot         46\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_0-4     11\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_5-14    10\n##  7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_15       5\n##  8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot         26\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_0-4      8\n## 10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_5-14     5\n## # ... with 12,142 more rows\n# provide columns by position\ncount_data %>% \n  pivot_longer(\n    cols = 6:9\n  )\n# provide range of consecutive columns\ncount_data %>% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_tot\n  )\ndf_long <- \n  count_data %>% \n  pivot_longer(\n    cols = starts_with(\"malaria_\"),\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\ndf_long## # A tibble: 12,152 x 8\n##    location_name data_date  submitted_date Province District newid age_group        counts\n##    <chr>         <date>     <date>         <chr>    <chr>    <int> <chr>             <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_0-4      11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_5-14     12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_15       23\n##  4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot          46\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_0-4      11\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_5-14     10\n##  7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_15        5\n##  8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot          26\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_0-4       8\n## 10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_5-14      5\n## # ... with 12,142 more rows\nggplot(data = df_long) +\n  geom_col(\n    mapping = aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\ndf_long %>% \n  filter(age_group != \"malaria_tot\") %>% \n  ggplot() +\n  geom_col(\n    aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\ncount_data %>% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )## # A tibble: 9,114 x 9\n##    location_name data_date  submitted_date Province District malaria_tot newid age_group        counts\n##    <chr>         <date>     <date>         <chr>    <chr>          <int> <int> <chr>             <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1 malaria_rdt_0-4      11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1 malaria_rdt_5-14     12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1 malaria_rdt_15       23\n##  4 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2 malaria_rdt_0-4      11\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2 malaria_rdt_5-14     10\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2 malaria_rdt_15        5\n##  7 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3 malaria_rdt_0-4       8\n##  8 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3 malaria_rdt_5-14      5\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3 malaria_rdt_15        5\n## 10 Facility 4    2020-08-11 2020-08-12     North    Bolo              49     4 malaria_rdt_0-4      16\n## # ... with 9,104 more rows"},{"path":"pivoting.html","id":"xoay-trục-dữ-liệu-trên-nhiều-định-dạng-cột","chapter":"12 Xoay trục dữ liệu","heading":"Xoay trục dữ liệu trên nhiều định dạng cột","text":"Ví dụ trên hoạt động ổn trong các trường hợp mà tất cả các cột bạn muốn “xoay trục dọc” đều thuộc cùng một phân lớp, định dạng (ký tự, số, lôgic, …).Tuy nhiên, sẽ có nhiều trường hợp, với tư cách là một nhà dịch tễ học thực địa, bạn sẽ làm việc với dữ liệu được chuẩn bị bởi những người không phải là chuyên gia và tuân theo những logic không chuẩn của riêng họ - như Hadley Wickham đã lưu ý (trích dẫn từ Tolstoy) trong bài báo của ông ấy về nguyên tắc của dữ liệu gọn gàng: “Các bộ dữ liệu sạch đều giống nhau nhưng mọi bộ dữ liệu lộn xộn đều lộn xộn theo cách riêng của nó.”Một vấn đề đặc biệt phổ biến mà bạn sẽ gặp phải là nhu cầu xoay trục các cột chứa các phân lớp dữ liệu khác nhau. Việc xoay trục này sẽ dẫn đến việc lưu trữ các kiểu định dạng dữ liệu khác nhau này trong cùng một cột duy nhất, và đây không phải là một kịch bản tốt. Có nhiều cách tiếp cận khác nhau mà người ta có thể thực hiện để loại bỏ sự hỗn độn này, nhưng có một bước quan trọng bạn có thể thực hiện bằng cách sử dụng hàm pivot_longer() để tránh tạo ra tình huống như vậy.Hãy thực hiện một tình huống trong đó có một loạt các quan sát ở các sự kiện thời gian khác nhau cho từng danh mục trong số ba danh mục , B và C. Ví dụ về các danh mục đó có thể là từng cá nhân (ví dụ: các mối liên hệ của một trường hợp Ebola được theo dõi mỗi ngày trong 21 ngày) hoặc các trạm y tế thôn bản vùng sâu, vùng xa được theo dõi mỗi năm một lần để đảm bảo chúng vẫn được duy trì hoạt động. Hãy sử dụng ví dụ theo dõi mối liên hệ. Hãy tưởng tượng rằng dữ liệu sẽ được lưu trữ như sau:Có thể thấy, dữ liệu hơi phức tạp. Mỗi hàng lưu trữ thông tin về một danh mục, nhưng với chuỗi thời gian chạy ngày càng xa về bên phải khi thời gian tịnh tiến. Hơn nữa, các cột dạng phân loại xen kẽ giữa các giá trị ngày tháng và giá trị ký tự.Một ví dụ đặc biệt tồi tệ mà tác giả này gặp phải liên quan đến dữ liệu giám sát dịch tả, trong đó 8 cột quan sát mới được thêm vào mỗi ngày trong suốt 4 năm. Mất hơn 10 phút trên máy tính xách tay của tôi chỉ để mở tệp tin Excel lưu trữ những dữ liệu này!Để làm việc với những dữ liệu này, chúng ta cần chuyển đổi bộ dữ liệu sang định dạng dọc, nhưng vẫn giữ sự riêng biệt giữa cột date và cột character (trạng thái), cho mỗi quan sát cho mỗi danh mục. Nếu không, chúng ta có thể thu về một sự hỗn hợp các loại biến trong một cột duy nhất (một sự “ngỡ ngàng vô định” khi nhắc đến quản lý dữ liệu và dữ liệu sạch):Ở trên, trục xoay của chúng ta đã hợp nhất giá trị ngày và giá trị ký tự trong cùng một cột giá trị duy nhất. R sẽ hoạt động bằng cách chuyển toàn bộ cột thành định dạng ký tự, và các định dạng liên quan đến giá trị ngày sẽ không còn.Để ngăn chặn tình trạng này, chúng ta có thể tận dụng cấu trúc cú pháp của các tên cột ban đầu. Có một cấu trúc đặt tên phổ biến, với số quan sát, dấu gạch dưới và sau đó là “trạng thái” hoặc “ngày-tháng”. Chúng ta có thể tận dụng cú pháp này để giữ lại hai kiểu dữ liệu này trong các cột riêng biệt sau khi xoay trục.Chúng ta thực hiện như sau:Cung cấp một vectơ dạng ký tự cho đối số names_to =, với mục thứ hai là (\".value\"). Thuật ngữ đặc biệt này chỉ ra rằng các cột được xoay trục sẽ được phân chia dựa trên ký tự trong tên của chúng …Bạn cũng cần cung cấp ký tự “phân tách” cho đối số names_sep =. Trong trường hợp này, đó là dấu gạch dưới “_”.đó, việc đặt tên và tách cột mới được dựa trên dấu gạch dưới trong các tên biến hiện có.Hoàn thiện:Lưu ý rằng cột date hiện đang ở dạng ký tự - chúng ta có thể dễ dàng chuyển đổi cột này thành dạng ngày thích hợp bằng cách sử dụng hàm mutate() và as_date() được mô tả trong chương Làm việc với ngày tháng.Chúng ta cũng có thể muốn chuyển đổi cột observation sang định dạng numeric bằng cách bỏ tiền tố “obs” và chuyển đổi thành số. Chúng ta có thể thực hiện với hàm str_remove_all() từ package stringr (xem chương Ký tự và chuỗi).Và bây giờ, chúng ta có thể bắt đầu làm việc với dữ liệu ở định dạng này, ví dụ: bằng cách vẽ biểu đồ mô tả dạng lưới-nhiệt:","code":"\ndf %>% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\")\n  )## # A tibble: 18 x 3\n##    id    observation value     \n##    <chr> <chr>       <chr>     \n##  1 A     obs1_date   2021-04-23\n##  2 A     obs1_status Healthy   \n##  3 A     obs2_date   2021-04-24\n##  4 A     obs2_status Healthy   \n##  5 A     obs3_date   2021-04-25\n##  6 A     obs3_status Unwell    \n##  7 B     obs1_date   2021-04-23\n##  8 B     obs1_status Healthy   \n##  9 B     obs2_date   2021-04-24\n## 10 B     obs2_status Healthy   \n## 11 B     obs3_date   2021-04-25\n## 12 B     obs3_status Healthy   \n## 13 C     obs1_date   2021-04-23\n## 14 C     obs1_status Missing   \n## 15 C     obs2_date   2021-04-24\n## 16 C     obs2_status Healthy   \n## 17 C     obs3_date   2021-04-25\n## 18 C     obs3_status Healthy\ndf_long <- \n  df %>% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\", \".value\"),\n    names_sep = \"_\"\n  )\n\ndf_long## # A tibble: 9 x 4\n##   id    observation date       status \n##   <chr> <chr>       <chr>      <chr>  \n## 1 A     obs1        2021-04-23 Healthy\n## 2 A     obs2        2021-04-24 Healthy\n## 3 A     obs3        2021-04-25 Unwell \n## 4 B     obs1        2021-04-23 Healthy\n## 5 B     obs2        2021-04-24 Healthy\n## 6 B     obs3        2021-04-25 Healthy\n## 7 C     obs1        2021-04-23 Missing\n## 8 C     obs2        2021-04-24 Healthy\n## 9 C     obs3        2021-04-25 Healthy\ndf_long <- \n  df_long %>% \n  mutate(\n    date = date %>% lubridate::as_date(),\n    observation = \n      observation %>% \n      str_remove_all(\"obs\") %>% \n      as.numeric()\n  )\n\ndf_long## # A tibble: 9 x 4\n##   id    observation date       status \n##   <chr>       <dbl> <date>     <chr>  \n## 1 A               1 2021-04-23 Healthy\n## 2 A               2 2021-04-24 Healthy\n## 3 A               3 2021-04-25 Unwell \n## 4 B               1 2021-04-23 Healthy\n## 5 B               2 2021-04-24 Healthy\n## 6 B               3 2021-04-25 Healthy\n## 7 C               1 2021-04-23 Missing\n## 8 C               2 2021-04-24 Healthy\n## 9 C               3 2021-04-25 Healthy\nggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +\n  geom_tile(colour = \"black\") +\n  scale_fill_manual(\n    values = \n      c(\"Healthy\" = \"lightgreen\", \n        \"Unwell\" = \"red\", \n        \"Missing\" = \"orange\")\n  )"},{"path":"pivoting.html","id":"dọc-thành-ngang","chapter":"12 Xoay trục dữ liệu","heading":"12.3 Dọc-thành-ngang","text":"Trong một số trường hợp, chúng ta có thể muốn chuyển đổi bộ dữ liệu sang định dạng ngang. Đối với điều này, chúng ta có thể sử dụng hàm pivot_wider().Tình huống phổ biến là khi chúng ta muốn chuyển đổi kết quả phân tích thành một định dạng dễ hiểu hơn cho người đọc (chẳng hạn như trong chương Trình bày bảng). Thông thường, điều này bao gồm việc chuyển đổi một bộ dữ liệu trong đó thông tin chủ thể được trải rộng trên nhiều hàng, sau đó được thống nhất thành một định dạng mà thông tin được lưu trữ trên một hàng duy nhất.","code":""},{"path":"pivoting.html","id":"dữ-liệu","chapter":"12 Xoay trục dữ liệu","heading":"Dữ liệu","text":"Trong chương này, chúng ta sẽ sử dụng bộ dữ liệu ca bệnh linelist (xem mục Chuẩn bị), với mỗi trường hợp nằm trên một hàng.Dưới đây là 50 hàng đầu tiên:Giả sử rằng chúng ta muốn biết số lượng cá thể ở các nhóm tuổi khác nhau, theo giới tính:Điều này cho chúng ta một bộ dữ liệu dạng dọc, rất tốt để trực quan hóa trong ggplot2, nhưng không lý tưởng để trình bày bảng:","code":"\ndf_wide <- \n  linelist %>% \n  count(age_cat, gender)\n\ndf_wide##    age_cat gender   n\n## 1      0-4      f 640\n## 2      0-4      m 416\n## 3      0-4   <NA>  39\n## 4      5-9      f 641\n## 5      5-9      m 412\n## 6      5-9   <NA>  42\n## 7    10-14      f 518\n## 8    10-14      m 383\n## 9    10-14   <NA>  40\n## 10   15-19      f 359\n## 11   15-19      m 364\n## 12   15-19   <NA>  20\n## 13   20-29      f 468\n## 14   20-29      m 575\n## 15   20-29   <NA>  30\n## 16   30-49      f 179\n## 17   30-49      m 557\n## 18   30-49   <NA>  18\n## 19   50-69      f   2\n## 20   50-69      m  91\n## 21   50-69   <NA>   2\n## 22     70+      m   5\n## 23     70+   <NA>   1\n## 24    <NA>   <NA>  86\nggplot(df_wide) +\n  geom_col(aes(x = age_cat, y = n, fill = gender))"},{"path":"pivoting.html","id":"xoay-trục-ngang","chapter":"12 Xoay trục dữ liệu","heading":"Xoay trục ngang","text":"đó, chúng ta có thể sử dụng hàm pivot_wider() để chuyển đổi dữ liệu sang định dạng tốt hơn để đưa vào các bảng trong báo cáo.Đối số names_from chỉ định cột mà từ đó tạo ra tên cột mới, trong khi đối số values_from chỉ định cột mà từ đó nhận các giá trị để điền. Đối số id_cols = là tùy chọn, nhưng nó có thể được chứa một vectơ tên các cột không xoay trục và đó sẽ xác định từng hàng.Bảng này thân thiện với người đọc hơn nhiều và có thể thêm vào báo cáo của chúng ta. Bạn có thể chuyển đổi thành một bảng tuyệt vời với một số package bao gồm flextable và knitr. Quá trình này được trình bày chi tiết trong chương Trình bày bảng.","code":"\ntable_wide <- \n  df_wide %>% \n  pivot_wider(\n    id_cols = age_cat,\n    names_from = gender,\n    values_from = n\n  )\n\ntable_wide## # A tibble: 9 x 4\n##   age_cat     f     m  `NA`\n##   <fct>   <int> <int> <int>\n## 1 0-4       640   416    39\n## 2 5-9       641   412    42\n## 3 10-14     518   383    40\n## 4 15-19     359   364    20\n## 5 20-29     468   575    30\n## 6 30-49     179   557    18\n## 7 50-69       2    91     2\n## 8 70+        NA     5     1\n## 9 <NA>       NA    NA    86\ntable_wide %>% \n  janitor::adorn_totals(c(\"row\", \"col\")) %>% # adds row and column totals\n  knitr::kable() %>% \n  kableExtra::row_spec(row = 10, bold = TRUE) %>% \n  kableExtra::column_spec(column = 5, bold = TRUE) "},{"path":"pivoting.html","id":"điền","chapter":"12 Xoay trục dữ liệu","heading":"12.4 Điền","text":"Trong một số tình huống sau khi pivot, và phổ biến hơn là sau khi bind, chúng ta sẽ để lại một số ô trống mà chúng ta sẽ muốn lấp đầy.","code":""},{"path":"pivoting.html","id":"dữ-liệu-1","chapter":"12 Xoay trục dữ liệu","heading":"Dữ liệu","text":"Ví dụ: lấy hai bộ dữ liệu, mỗi bộ dữ liệu có các quan sát về các đại lượng đo lường, tên của cơ sở y tế và số ca bệnh tại thời điểm đó. Tuy nhiên, bộ dữ liệu thứ hai cũng có biến Year.Khi chúng ta thực hiện lệnh bind_rows() để nối hai bộ dữ liệu với nhau, biến Year được điền NA cho những hàng không có thông tin trước đó (ví dụ là bộ dữ liệu đầu tiên):","code":"\ndf1 <- \n  tibble::tribble(\n       ~Measurement, ~Facility, ~Cases,\n                  1,  \"Hosp 1\",     66,\n                  2,  \"Hosp 1\",     26,\n                  3,  \"Hosp 1\",      8,\n                  1,  \"Hosp 2\",     71,\n                  2,  \"Hosp 2\",     62,\n                  3,  \"Hosp 2\",     70,\n                  1,  \"Hosp 3\",     47,\n                  2,  \"Hosp 3\",     70,\n                  3,  \"Hosp 3\",     38,\n       )\n\ndf1 ## # A tibble: 9 x 3\n##   Measurement Facility Cases\n##         <dbl> <chr>    <dbl>\n## 1           1 Hosp 1      66\n## 2           2 Hosp 1      26\n## 3           3 Hosp 1       8\n## 4           1 Hosp 2      71\n## 5           2 Hosp 2      62\n## 6           3 Hosp 2      70\n## 7           1 Hosp 3      47\n## 8           2 Hosp 3      70\n## 9           3 Hosp 3      38\ndf2 <- \n  tibble::tribble(\n    ~Year, ~Measurement, ~Facility, ~Cases,\n     2000,            1,  \"Hosp 4\",     82,\n     2001,            2,  \"Hosp 4\",     87,\n     2002,            3,  \"Hosp 4\",     46\n  )\n\ndf2## # A tibble: 3 x 4\n##    Year Measurement Facility Cases\n##   <dbl>       <dbl> <chr>    <dbl>\n## 1  2000           1 Hosp 4      82\n## 2  2001           2 Hosp 4      87\n## 3  2002           3 Hosp 4      46\ndf_combined <- \n  bind_rows(df1, df2) %>% \n  arrange(Measurement, Facility)\n\ndf_combined## # A tibble: 12 x 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 1      66    NA\n##  2           1 Hosp 2      71    NA\n##  3           1 Hosp 3      47    NA\n##  4           1 Hosp 4      82  2000\n##  5           2 Hosp 1      26    NA\n##  6           2 Hosp 2      62    NA\n##  7           2 Hosp 3      70    NA\n##  8           2 Hosp 4      87  2001\n##  9           3 Hosp 1       8    NA\n## 10           3 Hosp 2      70    NA\n## 11           3 Hosp 3      38    NA\n## 12           3 Hosp 4      46  2002"},{"path":"pivoting.html","id":"fill","chapter":"12 Xoay trục dữ liệu","heading":"fill()","text":"Trong trường hợp này, Year là một biến hữu ích cần để thêm vào bộ số liệu, đặc biệt nếu chúng ta muốn tìm hiểu các xu hướng theo thời gian. đó, chúng ta sử dụng hàm fill() để điền vào các ô trống đó, bằng cách chỉ định cột và hướng cần điền (trong trường hợp này là hướng từ dưới lên trên):Ngoài ra, chúng ta có thể sắp xếp lại dữ liệu để chúng ta cần điền theo hướng từ trên xuống dưới:Bây giờ chúng ta có một bộ dữ liệu sạch để vẽ biểu đồ:Nhưng ít hữu ích cho việc trình bày bảng, vì vậy hãy thực hành chuyển đổi bộ dữ liệu dọc-chưa làm sạch này thành một bộ dữ liệu ngang-sạch:Chú ý: Trong trường hợp này, chúng ta cần chỉ định chỉ bao gồm ba biến Facility, Year, và Cases vì biến bổ sung Measurement sẽ khiến khó khăn hơn khi tạo bảng:","code":"\ndf_combined %>% \n  fill(Year, .direction = \"up\")## # A tibble: 12 x 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 1      66  2000\n##  2           1 Hosp 2      71  2000\n##  3           1 Hosp 3      47  2000\n##  4           1 Hosp 4      82  2000\n##  5           2 Hosp 1      26  2001\n##  6           2 Hosp 2      62  2001\n##  7           2 Hosp 3      70  2001\n##  8           2 Hosp 4      87  2001\n##  9           3 Hosp 1       8  2002\n## 10           3 Hosp 2      70  2002\n## 11           3 Hosp 3      38  2002\n## 12           3 Hosp 4      46  2002\ndf_combined <- \n  df_combined %>% \n  arrange(Measurement, desc(Facility))\n\ndf_combined## # A tibble: 12 x 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 4      82  2000\n##  2           1 Hosp 3      47    NA\n##  3           1 Hosp 2      71    NA\n##  4           1 Hosp 1      66    NA\n##  5           2 Hosp 4      87  2001\n##  6           2 Hosp 3      70    NA\n##  7           2 Hosp 2      62    NA\n##  8           2 Hosp 1      26    NA\n##  9           3 Hosp 4      46  2002\n## 10           3 Hosp 3      38    NA\n## 11           3 Hosp 2      70    NA\n## 12           3 Hosp 1       8    NA\ndf_combined <- \n  df_combined %>% \n  fill(Year, .direction = \"down\")\n\ndf_combined## # A tibble: 12 x 4\n##    Measurement Facility Cases  Year\n##          <dbl> <chr>    <dbl> <dbl>\n##  1           1 Hosp 4      82  2000\n##  2           1 Hosp 3      47  2000\n##  3           1 Hosp 2      71  2000\n##  4           1 Hosp 1      66  2000\n##  5           2 Hosp 4      87  2001\n##  6           2 Hosp 3      70  2001\n##  7           2 Hosp 2      62  2001\n##  8           2 Hosp 1      26  2001\n##  9           3 Hosp 4      46  2002\n## 10           3 Hosp 3      38  2002\n## 11           3 Hosp 2      70  2002\n## 12           3 Hosp 1       8  2002\nggplot(df_combined) +\n  aes(Year, Cases, fill = Facility) +\n  geom_col()\ndf_combined %>% \n  pivot_wider(\n    id_cols = c(Facility, Year, Cases),\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %>% \n  arrange(Facility) %>% \n  janitor::adorn_totals(c(\"row\", \"col\")) %>% \n  knitr::kable() %>% \n  kableExtra::row_spec(row = 5, bold = TRUE) %>% \n  kableExtra::column_spec(column = 5, bold = TRUE) \ndf_combined %>% \n  pivot_wider(\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %>% \n  knitr::kable()"},{"path":"pivoting.html","id":"tài-liệu-tham-khảo","chapter":"12 Xoay trục dữ liệu","heading":"12.5 Tài liệu tham khảo","text":"Đây là một hướng dẫn bổ ích","code":""},{"path":"grouping.html","id":"grouping","chapter":"13 Nhóm dữ liệu","heading":"13 Nhóm dữ liệu","text":"Chương này trình bày cách nhóm và tổng hợp dữ liệu phục vụ phân tích mô tả. Sử dụng các package trong hệ sinh thái tidyverse với các hàm phổ biến và dễ sử dụng.Nhóm dữ liệu là một cấu phần cốt lõi trong quản lý và phân tích dữ liệu. Dữ liệu được nhóm tổng hợp thống kê theo nhóm và có thể được vẽ biểu đồ theo nhóm. Các hàm từ package dplyr (một phần của thư viện tidyverse) giúp việc nhóm dữ liệu và các thao tác tiếp theo trở nên dễ dàng hơn.Chương này sẽ giải quyết các chủ đề sau:Nhóm dữ liệu với hàm group_by()Gỡ nhóm dữ liệusummarise() dữ liệu được nhóm với các thống kêSự khác biệt giữa hàm count() và tally()Ứng dụng hàm arrange() với dữ liệu được nhómỨng dụng hàm filter() với dữ liệu được nhómỨng dụng hàm mutate() với dữ liệu được nhómỨng dụng hàm select() với dữ liệu được nhómHàm aggregate() trong base R như một lựa chọn thay thế","code":""},{"path":"grouping.html","id":"chuẩn-bị-4","chapter":"13 Nhóm dữ liệu","heading":"13.1 Chuẩn bị","text":"","code":""},{"path":"grouping.html","id":"gọi-package-2","chapter":"13 Nhóm dữ liệu","heading":"Gọi package","text":"Đoạn code này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn này, chúng ta nhấn mạnh đến hàm p_load() từ package pacman, sẽ cài đặt packahe nếu cần và gọi để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.","code":"\npacman::p_load(\n  rio,       # to import data\n  here,      # to locate files\n  tidyverse, # to clean, handle, and plot the data (includes dplyr)\n  janitor)   # adding total rows and columns"},{"path":"grouping.html","id":"nhập-dữ-liệu-6","chapter":"13 Nhóm dữ liệu","heading":"Nhập dữ liệu","text":"Chúng ta nhập bộ dữ liệu về các trường hợp mô phỏng từ một vụ dịch Ebola. Nếu bạn muốn cùng thực hành, bấm vào đây để tải bộ liệu linelist “sạch” (tệp .rds). Bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau.50 hàng đầu tiên của bộ số liệu linelist:","code":"\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"grouping.html","id":"nhóm","chapter":"13 Nhóm dữ liệu","heading":"13.2 Nhóm","text":"Hàm group_by() từ dplyr nhóm các hàng theo các giá trị duy nhất trong cột chỉ định. Nếu nhiều cột được chỉ định, các hàng được nhóm theo sự tổ hợp các giá trị thành giá trị duy nhất từ các cột. Mỗi giá trị duy nhất (hoặc tổ hợp các giá trị) tạo thành một nhóm. Những thay đổi sau đó đối với bộ dữ liệu hoặc các phép tính có thể thực hiện tùy theo đặc điểm của mỗi nhóm.Ví dụ: lệnh bên dưới truy vấn bộ số liệu linelist và nhóm các hàng theo giá trị duy nhất trong cột outcome, lưu kết quả đầu ra dưới dạng bộ dữ liệu mới có tên ll_by_outcome. (Các) cột được nhóm được đặt bên trong dấu ngoặc đơn của hàm group_by().Lưu ý rằng không có thay đổi dễ nhận thấy nào đối với bộ dữ liệu sau khi chạy lệnh group_by(), cho đến khi phối hợp thêm một số hàm từ dplyr khác như mutate(), summarise(), hoặc arrange() trong bộ dữ liệu “đã được nhóm”.Tuy nhiên, bạn có thể “xem” các nhóm bằng cách bộ dữ liệu. Khi bạn một bộ dữ liệu được nhóm, bạn sẽ thấy nó đã được chuyển đổi thành một đối tượng dạng tibble, mà khi được ra, sẽ hiển thị những nhóm nào đã được áp dụng và có bao nhiêu nhóm - được viết ngay phía trên hàng tiêu đề.","code":"\nll_by_outcome <- linelist %>% \n  group_by(outcome)\n# print to see which groups are active\nll_by_outcome## # A tibble: 5,888 x 30\n## # Groups:   outcome [3]\n##    case_id generation date_infection date_onset date_hospitalis~ date_outcome outcome gender   age age_unit age_years age_cat age_cat5 hospital   lon   lat infector source\n##    <chr>        <dbl> <date>         <date>     <date>           <date>       <chr>   <chr>  <dbl> <chr>        <dbl> <fct>   <fct>    <chr>    <dbl> <dbl> <chr>    <chr> \n##  1 5fe599           4 2014-05-08     2014-05-13 2014-05-15       NA           <NA>    m          2 years            2 0-4     0-4      Other    -13.2  8.47 f547d6   other \n##  2 8689b7           4 NA             2014-05-13 2014-05-14       2014-05-18   Recover f          3 years            3 0-4     0-4      Missing  -13.2  8.45 <NA>     <NA>  \n##  3 11f8ea           2 NA             2014-05-16 2014-05-18       2014-05-30   Recover m         56 years           56 50-69   55-59    St. Mar~ -13.2  8.46 <NA>     <NA>  \n##  4 b8812a           3 2014-05-04     2014-05-18 2014-05-20       NA           <NA>    f         18 years           18 15-19   15-19    Port Ho~ -13.2  8.48 f90f5f   other \n##  5 893f25           3 2014-05-18     2014-05-21 2014-05-22       2014-05-29   Recover m          3 years            3 0-4     0-4      Militar~ -13.2  8.46 11f8ea   other \n##  6 be99c8           3 2014-05-03     2014-05-22 2014-05-23       2014-05-24   Recover f         16 years           16 15-19   15-19    Port Ho~ -13.2  8.46 aec8ec   other \n##  7 07e3e8           4 2014-05-22     2014-05-27 2014-05-29       2014-06-01   Recover f         16 years           16 15-19   15-19    Missing  -13.2  8.46 893f25   other \n##  8 369449           4 2014-05-28     2014-06-02 2014-06-03       2014-06-07   Death   f          0 years            0 0-4     0-4      Missing  -13.2  8.46 133ee7   other \n##  9 f393b4           4 NA             2014-06-05 2014-06-06       2014-06-18   Recover m         61 years           61 50-69   60-64    Missing  -13.2  8.46 <NA>     <NA>  \n## 10 1389ca           4 NA             2014-06-05 2014-06-07       2014-06-09   Death   f         27 years           27 20-29   25-29    Missing  -13.3  8.47 <NA>     <NA>  \n## # ... with 5,878 more rows, and 12 more variables: wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>, temp <dbl>,\n## #   time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>"},{"path":"grouping.html","id":"nhóm-duy-nhất","chapter":"13 Nhóm dữ liệu","heading":"Nhóm duy nhất","text":"Các nhóm được tạo phản ánh từng tổ hợp giá trị duy nhất dọc theo các cột được sử dụng để nhóm.Để xem các nhóm và số hàng trong mỗi nhóm, hãy chuyển tiếp dữ liệu được nhóm đến hàm tally(). Nếu chỉ cần xem các nhóm duy nhất mà không cần số lượng, bạn có thể sử dụng hàm group_keys().Dưới đây là ba giá trị duy nhất trong cột được nhóm là outcome: “Death”, “Recover”, và NA. Ta thấy rằng đã có nrow(linelist %>% filter(outcome == \"Death\")) tử vong, nrow(linelist %>% filter(outcome == \"Recover\")) hồi phục, và nrow(linelist %>% filter(.na(outcome))) không có outcome nào được ghi nhận.Bạn có thể nhóm nhiều hơn một cột. Dưới đây, bộ dữ liệu được nhóm theo outcome và gender, sau đó được đánh số. Lưu ý cách mỗi kết hợp duy nhất của outcome và gender được tổ hợp thành nhóm riêng - bao gồm cả các giá trị bị thiếu ở một trong hai cột.","code":"\nlinelist %>% \n  group_by(outcome) %>% \n  tally()## # A tibble: 3 x 2\n##   outcome     n\n##   <chr>   <int>\n## 1 Death    2582\n## 2 Recover  1983\n## 3 <NA>     1323\nlinelist %>% \n  group_by(outcome, gender) %>% \n  tally()## # A tibble: 9 x 3\n## # Groups:   outcome [3]\n##   outcome gender     n\n##   <chr>   <chr>  <int>\n## 1 Death   f       1227\n## 2 Death   m       1228\n## 3 Death   <NA>     127\n## 4 Recover f        953\n## 5 Recover m        950\n## 6 Recover <NA>      80\n## 7 <NA>    f        627\n## 8 <NA>    m        625\n## 9 <NA>    <NA>      71"},{"path":"grouping.html","id":"cột-mới","chapter":"13 Nhóm dữ liệu","heading":"Cột mới","text":"Bạn cũng có thể tạo một cột mới dùng để nhóm trong câu lệnh group_by(). Điều này tương đương với việc sử dụng hàm mutate() trước khi sử dụng hàm group_by(). Để tạo cột nhanh, cách này có thể hữu ích, nhưng để rõ ràng hơn trong code của bạn, hãy cân nhắc cách tạo cột này ở bước mutate() và sau đó chuyển tiếp đến hàm group_by().","code":"\n# group dat based on a binary column created *within* the group_by() command\nlinelist %>% \n  group_by(\n    age_class = ifelse(age >= 18, \"adult\", \"child\")) %>% \n  tally(sort = T)## # A tibble: 3 x 2\n##   age_class     n\n##   <chr>     <int>\n## 1 child      3618\n## 2 adult      2184\n## 3 <NA>         86"},{"path":"grouping.html","id":"thêmbỏ-cột-được-nhóm","chapter":"13 Nhóm dữ liệu","heading":"Thêm/bỏ cột được nhóm","text":"Mặc định, nếu bạn chạy lệnh group_by() trên dữ liệu đã được nhóm, các nhóm cũ sẽ bị xóa và (các) nhóm mới sẽ được áp dụng. Nếu bạn muốn thêm nhóm mới vào nhóm hiện có, hãy thêm đối số .add = TRUE.","code":"\n# Grouped by outcome\nby_outcome <- linelist %>% \n  group_by(outcome)\n\n# Add grouping by gender in addition\nby_outcome_gender <- by_outcome %>% \n  group_by(gender, .add = TRUE)"},{"path":"grouping.html","id":"giữ-tất-cả-các-nhóm","chapter":"13 Nhóm dữ liệu","heading":"13.3 Giữ tất cả các nhóm","text":"Nếu bạn nhóm trên một cột dạng factor, có thể có các thứ bậc của factor mà không có trong dữ liệu. Nếu bạn nhóm trên cột này, mặc định, những thứ bậc không có trong dữ liệu đó sẽ bị loại bỏ và không thuộc dạng nhóm. Để thay đổi điều này để tất cả các thứ bậc xuất hiện dưới dạng nhóm (ngay cả khi không có trong dữ liệu), đặt .drop = FALSE trong lệnh group_by().","code":""},{"path":"grouping.html","id":"loại-bỏ-nhóm","chapter":"13 Nhóm dữ liệu","heading":"13.4 Loại bỏ nhóm","text":"Dữ liệu đã được nhóm sẽ vẫn được nhóm cho đến khi hủy nhóm bởi lệnh ungroup(). Nếu bạn quên hủy nhóm, nó có thể gây ra tính toán không chính xác! Dưới đây là ví dụ về việc loại bỏ tất cả các nhóm:Bạn cũng có thể loại bỏ nhóm với các cột cụ thể, bằng cách đặt tên cột bên trong lệnh ungroup().GHI CHÚ: Hàm count() tự động hủy nhóm dữ liệu sau khi đếm.","code":"\nlinelist %>% \n  group_by(outcome, gender) %>% \n  tally() %>% \n  ungroup()\nlinelist %>% \n  group_by(outcome, gender) %>% \n  tally() %>% \n  ungroup(gender) # remove the grouping by gender, leave grouping by outcome"},{"path":"grouping.html","id":"group_summarise","chapter":"13 Nhóm dữ liệu","heading":"13.5 Tổng hợp","text":"Xem package dplyr trong chương Bảng mô tả để biết mô tả chi tiết về cách tạo bảng tổng hợp với hàm summarise(). Ở đây chúng ta giải quyết ngắn gọn cách hoạt động thay đổi khi áp dụng cho dữ liệu được nhóm.Hàm dplyr summarise() (hoặc summarize()) lấy một data frame và chuyển nó thành một data frame tổng hợp mới, với các cột chứa thông tin các giá trị thống kê bạn xác định. Trên bộ dữ liệu chưa nhóm, các tổng hợp thống kê sẽ được tính toán từ tất cả các hàng. Việc áp dụng hàm summarise() vào dữ liệu được nhóm sẽ tổng hợp những giá trị thống kê cho từng nhóm.Cú pháp của hàm summarise() là bạn cung cấp tên của (các) cột tổng hợp mới, một dấu bằng và sau đó là một hàm thống kê để áp dụng cho dữ liệu, như được trình bày bên dưới. Ví dụ: min(), max(), median(), hoặc sd(). Trong hàm thống kê, hãy liệt kê cột sẽ được áp dụng và bất kỳ đối số nào có liên quan (ví dụ: na.rm = TRUE). Bạn có thể sử dụng hàm sum() để đếm số hàng đáp ứng tiêu chí logic (với dấu bằng kép ==).Dưới đây là một ví dụ về hàm summarise() được áp dụng mà không có dữ liệu được nhóm. Các giá trị thống kê trả về được tạo ra từ toàn bộ bộ dữ liệu.Ngược lại, bên dưới là câu lệnh summarise() tương tự được áp dụng cho dữ liệu được nhóm. Các số liệu thống kê được tính toán cho từng nhóm kết quả. Lưu ý cách các cột dùng để nhóm sẽ chuyển sang data frame mới.MẸO: Hàm tổng hợp hoạt động với cả cách viết của kiểu Anh và Mỹ - summarise() và summarize() đều chỉ định cùng cùng một hàm.","code":"\n# summary statistics on ungrouped linelist\nlinelist %>% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males  = sum(gender == \"m\", na.rm=T))##   n_cases mean_age max_age min_age n_males\n## 1    5888 16.01831      84       0    2803\n# summary statistics on grouped linelist\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males    = sum(gender == \"m\", na.rm=T))## # A tibble: 3 x 6\n##   outcome n_cases mean_age max_age min_age n_males\n##   <chr>     <int>    <dbl>   <dbl>   <dbl>   <int>\n## 1 Death      2582     15.9      76       0    1228\n## 2 Recover    1983     16.1      84       0     950\n## 3 <NA>       1323     16.2      69       0     625"},{"path":"grouping.html","id":"counts-và-tallies","chapter":"13 Nhóm dữ liệu","heading":"13.6 Counts và tallies","text":"count() và tally() đều cung cấp tính năng tương tự nhưng thực chất là khác nhau. Đọc thêm về sự khác biệt giữa tally() và count() tại đây.","code":""},{"path":"grouping.html","id":"tally","chapter":"13 Nhóm dữ liệu","heading":"tally()","text":"tally() là viết tắt của summarise(n = n()) và không nhóm dữ liệu. đó, để có thể kiểm đếm theo nhóm, nó phải theo sau lệnh group_by(). Bạn có thể thêm sort = TRUE để xem các nhóm lớn nhất trước tiên.","code":"\nlinelist %>% \n  tally()##      n\n## 1 5888\nlinelist %>% \n  group_by(outcome) %>% \n  tally(sort = TRUE)## # A tibble: 3 x 2\n##   outcome     n\n##   <chr>   <int>\n## 1 Death    2582\n## 2 Recover  1983\n## 3 <NA>     1323"},{"path":"grouping.html","id":"count","chapter":"13 Nhóm dữ liệu","heading":"count()","text":"Ngược lại, hàm count() hoạt động như sau:Áp dụng group_by() trên (các) cột đã chỉ địnhÁp dụng summarise() và trả về cột n với số lượng dòng mỗi nhómÁp dụng ungroup()Cũng giống như với hàm group_by(), bạn có thể tạo một cột mới trong lệnh count():count() có thể được sử dụng nhiều lần, với tính năng “cuộn lên”. Ví dụ: để tổng hợp số lượng bệnh viện hiện có cho mỗi giới tính, hãy chạy lệnh như sau. Lưu ý, tên của cột cuối cùng đã được thay đổi từ tên mặc định là “n” để cho rõ ràng (với name  =).","code":"\nlinelist %>% \n  count(outcome)##   outcome    n\n## 1   Death 2582\n## 2 Recover 1983\n## 3    <NA> 1323\nlinelist %>% \n  count(age_class = ifelse(age >= 18, \"adult\", \"child\"), sort = T)##   age_class    n\n## 1     child 3618\n## 2     adult 2184\n## 3      <NA>   86\nlinelist %>% \n  # produce counts by unique outcome-gender groups\n  count(gender, hospital) %>% \n  # gather rows by gender (3) and count number of hospitals per gender (6)\n  count(gender, name = \"hospitals per gender\" ) ##   gender hospitals per gender\n## 1      f                    6\n## 2      m                    6\n## 3   <NA>                    6"},{"path":"grouping.html","id":"thêm-giá-trị-đếm","chapter":"13 Nhóm dữ liệu","heading":"Thêm giá trị đếm","text":"Ngược lại với count() và summarise(), bạn có thể sử dụng add_count() để thêm một cột mới n với số lượng hàng cho mỗi nhóm trong khi vẫn giữ lại tất cả các cột khác trong dữ liệu.Điều này có nghĩa là số lượng của nhóm, trong cột mới n, sẽ được ra trong mỗi hàng của nhóm. Với mục đích minh họa, chúng tôi thêm cột này và sau đó sắp xếp lại các cột để dễ xem hơn. Xem mục bên dưới về bộ lọc theo kích thước nhóm để biết một ví dụ khác.","code":"\nlinelist %>% \n  as_tibble() %>%                   # convert to tibble for nicer printing \n  add_count(hospital) %>%           # add column n with counts by hospital\n  select(hospital, n, everything()) # re-arrange for demo purposes## # A tibble: 5,888 x 31\n##    hospital      n case_id generation date_infection date_onset date_hospitalis~ date_outcome outcome gender   age age_unit age_years age_cat age_cat5   lon   lat infector\n##    <chr>     <int> <chr>        <dbl> <date>         <date>     <date>           <date>       <chr>   <chr>  <dbl> <chr>        <dbl> <fct>   <fct>    <dbl> <dbl> <chr>   \n##  1 Other       885 5fe599           4 2014-05-08     2014-05-13 2014-05-15       NA           <NA>    m          2 years            2 0-4     0-4      -13.2  8.47 f547d6  \n##  2 Missing    1469 8689b7           4 NA             2014-05-13 2014-05-14       2014-05-18   Recover f          3 years            3 0-4     0-4      -13.2  8.45 <NA>    \n##  3 St. Mark~   422 11f8ea           2 NA             2014-05-16 2014-05-18       2014-05-30   Recover m         56 years           56 50-69   55-59    -13.2  8.46 <NA>    \n##  4 Port Hos~  1762 b8812a           3 2014-05-04     2014-05-18 2014-05-20       NA           <NA>    f         18 years           18 15-19   15-19    -13.2  8.48 f90f5f  \n##  5 Military~   896 893f25           3 2014-05-18     2014-05-21 2014-05-22       2014-05-29   Recover m          3 years            3 0-4     0-4      -13.2  8.46 11f8ea  \n##  6 Port Hos~  1762 be99c8           3 2014-05-03     2014-05-22 2014-05-23       2014-05-24   Recover f         16 years           16 15-19   15-19    -13.2  8.46 aec8ec  \n##  7 Missing    1469 07e3e8           4 2014-05-22     2014-05-27 2014-05-29       2014-06-01   Recover f         16 years           16 15-19   15-19    -13.2  8.46 893f25  \n##  8 Missing    1469 369449           4 2014-05-28     2014-06-02 2014-06-03       2014-06-07   Death   f          0 years            0 0-4     0-4      -13.2  8.46 133ee7  \n##  9 Missing    1469 f393b4           4 NA             2014-06-05 2014-06-06       2014-06-18   Recover m         61 years           61 50-69   60-64    -13.2  8.46 <NA>    \n## 10 Missing    1469 1389ca           4 NA             2014-06-05 2014-06-07       2014-06-09   Death   f         27 years           27 20-29   25-29    -13.3  8.47 <NA>    \n## # ... with 5,878 more rows, and 13 more variables: source <chr>, wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>,\n## #   vomit <chr>, temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>"},{"path":"grouping.html","id":"thêm-giá-trị-tổng","chapter":"13 Nhóm dữ liệu","heading":"Thêm giá trị tổng","text":"Để dễ dàng thêm tổng các hàng hoặc cột sau khi sử dụng tally() hoặc count(), hãy xem mục janitor trong chương Bảng mô tả. Package này cung cấp các hàm như adorn_totals() và adorn_percentages() để thêm tổng và chuyển đổi sang hiển thị tỷ lệ phần trăm. Dưới đây là một ví dụ ngắn gọn:Để thêm các hàng tổng phức tạp hơn bao gồm các thống kê tổng hợp khác, hãy xem mục sau trong chương Bảng mô tả.","code":"\nlinelist %>%                                  # case linelist\n  tabyl(age_cat, gender) %>%                  # cross-tabulate counts of two columns\n  adorn_totals(where = \"row\") %>%             # add a total row\n  adorn_percentages(denominator = \"col\") %>%  # convert to proportions with column denominator\n  adorn_pct_formatting() %>%                  # convert proportions to percents\n  adorn_ns(position = \"front\") %>%            # display as: \"count (percent)\"\n  adorn_title(                                # adjust titles\n    row_name = \"Age Category\",\n    col_name = \"Gender\")##                      Gender                           \n##  Age Category             f             m          NA_\n##           0-4  640  (22.8%)  416  (14.8%)  39  (14.0%)\n##           5-9  641  (22.8%)  412  (14.7%)  42  (15.1%)\n##         10-14  518  (18.5%)  383  (13.7%)  40  (14.4%)\n##         15-19  359  (12.8%)  364  (13.0%)  20   (7.2%)\n##         20-29  468  (16.7%)  575  (20.5%)  30  (10.8%)\n##         30-49  179   (6.4%)  557  (19.9%)  18   (6.5%)\n##         50-69    2   (0.1%)   91   (3.2%)   2   (0.7%)\n##           70+    0   (0.0%)    5   (0.2%)   1   (0.4%)\n##          <NA>    0   (0.0%)    0   (0.0%)  86  (30.9%)\n##         Total 2807 (100.0%) 2803 (100.0%) 278 (100.0%)"},{"path":"grouping.html","id":"nhóm-theo-ngày","chapter":"13 Nhóm dữ liệu","heading":"13.7 Nhóm theo ngày","text":"Khi nhóm dữ liệu theo ngày, bạn phải có (hoặc tạo) một cột cho đơn vị ngày quan tâm - ví dụ: “ngày”, “tuần dịch tễ”, “tháng”, v.v. Bạn có thể tạo cột này bằng cách sử dụng floor_date() từ lubridate, như được giải thích trong phần Tuần dịch tễ học trong chương Làm việc với ngày tháng. Khi bạn có cột này, bạn có thể sử dụng count() từ dplyr để nhóm các hàng theo các giá trị ngày duy nhất đó và thu về giá trị số lượng tổng hợp.Một bước bổ sung phổ biến cho các tình huống với ngày/tháng, là “điền vào” bất kỳ ngày nào trong chuỗi ngày không có trong dữ liệu. Sử dụng complete() từ tidyr để chuỗi ngày tổng hợp được hoàn chỉnh bao gồm tất cả các đơn vị ngày có thể có trong phạm vi. Nếu không có bước này, một tuần không có trường hợp nào được báo cáo có thể không xuất hiện trong dữ liệu của bạn!Trong complete(), bạn xác định lại cột ngày của mình dưới dạng một chuỗi ngày seq.Date() từ giá trị nhỏ nhất đến giá trị lớn nhất - đó mà ngày/tháng được mở rộng. Mặc định, giá trị số lượng trong bất kỳ hàng “mở rộng” mới nào sẽ là NA. Bạn có thể đặt chúng thành 0 bằng cách sử dụng argument fill = của hàm complete(), trong đó yêu cầu một danh sách được đặt tên (nếu cột số lượng của bạn được đặt tên là n, hãy thêm fill = list(n = 0)). Xem ?complete để biết chi tiết và xem ví dụ trong chương Làm việc với ngày tháng.","code":""},{"path":"grouping.html","id":"các-trường-hợp-trong-linelist-theo-ngày","chapter":"13 Nhóm dữ liệu","heading":"Các trường hợp trong linelist theo ngày","text":"Dưới đây là một ví dụ về nhóm các trường hợp theo ngày mà không sử dụng complete(). Lưu ý các hàng đầu tiên bỏ qua các ngày mà không có trường hợp nào.Dưới đây, chúng ta thêm lệnh complete() để đảm bảo mỗi ngày trong phạm vi đều được hiển thị.","code":"\ndaily_counts <- linelist %>% \n  drop_na(date_onset) %>%        # remove that were missing date_onset\n  count(date_onset)              # count number of rows per unique date\ndaily_counts <- linelist %>% \n  drop_na(date_onset) %>%                 # remove case missing date_onset\n  count(date_onset) %>%                   # count number of rows per unique date\n  complete(                               # ensure all days appear even if no cases\n    date_onset = seq.Date(                # re-define date colume as daily sequence of dates\n      from = min(date_onset, na.rm=T), \n      to = max(date_onset, na.rm=T),\n      by = \"day\"),\n    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) "},{"path":"grouping.html","id":"các-trường-hợp-trong-linelist-theo-tuần","chapter":"13 Nhóm dữ liệu","heading":"Các trường hợp trong linelist theo tuần","text":"Nguyên tắc tương tự có thể được áp dụng cho tuần. Đầu tiên, hãy tạo một cột mới các trường hợp theo tuần bằng cách sử dụng floor_date() với unit = \"week\". Sau đó, sử dụng count() như trên để đạt được số lượng ca hàng tuần. Kết thúc bằng hàm complete() để đảm bảo rằng tất cả các tuần đều được hiển thị, ngay cả khi chúng không chứa ca nào.Đây là 50 hàng đầu tiên của bộ dữ liệu khi trả kết quả:","code":"\n# Make dataset of weekly case counts\nweekly_counts <- linelist %>% \n  drop_na(date_onset) %>%                 # remove cases missing date_onset\n  mutate(week = lubridate::floor_date(date_onset, unit = \"week\")) %>%  # new column of week of onset\n  count(week) %>%                         # group data by week and count rows per group\n  complete(                               # ensure all days appear even if no cases\n    week = seq.Date(                      # re-define date colume as daily sequence of dates\n      from = min(week, na.rm=T), \n      to = max(week, na.rm=T),\n      by = \"week\"),\n    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) "},{"path":"grouping.html","id":"các-trường-hợp-trong-linelist-theo-tháng","chapter":"13 Nhóm dữ liệu","heading":"Các trường hợp trong linelist theo tháng","text":"Để tổng hợp các trường hợp theo tháng, hãy sử dụng lại floor_date() từ package lubridate, nhưng với argument unit = \"months\". Điều này làm tròn xuống các ngày thành ngày đầu tiên của tháng. Đầu ra sẽ là định dạng ngày. Lưu ý rằng trong bước complete(), chúng ta cũng sử dụng = \"months\".","code":"\n# Make dataset of monthly case counts\nmonthly_counts <- linelist %>% \n  drop_na(date_onset) %>% \n  mutate(month = lubridate::floor_date(date_onset, unit = \"months\")) %>%  # new column, 1st of month of onset\n  count(month) %>%                          # count cases by month\n  complete(\n    month = seq.Date(\n      min(month, na.rm=T),     # include all months with no cases reported\n      max(month, na.rm=T),\n      by=\"month\"),\n    fill = list(n = 0))"},{"path":"grouping.html","id":"số-lượng-đếm-hàng-ngày-theo-tuần","chapter":"13 Nhóm dữ liệu","heading":"Số lượng đếm hàng ngày theo tuần","text":"Để tổng hợp số lượng hàng ngày thành số lượng hàng tuần, hãy sử dụng floor_date() như trên. Tuy nhiên, hãy sử dụng group_by() và summarize() thay vì count() bởi vì chúng ta cần tính tổng sum() số lượng trường hợp hàng ngày thay vì chỉ đếm số hàng mỗi tuần.","code":""},{"path":"grouping.html","id":"số-lượng-đếm-hàng-ngày-theo-tuần-1","chapter":"13 Nhóm dữ liệu","heading":"Số lượng đếm hàng ngày theo tuần","text":"Để tổng hợp số lượng hàng ngày thành số lượng hàng tháng, hãy sử dụng floor_date() với unit = \"month\" như trên. Tuy nhiên, hãy sử dụng group_by() và summarize() thay vì count() bởi vì chúng ta cần tính tổng sum() số lượng trường hợp hàng ngày thay vì chỉ đếm số hàng mỗi tháng.","code":""},{"path":"grouping.html","id":"sắp-xếp-dữ-liệu-đã-nhóm","chapter":"13 Nhóm dữ liệu","heading":"13.8 Sắp xếp dữ liệu đã nhóm","text":"Sử dụng hàm dplyr arrange() để sắp xếp các hàng trong bộ dữ liệu tương tự khi dữ liệu được nhóm lại, trừ khi bạn thiết lập đối số .by_group =TRUE. Trong trường hợp này, các hàng được sắp xếp thứ tự đầu tiên theo các cột nhóm và sau đó theo bất kỳ cột nào khác mà bạn chỉ định để arrange().","code":""},{"path":"grouping.html","id":"lọc-trên-nhóm-dữ-liệu-đã-nhóm","chapter":"13 Nhóm dữ liệu","heading":"13.9 Lọc trên nhóm dữ liệu đã nhóm","text":"","code":""},{"path":"grouping.html","id":"filter","chapter":"13 Nhóm dữ liệu","heading":"filter()","text":"Khi được áp dụng cùng với các hàm đánh giá bộ dữ liệu (như max(), min(), mean()), các hàm này sẽ được áp dụng cho các nhóm. Ví dụ: nếu bạn muốn lọc và giữ các hàng có bệnh nhân trên độ tuổi trung vị, hàm này sẽ áp dụng cho mỗi nhóm - lọc để giữ các hàng trên độ tuổi trung bình của nhóm.","code":""},{"path":"grouping.html","id":"cắt-hàng-theo-nhóm","chapter":"13 Nhóm dữ liệu","heading":"Cắt hàng theo nhóm","text":"Hàm dplyr slice(), mà lọc hàng dựa trên vị trí trong dữ liệu, cũng có thể được áp dụng cho mỗi nhóm. Hãy nhớ sắp xếp dữ liệu trong mỗi nhóm để có được “lát cắt” mong muốn.Ví dụ: chỉ lấy 5 lần nhập viện gần nhất từ mỗi bệnh viện:Nhóm bộ số liệu linelist theo cột hospitalSắp xếp bản ghi từ gần nhất đến xa nhất theo date_hospitalisation trong mỗi nhóm bệnh việnCắt để lấy 5 hàng đầu tiên từ mỗi bệnh việnslice_head() - chọn n hàng từ trên xuống dướislice_tail() - chọn n hàng từ dưới lên trênslice_sample() - chọn ngẫu nhiên n dòngslice_min() - chọn n dòng với giá trị cao nhất trong cột order_by =, sử dụng with_ties = TRUE để giữ mối liên hệslice_max() - chọn n dòng với giá trị thấp nhất trong cột order_by =,sử dụng with_ties = TRUE để giữ mối liên hệXem chương Loại bỏ trùng lặp để tham khảo thêm ví dụ và chi tiết về hàm slice().","code":"\nlinelist %>%\n  group_by(hospital) %>%\n  arrange(hospital, date_hospitalisation) %>%\n  slice_head(n = 5) %>% \n  arrange(hospital) %>%                            # for display\n  select(case_id, hospital, date_hospitalisation)  # for display## # A tibble: 30 x 3\n## # Groups:   hospital [6]\n##    case_id hospital          date_hospitalisation\n##    <chr>   <chr>             <date>              \n##  1 20b688  Central Hospital  2014-05-06          \n##  2 d58402  Central Hospital  2014-05-10          \n##  3 b8f2fd  Central Hospital  2014-05-13          \n##  4 acf422  Central Hospital  2014-05-28          \n##  5 275cc7  Central Hospital  2014-05-28          \n##  6 d1fafd  Military Hospital 2014-04-17          \n##  7 974bc1  Military Hospital 2014-05-13          \n##  8 6a9004  Military Hospital 2014-05-13          \n##  9 09e386  Military Hospital 2014-05-14          \n## 10 865581  Military Hospital 2014-05-15          \n## # ... with 20 more rows"},{"path":"grouping.html","id":"group_filter_grp_size","chapter":"13 Nhóm dữ liệu","heading":"Lọc theo quy mô nhóm","text":"Hàm add_count() thêm một cột n vào dữ liệu gốc cho biết số hàng trong nhóm của hàng đó.Như trình bày bên dưới, add_count() được áp dụng cho cột hospital, vì vậy các giá trị trong cột mới n phản ánh số hàng trong nhóm bệnh viện của hàng đó. Lưu ý cách các giá trị trong cột n được lặp lại. Trong ví dụ dưới đây, tên cột n có thể được thay đổi bằng cách sử dụng đối số name = trong add_count(). Với mục đích diễn giải, chúng ta sắp xếp lại các cột với select().Sau đó, nó trở nên dễ dàng để lọc các hàng trường hợp nhập viện tại một bệnh viện “nhỏ”, chẳng hạn như một bệnh viện tiếp nhận ít hơn 500 bệnh nhân:","code":"\nlinelist %>% \n  as_tibble() %>% \n  add_count(hospital) %>%          # add \"number of rows admitted to same hospital as this row\" \n  select(hospital, n, everything())## # A tibble: 5,888 x 31\n##    hospital      n case_id generation date_infection date_onset date_hospitalis~ date_outcome outcome gender   age age_unit age_years age_cat age_cat5   lon   lat infector\n##    <chr>     <int> <chr>        <dbl> <date>         <date>     <date>           <date>       <chr>   <chr>  <dbl> <chr>        <dbl> <fct>   <fct>    <dbl> <dbl> <chr>   \n##  1 Other       885 5fe599           4 2014-05-08     2014-05-13 2014-05-15       NA           <NA>    m          2 years            2 0-4     0-4      -13.2  8.47 f547d6  \n##  2 Missing    1469 8689b7           4 NA             2014-05-13 2014-05-14       2014-05-18   Recover f          3 years            3 0-4     0-4      -13.2  8.45 <NA>    \n##  3 St. Mark~   422 11f8ea           2 NA             2014-05-16 2014-05-18       2014-05-30   Recover m         56 years           56 50-69   55-59    -13.2  8.46 <NA>    \n##  4 Port Hos~  1762 b8812a           3 2014-05-04     2014-05-18 2014-05-20       NA           <NA>    f         18 years           18 15-19   15-19    -13.2  8.48 f90f5f  \n##  5 Military~   896 893f25           3 2014-05-18     2014-05-21 2014-05-22       2014-05-29   Recover m          3 years            3 0-4     0-4      -13.2  8.46 11f8ea  \n##  6 Port Hos~  1762 be99c8           3 2014-05-03     2014-05-22 2014-05-23       2014-05-24   Recover f         16 years           16 15-19   15-19    -13.2  8.46 aec8ec  \n##  7 Missing    1469 07e3e8           4 2014-05-22     2014-05-27 2014-05-29       2014-06-01   Recover f         16 years           16 15-19   15-19    -13.2  8.46 893f25  \n##  8 Missing    1469 369449           4 2014-05-28     2014-06-02 2014-06-03       2014-06-07   Death   f          0 years            0 0-4     0-4      -13.2  8.46 133ee7  \n##  9 Missing    1469 f393b4           4 NA             2014-06-05 2014-06-06       2014-06-18   Recover m         61 years           61 50-69   60-64    -13.2  8.46 <NA>    \n## 10 Missing    1469 1389ca           4 NA             2014-06-05 2014-06-07       2014-06-09   Death   f         27 years           27 20-29   25-29    -13.3  8.47 <NA>    \n## # ... with 5,878 more rows, and 13 more variables: source <chr>, wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>,\n## #   vomit <chr>, temp <dbl>, time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>\nlinelist %>% \n  add_count(hospital) %>% \n  filter(n < 500)"},{"path":"grouping.html","id":"tạo-cột-mới-trên-dữ-liệu-được-nhóm","chapter":"13 Nhóm dữ liệu","heading":"13.10 Tạo cột mới trên dữ liệu được nhóm","text":"Để giữ lại tất cả các cột và hàng (không tổng hợp) và thêm một cột mới chứa thống kê theo nhóm, hãy sử dụng hàm mutate() sau group_by() thay vì summarise().Điều này hữu ích nếu bạn muốn nhóm thống kê trong bộ dữ liệu gốc với tất cả các cột khác được hiển thị - ví dụ: cho các phép tính sánh một hàng với nhóm của nó.Ví dụ: code dưới đây tính toán sự khác biệt giữa thời gian trễ nhập viện của một hàng và thời gian chậm trễ trung vị đối với bệnh viện đó. Các bước lần lượt là:Nhóm dữ liệu theo bệnh việnSử dụng cột days_onset_hosp (nhập viện trễ) để tạo một cột mới chứa giá trị trễ trung bình tại bệnh viện của hàng đóTính toán sự khác biệt giữa hai cộtChúng ta chỉ lựa chọn select() những cột cần hiển thị, cho mục đích diễn giải.","code":"\nlinelist %>% \n  # group data by hospital (no change to linelist yet)\n  group_by(hospital) %>% \n  \n  # new columns\n  mutate(\n    # mean days to admission per hospital (rounded to 1 decimal)\n    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),\n    \n    # difference between row's delay and mean delay at their hospital (rounded to 1 decimal)\n    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%\n  \n  # select certain rows only - for demonstration/viewing purposes\n  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)## # A tibble: 5,888 x 5\n## # Groups:   hospital [6]\n##    case_id hospital                             days_onset_hosp group_delay_admit diff_to_group\n##    <chr>   <chr>                                          <dbl>             <dbl>         <dbl>\n##  1 5fe599  Other                                              2               2             0  \n##  2 8689b7  Missing                                            1               2.1          -1.1\n##  3 11f8ea  St. Mark's Maternity Hospital (SMMH)               2               2.1          -0.1\n##  4 b8812a  Port Hospital                                      2               2.1          -0.1\n##  5 893f25  Military Hospital                                  1               2.1          -1.1\n##  6 be99c8  Port Hospital                                      1               2.1          -1.1\n##  7 07e3e8  Missing                                            2               2.1          -0.1\n##  8 369449  Missing                                            1               2.1          -1.1\n##  9 f393b4  Missing                                            1               2.1          -1.1\n## 10 1389ca  Missing                                            2               2.1          -0.1\n## # ... with 5,878 more rows"},{"path":"grouping.html","id":"chọn-trên-dữ-liệu-được-nhóm","chapter":"13 Nhóm dữ liệu","heading":"13.11 Chọn trên dữ liệu được nhóm","text":"Hàm select() hoạt động trên dữ liệu được nhóm, nhưng các cột được nhóm luôn được bao gồm (ngay cả khi không được đề cập trong select()). Nếu bạn không muốn nhóm các cột này, trước tiên hãy bỏ nhóm bằng hàm ungroup().","code":""},{"path":"grouping.html","id":"tài-nguyên-học-liệu-1","chapter":"13 Nhóm dữ liệu","heading":"13.12 Tài nguyên học liệu","text":"Dưới đây là một số tài nguyên hữu ích cung cấp thêm thông tin:Bạn có thể thực hiện bất kỳ hàm tổng hợp nào trên dữ liệu được nhóm; xem RStudio cheat sheet về biến đổi dữ liệuTrang Data Carpentry của dplyr\nChương tham khảo hệ sinh thái tidyverse về group_by() và groupingTrang này về Thao tác dữ liệuTổng hợp có điều kiện với dplyr","code":""},{"path":"joining-matching.html","id":"joining-matching","chapter":"14 Nối dữ liệu","heading":"14 Nối dữ liệu","text":"Ở trên: một ví dụ động về phép nối bên trái (nguồn ảnh)Chương này mô tả các cách “nối (join)”, “khớp (match)”, “liên kết (link),”gắn (bind)” và các cách khác để kết hợp các data frame.Việc phân tích hay quy trình làm việc dịch tễ học của bạn liên quan đến nhiều nguồn dữ liệu và sự liên kết của nhiều bộ dữ liệu với nhau là phổ biến. Có thể bạn cần kết nối dữ liệu phòng thí nghiệm với kết quả lâm sàng của bệnh nhân, hoặc dữ liệu di động của Google với các xu hướng bệnh truyền nhiễm hay thậm chí là bộ dữ liệu ở một giai đoạn phân tích với phiên bản đã biến đổi của chính nó.Trong chương này chúng ta trình bày code nhằm:Hướng dẫn nối hai data frame sao cho các hàng khớp với nhau dựa trên các giá trị chung trong cột định danhNối hai data frame dựa trên sự phù hợp (có khả năng) theo xác suất giữa các giá trịMở rộng một data frame bằng cách gắn hoặc (“thêm vào”) trực tiếp các hàng hoặc cột từ một data frame khác","code":""},{"path":"joining-matching.html","id":"chuẩn-bị-5","chapter":"14 Nối dữ liệu","heading":"14.1 Chuẩn bị","text":"","code":""},{"path":"joining-matching.html","id":"gọi-package-3","chapter":"14 Nối dữ liệu","heading":"Gọi package","text":"Đoạn code này hiển thị những package cần gọi cho các phân tích. Trong sổ tay này, chúng ta nhấn mạnh đến hàm p_load() từ pacman, hàm sẽ cài đặt package nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để có thêm thông tin về các R package.","code":"\npacman::p_load(\n  rio,            # import and export\n  here,           # locate files \n  tidyverse,      # data management and visualisation\n  RecordLinkage,  # probabilistic matches\n  fastLink        # probabilistic matches\n)"},{"path":"joining-matching.html","id":"nhập-dữ-liệu-7","chapter":"14 Nối dữ liệu","heading":"Nhập dữ liệu","text":"Để bắt đầu, chúng ta nhập các trường hợp trong linelist đã được làm sạch từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, bấm để tải xuống linelist “đã được làm sạch” (tệp .rds). Nhập dữ liệu với hàm import() từ package rio (hàm này xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương Nhập xuất dữ liệu để biết thêm chi tiết).50 hàng đầu tiên của linelist được hiển thị dưới đây.","code":"\n# import case linelist \nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"joining-matching.html","id":"bộ-dữ-liệu-mẫu","chapter":"14 Nối dữ liệu","heading":"Bộ dữ liệu mẫu","text":"Trong phần nối dữ liệu dưới đây, chúng ta sẽ sử dụng các bộ dữ liệu sau:Một phiên bản “thu nhỏ” của bộ dữ liệu linelist, chỉ chứa các cột case_id, date_onset, hospital và chỉ 10 hàng đầu tiênMột data frame riêng biệt có tên hosp_info, chứa thêm thông tin chi tiết của từng bệnh việnTrong phần ghép theo xác suất, chúng ta sẽ sử dụng hai bộ dữ liệu nhỏ khác nhau. Code để tạo các bộ dữ liệu này được đưa ra trong phần đó.","code":""},{"path":"joining-matching.html","id":"joins_llmini","chapter":"14 Nối dữ liệu","heading":"Dữ liệu linelist “thu nhỏ”","text":"Dưới đây là bộ dữ liệu linelist thu nhỏ, bao gồm 10 hàng và chỉ chứa các cột case_id, date_onset và hospital.","code":"\nlinelist_mini <- linelist %>%                 # start with original linelist\n  select(case_id, date_onset, hospital) %>%   # select columns\n  head(10)                                    # only take the first 10 rows"},{"path":"joining-matching.html","id":"joins_hosp_info","chapter":"14 Nối dữ liệu","heading":"Data frame thông tin bệnh viện","text":"Dưới đây là code để tạo một data frame riêng biệt với thông tin bổ sung của bảy bệnh viện (số lượng người dân có thể tiếp cận và mức độ chăm sóc hiện có). Lưu ý rằng tên “Bệnh viện Quân đội (Military Hospital)” thuộc về hai bệnh viện khác nhau - một bệnh viện cấp 1 phục vụ 10000 cư dân và một bệnh viện cấp hai phục vụ 40500 cư dân.Đây là data frame này:","code":"\n# Make the hospital information data frame\nhosp_info = data.frame(\n  hosp_name     = c(\"central hospital\", \"military\", \"military\", \"port\", \"St. Mark's\", \"ignace\", \"sisters\"),\n  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),\n  level         = c(\"Tertiary\", \"Secondary\", \"Primary\", \"Secondary\", \"Secondary\", \"Primary\", \"Primary\")\n)"},{"path":"joining-matching.html","id":"làm-sạch-trước","chapter":"14 Nối dữ liệu","heading":"Làm sạch trước","text":"Các phương pháp nối truyền thống (không theo xác suất) phân biệt chữ hoa, chữ thường và yêu cầu khớp các ký tự chính xác giữa các giá trị trong hai data frame. Để minh họa một số bước làm sạch mà bạn có thể cần làm trước khi bắt đầu nối, chúng ta sẽ làm sạch và căn chỉnh bộ dữ liệu linelist_mini và hosp_info ngay bây giờ.Xác định điểm khác biệtChúng ta cần các giá trị của cột hosp_name trong data frame hosp_info để khớp với các giá trị của cột hospital trong data frame linelist_mini.Dưới đây là các giá trị trong data frame linelist_mini, được bằng hàm unique()trong base R:và đây là các giá trị trong data frame hosp_info:Bạn có thể thấy rằng mặc dù một số bệnh viện tồn tại trong cả hai data frame, nhưng có nhiều điểm khác biệt về chính tả.Căn chỉnh giá trịChúng ta bắt đầu bằng cách làm sạch các giá trị trong data frame hosp_info. Như đã được giải thích trong chương Làm sạch số liệu và các hàm quan trọng, chúng ta có thể code lại các giá trị với tiêu chí logic bằng cách sử dụng hàm case_when() của dplyr. Đối với bốn bệnh viện tồn tại trong cả hai data frame, chúng ta thay đổi các giá trị để phù hợp với các giá trị trong linelist_mini. Các bệnh viện khác chúng ta để nguyên giá trị (TRUE ~ hosp_name).CẨN TRỌNG: Thông thường khi làm sạch, chúng ta nên tạo một cột mới (ví dụ: hosp_name_clean), nhưng để dễ dàng giải thích, chúng ta hiển thị các thay đổi trên cột cũTên bệnh viện xuất hiện trong cả hai data frame đều được căn chỉnh. Có hai bệnh viện trong dữ liệu hosp_info không có trong linelist_mini - chúng ta sẽ giải quyết những trường hợp này sau, trong phần nối dữ liệu.Trước một phép nối, việc chuyển đổi một cột thành tất cả chữ thường hoặc tất cả chữ hoa thường dễ dàng nhất. Nếu bạn cần chuyển đổi tất cả các giá trị trong một cột thành CHỮ HOA hoặc chữ thường, hãy sử dụng mutate() và đặt cột bên trong một trong những hàm từ package stringr, như ã được trình bày trong chương Ký tự và chuỗi.str_to_upper()str_to_upper()str_to_title()","code":"\nunique(linelist_mini$hospital)## [1] \"Other\"                                \"Missing\"                              \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \n## [5] \"Military Hospital\"\nunique(hosp_info$hosp_name)## [1] \"central hospital\" \"military\"         \"port\"             \"St. Mark's\"       \"ignace\"           \"sisters\"\nhosp_info <- hosp_info %>% \n  mutate(\n    hosp_name = case_when(\n      # criteria                         # new value\n      hosp_name == \"military\"          ~ \"Military Hospital\",\n      hosp_name == \"port\"              ~ \"Port Hospital\",\n      hosp_name == \"St. Mark's\"        ~ \"St. Mark's Maternity Hospital (SMMH)\",\n      hosp_name == \"central hospital\"  ~ \"Central Hospital\",\n      TRUE                             ~ hosp_name\n      )\n    )\nunique(hosp_info$hosp_name)## [1] \"Central Hospital\"                     \"Military Hospital\"                    \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\n## [5] \"ignace\"                               \"sisters\""},{"path":"joining-matching.html","id":"nối-bằng-dplyr","chapter":"14 Nối dữ liệu","heading":"14.2 Nối bằng dplyr","text":"Package dplyr cung cấp một số hàm nối khác nhau. dplyr là một package thuộc hệ sinh thái tidyverse. Các hàm nối này được mô tả ở bên dưới, trong các trường hợp sử dụng đơn giản.Rất cảm ơn https://github.com/gadenbuie vì những tấm ảnh động bổ ích!","code":""},{"path":"joining-matching.html","id":"cú-pháp-chung","chapter":"14 Nối dữ liệu","heading":"Cú pháp chung","text":"Các lệnh nối có thể được chạy dưới dạng các lệnh độc lập để nối hai data frame thành một đối tượng mới, hoặc chúng có thể được sử dụng trong một chuỗi pipe (%>%) để hợp nhất một data frame vào một data frame khác khi nó đang được làm sạch hoặc chỉnh sửa.Trong ví dụ dưới đây, hàm left_join() được sử dụng như một lệnh độc lập để tạo một data frame joined_data mới. Các dữ liệu đầu vào là data frame 1 và 2 (df1 và df2). Data frame đầu tiên được liệt kê là data frame cơ sở và data frame thứ hai được liệt kê là data frame sẽ nối với data frame thứ nhất.Đối số thứ ba = là nơi bạn xác định các cột trong mỗi data frame mà sẽ được sử dụng để căn chỉnh các hàng trong hai data frame. Nếu tên của các cột này khác nhau, hãy đặt chúng trong một vectơ c() như được trình bày dưới đây, nơi mà các hàng được khớp trên cơ sở các giá trị chung giữa cột ID trong df1 và cột identifier trong df2.Nếu các cột trong cả hai data frame có cùng tên, bạn chỉ cần cung cấp tên này, đặt trong dấu ngoặc kép.Nếu bạn đang nối các data frame dựa trên các giá trị chung của nhiều trường, hãy liệt kê các trường này trong vectơ c(). Ví dụ dưới đây nối các hàng nếu các giá trị trong ba cột trong mỗi bộ dữ liệu căn chỉnh chính xác.Các lệnh nối cũng có thể được chạy trong một chuỗi pipe. Điều này sẽ thực hiện sửa đổi data frame trong chuỗi pipe.Trong ví dụ dưới đây, df1 được đưa qua các pipe, df2 được nối vào đó và vì thế df1 được chỉnh sửa và xác định lại.CẨN TRỌNG: Nối dựa trên những trường hợp cụ thể! đó, rất hữu ích khi chuyển đổi tất cả các giá trị thành chữ thường hoặc chữ hoa trước khi nối. Xem thêm chương về ký tự/chuỗi.","code":"\n# Join based on common values between column \"ID\" (first data frame) and column \"identifier\" (second data frame)\njoined_data <- left_join(df1, df2, by = c(\"ID\" = \"identifier\"))\n# Joint based on common values in column \"ID\" in both data frames\njoined_data <- left_join(df1, df2, by = \"ID\")\n# join based on same first name, last name, and age\njoined_data <- left_join(df1, df2, by = c(\"name\" = \"firstname\", \"surname\" = \"lastname\", \"Age\" = \"age\"))\ndf1 <- df1 %>%\n  filter(date_onset < as.Date(\"2020-03-05\")) %>% # miscellaneous cleaning \n  left_join(df2, by = c(\"ID\" = \"identifier\"))    # join df2 to df1"},{"path":"joining-matching.html","id":"nối-trái-và-phải","chapter":"14 Nối dữ liệu","heading":"Nối trái và phải","text":"Nối trái hoặc phải thường được sử dụng để thêm thông tin vào data frame - thông tin mới chỉ được thêm vào các hàng đã tồn tại trong data frame cơ sở. Đây là những phép nối phổ biến trong hoạt động dịch tễ học vì chúng được sử dụng để thêm thông tin từ một bộ dữ liệu vào một bộ dữ liệu khác.Khi sử dụng các phép nối này, thứ tự viết của các data frame trong lệnh rất quan trọng*.Trong phép nối trái, data frame đầu tiên được viết là data frame cơ sởTrong phép nối phải, data frame thứ hai được viết là data frame cơ sởTất cả các hàng của data frame cơ sở được giữ lại. Thông tin trong data frame (thứ cấp) khác được kết hợp với data frame cơ sở chỉ khi có sự trùng khớp của (các) cột định danh. Ngoài ra:Các hàng trong data frame thứ cấp không khớp sẽ bị loại bỏ.Nếu có nhiều hàng cơ sở khớp với một hàng trong data frame thứ cấp (nhiều-khớp-một), thông tin phụ sẽ được thêm vào mỗi hàng cơ sở được khớp.Nếu một hàng cơ sở khớp với nhiều hàng trong data frame thứ cấp (một-khớp-nhiều), tất cả các kết hợp sẽ được đưa ra, nghĩa là các hàng mới có thể được thêm vào data frame trả về của bạn!Sau đây là các ví dụ động về phép nối trái và phải (nguồn ảnh)Ví dụDưới đây là kết quả đầu ra của phép nối trái left_join() của bộ dữ liệu hosp_info (data frame thứ cấp, xem tại đây) vào linelist_mini (data frame cơ sở, xem tại đây). linelist_mini gốc có nrow(linelist_mini) hàng. linelist_mini đã chỉnh sửa được hiển thị. Lưu ý những điều dưới đây:Hai cột mới catchment_pop và level đã được thêm vào bên trái của linelist_miniTất cả các hàng gốc của data frame cơ sở linelist_mini đều được giữ lạiBất kỳ hàng gốc nào của linelist_mini cho “Military Hospital” đều bị trùng lặp vì nó khớp với hai hàng trong data frame thứ cấp, đó cả hai sự kết hợp đều được trả vềCột định danh kết hợp của bộ dữ liệu thứ cấp (hosp_name) đã biến mất vì nó thừa với cột định danh trong bộ dữ liệu chính (hospital)Khi một hàng cơ sở không khớp với bất kỳ hàng thứ cấp nào (ví dụ: khi hospital là “” hoặc “Missing”), NA (trống) sẽ điền vào các cột từ data frame thứ cấpCác hàng trong data frame thứ cấp không khớp với data frame cơ sở (bệnh viện “sisters” và “ignace”) đã bị loại bỏ","code":"\nlinelist_mini %>% \n  left_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))"},{"path":"joining-matching.html","id":"tôi-nên-sử-dụng-phép-nối-phải-hay-phép-nối-trái","chapter":"14 Nối dữ liệu","heading":"“Tôi nên sử dụng phép nối phải hay phép nối trái?”","text":"Để trả lời câu hỏi trên, hãy tự hỏi “data frame nào nên giữ lại tất cả các hàng của nó?” - hãy sử dụng cái này làm data frame cơ sở. Phép nối trái giữ tất cả các hàng trong data frame đầu tiên được viết trong lệnh, trong khi phép nối phải giữ tất cả các hàng trong data frame thứ hai.Hai lệnh bên dưới đạt cùng một kết quả đầu ra - 10 hàng hosp_info được nối vào bộ dữ liệu cơ sở linelist_mini, tuy nhiên chúng sử dụng các phép nối khác nhau. Kết quả là thứ tự cột sẽ khác nhau dựa trên việc hosp_info đến từ bên phải (trong phép nối bên trái) hay đến từ bên trái (trong phép nối bên phải). Thứ tự của các hàng cũng có thể thay đổi tương ứng. Nhưng cả hai hệ quả này đều có thể được giải quyết bằng cách sử dụng select() để sắp xếp lại các cột hoặc arrange() để sắp xếp các hàng.Đây là kết quả nối hosp_info vào linelist_mini qua phép nối trái (các cột mới đến từ bên phải)Đây là kết quả nối hosp_info vào linelist_mini qua phép nối phải (các cột mới đến từ bên trái)Ngoài ra, hãy xem xét liệu trường hợp-đang sử dụng của bạn có nằm trong một chuỗi pipe (%>%) hay không. Nếu bộ dữ liệu nằm trong pipe là đường cơ sở, bạn có thể sẽ sử dụng một phép nối trái để thêm dữ liệu vào đó.","code":"\n# The two commands below achieve the same data, but with differently ordered rows and columns\nleft_join(linelist_mini, hosp_info, by = c(\"hospital\" = \"hosp_name\"))\nright_join(hosp_info, linelist_mini, by = c(\"hosp_name\" = \"hospital\"))"},{"path":"joining-matching.html","id":"nối-hoàn-toàn","chapter":"14 Nối dữ liệu","heading":"Nối hoàn toàn","text":"Nối hoàn toàn là phép nối bao hàm nhất trong tất cả các phép nối - nó trả về tất cả các hàng từ cả hai data frame.Nếu có bất kỳ hàng nào chỉ hiện diện duy nhất trong một data frame (khi không tìm thấy hàng nào phù hợp), data frame sẽ bao gồm các hàng đó và trở nên dài hơn. Các giá trị missing NA được sử dụng để điền-vào bất kỳ khoảng trống nào đã tạo. Khi bạn nối, hãy kiểm tra số cột và số hàng cẩn thận để khắc phục lỗi về phân biệt chữ hoa với chữ thường và đảm bảo các kết quả khớp ký tự chính xác.Data frame “cơ sở” là data frame được viết đầu tiên trong lệnh. Việc điều chỉnh data frame này sẽ không ảnh hưởng đến những bản ghi nào được trả về bởi phép nối, nhưng nó có thể ảnh hưởng đến thứ tự cột kết quả, thứ tự hàng và cột định danh nào được giữ lại.Ví dụ động về một phép nối hoàn toàn (nguồn ảnh)Ví dụDưới đây kết quả đầu ra của phép nối hoàn toàn full_join() của hosp_info (ban đầu là nrow(hosp_info), xem tại đây) vào linelist_mini (ban đầu là nrow(linelist_mini), xem tại đây). Lưu ý những điều dưới đây:Tất cả các hàng cơ sở đều được giữ nguyên (linelist_mini)Các hàng trong data frame thứ cấp không khớp với data frame cơ sở được giữ lại (“ignace” và “sisters”), với các giá trị trong các cột cơ sở tương ứng case_id và onset điền-vào các giá trị missingTương tự, các hàng trong data frame cơ sở không khớp với hàng trong data frame thứ cấp (“” và “Missing”) được giữ lại, với các cột phụ catchment_pop và level điền-vào các giá trị missingTrong trường hợp khớp một-với-một hoặc nhiều-với-một (ví dụ: các hàng của “Military Hospital”), tất cả các kết hợp có thể có được trả về (kéo dài thêm data frame cuối cùng)Chỉ cột định danh từ data frame cơ sở được giữ lại (hospital)","code":"\nlinelist_mini %>% \n  full_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))"},{"path":"joining-matching.html","id":"nối-bên-trong","chapter":"14 Nối dữ liệu","heading":"Nối bên trong","text":"Nối bên trong là phép nối hạn chế nhất trong tất cả các phép nối - nó chỉ trả về các hàng có kết quả khớp trên cả hai data frame.\nĐiều này có nghĩa là số hàng trong data frame cơ sở có thể thực sự giảm xuống. Việc điều chỉnh data frame nào là “cơ sở” (được viết đầu tiên trong hàm) sẽ không ảnh hưởng đến hàng nào được trả về, nhưng nó sẽ ảnh hưởng đến thứ tự cột, thứ tự hàng và cột định danh nào được giữ lại.Ví dụ động về một phép nối bên trong (nguồn ảnh)Ví dụDưới đây kết quả đầu ra việc nối inner_join() của linelist_mini (cơ sở) với hosp_info (thứ cấp). Lưu ý những điều dưới đây:Các hàng cơ sở không khớp với dữ liệu thứ cấp sẽ bị xóa (các hàng mà hospital nhận giá trị “Missing” hoặc “”)Tương tự, các hàng từ data frame thứ cấp không khớp trong data frame cơ sở sẽ bị xóa (các hàng mà hosp_name nhận giá trị “sisters” hoặc “ignace”)Chỉ cột định danh từ data frame cơ sở được giữ lại (hospital)","code":"\nlinelist_mini %>% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))"},{"path":"joining-matching.html","id":"nối-một-phần","chapter":"14 Nối dữ liệu","heading":"Nối một phần","text":"Nối một phần là một “phép nối chọn lọc” mà sử dụng bộ dữ liệu khác không nhằm để thêm hàng hay cột, mà để lọc dữ liệu.Phép nối-một phần giữ lại tất cả các quan sát trong data frame cơ sở mà có sự trùng khớp với data frame thứ cấp (nhưng không thêm cột mới cũng như không sao chép bất kỳ hàng nào cho các dữ liệu khớp). Đọc thêm về những phép nối “chọn lọc” này tại đây.Ví dụ động về phép nối một phần (nguồn ảnh)Như một ví dụ, code dưới đây trả về các hàng từ data frame hosp_info mà khớp với linelist_mini theo tên bệnh viện.","code":"\nhosp_info %>% \n  semi_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))##                              hosp_name catchment_pop     level\n## 1                    Military Hospital         40500 Secondary\n## 2                    Military Hospital         10000   Primary\n## 3                        Port Hospital         50280 Secondary\n## 4 St. Mark's Maternity Hospital (SMMH)         12000 Secondary"},{"path":"joining-matching.html","id":"anti-join","chapter":"14 Nối dữ liệu","heading":"Anti join","text":"Anti join là một “phép nối chọn lọc” khác trả về các hàng trong data frame cơ sở không khớp với data frame thứ cấp.Đọc thêm về những phép nối “chọn lọc” này tại đây.Các tình huống phổ biến của anti join bao gồm xác định các bản ghi không tồn tại trong một data frame khác, khắc phục lỗi chính tả trong một phép nối (xem xét các bản ghi đáng lẽ sẽ khớp) và kiểm tra các bản ghi đã bị loại trừ sau một phép nối khác.Như với right_join() và left_join(), quan trọng là data frame cơ sở (được liệt kê đầu tiên). Các hàng được trả về chỉ từ data frame cơ sở. Lưu ý trong ảnh động bên dưới, hàng trong data frame thứ cấp (hàng 4 màu tím) không được trả về mặc dù nó không khớp với hàng cơ sở.Ví dụ động về anti join (nguồn ảnh)","code":""},{"path":"joining-matching.html","id":"ví-dụ-anti_join-đơn-giản","chapter":"14 Nối dữ liệu","heading":"Ví dụ anti_join() đơn giản","text":"Một ví dụ đơn giản, hãy tìm bệnh viện trong hosp_info mà không tồn tại trong linelist_mini. chúng ta liệt kê hosp_info trước, như một data frame cơ sở. Các bệnh viện không có trong linelist_mini sẽ được trả về.","code":"\nhosp_info %>% \n  anti_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))"},{"path":"joining-matching.html","id":"ví-dụ-anti_join-phức-tạp","chapter":"14 Nối dữ liệu","heading":"Ví dụ anti_join() phức tạp","text":"Một ví dụ khác, giả sử chúng ta đã chạy một inner_join() giữa linelist_mini và hosp_info. Lệnh này chỉ trả về một tập con các bản ghi của linelist_mini gốc, vì một số bản ghi không có trong hosp_info.Để xem lại các bản ghi linelist_mini đã bị loại trừ trong phép nối bên trong, chúng ta có thể chạy một phép nối anti-join với cùng thiết lập (linelist_mini là data frame cơ sở).Để xem các bản ghi hosp_info đã bị loại trừ trong phép nối bên trong, chúng ta cũng có thể chạy một phép nối anti-join với hosp_info là data frame cơ sở.","code":"\nlinelist_mini %>% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\nlinelist_mini %>% \n  anti_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))"},{"path":"joining-matching.html","id":"khớp-theo-xác-suất","chapter":"14 Nối dữ liệu","heading":"14.3 Khớp theo xác suất","text":"Nếu bạn không có thông tin định danh duy nhất chung trên các bộ dữ liệu để nối, hãy xem xét sử dụng thuật toán khớp theo xác suất. Phương pháp này sẽ tìm thấy các bản ghi khớp với nhau dựa trên sự tương đồng (ví dụ: khoảng cách chuỗi Jaro-Winkler hoặc khoảng cách số). Dưới đây là một ví dụ đơn giản sử dụng package fastLink.Gọi packageDưới đây là hai bộ dữ liệu mẫu nhỏ mà chúng ta sẽ sử dụng để giải thích phương pháp khớp theo xác suất (cases và test_results):Đây là code được sử dụng để tạo bộ dữ liệu:Bộ dữ liệu cases có 9 bản ghi của những bệnh nhân đang chờ kết quả xét nghiệm.Bộ dữ liệu test_results có 14 bản ghi và chứa cột result, cột mà chúng ta muốn thêm vào các bản ghi trong cases dựa trên các bản ghi khớp theo xác xuất.","code":"\npacman::p_load(\n  tidyverse,      # data manipulation and visualization\n  fastLink        # record matching\n  )\n# make datasets\n\ncases <- tribble(\n  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,\n  \"M\",     \"Amir\",      NA,          \"Khan\",       1989,  11,   22,   \"River\",\n  \"M\",     \"Anthony\",   \"B.\",        \"Smith\",      1970, 09, 19,      \"River\", \n  \"F\",     \"Marialisa\", \"Contreras\", \"Rodrigues\",  1972, 04, 15,      \"River\",\n  \"F\",     \"Elizabeth\", \"Casteel\",   \"Chase\",      1954, 03, 03,      \"City\",\n  \"M\",     \"Jose\",      \"Sanchez\",   \"Lopez\",      1996, 01, 06,      \"City\",\n  \"F\",     \"Cassidy\",   \"Jones\",      \"Davis\",     1980, 07, 20,      \"City\",\n  \"M\",     \"Michael\",   \"Murphy\",     \"O'Calaghan\",1969, 04, 12,      \"Rural\", \n  \"M\",     \"Oliver\",    \"Laurent\",    \"De Bordow\" , 1971, 02, 04,     \"River\",\n  \"F\",      \"Blessing\",  NA,          \"Adebayo\",   1955,  02, 14,     \"Rural\"\n)\n\nresults <- tribble(\n  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,\n  \"M\",      \"Amir\",     NA,          \"Khan\",         1989, 11,   22,  \"River\", \"positive\",\n  \"M\",      \"Tony\",   \"B\",         \"Smith\",          1970, 09,   19,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Contreras\", \"Rodriguez\",    1972, 04,   15,  \"Cty\",   \"negative\",\n  \"F\",      \"Betty\",    \"Castel\",   \"Chase\",        1954,  03,   30,  \"City\",  \"positive\",\n  \"F\",      \"Andrea\",   NA,          \"Kumaraswamy\",  2001, 01,   05,  \"Rural\", \"positive\",      \n  \"F\",      \"Caroline\", NA,          \"Wang\",         1988, 12,   11,  \"Rural\", \"negative\",\n  \"F\",      \"Trang\",    NA,          \"Nguyen\",       1981, 06,   10,  \"Rural\", \"positive\",\n  \"M\",      \"Olivier\" , \"Laurent\",   \"De Bordeaux\",  NA,   NA,   NA,  \"River\", \"positive\",\n  \"M\",      \"Mike\",     \"Murphy\",    \"O'Callaghan\",  1969, 04,   12,  \"Rural\", \"negative\",\n  \"F\",      \"Cassidy\",  \"Jones\",     \"Davis\",        1980, 07,   02,  \"City\",  \"positive\",\n  \"M\",      \"Mohammad\", NA,          \"Ali\",          1942, 01,   17,  \"City\",  \"negative\",\n  NA,       \"Jose\",     \"Sanchez\",   \"Lopez\",        1995, 01,   06,  \"City\",  \"negative\",\n  \"M\",      \"Abubakar\", NA,          \"Abullahi\",     1960, 01,   01,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Salinas\",   \"Contreras\",    1955, 03,   03,  \"River\", \"positive\"\n  )"},{"path":"joining-matching.html","id":"khớp-theo-xác-suất-1","chapter":"14 Nối dữ liệu","heading":"Khớp theo xác suất","text":"Hàm fastLink() từ package fastLink có thể được sử dụng để áp dụng một thuật toán khớp. Đây là thông tin cơ bản. Bạn có thể đọc chi tiết thêm bằng cách nhập ?fastLink trong console của mình.Xác định hai data frame để sánh với các đối số dfA = và dfB =Trong varnames = cung cấp tất cả các tên cột được sử dụng để khớp. Tất cả tên cột phải tồn tại trong cả hai dfA và dfB.Trong stringdist.match = cung cấp các cột từ những cột trong varnames được đánh giá trên chuỗi “distance”.Trong numeric.match = cung cấp các cột từ những cột trong varnames được đánh giá trên khoảng.Các giá trị missing sẽ bị bỏ quaTheo mặc định, mỗi hàng từ một trong hai data frame sẽ được khớp với nhiều nhất một hàng trong data frame còn lại. Nếu bạn muốn xem tất cả các kết quả khớp được đánh giá, hãy đặt dedupe.matches = FALSE. Việc loại bỏ trùng lặp được thực hiện bằng giải pháp gán tuyến tính của Winkler.Mẹo: tách một cột ngày thành ba cột số riêng biệt bằng cách sử dụng day(), month() và year() từ package lubridateNgưỡng mặc định cho các kết quả khớp là 0,94 (threshold.match =) nhưng bạn có thể điều chỉnh nó cao hơn hoặc thấp hơn. Nếu bạn xác định ngưỡng, hãy cân nhắc việc ngưỡng cao hơn có thể mang lại nhiều âm tính giả hơn (các hàng không khớp sẽ thực sự khớp) và tương tự như vậy, ngưỡng thấp hơn có thể mang lại nhiều kết quả dương tính giả hơn.Dưới đây, dữ liệu được đối sánh trên khoảng cách chuỗi trên các cột tên (name) và quận (district), cũng như khoảng cách số cho ngày (day), tháng month), năm sinh (year). Ngưỡng đối sánh với xác suất là 95% được thiết lập.Xem lại các kết quả khớpchúng ta đã định nghĩa đối tượng được trả về từ fastLink() là fl_output. Nó thuộc nhóm list, và nó thực sự chứa một số data frame bên trong nó, mô tả chi tiết kết quả của việc khớp. Một trong những data frame này là matches, chứa các kết quả khớp có nhiều khả năng nhất giữa cases và results. Bạn có thể truy cập data frame “khớp” này với fl_output$matches. Dưới đây, nó được lưu dưới dạng my_matches để tiện cho việc truy cập sau này.Khi my_matches được , bạn sẽ thấy hai vectơ cột: các cặp số/chỉ số hàng (còn được gọi là “tên hàng (rownames)”) trong cases (“inds.”) và trong results (“inds.b”) đại diện cho các kết quả khớp phù hợp nhất. Nếu số hàng từ data frame bị thiếu, có nghĩa là không tìm thấy kết quả khớp nào trong data frame khác ở ngưỡng đối sánh đã chỉ định.Những điều cần lưu ý:Các kết quả trùng khớp đã xảy ra mặc dù có sự khác biệt nhỏ về cách viết tên cũng như ngày sinh:\n“Tony B. Smith” khớp với “Anthony B Smith”\n“Maria Rodriguez” khớp với “Marialisa Rodrigues”\n“Betty Chase” khớp với “Elizabeth Chase”\n“Olivier Laurent De Bordeaux” khớp với “Oliver Laurent De Bordow” (ngày sinh missing bị bỏ qua)\nCác kết quả trùng khớp đã xảy ra mặc dù có sự khác biệt nhỏ về cách viết tên cũng như ngày sinh:“Tony B. Smith” khớp với “Anthony B Smith”“Maria Rodriguez” khớp với “Marialisa Rodrigues”“Betty Chase” khớp với “Elizabeth Chase”“Olivier Laurent De Bordeaux” khớp với “Oliver Laurent De Bordow” (ngày sinh missing bị bỏ qua)Một hàng trong cases (đối với “Blessing Adebayo”, hàng 9) không có kết quả khớp tốt trong results, vì vậy nó không tồn tại my_matches.Một hàng trong cases (đối với “Blessing Adebayo”, hàng 9) không có kết quả khớp tốt trong results, vì vậy nó không tồn tại my_matches.Nối dựa trên việc khớp theo xác suấtĐể sử dụng các kết quả khớp này nhằm nối results vào cases, chiến lược là:Sử dụng left_join() để nối my_matches vào cases (khớp tên hàng (rowname) trong cases với “inds.” trong my_matches)Sau đó sử dụng left_join() khác để nối results vào cases (khớp với “inds.b” mới có được trong cases với rowname trong results)Trước khi nối, chúng ta nên làm sạch ba data frame:Cả dfA và dfB nên có số hàng của chúng (“rowname”) được chuyển đổi thành một cột thích hợp.Cả hai cột trong my_matches đều được chuyển đổi thành nhóm ký tự, vì vậy chúng có thể được nối với ký tự rownamesNhư được trình bày bằng cách sử dụng code trên, data frame kết quả complete sẽ chứa tất cả các cột từ cả cases và results. Nhiều cột sẽ được thêm vào bằng các hậu tố “.x” và “.y”, vì nếu không, tên cột sẽ bị trùng lặp.Ngoài ra, để chỉ lấy 9 bản ghi “gốc” trong cases với (các) cột mới từ results, hãy sử dụng select() trên results trước khi nối, để nó chỉ chứa rownames và cột mà bạn muốn thêm vào cases (ví dụ: cột result).Nếu bạn chỉ muốn lấy một trong hai bộ dữ liệu cho các hàng khớp, bạn có thể sử dụng code bên dưới:Hoặc, để chỉ xem các hàng không khớp::","code":"\nfl_output <- fastLink::fastLink(\n  dfA = cases,\n  dfB = results,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\"),\n  stringdist.match = c(\"first\", \"middle\", \"last\", \"district\"),\n  numeric.match = c(\"yr\", \"mon\", \"day\"),\n  threshold.match = 0.95)## \n## ==================== \n## fastLink(): Fast Probabilistic Record Linkage\n## ==================== \n## \n## If you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\n## Calculating matches for each variable.\n## Getting counts for parameter estimation.\n##     Parallelizing calculation using OpenMP. 1 threads out of 4 are used.\n## Running the EM algorithm.\n## Getting the indices of estimated matches.\n##     Parallelizing calculation using OpenMP. 1 threads out of 4 are used.\n## Deduping the estimated matches.\n## Getting the match patterns for each estimated match.\n# print matches\nmy_matches <- fl_output$matches\nmy_matches##   inds.a inds.b\n## 1      1      1\n## 2      2      2\n## 3      3      3\n## 4      4      4\n## 5      8      8\n## 6      7      9\n## 7      6     10\n## 8      5     12\n# Clean data prior to joining\n#############################\n\n# convert cases rownames to a column \ncases_clean <- cases %>% rownames_to_column()\n\n# convert test_results rownames to a column\nresults_clean <- results %>% rownames_to_column()  \n\n# convert all columns in matches dataset to character, so they can be joined to the rownames\nmatches_clean <- my_matches %>%\n  mutate(across(everything(), as.character))\n\n\n\n# Join matches to dfA, then add dfB\n###################################\n# column \"inds.b\" is added to dfA\ncomplete <- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\n\n# column(s) from dfB are added \ncomplete <- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\ncases_clean <- cases %>% rownames_to_column()\n\nresults_clean <- results %>%\n  rownames_to_column() %>% \n  select(rowname, result)    # select only certain columns \n\nmatches_clean <- my_matches %>%\n  mutate(across(everything(), as.character))\n\n# joins\ncomplete <- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\ncomplete <- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\ncases_matched <- cases[my_matches$inds.a,]  # Rows in cases that matched to a row in results\nresults_matched <- results[my_matches$inds.b,]  # Rows in results that matched to a row in cases\ncases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a,]  # Rows in cases that did NOT match to a row in results\nresults_not_matched <- results[!rownames(results) %in% my_matches$inds.b,]  # Rows in results that did NOT match to a row in cases"},{"path":"joining-matching.html","id":"loại-bỏ-trùng-lặp-theo-xác-suất","chapter":"14 Nối dữ liệu","heading":"Loại bỏ trùng lặp theo xác suất","text":"Khớp theo xác suất cũng có thể được sử dụng để loại bỏ trùng lặp trong một bộ dữ liệu. Xem chương về Loại bỏ trùng lặp để biết các phương pháp loại bỏ trùng lặp khác.Ở đây chúng ta đã bắt đầu với bộ dữ liệu cases, nhưng bây giờ đang được gọi là cases_dup, vì nó có 2 hàng bổ sung mà có thể là bản trùng lặp của các hàng trước đó: Xem “Tony” với “Anthony”, và “Marialisa Rodrigues” với “Maria Rodriguez”.Chạy fastLink() giống nhu trước, nhưng sánh data frame cases_dup với chính nó. Khai hai data frames được cung cấp giống hệt nhau, hàm sẽ giả định rằng bạn muốn loại bỏ trùng lặp. Lưu ý rằng chúng ta không chỉ định stringdist.match = hoặc numeric.match = như chúng ta đã làm trước đây.Bây giờ, bạn có thể xem xét các bản trùng lặp có thể xảy ra với getMatches(). Cung cấp data frame dưới dạng cả dfA = và dfB =, đồng thời cung cấp kết quả đầu ra của hàm fastLink() là fl.=. fl.= phải thuộc nhóm fastLink.dedupe, hay nói cách khác, là kết quả của fastLink().Xem cột ngoài cùng bên phải, cột cho biết ID trùng lặp - hai hàng cuối cùng được xác định có thể là trùng lặp ở hàng 2 và 3.Để trả về số hàng của những hàng có khả năng trùng lặp, bạn có thể đếm số hàng trên mỗi giá trị duy nhất trong cột dedupe.ids, sau đó lọc để chỉ giữ lại những hàng có nhiều hơn một hàng. Trong trường hợp này, nó để lại hàng 2 và 3.Để kiểm tra toàn bộ các hàng có khả năng trùng lặp, hãy đặt số hàng trong lệnh này:","code":"\n## Run fastLink on the same dataset\ndedupe_output <- fastLink(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\")\n)## \n## ==================== \n## fastLink(): Fast Probabilistic Record Linkage\n## ==================== \n## \n## If you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\n## dfA and dfB are identical, assuming deduplication of a single data set.\n## Setting return.all to FALSE.\n## \n## Calculating matches for each variable.\n## Getting counts for parameter estimation.\n##     Parallelizing calculation using OpenMP. 1 threads out of 4 are used.\n## Running the EM algorithm.\n## Getting the indices of estimated matches.\n##     Parallelizing calculation using OpenMP. 1 threads out of 4 are used.\n## Calculating the posterior for each pair of matched observations.\n## Getting the match patterns for each estimated match.\n## Run getMatches()\ncases_dedupe <- getMatches(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  fl.out = dedupe_output)\ncases_dedupe %>% \n  count(dedupe.ids) %>% \n  filter(n > 1)##   dedupe.ids n\n## 1          2 2\n## 2          3 2\n# displays row 2 and all likely duplicates of it\ncases_dedupe[cases_dedupe$dedupe.ids == 2,]   ##    gender   first middle  last   yr mon day district dedupe.ids\n## 2       M Anthony     B. Smith 1970   9  19    River          2\n## 10      M    Tony     B. Smith 1970   9  19    River          2"},{"path":"joining-matching.html","id":"gắn-vào-và-căn-chỉnh","chapter":"14 Nối dữ liệu","heading":"14.4 Gắn vào và căn chỉnh","text":"Một phương pháp khác để kết hợp hai data frame là “ràng buộc” chúng với nhau. Bạn cũng có thể coi đây là hàng hoặc cột được “gắn vào” hoặc “thêm”.Phần này cũng sẽ thảo luận về cách “căn chỉnh” thứ tự các hàng của một data frame với thứ tự các hàng trong data frame khác. Chủ đề này được thảo luận dưới đây trong phần về Gắn các cột.","code":""},{"path":"joining-matching.html","id":"gắn-các-hàng","chapter":"14 Nối dữ liệu","heading":"Gắn các hàng","text":"Để gắn các hàng của một data frame này với phần cuối của một data frame khác, hãy sử dụng bind_rows() từ dplyr. Hàm này có tính dung nạp, vì vậy bất kỳ cột nào có trong một trong hai data frame sẽ được đưa vào kết quả đầu ra. Một số lưu ý:Không giống như row.bind() của phiên bản base R, bind_rows() của dplyr không yêu cầu thứ tự của các cột phải giống nhau trong cả hai data frame. Miễn là các tên cột được viết giống nhau, nó sẽ căn chỉnh chúng một cách chính xác.Bạn có thể tùy chọn xác định đối số .id =. Cung cấp một tên cột ký tự. Điều này sẽ tạo ra một cột mới dùng để xác định mỗi hàng ban đầu đến từ data frame nào.Bạn có thể sử dụngbind_rows() trên một list các data frame có cấu trúc tương tự để kết hợp chúng thành một. Xem ví dụ trong chương [Lặp, vòng lặp và danh sách] về việc nhập nhiều linelist với purrr.Một ví dụ phổ biến về row binding là gắn một hàng “tổng (total)” vào một bảng mô tả được tạo bằng hàm summarise() của dplyr. Dưới đây, chúng ta tạo một bảng đếm số trường hợp và giá trị CT trung bình theo bệnh viện với một hàng tổng.Hàm summarise() được sử dụng trên dữ liệu đã nhóm theo bệnh viện để trả về một data frame tóm tắt theo bệnh viện. Nhưng hàm summarise() không tự động tạo ra hàng “tổng”, vì vậy chúng ta tạo ra nó bằng cách tổng hợp lại dữ liệu, nhưng với dữ liệu không bị nhóm theo bệnh viện. Điều này tạo ra một data frame thứ hai chỉ gồm một hàng. Sau đó, chúng ta có thể liên kết các data frame này với nhau để có được bảng cuối cùng.Xem các ví dụ hoạt động khác tương tự như thế này trong chương Bảng mô tả và Trình bày bảng.Đây là data frame hosp_summary:Tạo một data frame với thống kê “tổng” (không bị nhóm theo bệnh viện). Điều này sẽ trả về chỉ một hàng.Và dưới đây là data frame totals. Lưu ý cách mà chỉ tạo ra hai cột. Những cột này cũng nằm trong hosp_summary, nhưng có một cột trong hosp_summary mà không nằm trong totals (hospital).Bây giờ chúng ta có thể gắn các hàng với nhau bằng bind_rows().Bây giờ chúng ta có thể xem kết quả. Xem cách mà trong hàng cuối cùng, giá trị NA trống được điền vào cột trong hospital mà không có trong hosp_summary. Như đã giải thích trong chương Trình bày bảng, bạn có thể “điền” vào ô này với “Tổng” bằng cách sử dụng replace_na().","code":"\n# Create core table\n###################\nhosp_summary <- linelist %>% \n  group_by(hospital) %>%                        # Group data by hospital\n  summarise(                                    # Create new summary columns of indicators of interest\n    cases = n(),                                  # Number of rows per hospital-outcome group     \n    ct_value_med = median(ct_blood, na.rm=T))     # median CT value per group\n# create totals\n###############\ntotals <- linelist %>% \n  summarise(\n    cases = n(),                               # Number of rows for whole dataset     \n    ct_value_med = median(ct_blood, na.rm=T))  # Median CT for whole dataset\n# Bind data frames together\ncombined <- bind_rows(hosp_summary, totals)"},{"path":"joining-matching.html","id":"gắn-các-cột","chapter":"14 Nối dữ liệu","heading":"Gắn các cột","text":"Có một hàm dplyr tuơng tự là bind_cols(), hàm mà bạn có thể sử dụng để kết hợp hai data frame theo chiều ngang. Lưu ý rằng các hàng được khớp với nhau theo vị trí (khác với phép nối ở trên) - ví dụ: hàng thứ 12 trong mỗi data frame sẽ được căn chỉnh.Ví dụ, chúng ta liên kết một số bảng tóm tắt với nhau. Để làm điều này, chúng ta cũng trình bày cách sắp xếp lại thứ tự của các hàng trong một data frame để khớp với thứ tự hàng trong một data frame khác, với match().Ở đây chúng ta định nghĩa case_info là một data frame tóm tắt về các trường hợp trong linelist theo bệnh viện, với số trường hợp và số ca tử vong.Và giả sử rằng đây là một data frame contact_fu khác chứa thông tin về phần trăm số liên hệ bị phơi nhiễm được điều tra và “theo dõi”, lại một lần nữa bởi bệnh viện.Lưu ý rằng các bệnh viện đều như nhau, nhưng theo thứ tự khác nhau trong mỗi data frame. Giải pháp đơn giản nhất là sử dụng left_join() trên cột hospital, nhưng bạn cũng có thể sử dụng bind_cols() với một bước bổ sung.","code":"\n# Case information\ncase_info <- linelist %>% \n  group_by(hospital) %>% \n  summarise(\n    cases = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T)\n  )\ncontact_fu <- data.frame(\n  hospital = c(\"St. Mark's Maternity Hospital (SMMH)\", \"Military Hospital\", \"Missing\", \"Central Hospital\", \"Port Hospital\", \"Other\"),\n  investigated = c(\"80%\", \"82%\", NA, \"78%\", \"64%\", \"55%\"),\n  per_fu = c(\"60%\", \"25%\", NA, \"20%\", \"75%\", \"80%\")\n)"},{"path":"joining-matching.html","id":"sử-dụng-match-để-sắp-xếp-thứ-tự","chapter":"14 Nối dữ liệu","heading":"Sử dụng match() để sắp xếp thứ tự","text":"thứ tự hàng khác nhau, một lệnh bind_cols() đơn giản sẽ dẫn đến khớp sai dữ liệu. Để khắc phục điều này, chúng ta có thể sử dụng hàm match() trong base R để căn chỉnh các hàng của data frame theo thứ tự giống với thứ tự trong data frame khác. Chúng ta giả định đối với phương pháp này rằng không có giá trị trùng lặp nào trong cả hai data frame.Khi chúng ta sử dụng match(), với cú pháp là match(TARGET ORDER VECTOR, DATA FRAME COLUMN CHANGE), trong đó đối số đầu tiên là thứ tự mong muốn (hoặc là một vectơ độc lập, hoặc trong trường hợp này là một cột trong data frame), và đối số thứ hai là cột data frame trong data frame mà sẽ được sắp xếp lại. Kết quả đầu ra của match() sẽ là một vectơ số đại diện cho thứ tự vị trí chính xác. Bạn có thể đọc thêm với ?match.Bạn có thể sử dụng vectơ số này để sắp xếp lại thứ tự data frame - đặt nó trong tập con của dấu ngoặc [ ] trước dấu phẩy. Đọc thêm về cú pháp tập con của dấu ngoặc base R trong chương R cơ bản. Lệnh bên dưới tạo ra một data frame mới, được định nghĩa là data frame cũ mà trong đó các hàng được sắp xếp theo thứ tự trong vectơ số ở trên.Bây giờ chúng ta có thể gắn các cột data frame với nhau, với thứ tự hàng chính xác. Lưu ý rằng một số cột bị trùng lặp và sẽ yêu cầu làm sạch bằng rename(). Đọc thêm về bind_rows() tại đây.Một hàm trong base R thay thế cho bind_cols là cbind(), hàm này hoạt động tương tự với bind_cols.","code":"\nmatch(case_info$hospital, contact_fu$hospital)## [1] 4 2 3 6 5 1\ncontact_fu_aligned <- contact_fu[match(case_info$hospital, contact_fu$hospital),]\nbind_cols(case_info, contact_fu)## New names:\n## * hospital -> hospital...1\n## * hospital -> hospital...4## # A tibble: 6 x 6\n##   hospital...1                         cases deaths hospital...4                         investigated per_fu\n##   <chr>                                <int>  <int> <chr>                                <chr>        <chr> \n## 1 Central Hospital                       454    193 St. Mark's Maternity Hospital (SMMH) 80%          60%   \n## 2 Military Hospital                      896    399 Military Hospital                    82%          25%   \n## 3 Missing                               1469    611 Missing                              <NA>         <NA>  \n## 4 Other                                  885    395 Central Hospital                     78%          20%   \n## 5 Port Hospital                         1762    785 Port Hospital                        64%          75%   \n## 6 St. Mark's Maternity Hospital (SMMH)   422    199 Other                                55%          80%"},{"path":"joining-matching.html","id":"tài-nguyên-học-liệu-2","chapter":"14 Nối dữ liệu","heading":"14.5 Tài nguyên học liệu","text":"tidyverse page joinsR Data Science page relational datatidyverse page dplyr về ràng buộc dữ liệuĐặc trưng của fastLink tại trang Github packageXuất bản mô tả phương pháp luận của fastLinkXuất bản mô tả package RecordLinkage","code":""},{"path":"deduplication.html","id":"deduplication","chapter":"15 Loại bỏ trùng lặp","heading":"15 Loại bỏ trùng lặp","text":"Chương này đề cập đến các kỹ thuật loại bỏ trùng lặp sau:Xác định và loại bỏ các hàng trùng lặp“Cắt” một số hàng để chỉ giữ lại những hàng nhất định (ví dụ: tối thiểu hoặc tối đa) từ mỗi nhóm hàng“Rolling-” hoặc kết hợp các giá trị từ nhiều hàng thành một hàng","code":""},{"path":"deduplication.html","id":"chuẩn-bị-6","chapter":"15 Loại bỏ trùng lặp","heading":"15.1 Chuẩn bị","text":"","code":""},{"path":"deduplication.html","id":"gọi-package-4","chapter":"15 Loại bỏ trùng lặp","heading":"Gọi package","text":"Đoạn code này hiển thị những package cần tải cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ pacman, hàm sẽ cài đặt package nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với library() từ base R. Xem chương R cơ bản để có thêm thông tin về các R package.","code":"\npacman::p_load(\n  tidyverse,   # deduplication, grouping, and slicing functions\n  janitor,     # function for reviewing duplicates\n  stringr)      # for string searches, can be used in \"rolling-up\" values"},{"path":"deduplication.html","id":"nhập-dữ-liệu-8","chapter":"15 Loại bỏ trùng lặp","heading":"Nhập dữ liệu","text":"Để minh họa, chúng tôi sẽ sử dụng một bộ dữ liệu mẫu được tạo bằng code R bên dưới.Dữ liệu là các bản ghi về những cuộc gọi truy vết COVID-19, bao gồm những cuộc gọi truy vết với các liên hệ và với các trường hợp. Các cột bao gồm recordID (mã bản ghi) (máy tính tạo), personID (mã người truy vết), name (tên), date (ngày) truy vết, time (thời gian) truy vết, purpose (mục đích) truy vết (phỏng vấn một trường hợp hoặc một liên hệ) và symptoms_ever (liệu người được truy vết đã từng được báo cáo có triệu chứng hay không).Đây là code để tạo bộ dữ liệu obs:","code":"\nobs <- data.frame(\n  recordID  = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),\n  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),\n  name      = c(\"adam\", \"adam\", \"amrish\", \"amrish\", \"mariah\", \"amrish\", \"nikhil\", \"brian\", \"smita\", \"raquel\", \"amrish\",\n                \"adam\", \"mariah\", \"mariah\", \"nikhil\", \"brian\", \"brian\", \"raquel\", \"natalie\"),\n  date      = c(\"1/1/2020\", \"1/1/2020\", \"2/1/2020\", \"2/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\",\"5/1/2020\", \"2/1/2020\",\n                \"5/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"7/1/2020\", \"7/1/2020\", \"7/1/2020\"),\n  time      = c(\"09:00\", \"09:00\", \"14:20\", \"14:20\", \"12:00\", \"16:10\", \"13:01\", \"15:20\", \"14:20\", \"12:30\", \"10:24\",\n                \"09:40\", \"07:25\", \"08:32\", \"15:36\", \"15:31\", \"07:59\", \"11:13\", \"17:12\"),\n  encounter = c(1,1,1,1,1,3,1,1,1,1,2,\n                2,2,3,2,2,3,2,1),\n  purpose   = c(\"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"contact\",\n                \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"contact\", \"case\"),\n  symptoms_ever = c(NA, NA, \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\", \"Yes\", NA, \"Yes\",\n                    \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\",\"No\", \"No\")) %>% \n  mutate(date = as.Date(date, format = \"%d/%m/%Y\"))"},{"path":"deduplication.html","id":"dedup_data","chapter":"15 Loại bỏ trùng lặp","heading":"Đây là data frame","text":"Sử dụng bộ lọc của các box ở trên cùng để xem lại các cuộc gọi truy vết theo từng người.Một số điều cần lưu ý khi bạn xem xét dữ liệu:Hai bản ghi đầu tiên hoàn toàn 100% là trùng lặp, bao gồm cả recordID (hẳn là một lỗi máy tính!)Hai hàng thứ hai trùng lặp trong tất cả các cột ngoại trừ recordIDMột vài cá nhân có nhiều cuộc gọi truy vết, vào những ngày, giờ khác nhau, được tính là những liên hệ và/hoặc những trường hợpỞ mỗi cuộc gọi truy vết, người được truy vết được hỏi đã từng mắc các triệu chứng chưa và một số thông tin này bị missing.Và đây là bản tóm tắt nhanh về những người truy vết và mục đích các cuộc gọi truy vết của họ, sử dụng hàm tabyl() từ janitor:","code":"\nobs %>% \n  tabyl(name, purpose)##     name case contact\n##     adam    1       2\n##   amrish    1       3\n##    brian    1       2\n##   mariah    1       2\n##  natalie    1       0\n##   nikhil    0       2\n##   raquel    0       2\n##    smita    0       1"},{"path":"deduplication.html","id":"loại-bỏ-trùng-lặp-1","chapter":"15 Loại bỏ trùng lặp","heading":"15.2 Loại bỏ trùng lặp","text":"Phần này mô tả cách xem xét và loại bỏ các hàng trùng lặp trong data frame. Đồng thời cũng chỉ ra cách xử lý các phần tử trùng lặp trong một vectơ.","code":""},{"path":"deduplication.html","id":"kiểm-tra-hàng-trùng-lặp","chapter":"15 Loại bỏ trùng lặp","heading":"Kiểm tra hàng trùng lặp","text":"Để nhanh chóng xem lại các hàng có trùng lặp, bạn có thể sử dụng get_dupes() từ package janitor. Theo mặc định, tất cả các cột được xem xét khi đánh giá trùng lặp - các hàng được hàm trả về là trùng lặp 100% nếu xét đến các giá trị trong tất cả các cột.Trong data frame obs, hai hàng đầu tiên trùng lặp 100% - chúng có cùng giá trị trong tất cả các cột (bao gồm cả cột recordID, vốn được cho là duy nhất - hẳn là một số trục trặc máy tính). Data frame được trả về tự động bao gồm một cột mới dupe_count ở phía bên phải, hiển thị số hàng có sự kết hợp của các giá trị trùng lặp đó.Xem dữ liệu gốcTuy nhiên, nếu chúng ta chọn bỏ qua recordID, thì hàng thứ 3 và thứ 4 cũng là bản trùng lặp của nhau. Nghĩa là chúng có cùng giá trị trong tất cả các cột ngoại trừ recordID. Bạn có thể xác định các cột cụ thể bị bỏ qua trong hàm bằng ký hiệu - (dấu trừ).Bạn cũng có thể xác định rõ các cột cần xem xét. Dưới đây, chỉ các hàng có cùng giá trị trong cột name và purpose được trả về. Lưu ý rằng “amrish” hiện có dupe_count bằng 3 cho thấy ba cuộc gọi truy vết “liên hệ” của anh ta.Cuộn sang trái để xem thêm hàngXem dữ liệu gốc.Xem ?get_dupes để biết thêm chi tiết hoặc xem tài liệu tham khảo trực tuyến này","code":"\n# 100% duplicates across all columns\nobs %>% \n  janitor::get_dupes()\n# Duplicates when column recordID is not considered\nobs %>% \n  janitor::get_dupes(-recordID)         # if multiple columns, wrap them in c()\n# duplicates based on name and purpose columns ONLY\nobs %>% \n  janitor::get_dupes(name, purpose)"},{"path":"deduplication.html","id":"chỉ-giữ-lại-các-hàng-duy-nhất","chapter":"15 Loại bỏ trùng lặp","heading":"Chỉ giữ lại các hàng duy nhất","text":"Để chỉ giữ lại các hàng duy nhất của một data frame, hãy sử dụng distinct() từ dplyr (đã được giải thích trong chương Làm sạch số liệu và các hàm quan trọng). Các hàng trùng lặp sẽ bị loại bỏ sao cho chỉ giữ lại hàng đầu tiên trong số các hàng đó. Theo mặc định, hàng “đầu tiên” có nghĩa là hàng có rownumber cao nhất (thứ tự của các hàng từ trên-xuống-dưới). Chỉ các hàng duy nhất được giữ lại.Trong ví dụ dưới đây, chúng tôi chạy lệnh distinct() sao cho cột recordID bị loại trừ khỏi việc xem xét - đó hai hàng trùng lặp sẽ bị loại bỏ. Hàng đầu tiên (đối với “adam”) bị trùng lặp 100% và đã bị loại bỏ. Bên cạnh đó, hàng 3 (cho “amrish”) là một bản bị trùng lặp trong tất cả các cột ngoại trừ recordID (đang không được xét) và đó cũng bị loại bỏ. Bộ dữ liệu obs bây giờ có số dòng là nrow(obs)-2, không phải là nrow(obs)).Cuộn sang trái để xem toàn bộ data frameCHÚ Ý: Nếu sử dụng distinct() trên nhóm dữ liệu, hàm sẽ áp dụng cho từng nhóm.Loại bỏ trùng lặp dựa trên cột cụ thểBạn cũng có thể xác định các cột cơ sở để loại bỏ trùng lặp. Theo cách này, loại bỏ trùng lặp chỉ áp dụng cho các hàng trùng lặp trong các cột được chỉ định. Trừ khi bạn đặt .keep_all = TRUE, tất cả các cột không được đề cập sẽ bị loại bỏ.Trong ví dụ dưới đây, loại bỏ trùng lặp chỉ áp dụng cho các hàng có giá trị giống nhau trong các cột name và purpose. đó, “brian” chỉ có 2 hàng thay vì 3 - cuộc gọi truy vết “liên hệ” đầu tiên và cuộc gọi truy vết “trường hợp” duy nhất của anh ta. Để điều chỉnh sao cho cuộc gọi truy vết mới nhất của brian đối với từng mục đích được lưu giữ, hãy xem mục Cắt theo nhóm.Cuộn sang trái để xem toàn bộ data frameXem dữ liệu gốc.","code":"\n# added to a chain of pipes (e.g. data cleaning)\nobs %>% \n  distinct(across(-recordID), # reduces data frame to only unique rows (keeps first one of any duplicates)\n           .keep_all = TRUE) \n\n# if outside pipes, include the data as first argument \n# distinct(obs)\n# added to a chain of pipes (e.g. data cleaning)\nobs %>% \n  distinct(name, purpose, .keep_all = TRUE) %>%  # keep rows unique by name and purpose, retain all columns\n  arrange(name)                                  # arrange for easier viewing"},{"path":"deduplication.html","id":"loại-bỏ-phần-tử-trùng-lặp-trong-một-vectơ","chapter":"15 Loại bỏ trùng lặp","heading":"Loại bỏ phần tử trùng lặp trong một vectơ","text":"Hàm duplicated() từ base R sẽ đánh giá một vectơ (cột) và trả về một vectơ logic có cùng độ dài (TRUE/FALSE). Lần đầu tiên một giá trị xuất hiện, nó sẽ trả về giá trị FALSE (không phải là một bản trùng lặp) và những lần tiếp theo giá trị đó xuất hiện, nó sẽ trả về giá trị TRUE. Lưu ý giá trị NA được xử lý giống như bất kỳ giá trị nào khác.Để chỉ trả về các phần tử bị trùng lặp, bạn có thể sử dụng dấu ngoặc để đặt vectơ gốc:Để chỉ trả về các phần tử duy nhất, hãy sử dụng hàm unique() từ base R. Để loại bỏ các NA khỏi kết quả đầu ra, hãy lồng na.omit() trong unique().","code":"\nx <- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)\nduplicated(x)##  [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\nx[duplicated(x)]## [1]  1 NA  4  4  1  2\nunique(x)           # alternatively, use x[!duplicated(x)]## [1]  1  2 NA  4  5\nunique(na.omit(x))  # remove NAs ## [1] 1 2 4 5"},{"path":"deduplication.html","id":"sử-dụng-base-r-1","chapter":"15 Loại bỏ trùng lặp","heading":"Sử dụng base R","text":"Để trả về các hàng trùng lặpTrong base R, bạn cũng có thể xem những hàng nào là trùng lặp 100% trong data frame df bằng lệnh duplicated(df) (trả về một vectơ logic của các hàng).đó, bạn cũng có thể sử dụng tập con cơ sở [ ] trên data frame để xem các hàng trùng lặp với df[duplicated(df),] (đừng quên dấu phẩy, điều đó có nghĩa là bạn muốn xem tất cả các cột!).Để trả về các hàng duy nhấtXem các ghi chú ở trên. Để xem các hàng duy nhất, bạn thêm dấu phủ định logic ! ở trước hàm duplicated():df[!duplicated(df),]Để trả về các hàng trùng lặp chỉ với một số cột nhất địnhĐặt df nằm trong dấu ngoặc đơn hàm duplicated(), hàm này sẽ chỉ hoạt động trên một số cột nhất định của df.Để xác định các cột, hãy cung cấp số thứ tự hoặc tên cột sau dấu phẩy (nhớ rằng đặt tất cả những thông tin này trong hàm duplicated()).Hãy chắc chắn đặt dấu phẩy , bên ngoài và sau hàm duplicated()!Ví dụ: Để chỉ đánh giá các cột từ 2 đến 5 cho các bản trùng lặp: df[!duplicated(df[, 2:5]),]\nĐể chỉ đánh giá các cột name và purpose cho các bản trùng lặp: df[!duplicated(df[, c(\"name\", \"purpose)]),]","code":""},{"path":"deduplication.html","id":"cắt-dòng","chapter":"15 Loại bỏ trùng lặp","heading":"15.3 Cắt dòng","text":"“Cắt” một data frame nhằm áp dụng bộ lọc trên các hàng theo số/vị trí hàng. Điều này trở nên đặc biệt hữu ích nếu bạn có nhiều hàng cho mỗi nhóm chức năng (ví dụ: mỗi “người”) và bạn chỉ muốn giữ một hoặc một số hàng trong số đó.Hàm slice() cơ bản chấp nhận các số và trả về các hàng ở những vị trí đó. Nếu các số được cung cấp là số dương, chỉ có chúng được trả về. Nếu là số âm, những hàng đó không được trả về. Tất cả các số đều phải là số dương hoặc đều là số âm.Xem dữ liệu gốc.Có một số biến thể: Chúng phải được cung cấp với một cột và một số hàng để trả về (tới n =).slice_min() và slice_max() chỉ giữ (các) hàng có (các) giá trị nhỏ nhất hoặc lớn nhất của cột được chỉ định. Hàm này cũng hoạt động để trả về “tối thiểu” và “tối đa” của các biến factor có thứ tự.slice_head() và slice_tail() - chỉ giữ (các) hàng đầu tiên hoặc cuối cùng.slice_sample() - chỉ giữ một mẫu ngẫu nhiên của các hàng.Sử dụng đối số n = hoặc prop = để xác định số lượng hoặc tỷ lệ hàng cần giữ. Nếu không sử dụng hàm trong chuỗi pipe, trước tiên hãy cung cấp đối số dữ liệu (ví dụ: slice(data, n = 2)). Xem ?slice để biết thêm thông tin.Các đối số khác:.order_by = được sử dụng trong slice_min() và slice_max(), sắp xếp thứ tự theo một cột trước khi cắt.with_ties = TRUE theo mặc định, nghĩa là các ràng buộc bị giữ lại..preserve = FALSE theo mặc định. Nếu TRUE thì cấu trúc nhóm được tính toán lại sau khi cắt.weight_by = Tùy chọn, cột dữ liệu kiểu số được tính theo trọng số (số lớn hơn có nhiều khả năng được lấy mẫu hơn). Đồng thời replace = cho việc lấy mẫu liệu có được thực hiện mà có/không có sự thay thế.MẸO: Khi sử dụng slice_max() và slice_min(), hãy chắc chắn bạn cụ thể/ghi n = (ví dụ: n = 2, không chỉ 2). Nếu không, bạn có thể gặp lỗi Error:…empty.LƯU Ý: Bạn có thể gặp hàm top_n(), hàm mà đã bị thay thế bởi các hàm slice.","code":"\nobs %>% slice(4)  # return the 4th row##   recordID personID   name       date  time encounter purpose symptoms_ever\n## 1        3        2 amrish 2020-01-02 14:20         1 contact            No\nobs %>% slice(c(2,4))  # return rows 2 and 4##   recordID personID   name       date  time encounter purpose symptoms_ever\n## 1        1        1   adam 2020-01-01 09:00         1 contact          <NA>\n## 2        3        2 amrish 2020-01-02 14:20         1 contact            No\n#obs %>% slice(c(2:4))  # return rows 2 through 4\nobs %>% slice_max(encounter, n = 1)  # return rows with the largest encounter number##   recordID personID   name       date  time encounter purpose symptoms_ever\n## 1        5        2 amrish 2020-01-05 16:10         3    case           Yes\n## 2       13        3 mariah 2020-01-06 08:32         3 contact            No\n## 3       16        5  brian 2020-01-07 07:59         3    case            No"},{"path":"deduplication.html","id":"cắt-theo-nhóm","chapter":"15 Loại bỏ trùng lặp","heading":"Cắt theo nhóm","text":"Các hàm slice_*() có thể rất hữu ích nếu được áp dụng cho một data frame được nhóm lại vì thao tác cắt được thực hiện trên từng nhóm riêng biệt. Sử dụng hàm group_by() kết hợp với slice() nhằm nhóm dữ liệu để lấy một lát cắt từ mỗi nhóm.Điều này rất hữu ích cho việc loại bỏ trùng lặp nếu bạn có nhiều hàng cho mỗi người nhưng chỉ muốn giữ một trong số chúng. Trước tiên, bạn sử dụng group_by() với các cột chính mà giống nhau cho mỗi người, sau đó sử dụng một hàm slice trên một cột, điều này sẽ khác nhau giữa các hàng được nhóm.Trong ví dụ dưới đây, để chỉ giữ lại cuộc gọi truy vết mới nhất theo mỗi người, chúng ta nhóm các hàng theo cột name và sau đó sử dụng slice_max() với n = 1 trên cột date. Hãy lưu ý! Để áp dụng một hàm như slice_max() vào dates (ngày tháng), cột ngày tháng phải thuộc nhóm Date.Theo mặc định, “các ràng buộc” (ví dụ: cùng ngày trong trường hợp này) được giữ lại và chúng tôi sẽ vẫn nhận được nhiều hàng cho một số người (ví dụ: adam). Để tránh tình huống này, chúng tôi đặt with_ties = FALSE. Chúng tôi sẽ chỉ nhận lại một hàng cho mỗi người.CHÚ Ý: Nếu sử dụng arrange(), xác định .by_group = TRUE để sắp xếp dữ liệu trong mỗi nhóm.THẬN TRỌNG: Nếu with_ties = FALSE, hàng đầu tiên có ràng buộc được giữ lại. Điều này có thể là sự nhầm lẫn. Hãy xem trường hợp của Mariah, cô ấy có hai cuộc gọi truy vết vào ngày gần nhất (ngày 06/01) và cuộc gọi truy vết đầu tiên (sớm nhất) được giữ lại. Rất có thể, chúng ta muốn giữ lại cuộc gọi truy vết muộn hơn của cô ấy vào ngày đó. Xem cách “phá vỡ” những ràng buộc này trong ví dụ tiếp theo.Ví dụ ở trên, chúng ta có thể thấy rằng chỉ hàng của Amrish vào ngày 05/01 được giữ lại và chỉ hàng của Brian vào ngày 07/01 được giữ lại. Xem dữ lịệu gốc.Phá vỡ “ràng buộc”Nhiều câu lệnh cắt (slice) có thể được chạy để “phá vỡ các ràng buộc”. Trong trường hợp này, nếu một người có nhiều cuộc gọi truy vết vào ngày gần nhất, cuộc gọi truy vết với thời gian gần nhất sẽ được giữ lại (lubridate::hm() được sử dụng để chuyển đổi ký tự thời gian thành một lớp thời gian có thể sắp xếp).\nLưu ý rằng bây giờ, một hàng được giữ cho “Mariah” vào ngày 06/01 là cuộc gọi truy vết thứ 3 từ 08:32, không phải cuộc gọi truy vết thứ 2 lúc 07:25.Trong ví dụ trên, cũng có thể cắt theo số lần encounter, nhưng chúng tôi đã hiển thị cách cắt theo date và time cho mục đích ví dụ.MẸO: Để sử dụng slice_max() hoặc slice_min() trên một cột “kí tự”, hãy biến đối nó thành một lớp yếu tố được sắp xếp theo thứ tự!Xem dữ liệu gốc.","code":"\nobs %>% \n  group_by(name) %>%       # group the rows by 'name'\n  slice_max(date,          # keep row per group with maximum date value \n            n = 1,         # keep only the single highest row \n            with_ties = F) # if there's a tie (of date), take the first row\n# Example of multiple slice statements to \"break ties\"\nobs %>%\n  group_by(name) %>%\n  \n  # FIRST - slice by latest date\n  slice_max(date, n = 1, with_ties = TRUE) %>% \n  \n  # SECOND - if there is a tie, select row with latest time; ties prohibited\n  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)"},{"path":"deduplication.html","id":"giữ-lại-tất-cả-nhưng-đánh-dấu-các-dòng","chapter":"15 Loại bỏ trùng lặp","heading":"Giữ lại tất cả nhưng đánh dấu các dòng","text":"Nếu bạn muốn giữ lại tất cả các bản ghi nhưng chỉ đánh dấu một số để phân tích, hãy cân nhắc cách tiếp cận hai bước sử dụng một số recordID/encounter duy nhất:Giảm/cắt data frame gốc thành chỉ bao gồm các hàng cho phân tích. Lưu/giữ lại data frame đã được thu gọn này.Trong data frame gốc, hãy đánh dấu các hàng là thích hợp với case_when(), dựa trên việc liệu mã định danh duy nhất của những bản ghi này (recordID trong ví dụ này) có trong data frame thu gọn hay không.Xem dữ liệu gốc.","code":"\n# 1. Define data frame of rows to keep for analysis\nobs_keep <- obs %>%\n  group_by(name) %>%\n  slice_max(encounter, n = 1, with_ties = FALSE) # keep only latest encounter per person\n\n\n# 2. Mark original data frame\nobs_marked <- obs %>%\n\n  # make new dup_record column\n  mutate(dup_record = case_when(\n    \n    # if record is in obs_keep data frame\n    recordID %in% obs_keep$recordID ~ \"For analysis\", \n    \n    # all else marked as \"Ignore\" for analysis purposes\n    TRUE                            ~ \"Ignore\"))\n\n# print\nobs_marked##    recordID personID    name       date  time encounter purpose symptoms_ever   dup_record\n## 1         1        1    adam 2020-01-01 09:00         1 contact          <NA>       Ignore\n## 2         1        1    adam 2020-01-01 09:00         1 contact          <NA>       Ignore\n## 3         2        2  amrish 2020-01-02 14:20         1 contact            No       Ignore\n## 4         3        2  amrish 2020-01-02 14:20         1 contact            No       Ignore\n## 5         4        3  mariah 2020-01-05 12:00         1    case            No       Ignore\n## 6         5        2  amrish 2020-01-05 16:10         3    case           Yes For analysis\n## 7         6        4  nikhil 2020-01-05 13:01         1 contact           Yes       Ignore\n## 8         7        5   brian 2020-01-05 15:20         1 contact            No       Ignore\n## 9         8        6   smita 2020-01-05 14:20         1 contact           Yes For analysis\n## 10        9        7  raquel 2020-01-05 12:30         1 contact          <NA>       Ignore\n## 11       10        2  amrish 2020-01-02 10:24         2 contact           Yes       Ignore\n## 12       11        1    adam 2020-01-05 09:40         2    case            No For analysis\n## 13       12        3  mariah 2020-01-06 07:25         2 contact            No       Ignore\n## 14       13        3  mariah 2020-01-06 08:32         3 contact            No For analysis\n## 15       14        4  nikhil 2020-01-06 15:36         2 contact           Yes For analysis\n## 16       15        5   brian 2020-01-06 15:31         2 contact           Yes       Ignore\n## 17       16        5   brian 2020-01-07 07:59         3    case            No For analysis\n## 18       17        7  raquel 2020-01-07 11:13         2 contact            No For analysis\n## 19       18        8 natalie 2020-01-07 17:12         1    case            No For analysis"},{"path":"deduplication.html","id":"tính-toán-độ-hoàn-chỉnh-của-hàng","chapter":"15 Loại bỏ trùng lặp","heading":"Tính toán độ hoàn chỉnh của hàng","text":"Tạo một cột chứa số liệu về độ hoàn chỉnh (không bị thiếu) của hàng. Điều này có thể hữu ích khi quyết định ưu tiên hàng nào hơn hàng nào khi loại bỏ trùng lặp/cắt.Trong ví dụ này, các cột “chính” mà bạn muốn đo lường mức độ hoàn chỉnh được lưu trong một vectơ tên cột.Sau đó, cột mới key_completeness được tạo bằng hàm mutate(). Giá trị mới của mỗi hàng được xác định dưới dạng phân số được tính toán bằng: số giá trị không bị thiếu trong hàng đó trong số các cột chính, chia cho số cột chính.Điều này cần thêm hàm rowSums() từ base R. Data frame sử dụng được đại diện bởi dấu ., tức là tham chiếu đến data frame nguồn trong một chuỗi pipe (trong trường hợp này, nó sẽ được tách thành tập con với dấu ngoặc vuông []).Cuộn sang phải để xem các hàng khácXem dữ liệu gốc.","code":"\n# create a \"key variable completeness\" column\n# this is a *proportion* of the columns designated as \"key_cols\" that have non-missing values\n\nkey_cols = c(\"personID\", \"name\", \"symptoms_ever\")\n\nobs %>% \n  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) "},{"path":"deduplication.html","id":"str_rollup","chapter":"15 Loại bỏ trùng lặp","heading":"15.4 Gộp các giá trị","text":"Phần này miêu tả:Cách “gộp (roll-)” các giá trị từ nhiều hàng chỉ thành một hàng, với một số biến thểKhi bạn có các giá trị “đã được gộp”, cách để ghi đè/ưu tiên các giá trị trong mỗi ôTab này sử dụng bộ dữ liệu mẫu từ tab Chuẩn bị.","code":""},{"path":"deduplication.html","id":"gộp-các-giá-trị-thành-một-hàng","chapter":"15 Loại bỏ trùng lặp","heading":"Gộp các giá trị thành một hàng","text":"Code ví dụ bên dưới sử dụng group_by() và summarise() để nhóm các hàng theo từng người, rồi dán (paste) tất cả các giá trị duy nhất trong các hàng được nhóm lại với nhau. đó, bạn nhận được một hàng tóm tắt cho mỗi người. Một số lưu ý:Một hậu tố được thêm vào tất cả các cột mới (“_roll” trong ví dụ này)Nếu bạn chỉ muốn hiển thị các giá trị duy nhất trên mỗi ô, thì hãy đặt na.omit() trong unique()na.omit() loại bỏ các giá trị NA, nhưng nếu đây là điều không mong muốn, nó có thể bị loại bỏ bởi paste0(.x)…Kết quả là một hàng cho mỗi nhóm (ID), với các mục đã nhập được sắp xếp theo ngày và được dán cùng nhau. Cuộn sang trái để xem các hàng khácXem dữ liệu gốc.Biến thể này chỉ hiển thị các giá trị duy nhất:Biến thể này thêm hậu tố vào mỗi cột.\nTrong trường hợp này, “_roll” được dùng để biểu thị rằng nó đã được gộp:","code":"\n# \"Roll-up\" values into one row per group (per \"personID\") \ncases_rolled <- obs %>% \n  \n  # create groups by name\n  group_by(personID) %>% \n  \n  # order the rows within each group (e.g. by date)\n  arrange(date, .by_group = TRUE) %>% \n  \n  # For each column, paste together all values within the grouped rows, separated by \";\"\n  summarise(\n    across(everything(),                           # apply to all columns\n           ~paste0(na.omit(.x), collapse = \"; \"))) # function is defined which combines non-NA values\n# Variation - show unique values only \ncases_rolled <- obs %>% \n  group_by(personID) %>% \n  arrange(date, .by_group = TRUE) %>% \n  summarise(\n    across(everything(),                                   # apply to all columns\n           ~paste0(unique(na.omit(.x)), collapse = \"; \"))) # function is defined which combines unique non-NA values\n# Variation - suffix added to column names \ncases_rolled <- obs %>% \n  group_by(personID) %>% \n  arrange(date, .by_group = TRUE) %>% \n  summarise(\n    across(everything(),                \n           list(roll = ~paste0(na.omit(.x), collapse = \"; \")))) # _roll is appended to column names"},{"path":"deduplication.html","id":"ghi-đè-các-giá-trịhệ-thống-phân-cấp","chapter":"15 Loại bỏ trùng lặp","heading":"Ghi đè các giá trị/hệ thống phân cấp","text":"Sau đó, nếu bạn muốn đánh giá tất cả các giá trị đã gộp và chỉ giữ một giá trị cụ thể (ví dụ: giá trị “tốt nhất (best)” hoặc “tối đa (maximum)”), bạn có thể sử dụng hàm mutate() trên các cột mong muốn, để triển khai các điều kiện rẽ nhánh với case_when() và str_detect() từ package stringr để tìm kiếm tuần tự các mẫu chuỗi và ghi đè nội dung ô.Bây giờ bạn có thể thấy trong cột symptoms_ever rằng nếu người đó TỪNG trả lời “Yes” với các triệu chứng, thì chỉ “Yes” được hiển thị.Xem dữ liệu gốc.","code":"\n# CLEAN CASES\n#############\ncases_clean <- cases_rolled %>% \n    \n    # clean Yes-No-Unknown vars: replace text with \"highest\" value present in the string\n    mutate(across(c(contains(\"symptoms_ever\")),                     # operates on specified columns (Y/N/U)\n             list(mod = ~case_when(                                 # adds suffix \"_mod\" to new cols; implements case_when()\n               \n               str_detect(.x, \"Yes\")       ~ \"Yes\",                 # if \"Yes\" is detected, then cell value converts to yes\n               str_detect(.x, \"No\")        ~ \"No\",                  # then, if \"No\" is detected, then cell value converts to no\n               str_detect(.x, \"Unknown\")   ~ \"Unknown\",             # then, if \"Unknown\" is detected, then cell value converts to Unknown\n               TRUE                        ~ as.character(.x)))),   # then, if anything else if it kept as is\n      .keep = \"unused\")                                             # old columns removed, leaving only _mod columns"},{"path":"deduplication.html","id":"loại-bỏ-trùng-lặp-theo-xác-suất-1","chapter":"15 Loại bỏ trùng lặp","heading":"15.5 Loại bỏ trùng lặp theo xác suất","text":"Đôi khi, bạn có thể muốn xác định các bản trùng lặp “có khả năng xảy ra” dựa trên sự tương đồng (ví dụ: chuỗi “distance (khoảng cách)”) trên một số cột như name (tên), age (tuổi), sex (giới tính), date birth (ngày sinh), v.v. Bạn có thể áp dụng thuật toán khớp theo xác suất để xác định các bản trùng lặp có khả năng xảy ra.Xem chương Nối dữ liệu để được giải thích về phương pháp này. Mục sánh theo xác suất chứa một ví dụ về việc áp dụng các thuật toán này để sánh một data frame với chính nó, đó thực hiện loại bỏ trùng lặp theo xác suất.","code":""},{"path":"deduplication.html","id":"tài-nguyên-học-liệu-3","chapter":"15 Loại bỏ trùng lặp","heading":"15.6 Tài nguyên học liệu","text":"Phần lớn thông tin trong chương này được điều chỉnh từ các tài nguyên và vignette trực tuyến sau:datanoviadplyr tidyverse referencecran janitor vignette","code":""},{"path":"iteration.html","id":"iteration","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"16 Lặp, vòng lặp, và danh sách","text":"Các nhà dịch tễ học thường phải phân tích lặp lại trên các phân nhóm như quốc gia, quận hoặc nhóm tuổi. Đây chỉ là một vài trong số rất nhiều tình huống yêu cầu việc lặp lại. Mã hóa các thao tác lặp lại của bạn bằng cách sử dụng các phương pháp bên dưới sẽ giúp bạn thực hiện các tác vụ lặp đi lặp lại như vậy nhanh hơn, giảm khả năng xảy ra lỗi và giảm độ dài code.Chương này sẽ giới thiệu hai cách tiếp cận đối với các thao tác lặp lại - sử dụng các vòng lặp và package purrr.vòng lặp lặp lại code trên một loạt đầu vào, nhưng ít phổ biến hơn trong R với các ngôn ngữ lập trình khác. Tuy nhiên, chúng tôi giới thiệu chúng ở đây như một công cụ học tập và tham khảoPackage purrr là phương pháp tiếp cận tidyverse đối với các thao tác lặp lại - nó hoạt động bằng cách “maps” (áp dụng) một hàm trên nhiều đầu vào (giá trị, cột, datasets, v.v.)Trong chương này, chúng tôi sẽ lấy một số ví dụ như:Nhập và xuất nhiều tệpTạo các đường cong dịch bệnh cho nhiều tỉnhChạy T-tests cho nhiều cột trong dataframeTrong phần purrr, chúng tôi cũng sẽ cung cấp một số ví dụ về cách tạo và xử lý danh sách lists.","code":""},{"path":"iteration.html","id":"chuẩn-bị-7","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"16.1 Chuẩn bị","text":"","code":""},{"path":"iteration.html","id":"gọi-packages-3","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Gọi packages","text":"Đoạn code này hiển thị cách gọi các packages cần thiết cho phần phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt package nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về packages R.","code":"\npacman::p_load(\n     rio,         # import/export\n     here,        # file locator\n     purrr,       # iteration\n     tidyverse    # data management and visualization\n)"},{"path":"iteration.html","id":"nhập-dữ-liệu-9","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Nhập dữ liệu","text":"Chúng tôi nhập dataset về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn làm theo, hãy nhấp để tải xuống linelist “sạch” (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương Nhập xuất dữ liệu để biết chi tiết).50 hàng đầu tiên của linelist được hiển thị bên dưới.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"iteration.html","id":"vòng-lặp-for","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"16.2 vòng lặp for","text":"","code":""},{"path":"iteration.html","id":"iter_loops","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"vòng lặp for trong R","text":"Vòng lặp không được nhấn mạnh trong R, nhưng phổ biến trong các ngôn ngữ lập trình khác. Khi mới bắt đầu, chúng có thể hữu ích để học và thực hành vì chúng dễ “khám phá”, “gỡ lỗi” hơn và nắm bắt chính xác những gì đang xảy ra cho mỗi lần lặp, đặc biệt là khi bạn chưa cảm thấy thoải mái khi viết các hàm của riêng mình.Bạn có thể chuyển nhanh qua phần vòng lặp tới phần lặp với các hàm được tạo với purrr (xem phần bên dưới).","code":""},{"path":"iteration.html","id":"cấu-phần-cốt-lõi","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Cấu phần cốt lõi","text":"Một vòng lặp có ba phần cốt lõi:Chuỗi các phần tử cần lặp lạiCác thao tác để tiến hành cho mỗi phần tử trong chuỗiVùng chứa cho kết quả (tùy chọn)Cú pháp cơ bản là: (phần tử trong chuỗi) {các thao tác thực hiện với phần tử}. Lưu ý dấu ngoặc đơn và dấu ngoặc nhọn. Kết quả có thể được ra console hoặc được lưu trữ trong một đối tượng vùng chứa.Dưới đây là một ví dụ đơn giản về vòng lặp .","code":"\nfor (num in c(1,2,3,4,5)) {  # the SEQUENCE is defined (numbers 1 to 5) and loop is opened with \"{\"\n  print(num + 2)             # The OPERATIONS (add two to each sequence number and print)\n}                            # The loop is closed with \"}\"                            ## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7\n                             # There is no \"container\" in this example"},{"path":"iteration.html","id":"chuỗi","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Chuỗi","text":"Đây là phần “” của vòng lặp - các thao tác sẽ chạy “cho ()” từng phần tử trong chuỗi. Chuỗi có thể là một loạt các giá trị (ví dụ: tên của khu vực pháp lý, bệnh, tên cột, phần tử danh sách, v.v.) hoặc nó có thể là một chuỗi các số liên tiếp (ví dụ: 1,2,3,4,5). Mỗi cách tiếp cận được mô tả dưới đây có các tiện ích riêng của chúng.Cấu trúc cơ bản của biểu thức chuỗi là item vector.Bạn có thể viết bất kỳ ký tự hoặc từ nào thay cho “item” (ví dụ: “”, “num”, “hosp”, “district”, v.v.). Giá trị của “item” này thay đổi theo từng lần lặp lại của vòng lặp, tiếp tục qua từng giá trị trong vector.Vector có thể là các giá trị ký tự, tên cột hoặc có thể là một chuỗi số - đây là những giá trị sẽ thay đổi theo mỗi lần lặp. Bạn có thể sử dụng chúng trong các thao tác vòng lặp bằng cách sử dụng thuật ngữ “item”.Ví dụ: chuỗi giá trị ký tựTrong ví dụ này, một vòng lặp được thực hiện cho mỗi giá trị được xác định trước trong một vector ký tự của tên bệnh viện.Chúng tôi đã chọn thuật ngữ hosp để đại diện cho các giá trị từ vector hospital_names. Đối với lần lặp đầu tiên của vòng lặp, giá trị của hosp sẽ là hospital_names[[1]]. Đối với vòng lặp thứ hai, nó sẽ là hospital_names[[2]]. Và cứ như thế…Ví dụ: chuỗi tên cộtĐây là một biến thể của chuỗi ký tự ở trên, trong đó tên của một đối tượng R hiện có được trích xuất và trở thành vector. Ví dụ, tên cột của dataframe. Trong code hoạt động của vòng lặp , tên cột có thể được sử dụng để lập chỉ mục (tập hợp con) dataframe ban đầu của chúng.Dưới đây, chuỗi là names() (tên cột) của dataframe linelist. Tên “item” của chúng ta là col, sẽ đại diện cho từng tên cột khi các vòng lặp diễn ra.Với ví dụ này, chúng tôi bao gồm code thao tác bên trong vòng lặp , được chạy cho mọi giá trị trong chuỗi. Trong code này, các giá trị trình tự (tên cột) được sử dụng để chỉ mục (tập hợp con) từng phần tử một trong linelist. Như đã dạy trong chương R cơ bản, dấu ngoặc vuông kép [[]] được sử dụng cho tập hợp con. Cột kết quả được chuyển đến .na(), sau đó đến sum() để tạo ra số giá trị trong cột bị thiếu. Kết quả được ra console - một số cho mỗi cột.Một lưu ý về lập chỉ mục với tên cột - bất cứ khi nào tham chiếu đến chính cột đó, đừng chỉ viết “col”! col chỉ đại diện cho tên cột ký tự! Để tham chiếu đến toàn bộ cột, bạn phải sử dụng tên cột dưới dạng chỉ mục trên linelist thông qua linelist[[col]].Dãy sốTheo cách tiếp cận này, dãy số là một chuỗi các số liên tiếp. đó, giá trị của “item” không phải là giá trị ký tự (ví dụ: “Central Hospital” hoặc “date_onset”) mà là một số. Điều này rất hữu ích cho việc lặp qua các dataframes, vì bạn có thể sử dụng số “item” bên trong vòng lặp để lập chỉ mục dataframe theo số hàng.Ví dụ: giả sử bạn muốn lặp qua mọi hàng trong dataframe của mình và trích xuất thông tin nhất định. “Item” của bạn sẽ là số hàng số. Thông thường, “item” trong trường hợp này được viết là .Quá trình vòng lặp có thể được giải thích bằng lời là “đối với mọi mục trong chuỗi số từ 1 đến tổng số hàng trong dataframe của tôi, hãy thực hiện X”. Đối với lần lặp đầu tiên của vòng lặp, giá trị của “item” sẽ là 1. Đối với lần lặp thứ hai,sẽ là 2, v.v.Đây là hình thức của chuỗi trong code: (1:nrow(linelist)) {OPERATIONS CODE} trong đó đại diện cho “item”và 1:nrow(linelist) tạo ra một chuỗi liên tiếp số từ 1 đến số hàng trong linelist.Nếu bạn muốn chuỗi là số, nhưng bạn đang bắt đầu từ một vector (không phải dataframe), hãy sử dụng hàm tắt seq_along() để trả về một dãy số cho mỗi phần tử trong vector. Ví dụ: (seq_along(hospital_names) {OPERATIONS CODE}.Đoạn code dưới đây thực sự trả về các số, sẽ trở thành giá trị của trong vòng lặp tương ứng của chúng.Một lợi thế của việc sử dụng các số trong chuỗi là cũng dễ dàng sử dụng số để lập chỉ mục vùng chứa lưu trữ các kết quả đầu ra của vòng lặp. Có một ví dụ về điều này trong phần Thao tác bên dưới.","code":"\n# make vector of the hospital names\nhospital_names <- unique(linelist$hospital)\nhospital_names # print## [1] \"Other\"                                \"Missing\"                              \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                       \n## [5] \"Military Hospital\"                    \"Central Hospital\"\n# a 'for loop' with character sequence\n\nfor (hosp in hospital_names){       # sequence\n  \n       # OPERATIONS HERE\n  }\nfor (col in names(linelist)){        # loop runs for each column in linelist; column name represented by \"col\" \n  \n  # Example operations code - print number of missing values in column\n  print(sum(is.na(linelist[[col]])))  # linelist is indexed by current value of \"col\"\n     \n}## [1] 0\n## [1] 0\n## [1] 2087\n## [1] 256\n## [1] 0\n## [1] 936\n## [1] 1323\n## [1] 278\n## [1] 86\n## [1] 0\n## [1] 86\n## [1] 86\n## [1] 86\n## [1] 0\n## [1] 0\n## [1] 0\n## [1] 2088\n## [1] 2088\n## [1] 0\n## [1] 0\n## [1] 0\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 249\n## [1] 149\n## [1] 765\n## [1] 0\n## [1] 256\nfor (i in 1:nrow(linelist)) {  # use on a data frame\n  # OPERATIONS HERE\n}  \nseq_along(hospital_names)  # use on a named vector## [1] 1 2 3 4 5 6"},{"path":"iteration.html","id":"các-thao-tác","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Các thao tác","text":"Đây là code trong dấu ngoặc nhọn {} của vòng lặp . Bạn muốn code này chạy cho từng “item” trong chuỗi. đó, hãy thận trọng với mọi phần code của bạn thay đổi bởi “item” đều được mã hóa chính xác để nó thực sự thay đổi! Ví dụ. nhớ sử dụng [[ ]] để lập chỉ mục.Trong ví dụ dưới đây, chúng tôi lặp lại từng hàng trong linelist. Giá trị gender và age của mỗi hàng được dán lại với nhau và được lưu trữ trong vector ký tự vùng chứa cases_demographics. Lưu ý cách chúng tôi cũng sử dụng lập chỉ mục [[]] để lưu đầu ra của vòng lặp vào vị trí chính xác trong vector “container”.","code":"\n# create container to store results - a character vector\ncases_demographics <- vector(mode = \"character\", length = nrow(linelist))\n\n# the for loop\nfor (i in 1:nrow(linelist)){\n  \n  # OPERATIONS\n  # extract values from linelist for row i, using brackets for indexing\n  row_gender  <- linelist$gender[[i]]\n  row_age     <- linelist$age_years[[i]]    # don't forget to index!\n     \n  # combine gender-age and store in container vector at indexed location\n  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = \",\") \n\n}  # end for loop\n\n\n# display first 10 rows of container\nhead(cases_demographics, 10)##  [1] \"m,2\"  \"f,3\"  \"m,56\" \"f,18\" \"m,3\"  \"f,16\" \"f,16\" \"f,0\"  \"m,61\" \"f,27\""},{"path":"iteration.html","id":"vùng-chứa","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Vùng chứa","text":"Đôi khi kết quả của vòng lặp của bạn sẽ được ra console hoặc cửa sổ RStudio Plots. Lần khác, bạn sẽ muốn lưu trữ các kết quả đầu ra trong một “vùng chứa” để sử dụng sau này. Một vùng chứa như vậy có thể là một vector, một data frame hoặc thậm chí là một danh sách.Hiệu quả nhất là tạo vùng chứa cho các kết quả thậm chí trước khi bắt đầu vòng lặp . Trong thực tế, điều này có nghĩa là tạo một vector, data frame hoặc danh sách trống. Chúng có thể được tạo bằng các hàm vector() cho vectors hoặc danh sách, hoặc với matrix() và data.frame() cho một data frame.Vector trốngSử dụng vector() và chỉ định mode = dựa trên lớp phân loại dự kiến của các đối tượng mà bạn sẽ chèn - “double” (để giữ số), “ký tự” hoặc “logic”. Bạn cũng nên đặt trước length =. Đây phải là độ dài chuỗi vòng lặp của bạn.Giả sử bạn muốn lưu trữ thời gian nhập viện trễ trung bình cho mỗi bệnh viện. Bạn sẽ sử dụng “double” và đặt độ dài là số đầu ra dự kiến (số bệnh viện duy nhất trong data set).Data frame trốngBạn có thể tạo một data frame trống bằng cách chỉ định số hàng và cột như sau:Danh sách trốngBạn có thể muốn lưu trữ một số biểu đồ được tạo bởi vòng lặp trong danh sách. Một danh sách giống như vector, nhưng chứa các đối tượng R khác bên trong nó có thể thuộc các lớp khác nhau. Các phần tử trong danh sách có thể là một số, một dataframe, một vector và thậm chí là một danh sách khác.Bạn thực sự khởi tạo một danh sách trống bằng cách sử dụng cùng một lệnh vector() như trên, nhưng với mode = \"list\". Chỉ định độ dài như bạn muốn.","code":"\ndelays <- vector(\n  mode = \"double\",                            # we expect to store numbers\n  length = length(unique(linelist$hospital))) # the number of unique hospitals in the dataset\ndelays <- data.frame(matrix(ncol = 2, nrow = 3))\nplots <- vector(mode = \"list\", length = 16)"},{"path":"iteration.html","id":"in-1","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"In","text":"Lưu ý rằng để từ bên trong vòng lặp , bạn có thể sẽ cần phải đưa hàm print() vào.Trong ví dụ dưới đây, chuỗi là một vector ký tự rõ ràng, được sử dụng để đặt linelist con theo bệnh viện. Kết quả không được lưu trữ trong vùng chứa mà được ra console với hàm print().","code":"\nfor (hosp in hospital_names){ \n     hospital_cases <- linelist %>% filter(hospital == hosp)\n     print(nrow(hospital_cases))\n}## [1] 885\n## [1] 1469\n## [1] 422\n## [1] 1762\n## [1] 896\n## [1] 454"},{"path":"iteration.html","id":"kiểm-tra-vòng-lặp-for","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Kiểm tra vòng lặp for","text":"Để kiểm tra vòng lặp của mình, bạn có thể chạy lệnh để gán tạm thời “item”, chẳng hạn như <- 10 hoặc hosp <- \"Central Hospital\". Thực hiện việc này bên ngoài vòng lặp và sau đó chỉ chạy code thao tác của bạn (code trong dấu ngoặc nhọn) để xem liệu kết quả mong đợi có được tạo ra hay không.","code":""},{"path":"iteration.html","id":"lặp-lại-biểu-đồ","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Lặp lại biểu đồ","text":"Để đặt tất cả ba thành phần lại với nhau (vùng chứa, trình tự và thao tác), chúng ta hãy cố gắng vẽ biểu đồ đường cong dịch bệnh cho mỗi bệnh viện (xem chương Đường cong dịch bệnh).Chúng tôi có thể tạo ra một đường cong dịch bệnh đẹp về tất cả các trường hợp theo giới tính bằng cách sử dụng package incidence2 như bên dưới:Để tạo ra một biểu đồ riêng cho từng trường hợp của bệnh viện, chúng ta có thể đặt code đường cong dịch bệnh này trong vòng lặp .Đầu tiên, chúng tôi lưu một vector được đặt tên duy nhất của các tên bệnh viện, hospital_names. Vòng lặp sẽ chạy một lần cho mỗi tên sau: (hosp hospital_names). Mỗi lần lặp lại của vòng lặp , tên bệnh viện hiện tại từ vector sẽ được biểu diễn dưới dạng hosp để sử dụng trong vòng lặp.Trong các thao tác vòng lặp, bạn có thể viết code R như bình thường, nhưng cần biết rằng giá trị của “item” (hosp trong trường hợp này) sẽ thay đổi. Trong vòng lặp này:Một filter() được áp dụng cho linelist, sao cho cột hospital phải bằng giá trị hiện tại của hospĐối tượng tỷ lệ mắc được tạo trên linelist đã lọcBiểu đồ cho bệnh viện hiện tại được tạo, với tiêu đề tự động điều chỉnh sử dụng hospBiểu đồ cho bệnh viện hiện tại được lưu tạm thời và sau đó được inSau đó, vòng lặp di chuyển tiếp để lặp lại với bệnh viện tiếp theo trong hospital_names","code":"\n# create 'incidence' object\noutbreak <- incidence2::incidence(   \n     x = linelist,                   # dataframe - complete linelist\n     date_index = date_onset,        # date column\n     interval = \"week\",              # aggregate counts weekly\n     groups = gender,                # group values by gender\n     na_as_group = TRUE)             # missing gender is own group\n\n# plot epi curve\nplot(outbreak,                       # name of incidence object\n     fill = \"gender\",                # color bars by gender\n     color = \"black\",                # outline color of bars\n     title = \"Outbreak of ALL cases\" # title\n     )\n# make vector of the hospital names\nhospital_names <- unique(linelist$hospital)\n\n# for each name (\"hosp\") in hospital_names, create and print the epi curve\nfor (hosp in hospital_names) {\n     \n     # create incidence object specific to the current hospital\n     outbreak_hosp <- incidence2::incidence(\n          x = linelist %>% filter(hospital == hosp),   # linelist is filtered to the current hospital\n          date_index = date_onset,\n          interval = \"week\", \n          groups = gender,\n          na_as_group = TRUE\n     )\n     \n     # Create and save the plot. Title automatically adjusts to the current hospital\n     plot_hosp <- plot(\n       outbreak_hosp,\n       fill = \"gender\",\n       color = \"black\",\n       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n     )\n     \n     # print the plot for the current hospital\n     print(plot_hosp)\n     \n} # end the for loop when it has been run for every hospital in hospital_names "},{"path":"iteration.html","id":"theo-dõi-tiến-trình-của-một-vòng-lặp","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Theo dõi tiến trình của một vòng lặp","text":"Một vòng lặp có nhiều lần lặp có thể chạy trong nhiều phút hoặc thậm chí hàng giờ. đó, có thể hữu ích khi tiến trình ra R console. Câu lệnh dưới đây có thể được đặt trong các thao tác vòng lặp để mỗi số thứ 100. Chỉ cần điều chỉnh nó để là “item” trong vòng lặp của bạn.","code":"# loop with code to print progress every 100 iterations\nfor (i in seq_len(nrow(linelist))){\n\n  # print progress\n  if(i %% 100==0){    # The %% operator is the remainder\n    print(i)\n\n}"},{"path":"iteration.html","id":"iter_purrr","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"16.3 purrr và các danh sách","text":"Một cách tiếp cận khác đối với các thao tác lặp là package purrr - nó là phương pháp tidyverse để lặp lại.Nếu bạn phải thực hiện cùng một tác vụ nhiều lần, có lẽ bạn nên tạo một giải pháp tổng thể có thể sử dụng trên nhiều đầu vào. Ví dụ: tạo các biểu đồ cho nhiều khu vực pháp lý, hoặc nhập và kết hợp nhiều tệp.Ngoài ra còn có một số lợi thế khác đối với purrr - bạn có thể sử dụng nó với các pipes %>%, nó xử lý lỗi tốt hơn vòng lặp bình thường, và có cú pháp khá rõ ràng và đơn giản! Nếu bạn đang sử dụng vòng lặp , bạn có thể tạo vòng lặp rõ ràng và ngắn gọn hơn với purrr!Hãy nhớ rằng purrr là một công cụ lập trình theo hàm. Có nghĩa là, các thao tác lặp đi lặp lại được gói gọn trong các hàm. Xem chương Viết hàm để tìm hiểu cách viết hàm của riêng bạn.purrr cũng gần như hoàn toàn dựa trên danh sách và vectors - vì vậy hãy nghĩ về nó như là áp dụng một hàm cho mỗi phần tử của danh sách/vector đó!","code":""},{"path":"iteration.html","id":"tải-packages","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Tải packages","text":"purrr là một phần của tidyverse, vì vậy không cần cài đặt/tải một package riêng biệt.","code":"\npacman::p_load(\n     rio,            # import/export\n     here,           # relative filepaths\n     tidyverse,      # data mgmt and viz\n     writexl,        # write Excel file with multiple sheets\n     readxl          # import Excel with multiple sheets\n)"},{"path":"iteration.html","id":"map","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"map()","text":"Một hàm cốt lõi của purrr là map(), hàm này “maps” (áp dụng) một hàm cho từng phần tử đầu vào của danh sách/vector bạn cung cấp.Cú pháp cơ bản là map(.x = SEQUENCE, .f = HÀM, CÁC ĐỐI SỐ KHÁC). Chi tiết hơn như sau:.x = là các đầu vào mà hàm .f sẽ được áp dụng lặp đi lặp lại - ví dụ: vector của tên các khu vực pháp lý, các cột trong data frame hoặc danh sách các data frame.f = là hàm áp dụng cho từng phần tử của đầu vào .x - nó có thể là một hàm như print() đã tồn tại hoặc một hàm tùy chỉnh mà bạn xác định. Hàm thường được viết sau dấu ngã ~ (chi tiết bên dưới).Thêm một số lưu ý về cú pháp:Nếu hàm không cần chỉ định thêm đối số, nó có thể được viết không có dấu ngoặc đơn và không có dấu ngã (ví dụ: .f = mean). Để cung cấp các đối số sẽ có cùng giá trị cho mỗi lần lặp, hãy cung cấp chúng trong map() nhưng bên ngoài đối số .f =, chẳng hạn như na.rm = T trong map(.x = my_list, .f = mean, na.rm=T).Bạn có thể sử dụng .x (hoặc đơn giản là .) bên trong hàm .f = làm trình giữ chỗ cho giá trị .x của lần lặp đóSử dụng cú pháp dấu ngã (~) để kiểm soát hàm nhiều hơn - viết hàm như bình thường với dấu ngoặc đơn, chẳng hạn như: map(.x = my_list, .f = ~mean(., na.rm = T)). Sử dụng cú pháp này đặc biệt nếu giá trị của một đối số sẽ thay đổi mỗi lần lặp lại hoặc nếu nó là chính giá trị .x (xem ví dụ bên dưới)** Đầu ra của việc sử dụng map() là một danh sách** - một danh sách là một lớp đối tượng giống như một vector nhưng các phần tử của nó có thể thuộc các lớp khác nhau. Vì vậy, một danh sách được tạo bởi map() có thể chứa nhiều data frames, hoặc nhiều vector, nhiều giá trị đơn lẻ, hoặc thậm chí nhiều danh sách! Có các phiên bản thay thế của map() được giải thích bên dưới, tạo ra các loại kết quả khác (ví dụ: map_dfr() để tạo data frame, map_chr() để tạo vectors ký tự và map_dbl() để tạo vectors số).","code":""},{"path":"iteration.html","id":"iter_combined","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Ví dụ - nhập và kết hợp các trang tính Excel","text":"Hãy biểu diễn với một công việc thường gặp của nhà dịch tễ học: - Bạn muốn nhập một Excel workbook với dữ liệu trường hợp bệnh, nhưng dữ liệu được chia thành các trang tính có tên khác nhau trong workbook. Làm cách nào để bạn nhập và kết hợp các trang tính vào một data frame một cách hiệu quả?Giả sử chúng tôi được gửi Excel workbook bên dưới. Mỗi trang tính chứa các trường hợp từ một bệnh viện nhất định.Đây là một cách tiếp cận sử dụng map():map() hàm import() để nó chạy qua mỗi trang tính ExcelKết hợp các data frames đã nhập thành một bằng cách sử dụng bind_rows()Trong khi đó, hãy giữ nguyên tên trang tính ban đầu cho mỗi hàng, lưu trữ thông tin này trong một cột mới trong data frame cuối cùngĐầu tiên, chúng ta cần trích xuất tên trang tính và lưu chúng. Chúng tôi cung cấp đường dẫn tệp của Excel workbook tới hàm excel_sheets() từ package readxl, sẽ trích xuất tên trang tính. Chúng tôi lưu trữ chúng trong một vector ký tự được gọi là sheet_names.Đây là các tên trang tính:Bây giờ chúng ta có tên của vector này, map() có thể cung cấp từng cái một cho hàm import(). Trong ví dụ này, sheet_names là .x và import() là hàm .f.Nhớ lại từ chương [Nhập và xuất dữ liệu], khi sử dụng trên Excel workbooks, import() có thể chấp nhận đối số = để chỉ định trang tính để nhập. Trong hàm import() của .f, chúng tôi cung cấp = .x, giá trị của nó sẽ thay đổi theo mỗi lần lặp thông qua vector sheet_names - đầu tiên là “Central Hospital”, sau đó là “Military Hospital”, v.v.Lưu ý - bởi vì chúng tôi đã sử dụng map(), dữ liệu trong mỗi trang tính Excel sẽ được lưu thành một data frame riêng biệt trong danh sách. Chúng tôi muốn mỗi phần tử danh sách này (data frames) có một tên, vì vậy trước khi chuyển sheet_names đến map(), chúng tôi chuyển nó qua set_names() từ purrr, điều này đảm bảo rằng mỗi phần tử danh sách nhận được tên thích hợp.Chúng tôi lưu danh sách đầu ra dưới dạng combined.Khi kiểm tra đầu ra, chúng ta thấy rằng dữ liệu từ mỗi trang tính Excel được lưu trong danh sách với một tên. Điều này là tốt, nhưng chúng ta chưa kết thúc ở đây.Cuối cùng, chúng tôi sử dụng hàm bind_rows() (từ dplyr) chấp nhận danh sách các data frames có cấu trúc tương tự và kết hợp chúng thành một data frame. Để tạo một cột mới từ phần tử danh sách tên, chúng tôi sử dụng đối số .id = và cung cấp cho nó tên mong muốn cho cột mới.Dưới đây là toàn bộ chuỗi lệnh:Và bây giờ chúng ta có một data frame với một cột chứa trang tính ban đầu!Có những biến thể của map() mà bạn nên biết. Ví dụ: map_dfr() trả về data frame, không phải danh sách. Vì vậy, chúng ta có thể đã sử dụng nó cho tác vụ ở trên và không cần phải ràng buộc các hàng. Nhưng sau đó chúng ta sẽ không thể nắm bắt được trường hợp nào đến từ trang tính nào (bệnh viện).Các biến thể khác bao gồm map_chr(), map_dbl(). Đây là những hàm rất hữu ích vì hai lý . Trước hết, chúng tự động chuyển đổi đầu ra của một hàm lặp thành một vector (không phải danh sách). Thứ hai, chúng có thể kiểm soát rõ ràng lớp mà dữ liệu quay trở lại - bạn đảm bảo rằng dữ liệu của bạn quay trở lại dưới dạng vector ký tự với map_chr(), hoặc vector số với map_dbl(). Hãy quay lại những hàm này sau trong phần sau!Các hàm map_at() và map_if() cũng rất hữu ích để lặp lại - chúng cho phép bạn chỉ định phần tử nào của danh sách nên lặp lại! Chúng hoạt động đơn giản bằng cách áp dụng một vector gồm các chỉ mục/tên (với map_at()) hoặc một phép kiểm tra logic (với map_if()).Ví dụ, chúng tôi không muốn đọc trang tính đầu tiên chứa dữ liệu của bệnh viện. Chúng tôi sử dụng map_at() thay vì map() và chỉ định đối số .= thành c(-1) có nghĩa là không sử dụng phần tử đầu tiên của .x. Ngoài ra, bạn có thể cung cấp một vector gồm các số dương hoặc tên cho .= để chỉ định phần tử nào sẽ sử dụng.Lưu ý rằng tên trang tính đầu tiên sẽ vẫn xuất hiện như một phần tử của danh sách đầu ra - nhưng nó chỉ là một tên ký tự đơn lẻ (không phải là một data frame). Bạn sẽ cần phải loại bỏ phần tử này trước khi liên kết các hàng. Chúng tôi sẽ trình bày cách xóa và sửa đổi các phần tử danh sách trong phần sau.","code":"\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\nsheet_names## [1] \"Central Hospital\"              \"Military Hospital\"             \"Missing\"                       \"Other\"                         \"Port Hospital\"                \n## [6] \"St. Mark's Maternity Hospital\"\ncombined <- sheet_names %>% \n  purrr::set_names() %>% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")  # extract sheet names\n \ncombined <- sheet_names %>%                                     # begin with sheet names\n  purrr::set_names() %>%                                        # set their names\n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %>%  # iterate, import, save in list\n  bind_rows(.id = \"origin_sheet\") # combine list of data frames, preserving origin in new column  \nsheet_names <- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined <- sheet_names %>% \n     purrr::set_names() %>% \n     # exclude the first sheet\n     map_at(.f = ~import( \"hospital_linelists.xlsx\", which = .x),\n            .at = c(-1))"},{"path":"iteration.html","id":"tách-và-xuất-bộ-dữ-liệu","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Tách và xuất bộ dữ liệu","text":"Dưới đây, chúng tôi đưa ra một ví dụ về cách tách bộ dữ liệu thành các phần và sau đó sử dụng phép lặp map() để xuất từng phần dưới dạng trang tính Excel riêng biệt hoặc dưới dạng tệp CSV riêng biệt.","code":""},{"path":"iteration.html","id":"tách-bộ-dữ-liệu","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Tách bộ dữ liệu","text":"Giả sử chúng ta có toàn bộ trường hợp linelist làm data frame và bây giờ chúng ta muốn tạo một linelist riêng biệt cho từng bệnh viện và xuất từng trường hợp dưới dạng tệp CSV riêng biệt. Dưới đây, chúng tôi thực hiện các bước sau:Sử dụng group_split() (từ dplyr) để tách data frame linelist theo các giá trị duy nhất trong cột hospital. Đầu ra là một danh sách chứa một data frame cho mỗi tập hợp con của bệnh viện.Chúng ta có thể chạy View(linelist_split) và thấy rằng danh sách này chứa 6 data frames (“tibbles”), mỗi khung đại diện cho các trường hợp từ một bệnh viện.Tuy nhiên, lưu ý rằng các data frames trong danh sách không có tên theo mặc định! Chúng tôi muốn mỗi người có một tên và sau đó sử dụng tên đó khi lưu tệp CSV.Một cách tiếp cận để trích xuất các tên là sử dụng pull() (từ dplyr) để trích xuất cột hospital từ mỗi data frame trong danh sách. Sau đó, để toàn, chúng tôi chuyển đổi các giá trị thành ký tự và sau đó sử dụng unique() để lấy tên cho data frame cụ thể đó. Tất cả các bước này được áp dụng cho từng data frame thông qua map().Bây giờ chúng ta có thể thấy rằng mỗi phần tử trong danh sách đều có một tên. Những tên này có thể được truy cập thông qua names(linelist_split).","code":"\nlinelist_split <- linelist %>% \n     group_split(hospital)\nnames(linelist_split) <- linelist_split %>%   # Assign to names of listed data frames \n     # Extract the names by doing the following to each data frame: \n     map(.f = ~pull(.x, hospital)) %>%        # Pull out hospital column\n     map(.f = ~as.character(.x)) %>%          # Convert to character, just in case\n     map(.f = ~unique(.x))                    # Take the unique hospital name\nnames(linelist_split)## [1] \"Central Hospital\"                     \"Military Hospital\"                    \"Missing\"                              \"Other\"                               \n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\""},{"path":"iteration.html","id":"nhiều-hơn-một-cột-group_split","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Nhiều hơn một cột group_split()","text":"Nếu bạn muốn chia linelist theo nhiều hơn một nhóm cột, chẳng hạn như để tạo tập hợp con linelist theo giao điểm của bệnh viện VÀ giới tính, bạn sẽ cần một cách tiếp cận khác để đặt tên cho các phần tử danh sách. Điều này liên quan đến việc thu thập các “nhóm chính (group keys)” duy nhất bằng cách sử dụng group_keys() từ dplyr - chúng được trả về dưới dạng một data frame. Sau đó, bạn có thể kết hợp các nhóm chính thành các giá trị với unite() như được hiển thị bên dưới và gán các tên tập nhóm này cho linelist_split.Bây giờ chúng ta kết hợp các nhóm với nhau, được phân tách bằng dấu gạch ngang và gán chúng làm tên của các phần tử danh sách trong linelist_split. Thao tác này sẽ mất thêm vài dòng khi chúng ta thay thế NA bằng “Missing”, sử dụng unite() từ dplyr để kết hợp các giá trị cột với nhau (phân tách bằng dấu gạch ngang), sau đó chuyển đổi thành vector không tên để nó có thể được dùng làm tên của linelist_split.","code":"\n# split linelist by unique hospital-gender combinations\nlinelist_split <- linelist %>% \n     group_split(hospital, gender)\n\n# extract group_keys() as a dataframe\ngroupings <- linelist %>% \n     group_by(hospital, gender) %>%       \n     group_keys()\n\ngroupings      # show unique groupings ## # A tibble: 18 x 2\n##    hospital                             gender\n##    <chr>                                <chr> \n##  1 Central Hospital                     f     \n##  2 Central Hospital                     m     \n##  3 Central Hospital                     <NA>  \n##  4 Military Hospital                    f     \n##  5 Military Hospital                    m     \n##  6 Military Hospital                    <NA>  \n##  7 Missing                              f     \n##  8 Missing                              m     \n##  9 Missing                              <NA>  \n## 10 Other                                f     \n## 11 Other                                m     \n## 12 Other                                <NA>  \n## 13 Port Hospital                        f     \n## 14 Port Hospital                        m     \n## 15 Port Hospital                        <NA>  \n## 16 St. Mark's Maternity Hospital (SMMH) f     \n## 17 St. Mark's Maternity Hospital (SMMH) m     \n## 18 St. Mark's Maternity Hospital (SMMH) <NA>\n# Combine into one name value \nnames(linelist_split) <- groupings %>% \n     mutate(across(everything(), replace_na, \"Missing\")) %>%  # replace NA with \"Missing\" in all columns\n     unite(\"combined\", sep = \"-\") %>%                         # Unite all column values into one\n     setNames(NULL) %>% \n     as_vector() %>% \n     as.list()"},{"path":"iteration.html","id":"xuất-dưới-dạng-trang-tính-excel","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Xuất dưới dạng trang tính Excel","text":"Để xuất linelists bệnh viện dưới dạng Excel workbook với một linelist trên mỗi trang tính, chúng tôi chỉ có thể cung cấp danh sách có tên linelist_split cho hàm write_xlsx() từ package writexl. Điều này có khả năng lưu một Excel workbook với nhiều trang tính. Tên phần tử danh sách được tự động áp dụng làm tên trang tính.Bây giờ bạn có thể mở tệp Excel và thấy rằng mỗi bệnh viện có một trang tính riêng.","code":"\nlinelist_split %>% \n     writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))"},{"path":"iteration.html","id":"xuất-dưới-dạng-tệp-csv","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Xuất dưới dạng tệp CSV","text":"Đây là lệnh phức tạp hơn một chút, nhưng bạn cũng có thể xuất từng linelist dành riêng cho bệnh viện dưới dạng tệp CSV riêng biệt, với tên tệp dành riêng cho bệnh viện.Một lần nữa, chúng tôi sử dụng map(): chúng tôi lấy vector của tên phần tử danh sách (được hiển thị ở trên) và sử dụng map() để lặp lại chúng, áp dụng export() (từ package rio, xem chương [Nhập và xuất dữ liệu]) trên data frame với danh sách linelist_split có tên đó. Chúng tôi cũng sử dụng tên để tạo một tên tệp duy nhất. Đây là các bước thực hiện:Chúng ta bắt đầu với vector tên kí tự, được chuyển tới map() dưới dạng .xHàm .f là export(), hàm này yêu cầu một data frame và một đường dẫn tệp để ghi vàoĐầu vào .x (tên bệnh viện) được sử dụng trong .f để trích xuất/lập chỉ mục phần tử cụ thể đó của danh sách linelist_split. Điều này làm cho mỗi lần chỉ một data frame được cung cấp cho export().Ví dụ: khi map() lặp lại cho “Military Hospital”, thì linelist_split[[.x]] sẽ là linelist_split[[\"Military Hospital\"]], đó trả về phần tử thứ hai của linelist_split - đó là tất cả các trường hợp từ Military Hospital.Đường dẫn tệp được cung cấp cho export() là động thông qua việc sử dụng str_glue() (xem chương Ký tự và chuỗi):\n() được sử dụng để lấy cơ sở của đường dẫn tệp và chỉ định thư mục “data” (lưu ý dấu nháy đơn để không làm gián đoạn dấu ngoặc kép str_glue())\n() được sử dụng để lấy cơ sở của đường dẫn tệp và chỉ định thư mục “data” (lưu ý dấu nháy đơn để không làm gián đoạn dấu ngoặc kép str_glue())Sau đó là dấu gạch chéo /, rồi lại .x tên bệnh viện hiện tại để làm cho tệp có thể nhận dạng đượcCuối cùng là phần mở rộng “.csv” mà export() sử dụng để tạo tệp CSVBây giờ bạn có thể thấy rằng mỗi tệp được lưu trong thư mục “data” của Dự án R “Epi_R_handbook”!","code":"\nnames(linelist_split) %>%\n     map(.f = ~export(linelist_split[[.x]], file = str_glue(\"{here('data')}/{.x}.csv\")))"},{"path":"iteration.html","id":"hàm-tùy-chỉnh","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Hàm tùy chỉnh","text":"Bạn có thể muốn tạo một hàm của riêng mình để đưa vào map().Giả sử chúng ta muốn tạo đường cong dịch bệnh cho từng trường hợp của bệnh viện. Để thực hiện việc này với purrr, hàm .f của chúng ta có thể là ggplot() và các phần mở rộng bằng + như bình thường. Vì đầu ra của map() luôn là một danh sách nên các biểu đồ được lưu trữ trong một danh sách. Bởi vì chúng là các biểu đồ, chúng có thể được trích xuất và vẽ bằng hàm ggarrange() từ package ggpubr (documentation).Nếu code map() này trông quá lộn xộn, bạn có thể đạt được kết quả tương tự bằng cách lưu lệnh ggplot() cụ thể của mình dưới dạng một hàm tùy chỉnh người dùng xác định, ví dụ, chúng ta có thể đặt tên nó là make_epicurve(). Hàm này sau đó được sử dụng trong map(). .x sẽ được thay thế lặp lại bằng tên bệnh viện và được sử dụng làm hosp_name trong hàm make_epicurve(). Xem chương về Viết hàm.","code":"\n# load package for plotting elements from list\npacman::p_load(ggpubr)\n\n# map across the vector of 6 hospital \"names\" (created earlier)\n# use the ggplot function specified\n# output is a list with 6 ggplots\n\nhospital_names <- unique(linelist$hospital)\n\nmy_plots <- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %>% filter(hospital == .x)) +\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# print the ggplots (they are stored in a list)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n# Create function\nmake_epicurve <- function(hosp_name){\n  \n  ggplot(data = linelist %>% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n# mapping\nmy_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# print the ggplots (they are stored in a list)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)"},{"path":"iteration.html","id":"áp-dụng-một-hàm-qua-nhiều-cột","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Áp dụng một hàm qua nhiều cột","text":"Một trường hợp sử dụng phổ biến khác là áp dụng một hàm trên nhiều cột. Dưới đây, chúng tôi map() hàm t.test() qua các cột số trong data frame linelist, sánh các giá trị số theo giới tính.Nhớ lại từ chương về Các kiểm định thống kê cơ bản rằng t.test() có thể nhận đầu vào ở định dạng công thức, chẳng hạn như t.test(numeric column ~ binary column). Trong ví dụ này, chúng tôi làm như sau:Các cột số được chọn từ linelist - những cột này trở thành đầu vào .x cho map()Hàm t.test() được cung cấp dưới dạng hàm .f, được áp dụng cho mỗi cột sốTrong dấu ngoặc đơn của t.test():\ndấu ~ đầu tiên đứng trước .f mà map() sẽ lặp qua.x\n.x đại diện cho cột hiện tại được cung cấp cho hàm t.test()\ndấu ~ thứ hai là một phần của phương trình t-test được mô tả ở trên\nhàm t.test() yêu cầu một cột nhị phân ở phía bên phải của phương trình. Chúng tôi đưa vector linelist$gender một cách độc lập và có ý nghĩa thống kê (lưu ý rằng nó không được bao gồm trong select()).\ndấu ~ đầu tiên đứng trước .f mà map() sẽ lặp qua.x.x đại diện cho cột hiện tại được cung cấp cho hàm t.test()dấu ~ thứ hai là một phần của phương trình t-test được mô tả ở trênhàm t.test() yêu cầu một cột nhị phân ở phía bên phải của phương trình. Chúng tôi đưa vector linelist$gender một cách độc lập và có ý nghĩa thống kê (lưu ý rằng nó không được bao gồm trong select()).map() trả về một danh sách, vì vậy đầu ra là một danh sách các kết quả t-test - một danh sách phần tử cho mỗi cột số được phân tích.Đây là danh sách t.test_results trông như thế nào khi được mở (Cửa sổ Viewer) trong RStudio. Chúng tôi đã đánh dấu các phần quan trọng đối với các ví dụ trong trang này.Ở trên cùng, bạn có thể thấy toàn bộ danh sách được đặt tên là t.test_results và có năm phần tử. Năm phần tử đó được đặt tên là age, wt_km, ht_cm, ct_blood, temp theo mỗi biến được sử dụng trong t-test với gender từ linelist.Mỗi phần tử trong số năm phần tử đó đều là danh sách, với các phần tử bên trong chúng, chẳng hạn như p.value và conf.int. Một số phần tử như p.value là các số đơn lẻ, trong khi một số phần tử như estimate bao gồm hai hoặc nhiều phần tử (mean group f và mean group m).Lưu ý: Hãy nhớ rằng nếu bạn chỉ muốn áp dụng một hàm cho một số cột nhất định trong data frame, bạn cũng có thể chỉ cần sử dụng mutate() và across(), như được giải thích trong chương Làm sạch số liệu và các hàm quan trọng. Dưới đây là một ví dụ về việc áp dụng .character() cho chỉ các cột “age”. Lưu ý vị trí của dấu ngoặc đơn và dấu phẩy.","code":"\n# Results are saved as a list\nt.test_results <- linelist %>% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # keep only some numeric columns to map across\n  map(.f = ~t.test(.x ~ linelist$gender))        # t.test function, with equation NUMERIC ~ CATEGORICAL\n# convert columns with column name containing \"age\" to class Character\nlinelist <- linelist %>% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  "},{"path":"iteration.html","id":"trích-xuất-từ-danh-sách","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Trích xuất từ danh sách","text":"Khi map() tạo ra một đầu ra của lớp danh sách, chúng ta sẽ dành một chút thời gian thảo luận về cách trích xuất dữ liệu từ danh sách bằng cách sử dụng các hàm purrr đi kèm. Để minh họa điều này, chúng tôi sẽ sử dụng danh sách t.test_results từ phần trước. Đây là danh sách gồm 5 danh sách - mỗi danh sách trong số 5 danh sách chứa kết quả của t-test giữa một cột từ data frame linelist và cột nhị phân gender của nó. Xem hình ảnh trong phần trên để có hình ảnh về cấu trúc danh sách.","code":""},{"path":"iteration.html","id":"tên-của-các-phần-tử","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Tên của các phần tử","text":"Để trích xuất tên của chính các phần tử, chỉ cần sử dụng names() từ base R. Trong trường hợp này, chúng tôi sử dụng names() trên t.test_results để trả về tên của mỗi danh sách con, là tên của 5 biến đã thực hiện t-tests.","code":"\nnames(t.test_results)## [1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\""},{"path":"iteration.html","id":"các-phần-tử-theo-tên-hoặc-vị-trí","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Các phần tử theo tên hoặc vị trí","text":"Để trích xuất các phần tử danh sách theo tên hoặc theo vị trí, bạn có thể sử dụng dấu ngoặc [[ ]] như được mô tả trong chương R cơ bản. Dưới đây chúng tôi sử dụng dấu ngoặc kép để lập chỉ mục danh sách t.tests_results và hiển thị phần tử đầu tiên là kết quả của t-test trên age.Tuy nhiên, dưới đây chúng tôi sẽ trình bày việc sử dụng các hàm map() và pluck() của purrr đơn giản và linh hoạt để đạt được kết quả tương tự.","code":"\nt.test_results[[1]] # first element by position## \n##  Welch Two Sample t-test\n## \n## data:  .x by linelist$gender\n## t = -21.3, df = 4902.9, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.544409 -6.272675\n## sample estimates:\n## mean in group f mean in group m \n##        12.66085        19.56939\nt.test_results[[1]][\"p.value\"] # return element named \"p.value\" from first element  ## $p.value\n## [1] 2.350374e-96"},{"path":"iteration.html","id":"pluck","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"pluck()","text":"pluck() kéo ra các phần tử theo tên hoặc theo vị trí. Ví dụ - để trích xuất kết quả t-test cho độ tuổi, bạn có thể sử dụng pluck() như thế này:Lập chỉ mục các cấp độ sâu hơn bằng cách chỉ định các cấp độ cao hơn bằng dấu phẩy. Dưới đây trích xuất phần tử có tên “p.value” từ danh sách age trong danh sách t.test_results. Bạn cũng có thể sử dụng số thay vì tên ký tự.Bạn có thể trích xuất các phần tử bên trong như vậy từ tất cả các phần tử cấp một bằng cách sử dụng map() để chạy hàm pluck() trên từng phần tử cấp một. Ví dụ, đoạn mã dưới đây trích xuất các phần tử “p.value” từ tất cả các danh sách trong t.test_results. Danh sách các kết quả t-test là .x được lặp qua,pluck() là hàm .f đang được lặp và giá trị “p-value” được cung cấp cho hàm.Một cách thay thế khác là map() viết tắt tên phần tử trong dấu ngoặc kép và nó sẽ ngắt nó ra. Nếu bạn sử dụng map(), đầu ra sẽ là một danh sách, trong khi nếu bạn sử dụng map_chr() thì nó sẽ là một vectơ ký tự được đặt tên và nếu bạn sử dụng map_dbl() nó sẽ là một vector số được đặt tên.Bạn có thể đọc thêm về pluck() trong tài liệu về purrr. Nó có một hàm tương tự là chuck() sẽ trả về lỗi thay vì NULL nếu một phần tử không tồn tại.","code":"\nt.test_results %>% \n  pluck(\"age\")        # alternatively, use pluck(1)## \n##  Welch Two Sample t-test\n## \n## data:  .x by linelist$gender\n## t = -21.3, df = 4902.9, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.544409 -6.272675\n## sample estimates:\n## mean in group f mean in group m \n##        12.66085        19.56939\nt.test_results %>% \n  pluck(\"age\", \"p.value\")## [1] 2.350374e-96\nt.test_results %>%\n  map(pluck, \"p.value\")   # return every p-value## $age\n## [1] 2.350374e-96\n## \n## $wt_kg\n## [1] 2.664367e-182\n## \n## $ht_cm\n## [1] 3.515713e-144\n## \n## $ct_blood\n## [1] 0.4473498\n## \n## $temp\n## [1] 0.5735923\nt.test_results %>% \n  map_dbl(\"p.value\")   # return p-values as a named numeric vector##           age         wt_kg         ht_cm      ct_blood          temp \n##  2.350374e-96 2.664367e-182 3.515713e-144  4.473498e-01  5.735923e-01"},{"path":"iteration.html","id":"chuyển-đổi-danh-sách-thành-data-frame","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Chuyển đổi danh sách thành data frame","text":"Đây là một nội dung phức tạp - hãy xem phần Tài nguyên học liệu để có các hướng dẫn đầy đủ hơn. Tuy nhiên, chúng tôi sẽ minh họa việc chuyển đổi danh sách các kết quả t-test thành một data frame. Chúng tôi sẽ tạo một data frame với các cột cho biến, p-value của nó và giá trị trung bình từ hai nhóm (nam và nữ).Dưới đây là một số phương pháp và hàm mới sẽ được sử dụng:Hàm tibble() sẽ được sử dụng để tạo một tibble (giống như một data frame)\nChúng tôi bao quanh hàm tibble() bằng dấu ngoặc nhọn { } để ngăn toàn bộ t.test_results được lưu trữ dưới dạng cột nhỏ đầu tiên\nChúng tôi bao quanh hàm tibble() bằng dấu ngoặc nhọn { } để ngăn toàn bộ t.test_results được lưu trữ dưới dạng cột nhỏ đầu tiênTrong tibble(), mỗi cột được tạo một cách rõ ràng, tương tự như cú pháp của mutate():\nDấu . đại diện cho t.test_results\nĐể tạo một cột với các tên biến t-test (tên của mỗi phần tử danh sách), chúng tôi sử dụng names() như đã mô tả ở trên\nĐể tạo một cột với các p-values, chúng tôi sử dụng map_dbl() như được mô tả ở trên để kéo các phần tử p.value và chuyển đổi chúng thành một vector số\nDấu . đại diện cho t.test_resultsĐể tạo một cột với các tên biến t-test (tên của mỗi phần tử danh sách), chúng tôi sử dụng names() như đã mô tả ở trênĐể tạo một cột với các p-values, chúng tôi sử dụng map_dbl() như được mô tả ở trên để kéo các phần tử p.value và chuyển đổi chúng thành một vector sốNhưng bây giờ hãy thêm các cột chứa trung bình cho mỗi nhóm (nam và nữ).Chúng tôi sẽ cần trích xuất phần tử estimate, nhưng điều này thực sự chứa hai phần tử bên trong nó (mean group f và mean group m). Vì vậy, nó không thể được đơn giản hóa thành một vector với map_chr() hoặc map_dbl(). Thay vào đó, chúng tôi sử dụng map(), được sử dụng trong tibble(), sẽ tạo một cột lớp danh sách trong tibble! Vâng, điều này là có thể!Sau khi bạn có cột danh sách này, có một số hàm tidyr (một phần của tidyverse) giúp bạn “gỡ rối” hoặc “gỡ bỏ” các cột “danh sách lồng nhau” này. Đọc thêm về chúng tại đây hoặc bằng cách chạy vignette(\"rectangle\"). Tóm lại:unnest_wider() - đưa mỗi phần tử của mỗi danh sách cột một cột riêng của nóunnest_longer() - đưa mỗi phần tử của mỗi danh sách cột một hàng riêng của nóhoist() - hoạt động giống như unnest_wider() nhưng bạn chỉ định phần tử nào cần gỡ bỏDưới đây, chúng tôi chuyển tibble sang unnest_wider() để chỉ định cột means của tibble (là một danh sách lồng nhau). Kết quả là means được thay thế bằng hai cột mới, mỗi cột phản ánh hai phần tử trước đó trong mỗi ô means.","code":"\nt.test_results %>% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }## # A tibble: 5 x 2\n##   variables         p\n##   <chr>         <dbl>\n## 1 age       2.35e- 96\n## 2 wt_kg     2.66e-182\n## 3 ht_cm     3.52e-144\n## 4 ct_blood  4.47e-  1\n## 5 temp      5.74e-  1\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}## # A tibble: 5 x 3\n##   variables         p means       \n##   <chr>         <dbl> <named list>\n## 1 age       2.35e- 96 <dbl [2]>   \n## 2 wt_kg     2.66e-182 <dbl [2]>   \n## 3 ht_cm     3.52e-144 <dbl [2]>   \n## 4 ct_blood  4.47e-  1 <dbl [2]>   \n## 5 temp      5.74e-  1 <dbl [2]>\nt.test_results %>% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %>% \n  unnest_wider(means)## # A tibble: 5 x 4\n##   variables         p `mean in group f` `mean in group m`\n##   <chr>         <dbl>             <dbl>             <dbl>\n## 1 age       2.35e- 96              12.7              19.6\n## 2 wt_kg     2.66e-182              45.8              59.6\n## 3 ht_cm     3.52e-144             109.              142. \n## 4 ct_blood  4.47e-  1              21.2              21.2\n## 5 temp      5.74e-  1              38.6              38.6"},{"path":"iteration.html","id":"loại-bỏ-giữ-lại-và-thu-gọn-danh-sách","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"Loại bỏ, giữ lại và thu gọn danh sách","text":"Vì làm việc với purrr nên thường liên quan đến danh sách, chúng ta sẽ khám phá ngắn gọn một số hàm purrr để sửa đổi danh sách. Xem phần Tài nguyên học liệu để có hướng dẫn đầy đủ hơn về các hàm purrr.list_modify() có nhiều cách sử dụng, một trong số đó có thể là xóa một phần tử danh sáchkeep() giữ lại các phần tử được chỉ định cho .p = hoặc trong đó một hàm được cung cấp cho .p = đánh giá là TRUEdiscard() loại bỏ các phần tử được chỉ định cho .p hoặc trong đó một hàm được cung cấp cho .p = đánh giá là TRUEcompact() loại bỏ tất cả các phần tử trốngDưới đây là một số ví dụ sử dụng danh sách combined được tạo trong phần trên về sử dụng map() để nhập và kết hợp nhiều tệp (nó chứa 6 trường hợp linelist thuộc data frames):Các phần tử có thể được xóa bằng tên với list_modify() và đặt tên bằng NULL.Bạn cũng có thể loại bỏ các phần tử theo tiêu chí, bằng cách cung cấp phương trình “định trước” cho .p = (một phương trình đánh giá là TRUE hoặc FALSE). Đặt dấu ngã ~ trước hàm và sử dụng .x để đại diện cho phần tử danh sách. Sử dụng keep(), các phần tử danh sách đánh giá là TRUE sẽ được giữ lại. Ngược lại, nếu sử dụng discard(), các phần tử danh sách đánh giá là TRUE sẽ bị loại bỏ.Trong ví dụ dưới đây, các phần tử danh sách bị loại bỏ nếu lớp của chúng không phải là data frames.Hàm định trước của bạn cũng có thể tham chiếu các phần tử/cột trong mỗi mục danh sách. Ví dụ, bên dưới, liệt kê các phần tử có giá trị trung bình của cột ct_blood trên 25 sẽ bị loại bỏ.Lệnh này sẽ xóa tất cả các phần tử danh sách trống:","code":"\ncombined %>% \n  list_modify(\"Central Hospital\" = NULL)   # remove list element by name\n# keep only list elements with more than 500 rows\ncombined %>% \n  keep(.p = ~nrow(.x) > 500)  \n# Discard list elements that are not data frames\ncombined %>% \n  discard(.p = ~class(.x) != \"data.frame\")\n# keep only list elements where ct_blood column mean is over 25\ncombined %>% \n  discard(.p = ~mean(.x$ct_blood) > 25)  \n# Remove all empty list elements\ncombined %>% \n  compact()"},{"path":"iteration.html","id":"pmap","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"pmap()","text":"PHẦN NÀY ĐANG ĐƯỢC XÂY DỰNG","code":""},{"path":"iteration.html","id":"các-hàm-apply","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"16.4 Các hàm apply","text":"Nhóm hàm “apply” là một hàm R base thay thế cho purrr với các thao tác lặp lại. Bạn có thể đọc thêm về chúng tại đây.","code":""},{"path":"iteration.html","id":"tài-nguyên-học-liệu-4","chapter":"16 Lặp, vòng lặp, và danh sách","heading":"16.5 Tài nguyên học liệu","text":"loops Data CarpentryThe R Data Science page iterationVignette write/read Excel filesA purrr tutorial jennybcAnother purrr tutorial Rebecca BarterA purrr tutorial map, pmap, imappurrr cheatsheetpurrr tips trickskeep discard","code":""},{"path":"tables-descriptive.html","id":"tables-descriptive","chapter":"17 Bảng mô tả","heading":"17 Bảng mô tả","text":"Chương này minh họa cách sử dụng các package janitor, dplyr, gtsummary, rstatix, và base R để tóm tắt dữ liệu và tạo bảng với thống kê mô tả.Chương này bao gồm cách để tạo bảng cơ bản, trong khi đó chương Trình bày bảng bao gồm cách để định dạng đẹp và chúng.*Mỗi package này đều có những ưu và nhược điểm trong từng khía cạnh như sự đơn giản, khả năng tiếp cận kết quả, chất lượng kết quả được hiển thị. Sử dụng chương này để quyết định cách tiếp cận nào phù hợp với trường hợp của bạn.Bạn có một số lựa chọn khi tạo bảng tóm tắt và bảng chéo. Một số yếu tố cần xem xét bao gồm tính đơn giản của code, khả năng tùy chỉnh, đầu ra mong muốn (được ra R console, dưới dạng dataframe hoặc dưới dạng hình ảnh “đẹp” .png/.jpeg /.html) và dễ xử lý hậu kỳ. Hãy xem xét các điểm dưới đây khi bạn chọn công cụ cho tình huống của mình.Dùng tabyl() từ janitor để tạo và “làm đẹp” cho bảng và bảng chéoDùng get_summary_stats() từ rstatix để dễ dàng tạo data frame các tóm tắt thống kê dạng số cho nhiều cột và / hoặc nhómDùng summarise() và count() từ dplyr dành choo các thống kê phức tạp hơn, đầu ra của tidy dataframe hoặc chuẩn bị dữ liệu cho ggplot()Dùng tbl_summary() từ gtsummary để tạo ra các bảng chi tiết sẵn sàng xuất bảnDùng table() từ base R nếu bạn không có khả năng truy cập vào các package trên","code":""},{"path":"tables-descriptive.html","id":"chuẩn-bị-8","chapter":"17 Bảng mô tả","heading":"17.1 Chuẩn bị","text":"","code":""},{"path":"tables-descriptive.html","id":"gọi-packages-4","chapter":"17 Bảng mô tả","heading":"Gọi packages","text":"Đoạn code này hiển thị việc gọi các packages cần thiết cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến lệnh p_load() từ pacman, giúp cài đặt các package nếu cần và gọi chúng để sử dụng. Bạn cũng có thể gọi các package đã được cài đặt với library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package của R.","code":"\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  skimr,        # get overview of data\n  tidyverse,    # data management + ggplot2 graphics \n  gtsummary,    # summary statistics and tests\n  rstatix,      # summary statistics and statistical tests\n  janitor,      # adding totals and percents to tables\n  scales,       # easily convert proportions to percents  \n  flextable     # converting tables to pretty images\n  )"},{"path":"tables-descriptive.html","id":"nhập-dữ-liệu-10","chapter":"17 Bảng mô tả","heading":"Nhập dữ liệu","text":"Chúng ta sẽ nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, bấm để tải xuống dữ liệu linelist “đã làm sạch” (.rds file). Nhập dữ liệu của bạn bằng hàm import() từ package rio (chấp nhận nhiều loại tệp như .xlsx, .rds, .csv - xem thêm chi tiết tại chương Nhập xuất dữ liệu).50 hàng đầu tiên của linelist được hiển thị như dưới đây.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"tables-descriptive.html","id":"duyệt-dữ-liệu","chapter":"17 Bảng mô tả","heading":"17.2 Duyệt dữ liệu","text":"","code":""},{"path":"tables-descriptive.html","id":"skimr-package","chapter":"17 Bảng mô tả","heading":"skimr package","text":"Khi sử dụng package skimr package, bạn có thể có được cái nhìn tổng quan chi tiết và đẹp về mặt thẩm mỹ của từng biến trong tập dữ liệu của mình. Đọc thêm về skimr tại trang github của nhà phát triển.Dưới đây, hàm skim() được áp dụng cho toàn bộ data frame linelist giúp bạn có cái nhìn tổng quan về data frame và tóm tắt của tất cả các cột (theo lớp).\nTable 17.1: Data summary\nVariable type: characterVariable type: DateVariable type: factorVariable type: numericBạn cũng có thể sử dụng hàm summary() từ base R, để lấy thông tin về toàn bộ tập dữ liệu, nhưng kết quả đầu ra có thể khó đọc hơn với sử dụng skimr. đó, kết quả không được hiển thị bên dưới để tiết kiệm không gian trang.","code":"\n## get information about each variable in a dataset \nskim(linelist)\n## get information about each column in a dataset \nsummary(linelist)"},{"path":"tables-descriptive.html","id":"thống-kê-tóm-tắt","chapter":"17 Bảng mô tả","heading":"Thống kê tóm tắt","text":"Bạn có thể sử dụng các hàm base R để trả về thống kê tóm tắt trên một cột dữ liệu dạng số. Bạn có thể trả về hầu hết các thống kê tóm tắt hữu ích cho một cột dạng số bằng cách sử dụng hàm summary(), như dưới đây. Lưu ý rằng tên data frame cũng phải được xác định như hình dưới đây.Bạn có thể truy cập và lưu một phần cụ thể của nó bằng dấu ngoặc vuông [ ]:Bạn có thể trả về các thống kê riêng lẻ với các hàm base R như max(), min(), median(), mean(), quantile(), sd(), và range(). Xem chương R cơ bản để có danh sách đầy đủ.THẬN TRỌNG: Nếu dữ liệu của bạn chứa các giá trị missing, R muốn bạn biết điều này và đó sẽ trả về NA trừ khi bạn chỉ định cho các hàm toán học ở trên mà bạn muốn R bỏ qua các giá trị bị thiếu, thông qua đối số na.rm = TRUE.Bạn có thể sử dụng hàm get_summary_stats() từ package rstatix để trả về thống kê tóm tắt ở định dạng data frame. Điều này có thể hữu ích cho việc thực hiện các hoạt động tiếp theo hoặc vẽ biểu đồ trên các con số. Xem chương Các kiểm định thống kê cơ bản để biết thêm chi tiết về package rstatix và các hàm của nó.","code":"\nsummary(linelist$age_years)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    6.00   13.00   16.02   23.00   84.00      86\nsummary(linelist$age_years)[[2]]            # return only the 2nd element## [1] 6\n# equivalent, alternative to above by element name\n# summary(linelist$age_years)[[\"1st Qu.\"]]  \nlinelist %>% \n  get_summary_stats(\n    age, wt_kg, ht_cm, ct_blood, temp,  # columns to calculate for\n    type = \"common\")                    # summary stats to return## # A tibble: 5 x 10\n##   variable     n   min   max median   iqr  mean     sd    se    ci\n##   <chr>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\n## 1 age       5802   0    84     13      17  16.1 12.6   0.166 0.325\n## 2 ct_blood  5888  16    26     22       2  21.2  1.69  0.022 0.043\n## 3 ht_cm     5888   4   295    129      68 125.  49.5   0.645 1.26 \n## 4 temp      5739  35.2  40.8   38.8     1  38.6  0.977 0.013 0.025\n## 5 wt_kg     5888 -11   111     54      25  52.6 18.6   0.242 0.475"},{"path":"tables-descriptive.html","id":"tbl_janitor","chapter":"17 Bảng mô tả","heading":"17.3 janitor package","text":"Package janitor cung cấp hàm tabyl() giúp tạo ra các bảng đơn và bảng chéo, có thể được “tô điểm” hoặc sửa đổi bằng các hàm trợ giúp để hiển thị phần trăm, tỷ lệ, số đếm, v.v.Sau đây, chúng ta sẽ pipe linelist data frame tới các hàm của janitor và kết quả. Nếu muốn, bạn cũng có thể lưu các bảng kết quả bằng toán tử gán <-.","code":""},{"path":"tables-descriptive.html","id":"tabyl-đơn-giản","chapter":"17 Bảng mô tả","heading":"tabyl đơn giản","text":"Cách sử dụng mặc định của hàm tabyl() trên một cột cụ thể tạo ra các giá trị duy nhất, số lượng và “phần trăm” (tỷ lệ thực tế) theo cột. Tỷ lệ có thể có nhiều chữ số thập phân. Bạn có thể điều chỉnh số lượng số thập phân với hàm adorn_rounding() như được mô tả bên dưới.Như bạn có thể thấy ở trên, các giá trị missing sẽ được hiển thị trong một hàng có nhãn <NA>. Bạn có thể ngăn điều này bằng cách thêm show_na = FALSE. Nếu không có giá trị missing, hàng này sẽ không xuất hiện. Nếu có giá trị missing, tất cả các tỷ lệ sẽ được trình bày dưới dạng thô (mẫu số bao gồm cả NA) và “hợp lý” (mẫu số không bao gồm NA).Nếu giá trị cột là dạng Factor và chỉ một vài level nhất định có trong dữ liệu của bạn, thì tất cả các level sẽ vẫn xuất hiện trong bảng. Bạn có thể loại bỏ tính năng này bằng cách thêm show_missing_levels = FALSE. Đọc thêm trong chương Factors.","code":"\nlinelist %>% tabyl(age_cat)##  age_cat    n     percent valid_percent\n##      0-4 1095 0.185971467   0.188728025\n##      5-9 1095 0.185971467   0.188728025\n##    10-14  941 0.159816576   0.162185453\n##    15-19  743 0.126188859   0.128059290\n##    20-29 1073 0.182235054   0.184936229\n##    30-49  754 0.128057065   0.129955188\n##    50-69   95 0.016134511   0.016373664\n##      70+    6 0.001019022   0.001034126\n##     <NA>   86 0.014605978            NA"},{"path":"tables-descriptive.html","id":"bảng-chéo","chapter":"17 Bảng mô tả","heading":"Bảng chéo","text":"Bảng chéo được tạo bằng cách thêm một hoặc nhiều cột vào hàm tabyl(). Lưu ý rằng bây giờ chỉ có số lượng được hiện thị - tỷ lệ và phần trăm có thể được thêm vào bằng các bước bổ sung sẽ được trình bày bên dưới.","code":"\nlinelist %>% tabyl(age_cat, gender)##  age_cat   f   m NA_\n##      0-4 640 416  39\n##      5-9 641 412  42\n##    10-14 518 383  40\n##    15-19 359 364  20\n##    20-29 468 575  30\n##    30-49 179 557  18\n##    50-69   2  91   2\n##      70+   0   5   1\n##     <NA>   0   0  86"},{"path":"tables-descriptive.html","id":"tbl_adorn","chapter":"17 Bảng mô tả","heading":"“Tô điểm” cho tabyl","text":"Sử dụng các hàm “tô điểm” của janitor để thêm tổng hoặc chuyển đổi thành tỷ lệ, phần trăm hoặc điều chỉnh hiển thị. Thông thường, bạn sẽ pipe tabyl thông qua một số hàm này..Hãy cẩn trọng về thứ tự bạn áp dụng các hàm trên. Dưới đây là một số ví dụ.Bảng một chiều đơn giản với phần trăm thay vì tỷ lệ mặc định.Bảng chéo với tổng hàng và phần trăm hàng.Bảng chéo được điều chỉnh để cả số lượng và phần trăm đều được hiển thị.","code":"\nlinelist %>%               # case linelist\n  tabyl(age_cat) %>%       # tabulate counts and proportions by age category\n  adorn_pct_formatting()   # convert proportions to percents##  age_cat    n percent valid_percent\n##      0-4 1095   18.6%         18.9%\n##      5-9 1095   18.6%         18.9%\n##    10-14  941   16.0%         16.2%\n##    15-19  743   12.6%         12.8%\n##    20-29 1073   18.2%         18.5%\n##    30-49  754   12.8%         13.0%\n##    50-69   95    1.6%          1.6%\n##      70+    6    0.1%          0.1%\n##     <NA>   86    1.5%             -\nlinelist %>%                                  \n  tabyl(age_cat, gender) %>%                  # counts by age and gender\n  adorn_totals(where = \"row\") %>%             # add total row\n  adorn_percentages(denominator = \"row\") %>%  # convert counts to proportions\n  adorn_pct_formatting(digits = 1)            # convert proportions to percents##  age_cat     f     m    NA_\n##      0-4 58.4% 38.0%   3.6%\n##      5-9 58.5% 37.6%   3.8%\n##    10-14 55.0% 40.7%   4.3%\n##    15-19 48.3% 49.0%   2.7%\n##    20-29 43.6% 53.6%   2.8%\n##    30-49 23.7% 73.9%   2.4%\n##    50-69  2.1% 95.8%   2.1%\n##      70+  0.0% 83.3%  16.7%\n##     <NA>  0.0%  0.0% 100.0%\n##    Total 47.7% 47.6%   4.7%\nlinelist %>%                                  # case linelist\n  tabyl(age_cat, gender) %>%                  # cross-tabulate counts\n  adorn_totals(where = \"row\") %>%             # add a total row\n  adorn_percentages(denominator = \"col\") %>%  # convert to proportions\n  adorn_pct_formatting() %>%                  # convert to percents\n  adorn_ns(position = \"front\") %>%            # display as: \"count (percent)\"\n  adorn_title(                                # adjust titles\n    row_name = \"Age Category\",\n    col_name = \"Gender\")##                      Gender                           \n##  Age Category             f             m          NA_\n##           0-4  640  (22.8%)  416  (14.8%)  39  (14.0%)\n##           5-9  641  (22.8%)  412  (14.7%)  42  (15.1%)\n##         10-14  518  (18.5%)  383  (13.7%)  40  (14.4%)\n##         15-19  359  (12.8%)  364  (13.0%)  20   (7.2%)\n##         20-29  468  (16.7%)  575  (20.5%)  30  (10.8%)\n##         30-49  179   (6.4%)  557  (19.9%)  18   (6.5%)\n##         50-69    2   (0.1%)   91   (3.2%)   2   (0.7%)\n##           70+    0   (0.0%)    5   (0.2%)   1   (0.4%)\n##          <NA>    0   (0.0%)    0   (0.0%)  86  (30.9%)\n##         Total 2807 (100.0%) 2803 (100.0%) 278 (100.0%)"},{"path":"tables-descriptive.html","id":"in-với-tabyl","chapter":"17 Bảng mô tả","heading":"In với tabyl","text":"Theo mặc định, lệnh tabyl sẽ kết quả thô vào R console của bạn.Ngoài ra, bạn có thể chuyển tabyl sang flextable hoặc package tương tự để dưới dạng hình ảnh “đẹp” trong RStudio Viewer, có thể được xuất dưới dạng .png, .jpeg, .html, v.v. Điều này đã được thảo luận trong chương Trình bày bảng . Lưu ý rằng nếu theo cách này và sử dụng adorn_titles(), bạn cần thêm vào placement = \"combined\".Age Category/GenderfmNA_Total0-4640 (22.8%)416 (14.8%)39 (14.0%)1095 (18.6%)5-9641 (22.8%)412 (14.7%)42 (15.1%)1095 (18.6%)10-14518 (18.5%)383 (13.7%)40 (14.4%) 941 (16.0%)15-19359 (12.8%)364 (13.0%)20  (7.2%) 743 (12.6%)20-29468 (16.7%)575 (20.5%)30 (10.8%)1073 (18.2%)30-49179  (6.4%)557 (19.9%)18  (6.5%) 754 (12.8%)50-69  2  (0.1%) 91  (3.2%) 2  (0.7%)  95  (1.6%)70+  0  (0.0%)  5  (0.2%) 1  (0.4%)   6  (0.1%)  0  (0.0%)  0  (0.0%)86 (30.9%)  86  (1.5%)","code":"\nlinelist %>%\n  tabyl(age_cat, gender) %>% \n  adorn_totals(where = \"col\") %>% \n  adorn_percentages(denominator = \"col\") %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\") %>% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %>% # this is necessary to print as image\n  flextable::flextable() %>%    # convert to pretty image\n  flextable::autofit()          # format to one line per row "},{"path":"tables-descriptive.html","id":"sử-dụng-trên-các-bảng-khác","chapter":"17 Bảng mô tả","heading":"Sử dụng trên các bảng khác","text":"Bạn có thể sử dụng các hàmadorn_*() của janitor lên các bảng khác, chẳng hạn các bảng được tạo bởi hàm summarise() và count() của dplyr, hoặc table() từ base R. Đơn giản chỉ cần pipe bảng đến hàm mong muốn của package janitor. Ví dụ:","code":"\nlinelist %>% \n  count(hospital) %>%   # dplyr function\n  adorn_totals()        # janitor function##                              hospital    n\n##                      Central Hospital  454\n##                     Military Hospital  896\n##                               Missing 1469\n##                                 Other  885\n##                         Port Hospital 1762\n##  St. Mark's Maternity Hospital (SMMH)  422\n##                                 Total 5888"},{"path":"tables-descriptive.html","id":"lưu-với-tabyl","chapter":"17 Bảng mô tả","heading":"Lưu với tabyl","text":"Nếu bạn muốn chuyển đổi bảng thành một hình ảnh “đẹp” với package flextable, bạn có thể lưu nó bằng các hàm như save_as_html(), save_as_word(), save_as_ppt(), và save_as_image() từ package flextable (sẽ được bàn luận kỹ hơn ở chương Trình bày bảng). Ví dụ dưới đây, bảng được lưu lại dưới dạng tệp Word, và có khả năng chỉnh sửa được.","code":"\nlinelist %>%\n  tabyl(age_cat, gender) %>% \n  adorn_totals(where = \"col\") %>% \n  adorn_percentages(denominator = \"col\") %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\") %>% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %>% \n  flextable::flextable() %>%                     # convert to image\n  flextable::autofit() %>%                       # ensure only one line per row\n  flextable::save_as_docx(path = \"tabyl.docx\")   # save as Word document to filepath"},{"path":"tables-descriptive.html","id":"janitor_age_out_stats","chapter":"17 Bảng mô tả","heading":"Thống kê","text":"Bạn có thể áp dụng các kiểm định thống kê bằng tabyls, ví dụ như chisq.test() hoặc fisher.test() từ package stats, như được trình bày dưới đây. Chú ý là giá trị missing không được cho phép vì vậy chúng được loại bỏ khỏi tabyl bằng tùy chọn show_na = FALSE.Xem chương Các kiểm định thống kê cơ bản để có thêm code và các mẹo liên quan đến thống kê.","code":"\nage_by_outcome <- linelist %>% \n  tabyl(age_cat, outcome, show_na = FALSE) \n\nchisq.test(age_by_outcome)## \n##  Pearson's Chi-squared test\n## \n## data:  age_by_outcome\n## X-squared = 6.4931, df = 7, p-value = 0.4835"},{"path":"tables-descriptive.html","id":"các-mẹo-khác","chapter":"17 Bảng mô tả","heading":"Các mẹo khác","text":"Thêm đối số na.rm = TRUE để loại bỏ các giá trị missing.Nếu áp dụng bất kỳ hàm trợ giúp adorn_*() nào cho các bảng không được tạo bởi tabyl(), bạn có thể chỉ định (các) cột cụ thể để áp dụng chúng chẳng hạn như adorn_percentage(,,,c(cases,deaths)) (chỉ định chúng cho đối số không tên thứ 4). Thay vào đó, hãy cân nhắc sử dụng hàm summarise().Bạn có thể tìm đọc thêm ở janitor page và tabyl vignette.","code":""},{"path":"tables-descriptive.html","id":"dplyr-package","chapter":"17 Bảng mô tả","heading":"17.4 dplyr package","text":"dplyr là một phần của package tidyverse và là một công cụ quản lý dữ liệu rất phổ biến. Tạo bảng với các hàm của dplyr như summarise() và count() là một cách tiếp cận hữu ích để tính toán các tóm tắt thống kê, tổng hợp theo nhóm, hoặc chuyển bảng tới ggplot().summarise() tạo một data frame tổng hợp mới. Nếu dữ liệu được tách nhóm, nó sẽ trả về data frame có một hàng với thống kê tóm tắt được chỉ định cho toàn bộ data frame. Nếu dữ liệu được nhóm lại, data frames sẽ có một hàng cho từng nhóm (xem chương Nhóm dữ liệu).Bên trong dấu ngoặc đơn của hàm summarise(), bạn sẽ cung cấp tên của từng cột cần tổng hợp mới, theo sau là dấu bằng và một hàm thống kê để áp dụng.MẸO: Hàm summarise hoạt động được với cả cách viết Anh-Anh và Anh-Mỹ (summarise() và summarize()).","code":""},{"path":"tables-descriptive.html","id":"lấy-số-lượng","chapter":"17 Bảng mô tả","heading":"Lấy số lượng","text":"Hàm đơn giản nhất để áp dụng cùng với hàm summarise() là n(). Để trống dấu ngoặc đơn để đếm số hàng.Điều này sẽ thú vị hơn nếu chúng ta đã nhóm dữ liệu trước đó.Lệnh trên có thể được rút ngắn bằng cách sử dụng hàmcount() thay thế. count() làm những việc sau:Nhóm dữ liệu theo các cột được cung cấp cho nóTổng hợp chúng với n() (tạo cột n)Tách nhóm dữ liệuBạn có thể thay đổi tên của cột đếm từ mặc định là n thành một cái gì đó cụ thể chẳng hạn như name =.Tạo bảng đếm cho hai hoặc nhiều cột sẽ vẫn trả về địng dạng “dọc”, với số lượng ở cột n. Xem chương [Pivoting dữ liệu] để hiểu thêm về định dạng dữ liệu “dọc” và “ngang”.","code":"\nlinelist %>%                 # begin with linelist\n  summarise(n_rows = n())    # return new summary dataframe with column n_rows##   n_rows\n## 1   5888\nlinelist %>% \n  group_by(age_cat) %>%     # group data by unique values in column age_cat\n  summarise(n_rows = n())   # return number of rows *per group*## # A tibble: 9 x 2\n##   age_cat n_rows\n##   <fct>    <int>\n## 1 0-4       1095\n## 2 5-9       1095\n## 3 10-14      941\n## 4 15-19      743\n## 5 20-29     1073\n## 6 30-49      754\n## 7 50-69       95\n## 8 70+          6\n## 9 <NA>        86\nlinelist %>% \n  count(age_cat)##   age_cat    n\n## 1     0-4 1095\n## 2     5-9 1095\n## 3   10-14  941\n## 4   15-19  743\n## 5   20-29 1073\n## 6   30-49  754\n## 7   50-69   95\n## 8     70+    6\n## 9    <NA>   86\nlinelist %>% \n  count(age_cat, outcome)##    age_cat outcome   n\n## 1      0-4   Death 471\n## 2      0-4 Recover 364\n## 3      0-4    <NA> 260\n## 4      5-9   Death 476\n## 5      5-9 Recover 391\n## 6      5-9    <NA> 228\n## 7    10-14   Death 438\n## 8    10-14 Recover 303\n## 9    10-14    <NA> 200\n## 10   15-19   Death 323\n## 11   15-19 Recover 251\n## 12   15-19    <NA> 169\n## 13   20-29   Death 477\n## 14   20-29 Recover 367\n## 15   20-29    <NA> 229\n## 16   30-49   Death 329\n## 17   30-49 Recover 238\n## 18   30-49    <NA> 187\n## 19   50-69   Death  33\n## 20   50-69 Recover  38\n## 21   50-69    <NA>  24\n## 22     70+   Death   3\n## 23     70+ Recover   3\n## 24    <NA>   Death  32\n## 25    <NA> Recover  28\n## 26    <NA>    <NA>  26"},{"path":"tables-descriptive.html","id":"hiện-tất-cả-các-cấp-độ","chapter":"17 Bảng mô tả","heading":"Hiện tất cả các cấp độ","text":"Nếu bạn tạo bảng cho một cột có kiểu dữ liệu là factor, bạn có thể chắc chắng rằng tất cả các cấp độ được trình bày (không chỉ các cấp có giá trị trong dữ liệu) bằng cách thêm .drop = FALSE vào lệnh summarise() hoặc count().Kỹ thuật này rất hữu ích để chuẩn hóa các bảng/biểu đồ của bạn. Ví dụ: nếu bạn đang tạo số liệu cho nhiều nhóm con, hoặc liên tục tạo số liệu cho các báo cáo thường quy. Trong các trường hợp này, sự hiện diện của các giá trị trong dữ liệu có thể dao động, nhưng bạn có thể xác định các mức không đổi.Xem chương Factors để có nhiều thông tin hơn.","code":""},{"path":"tables-descriptive.html","id":"tbl_dplyr_prop","chapter":"17 Bảng mô tả","heading":"Tỷ lệ","text":"Tỷ lệ có thể được thêm vào bằng cách piping bảng tới hàm mutate() để tạo một cột mới. Định nghĩa cột mới là thương của số quan sát của từng yếu tố (mặc định là n) và tổng số quan sát sum() của cột (sẽ trả về giá trị là một tỷ lệ).Lưu ý trong trường hợp này, sum() trong lệnh mutate() sẽ trả về giá trị của toàn bộ cột n để dùng làm mẫu số của tỷ lệ. Như đã được giải thích trong chương Nhóm dữ liệu, nếu sum() được sử dụng với dữ liệu đã được nhóm (vd: nếu hàm mutate() được theo ngay phía sai hàm group_by()), nó sẽ trả về kết quả tổng hợp theo nhóm. Như đã nếu ở trên, count() hoàn thành nhiệm vụ của mình bằng cách tách nhóm. Vì vậy, trong trường hợp này chúng ta sẽ lấy toàn bộ tỷ lệ của cột.Để dễ dàng hiển thị phần trăm, bạn có thể đưa tỷ lệ vào trong hàm percent() từ package scales (lưu ý là điều nãy sẽ chuyển kết quả thành dạng ký tự (character)).Dưới đây là phương pháp tính tỷ lệ trong nhóm. Nó dựa trên các cấp độ nhóm dữ liệu khác nhau được áp dụng và loại bỏ một cách có chọn lọc. Đầu tiên, dữ liệu được nhóm theo outcome thông qua hàm group_by(). Sau đó, hàm count() được áp dụng. Hàm này sẽ tiếp tục nhóm dữ liệu phân theo age_cat và trả vế số lượng theo từng tổ hợp outcome-age-cat. Quan trọng là - khi nó kết thúc quy trình của mình, hàm count() sẽ tách nhóm theo age_cat, nên nhóm dữ liệu duy nhất còn lại là nhóm ban đầu theo outcome. đó, bước cuối cùng để tính toán tỷ lệ (mẫu số là sum(n)) vẫn được nhóm theo outcome.","code":"\nage_summary <- linelist %>% \n  count(age_cat) %>%                     # group and count by gender (produces \"n\" column)\n  mutate(                                # create percent of column - note the denominator\n    percent = scales::percent(n / sum(n))) \n\n# print\nage_summary##   age_cat    n percent\n## 1     0-4 1095  18.60%\n## 2     5-9 1095  18.60%\n## 3   10-14  941  15.98%\n## 4   15-19  743  12.62%\n## 5   20-29 1073  18.22%\n## 6   30-49  754  12.81%\n## 7   50-69   95   1.61%\n## 8     70+    6   0.10%\n## 9    <NA>   86   1.46%\nage_by_outcome <- linelist %>%                  # begin with linelist\n  group_by(outcome) %>%                         # group by outcome \n  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping\n  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group"},{"path":"tables-descriptive.html","id":"vẽ-biểu-đồ","chapter":"17 Bảng mô tả","heading":"Vẽ biểu đồ","text":"Để hiển thị kết quả từ một bảng “dài” như trên thì vẽ biểu đồ bằng hàm ggplot() tương đối trực quan. Dữ liệu một cách tự nhiên có định dạng “dọc”, nên tương thích với ggplot() một cách tự nhiên. Xem thêm các ví dụ ở chương ggplot cơ bản và Các tips với ggplot.","code":"\nlinelist %>%                      # begin with linelist\n  count(age_cat, outcome) %>%     # group and tabulate counts by two columns\n  ggplot()+                       # pass new data frame to ggplot\n    geom_col(                     # create bar plot\n      mapping = aes(   \n        x = outcome,              # map outcome to x-axis\n        fill = age_cat,           # map age_cat to the fill\n        y = n))                   # map the counts column `n` to the height"},{"path":"tables-descriptive.html","id":"tổng-hợp-thống-kê","chapter":"17 Bảng mô tả","heading":"Tổng hợp thống kê","text":"Một điểm mạnh của dplyr và summarise() là khả năng trả về các bảng tổng hợp thống kê nâng cao hơn như median(), mean(), max(), min(), sd() (độ lệch chuẩn), và phân vị. Bạn cũng có thể sử dụng sum() để trả vể số lượng dòng thỏa mãn một điều kiện logic nào đó. Như trên, các kết quả đầu ra này có thể được tạo cho toàn bộ data frame hoặc theo nhóm.Cú pháp là tương tự- bên trong dấu ngoặc hàm summarise() bạn cung cấp tên của từng cột tổng hợp được theo sau bởi dâu bằng và hàm thống kê được áp dụng. Trong hàm thống kê, cung cấp (các) cột sẽ được tính toán và bất kỳ các đối số có liên quan (vd: na.rm = TRUE cho tất cả các hàm toán học).Bạn cũng có thể sử dụng hàm sum() để trả vể số lượng dòng thỏa mãn một điều kiện logic cụ thể. Biểu thức điều kiện sẽ được đếm nếu nó được đánh giá là TRUE. Ví dụ:sum(age_years < 18, na.rm=T)sum(gender == \"male\", na.rm=T)sum(response %% c(\"Likely\", \"Likely\"))Dưới đây, bộ dữ liệu linelist được tổng hợp để mô tả những ngày trì hoãn từ khi bắt đầu có triệu chứng đến khi nhập viện (cột days_onset_hosp), phân theo bệnh viện.Một vài mẹp:Sử dụng sum() với một biểu thức logic để “đếm” các dòng đáp ứng các tiêu chí nhất định (==)Sử dụng sum() với một biểu thức logic để “đếm” các dòng đáp ứng các tiêu chí nhất định (==)Lưu ý cách sử dụng của na.rm = TRUE bên trong biểu thức toán học như là sum(), nếu không NA sẽ được trả lại nếu dữ liệu có giá trị missingLưu ý cách sử dụng của na.rm = TRUE bên trong biểu thức toán học như là sum(), nếu không NA sẽ được trả lại nếu dữ liệu có giá trị missingSử dụng hàm percent() từ package scales để dễ dàng chuyển đổi tỷ lệ phần trăm\nThiết lập accuracy = bằng 0.1 hoặc 0.01 để đảm bảo kết quả hiển thị 1 hoặc 2 chữ số thập phân sau dấ phẩy\nSử dụng hàm percent() từ package scales để dễ dàng chuyển đổi tỷ lệ phần trămThiết lập accuracy = bằng 0.1 hoặc 0.01 để đảm bảo kết quả hiển thị 1 hoặc 2 chữ số thập phân sau dấ phẩySử dụng hàm round() từ base R để chỉ định số thập phânSử dụng hàm round() từ base R để chỉ định số thập phânĐể tính toán các thống kê này trên toàn bộ tập dữ liệu, sử dụng summarise() và không có group_by()Để tính toán các thống kê này trên toàn bộ tập dữ liệu, sử dụng summarise() và không có group_by()Bạn có thể tạo các cột cho các mục đích tính toán sau này (ví dụ: mẫu số) mà thậm chí bạn bỏ ra khỏi data frame của mình với hàm select().Bạn có thể tạo các cột cho các mục đích tính toán sau này (ví dụ: mẫu số) mà thậm chí bạn bỏ ra khỏi data frame của mình với hàm select().","code":"\nsummary_table <- linelist %>%                                        # begin with linelist, save out as new object\n  group_by(hospital) %>%                                             # group all calculations by hospital\n  summarise(                                                         # only the below summary columns will be returned\n    cases       = n(),                                                # number of rows per group\n    delay_max   = max(days_onset_hosp, na.rm = T),                    # max delay\n    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # mean delay, rounded\n    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # standard deviation of delays, rounded\n    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # number of rows with delay of 3 or more days\n    pct_delay_3 = scales::percent(delay_3 / cases)                    # convert previously-defined delay column to percent \n  )\n\nsummary_table  # print## # A tibble: 6 x 7\n##   hospital                             cases delay_max delay_mean delay_sd delay_3 pct_delay_3\n##   <chr>                                <int>     <dbl>      <dbl>    <dbl>   <int> <chr>      \n## 1 Central Hospital                       454        12        1.9      1.9     108 24%        \n## 2 Military Hospital                      896        15        2.1      2.4     253 28%        \n## 3 Missing                               1469        22        2.1      2.3     399 27%        \n## 4 Other                                  885        18        2        2.2     234 26%        \n## 5 Port Hospital                         1762        16        2.1      2.2     470 27%        \n## 6 St. Mark's Maternity Hospital (SMMH)   422        18        2.1      2.3     116 27%"},{"path":"tables-descriptive.html","id":"thống-kê-có-điều-kiện","chapter":"17 Bảng mô tả","heading":"Thống kê có điều kiện","text":"Bạn có thể sẽ muốn trả về các thống kê có điều kiện - vd: số hàng tối đa đáp ứng các tiêu chí nhất định. Điều này có thể thực hiện được bằng cáhc subsetting cột bằng dấu ngoặc vuông [ ]. Ví dụ dưới đây trả về nhiệt độ tối đa cho những bệnh nhân được phân loại là có hoặc không bị sốt. Tuy nhiên hãy lưu ý - có thể thích hợp hơn nếu thêm một cột khác vào hàm group_by() và pivot_wider() (như được minh họa dưới đây).","code":"\nlinelist %>% \n  group_by(hospital) %>% \n  summarise(\n    max_temp_fvr = max(temp[fever == \"yes\"], na.rm = T),\n    max_temp_no = max(temp[fever == \"no\"], na.rm = T)\n  )## # A tibble: 6 x 3\n##   hospital                             max_temp_fvr max_temp_no\n##   <chr>                                       <dbl>       <dbl>\n## 1 Central Hospital                             40.4        38  \n## 2 Military Hospital                            40.5        38  \n## 3 Missing                                      40.6        38  \n## 4 Other                                        40.8        37.9\n## 5 Port Hospital                                40.6        38  \n## 6 St. Mark's Maternity Hospital (SMMH)         40.6        37.9"},{"path":"tables-descriptive.html","id":"gắn-với-nhau","chapter":"17 Bảng mô tả","heading":"Gắn với nhau","text":"Hàm str_glue() từ package stringr rất hữu ích để kết hợp các giá trị từ một số cột thành một cột mới. Trong trường hợp này nó được sử dụng sau hàm summarise().Trong chương Ký tự và chuỗi, có nhiều lựa chọn khác nhau để kết hợp các cột được thảo luận, bao gồm cả unite(), và paste0(). Trong trường hợp sử dụng này, chúng tôi ủng hộ str_glue() bởi vì nó linh hoạt hơn unite() và có cú pháp đơn giẩn hơn paste0().Dưới đây, data frame summary_table (được tạo bên trên) được biến đổi để kết hợp cột delay_mean và delay_sd, định dạng dấu ngoặc đơn được thêm vào cột mới, và các cột cũ tương ứng của chúng bị xóa.Sau đó, để làm cho bảng dễ nhìn hơn, tổng hàng được thêm vào bằng hàm adorn_totals() từ janitor (bỏ qua các cột không phải số). Cuối cùng, chúng tôi sử dụng hàm select() từ dplyr để sắp xếp và đặt tên lại cho các cột.Bây giờ bạn có thể chuyển kết quả tới flextable và chúng thành bảng trong Word, .png, .jpeg, .html, Powerpoint, RMarkdown, v.v.! (xem chương Trình bày bảng).","code":"\nsummary_table %>% \n  mutate(delay = str_glue(\"{delay_mean} ({delay_sd})\")) %>%  # combine and format other values\n  select(-c(delay_mean, delay_sd)) %>%                       # remove two old columns   \n  adorn_totals(where = \"row\") %>%                            # add total row\n  select(                                                    # order and rename cols\n    \"Hospital Name\"   = hospital,\n    \"Cases\"           = cases,\n    \"Max delay\"       = delay_max,\n    \"Mean (sd)\"       = delay,\n    \"Delay 3+ days\"   = delay_3,\n    \"% delay 3+ days\" = pct_delay_3\n    )##                         Hospital Name Cases Max delay Mean (sd) Delay 3+ days % delay 3+ days\n##                      Central Hospital   454        12 1.9 (1.9)           108             24%\n##                     Military Hospital   896        15 2.1 (2.4)           253             28%\n##                               Missing  1469        22 2.1 (2.3)           399             27%\n##                                 Other   885        18   2 (2.2)           234             26%\n##                         Port Hospital  1762        16 2.1 (2.2)           470             27%\n##  St. Mark's Maternity Hospital (SMMH)   422        18 2.1 (2.3)           116             27%\n##                                 Total  5888       101         -          1580               -"},{"path":"tables-descriptive.html","id":"bách-phân-vị","chapter":"17 Bảng mô tả","heading":"Bách phân vị","text":"Bách phân vị và tứ phân vị trong dplyr xứng đáng được đề cập tới. Để trả về tứ phân vị, sử dụng quantile() với các giá trị mặc định hoặc chỉ rõ giá trị bạn muốn bằng đối số probs =.Nếu bạn muốn trả về phân vị theo nhóm, bạn có thể gặp phải các kết quả đầu ra dài và ít hữu ích hơn nếu bạn chỉ cần thêm cột vào group_by(). Thay vào đó, hãy thử cách tiếp cận này - tạo một cột cho mỗi mức phân vị mong muốn.Mặc dù dplyr summarise() chắc chắn cung cấp khả năng kiểm soát tốt hơn, bạn có thể thấy rằng tất cả các thống kê tổng hợp mà bạn cần có thể được tạo ra với hàm get_summary_stat() từ package rstatix. Nếu thực hiện trên dữ liệu đã được nhóm, nó sẽ trả về các phân vị 0%, 25%, 50%, 75%, và 100%. applied ungrouped data, can specify percentiles probs = c(.05, .5, .75, .98).","code":"\n# get default percentile values of age (0%, 25%, 50%, 75%, 100%)\nlinelist %>% \n  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))##   age_percentiles\n## 1               0\n## 2               6\n## 3              13\n## 4              23\n## 5              84\n# get manually-specified percentile values of age (5%, 50%, 75%, 98%)\nlinelist %>% \n  summarise(\n    age_percentiles = quantile(\n      age_years,\n      probs = c(.05, 0.5, 0.75, 0.98), \n      na.rm=TRUE)\n    )##   age_percentiles\n## 1               1\n## 2              13\n## 3              23\n## 4              48\n# get manually-specified percentile values of age (5%, 50%, 75%, 98%)\nlinelist %>% \n  group_by(hospital) %>% \n  summarise(\n    p05 = quantile(age_years, probs = 0.05, na.rm=T),\n    p50 = quantile(age_years, probs = 0.5, na.rm=T),\n    p75 = quantile(age_years, probs = 0.75, na.rm=T),\n    p98 = quantile(age_years, probs = 0.98, na.rm=T)\n    )## # A tibble: 6 x 5\n##   hospital                               p05   p50   p75   p98\n##   <chr>                                <dbl> <dbl> <dbl> <dbl>\n## 1 Central Hospital                         1    12    21  48  \n## 2 Military Hospital                        1    13    24  45  \n## 3 Missing                                  1    13    23  48.2\n## 4 Other                                    1    13    23  50  \n## 5 Port Hospital                            1    14    24  49  \n## 6 St. Mark's Maternity Hospital (SMMH)     2    12    22  50.2\nlinelist %>% \n  group_by(hospital) %>% \n  rstatix::get_summary_stats(age, type = \"quantile\")## `mutate_if()` ignored the following grouping variables:\n## Column `variable`\n## `mutate_if()` ignored the following grouping variables:\n## Column `variable`\n## `mutate_if()` ignored the following grouping variables:\n## Column `variable`\n## `mutate_if()` ignored the following grouping variables:\n## Column `variable`\n## `mutate_if()` ignored the following grouping variables:\n## Column `variable`\n## `mutate_if()` ignored the following grouping variables:\n## Column `variable`## # A tibble: 6 x 8\n##   hospital                             variable     n  `0%` `25%` `50%` `75%` `100%`\n##   <chr>                                <chr>    <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\n## 1 Central Hospital                     age        445     0     6    12    21     58\n## 2 Military Hospital                    age        884     0     6    14    24     72\n## 3 Missing                              age       1441     0     6    13    23     76\n## 4 Other                                age        873     0     6    13    23     69\n## 5 Port Hospital                        age       1739     0     6    14    24     68\n## 6 St. Mark's Maternity Hospital (SMMH) age        420     0     7    12    22     84\nlinelist %>% \n  rstatix::get_summary_stats(age, type = \"quantile\")## `mutate_if()` ignored the following grouping variables:\n## Column `variable`## # A tibble: 1 x 7\n## # Groups:   variable [1]\n##   variable     n  `0%` `25%` `50%` `75%` `100%`\n##   <chr>    <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>\n## 1 age       5802     0     6    13    23     84"},{"path":"tables-descriptive.html","id":"tóm-tắt-dữ-liệu-tổng-hợp","chapter":"17 Bảng mô tả","heading":"Tóm tắt dữ liệu tổng hợp","text":"Nếu bạn bắt đầu với dữ liệu tổng hợp (aggregated data), sử dụng n() để trả về số lượng các dòng, không phải là tổng của các số lượng được đếm. Để lấy tổng, sử dụng sum() trên cột của dữ liệu đếm.Ví dụ, giả sử bạn đang bắt đầu với data frame đếm số lượng như bên dưới, gọi là linelist_agg - nó hiển thị ở định dạng “dọc”, các trường hợp được tính theo outcome và giới tính.Sau đây chúng ta sẽ tạo data frame minh hoạt số trường hợp của linelist được đếm theo outcome và gender (các giá trị missing được loại bỏ để rõ ràng).Để tính tổng số lượng (trong cột n) theo nhóm bạn có thể sử dụng hàm summarise() nhưng đặt cột mới bằng sum(n, na.rm=T). Để thêm phần tử điều kiện vào phép toán tổng, bạn có thể sử dụng cú pháp dấu ngoặc vuông tập hợp con [ ] trên cột đếm.","code":"\nlinelist_agg <- linelist %>% \n  drop_na(gender, outcome) %>% \n  count(outcome, gender)\n\nlinelist_agg##   outcome gender    n\n## 1   Death      f 1227\n## 2   Death      m 1228\n## 3 Recover      f  953\n## 4 Recover      m  950\nlinelist_agg %>% \n  group_by(outcome) %>% \n  summarise(\n    total_cases  = sum(n, na.rm=T),\n    male_cases   = sum(n[gender == \"m\"], na.rm=T),\n    female_cases = sum(n[gender == \"f\"], na.rm=T))## # A tibble: 2 x 4\n##   outcome total_cases male_cases female_cases\n##   <chr>         <int>      <int>        <int>\n## 1 Death          2455       1228         1227\n## 2 Recover        1903        950          953"},{"path":"tables-descriptive.html","id":"across-trên-nhiều-cột","chapter":"17 Bảng mô tả","heading":"across() trên nhiều cột","text":"Bạn có thể sử dụng summarise() trên nhiều cột bằng hàm across(). Điều này làm cho mọi thứ dễ dàng hơn khi bạn muốn tính toán các thống kê giống nhau cho nhiều cột. Đặt across() bên trong summarise() và chỉ rõ những điều sau:.cols = tên cột viết dưới dạng vector c() hoặc sử dụng các hàm trợ giúp chọn cột “tidyselect” (được giải thích bên dưới).fns = hàm thực hiện (không có dấu ngoặc) - bạn có thể đưa nhiều hàm vào thông qua list()Ví dụ dưới đây, mean() được áp dụng cho các cột dữ liệu dạng số. Một vectơ tên của các cột được gán cho .cols = và hàm duy nhất mean được xác định (không có dấu ngoặc) cho .fns =. Bất kỳ đối số bổ sung nào cho hàm (vd: na.rm=TRUE) được cung cấp phía sau .fns =, ngăn cách bởi dấu phẩy.Có thể khó để hiểu được thứ tự của dấu ngoặc đơn và dấu phẩy chính xác khi sử dụng across(). Hãy nhớ là bên trong hàm across() bạn phải bao gồm các cột, các hàm, và tất cả những đối số cần thiết cho các hàm.Nhiều hàm có thể được chạy cùng một lúc. Dưới đây hàm mean và sd được cung cấp cho .fns = bên trong một list(). Bạn có cơ hội cung cấp tên ký tự (vd: “mean” và “sd”) để thêm vào tên các cột mới.Dưới đây là danh sách các hàm trợ giúp “tidyselect” bạn có thể cung cấp cho .cols = để lựa chọn cột:everything() - tất cả các cột khác không được đề cậplast_col() - cột cuối cùngwhere() - áp dụng một hàm cho tất cả các cột và chọn những cột trả về giá trị TRUEstarts_with() - khớp với một tiền tố được chỉ định. Ví dụ: starts_with(\"date\")ends_with() - khớp với một hậu tố được chỉ định. Ví dụ: ends_with(\"_end\")contains() - cột chứa một chuỗi ký tự. Ví dụ: contains(\"time\")matches() - áp dụng một biểu thức chính quy (regex). Ví dụ: contains(\"[pt]al\")num_range() - khoảng giá trị sốany_of() - khớp nếu cột được đặt tên. Hữu ích nếu tên có thể không tồn tại. Ví dụ: any_of(date_onset, date_death, cardiac_arrest)Ví dụ, để trả về giá trị trung bình của tất cả các cột dạng số, sử dụng () và thêm vào hàm .numeric() (không có dấu ngoặc). Tất cả những thứ này vẫn được đặt trong hàm across().","code":"\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # columns\n                   .fns = mean,                               # function\n                   na.rm=T))                                  # extra arguments## # A tibble: 3 x 5\n##   outcome age_years  temp wt_kg ht_cm\n##   <chr>       <dbl> <dbl> <dbl> <dbl>\n## 1 Death        15.9  38.6  52.6  125.\n## 2 Recover      16.1  38.6  52.5  125.\n## 3 <NA>         16.2  38.6  53.0  125.\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # columns\n                   .fns = list(\"mean\" = mean, \"sd\" = sd),    # multiple functions \n                   na.rm=T))                                 # extra arguments## # A tibble: 3 x 9\n##   outcome age_years_mean age_years_sd temp_mean temp_sd wt_kg_mean wt_kg_sd ht_cm_mean ht_cm_sd\n##   <chr>            <dbl>        <dbl>     <dbl>   <dbl>      <dbl>    <dbl>      <dbl>    <dbl>\n## 1 Death             15.9         12.3      38.6   0.962       52.6     18.4       125.     48.7\n## 2 Recover           16.1         13.0      38.6   0.997       52.5     18.6       125.     50.1\n## 3 <NA>              16.2         12.8      38.6   0.976       53.0     18.9       125.     50.4\nlinelist %>% \n  group_by(outcome) %>% \n  summarise(across(\n    .cols = where(is.numeric),  # all numeric columns in the data frame\n    .fns = mean,\n    na.rm=T))## # A tibble: 3 x 12\n##   outcome generation   age age_years   lon   lat wt_kg ht_cm ct_blood  temp   bmi days_onset_hosp\n##   <chr>        <dbl> <dbl>     <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl> <dbl> <dbl>           <dbl>\n## 1 Death         16.7  15.9      15.9 -13.2  8.47  52.6  125.     21.3  38.6  45.6            1.84\n## 2 Recover       16.4  16.2      16.1 -13.2  8.47  52.5  125.     21.1  38.6  47.7            2.34\n## 3 <NA>          16.5  16.3      16.2 -13.2  8.47  53.0  125.     21.2  38.6  48.3            2.07"},{"path":"tables-descriptive.html","id":"tbls_pivot_wider","chapter":"17 Bảng mô tả","heading":"Xoay trục ngang (Pivot wider)","text":"Nếu bạn thích bảng của mình ở định dạng “rộng”, bạn có thể biến đổi nó sử dụng hàm tidyr pivot_wider(). Bạn có thể sẽ cần đặt lại tên cho các cột bằng rename(). Để tìm hiểu thêm, vui lòng xem chương [Pivoting dữ liệu].Ví dụ sau đây bắt đầu bằng một bảng “dài” age_by_outcome từ mục Tỷ lệ. Để dễ hình dung, chúng ta tạo lại bảng và ra:Để xoay trục ngang, chúng ta tạo các cột mới từ các giá trị trong cột hiện có age_cat (bằng cách đặt names_from = age_cat). Chúng ta cũng chỉ định rằng các giá trị bảng mới sẽ đến từ cột hiện có n, với values_from = n. Các cột không được đề cập trong lệnh pivoting (outcome) sẽ không thay đổi ở phía ngoài cùng bên trái.","code":"\nage_by_outcome <- linelist %>%                  # begin with linelist\n  group_by(outcome) %>%                         # group by outcome \n  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping\n  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group\nage_by_outcome %>% \n  select(-percent) %>%   # keep only counts for simplicity\n  pivot_wider(names_from = age_cat, values_from = n)  ## # A tibble: 3 x 10\n## # Groups:   outcome [3]\n##   outcome `0-4` `5-9` `10-14` `15-19` `20-29` `30-49` `50-69` `70+`  `NA`\n##   <chr>   <int> <int>   <int>   <int>   <int>   <int>   <int> <int> <int>\n## 1 Death     471   476     438     323     477     329      33     3    32\n## 2 Recover   364   391     303     251     367     238      38     3    28\n## 3 <NA>      260   228     200     169     229     187      24    NA    26"},{"path":"tables-descriptive.html","id":"tbl_dplyr_totals","chapter":"17 Bảng mô tả","heading":"Tổng các hàng","text":"Khi hàm summarise() vận hành trên dữ liệu đã được nhóm, nó không tính “tổng” một cách tự động. Sau đây là hai cách tiếp cận giúp bạn thêm tổng hàng:","code":""},{"path":"tables-descriptive.html","id":"janitors-adorn_totals","chapter":"17 Bảng mô tả","heading":"janitor’s adorn_totals()","text":"Nếu bảng của bạn chỉ chứa duy nhất số lượng hoặc tỷ lệ/tỷ lệ phần trăm có thể được tổng hợp thành một tổng, thì bạn có thể tính tổng sử dụng hàm adorn_totals() của package janitor như đã được mô tả bên trên. Lưu ý là hàm này chỉ có thể tính tổng của các cột định dạng là số - nếu bạn muốn tính các loại tổng khác, vui lòng xem cách tiếp cận tiếp theo bằng dplyr.Dưới đây, bộ dữ liệu linelist được nhóm theo giới và tóm tắt thành một bảng mô tả số trường hợp có outcome đã biết, tử vong và phục hồi. Piping bảng tới hàm adorn_totals() để thêm tổng các hàng ở hàng dưới cùng thể hiện giá trị tổng của từng cột. Các hàm adorn_*() khác điều chỉnh cách kết quả được hiển thị như được comment trong phần code.","code":"\nlinelist %>% \n  group_by(gender) %>%\n  summarise(\n    known_outcome = sum(!is.na(outcome)),           # Number of rows in group where outcome is not missing\n    n_death  = sum(outcome == \"Death\", na.rm=T),    # Number of rows in group where outcome is Death\n    n_recover = sum(outcome == \"Recover\", na.rm=T), # Number of rows in group where outcome is Recovered\n  ) %>% \n  adorn_totals() %>%                                # Adorn total row (sums of each numeric column)\n  adorn_percentages(\"col\") %>%                      # Get column proportions\n  adorn_pct_formatting() %>%                        # Convert proportions to percents\n  adorn_ns(position = \"front\")                      # display % and counts (with counts in front)##  gender known_outcome       n_death     n_recover\n##       f 2180  (47.8%) 1227  (47.5%)  953  (48.1%)\n##       m 2178  (47.7%) 1228  (47.6%)  950  (47.9%)\n##    <NA>  207   (4.5%)  127   (4.9%)   80   (4.0%)\n##   Total 4565 (100.0%) 2582 (100.0%) 1983 (100.0%)"},{"path":"tables-descriptive.html","id":"summarise-trên-dữ-liệu-tổng-rồi-sau-đó-bind_rows","chapter":"17 Bảng mô tả","heading":"summarise() trên dữ liệu “tổng” rồi sau đó bind_rows()","text":"Nếu bảng của bạn chứa các phép tính thống kế chẳng hạn như median(), mean(), v.v, thì cách tiếp cận dùng hàm adorn_totals() bên trên sẽ không đủ. Thay vào đó, để có được thống kê tóm tắt cho toàn bộ tập dữ liệu, bạn phải tính toán chúng bằng lệnh summarise() một cách độc lập sau đó gắn các kết quả này với bảng tổng hợp theo nhóm ban đầu. Để làm điều này, bạn có thể sử dụng hàm bind_rows() từ dplyr như được mô tả trong chương Nối dữ liệu. Dưới đây là một ví dụ:Bạn có thể tạo bảng tổng hợp của outcome theo bệnh viện với group_by() và summarise() như sau:Để tính tổng, vẫn sử dụng hàm summarise() nhưng chỉ nhóm dữ liệu theo outcome (không theo bệnh viện), như dưới đây:Bây giờ chúng ta có thể nối hai data frames này lại với nhau. Lưu ý là bảng by_hospital có 4 cột trong khi đó bảng kết quả totals có 3 cột. Bằng việc sử dụng bind_rows(), các cột được kết hợp theo tên, và bất kỳ khoảng trống nào sẽ được điền vào bằng giá trị NA (ví dụ ở cột hospital là các giá trị cho hai hàng totals mới). Sau khi gắn các hàng, chúng ta chuyển các khoảng trống đó thành “Tổng” bằng cách sử dụng replace_na() (xem chương Làm sạch số liệu và các hàm quan trọng).Đây là bảng mới với các hàng “Tổng” ở các hàng dưới cùng của bảng.Bảng này đang có định dạng “dài”, có thể là những gì bạn muốn. Tuy nhiên, bạn có thể xoay bảng này rộng hơn theo chiều ngang để dễ đọc. Xem thêm ở phần Xoay trục ngang (Pivot wider) bên trên, và chương Xoay trục dữ liệu. Bạn cũng có thêm nhiều cột nữa, và sắp xếp chúng một cách đẹp mắt. Phần code được trình bày bên dưới.Tiếp đó bạn có thể bảng kết quả dưới dạng một bức ảnh đẹp - sau đây là output được bằng flextable. Bạn có thể đọc chuyên sâu hơn về ví dụ này và cách tạo được bảng “đẹp” tương tự thế này trong chương Trình bày bảng.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nby_hospital <- linelist %>% \n  filter(!is.na(outcome) & hospital != \"Missing\") %>%  # Remove cases with missing outcome or hospital\n  group_by(hospital, outcome) %>%                      # Group data\n  summarise(                                           # Create new summary columns of indicators of interest\n    N = n(),                                            # Number of rows per hospital-outcome group     \n    ct_value = median(ct_blood, na.rm=T))               # median CT value per group\n  \nby_hospital # print table## # A tibble: 10 x 4\n## # Groups:   hospital [5]\n##    hospital                             outcome     N ct_value\n##    <chr>                                <chr>   <int>    <dbl>\n##  1 Central Hospital                     Death     193       22\n##  2 Central Hospital                     Recover   165       22\n##  3 Military Hospital                    Death     399       21\n##  4 Military Hospital                    Recover   309       22\n##  5 Other                                Death     395       22\n##  6 Other                                Recover   290       21\n##  7 Port Hospital                        Death     785       22\n##  8 Port Hospital                        Recover   579       21\n##  9 St. Mark's Maternity Hospital (SMMH) Death     199       22\n## 10 St. Mark's Maternity Hospital (SMMH) Recover   126       22\ntotals <- linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    \n      summarise(\n        N = n(),                                       # These statistics are now by outcome only     \n        ct_value = median(ct_blood, na.rm=T))\n\ntotals # print table## # A tibble: 2 x 3\n##   outcome     N ct_value\n##   <chr>   <int>    <dbl>\n## 1 Death    1971       22\n## 2 Recover  1469       22\ntable_long <- bind_rows(by_hospital, totals) %>% \n  mutate(hospital = replace_na(hospital, \"Total\"))\ntable_long %>% \n  \n  # Pivot wider and format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # Pivot from long to wide\n    values_from = c(ct_value, N),                       # new values are from ct and count columns\n    names_from = outcome) %>%                           # new column names are from outcomes\n  mutate(                                              # Add new columns\n    N_Known = N_Death + N_Recover,                               # number with known outcome\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)\n  select(                                              # Re-order columns\n    hospital, N_Known,                                   # Intro columns\n    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns\n  arrange(N_Known)                                  # Arrange rows from lowest to highest (Total row at bottom)## # A tibble: 6 x 8\n## # Groups:   hospital [6]\n##   hospital                             N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death ct_value_Death\n##   <chr>                                  <int>     <int> <chr>                  <dbl>   <int> <chr>              <dbl>\n## 1 St. Mark's Maternity Hospital (SMMH)     325       126 38.8%                     22     199 61.2%                 22\n## 2 Central Hospital                         358       165 46.1%                     22     193 53.9%                 22\n## 3 Other                                    685       290 42.3%                     21     395 57.7%                 22\n## 4 Military Hospital                        708       309 43.6%                     22     399 56.4%                 21\n## 5 Port Hospital                           1364       579 42.4%                     21     785 57.6%                 22\n## 6 Total                                   3440      1469 42.7%                     22    1971 57.3%                 22"},{"path":"tables-descriptive.html","id":"tbl_gt","chapter":"17 Bảng mô tả","heading":"17.5 gtsummary package","text":"Nếu bạn muốn các thống kê tóm tắt của mình dưới dạng đồ họa đẹp mắt, sẵn sàng xuất bản, bạn có thể sử dụng package gtsummary và hàm của nó tbl_summary(). Phần code ban đầu có thể trông phức tạp một chút, nhưng kết quả đầu ra trông rất đẹp và ra Viewer panel của RStudio dưới dạng một ảnh HTML. Đọc bản tóm tắt ở đây.Bạn cũng có thể thêm kết quả của các kiểm định thống kê vào các bảng của gtsummary. Quy trình này được trình bày ở mục gtsummary trong chương Các kiểm định thống kê cơ bản.Để giới thiệu về tbl_summary(), trước tiên chúng ta sẽ chỉ ra các quy trình cơ bản nhất, giúp bạn thực sự tạo ra một bảng lớn và đẹp. Sau đó, chúng ta sẽ tìm hiểu chi tiết hơn về cách thực hiện các điều chỉnh và các bảng được thiết kế sẵn.","code":""},{"path":"tables-descriptive.html","id":"bảng-tổng-hợp","chapter":"17 Bảng mô tả","heading":"Bảng tổng hợp","text":"Cách làm việc mặc định của tbl_summary() khá kinh ngạc - nó lấy các cột bạn cung cấp và tạo một bảng tóm tắt chỉ trong một lệnh. Hàm ra số liệu thống kê phù hợp với lớp cột: trung vị và khoảng tứ phân vị (IQR) cho các cột số, và số lượng (%) cho các cột danh mục. Giá trị missing được chuyển đổi thành “Unknown”. Chú thích được thêm vào cuối bảng để giải thích các phép tính thống kê, trong khi tổng N được hiển thị ở trên cùng.\n          1\n          \n           \n          Median (IQR); n (%)\n          ","code":"\nlinelist %>% \n  select(age_years, gender, outcome, fever, temp, hospital) %>%  # keep only the columns of interest\n  tbl_summary()                                                  # default"},{"path":"tables-descriptive.html","id":"các-điều-chỉnh","chapter":"17 Bảng mô tả","heading":"Các điều chỉnh","text":"Bây giờ chúng tôi sẽ giải thích cách hoạt động của hàm và cách điều chỉnh. Các đối số chính được trình bày chi tiết bên dưới:=\nBạn có thể phân tầng bảng của mình theo một cột (ví dụ theo outcome), để tạo thành bảng 2 chiều.statistic =\nSử dụng phương trình để chỉ định thống kê nào sẽ được hiển thị và cách hiển thị chúng. Có hai vế của phương trình, được ngăn cách bởi dấu ~. Ở vế phải, trong dấu ngoặc kép, là hiển thị phép toán thống kê mong muốn, và ở vế trái là các cột mà phép thống kê đó sẽ áp dụng.Vế phải của phương trình sử dụng cú pháp của hàm str_glue() từ stringr (xem Ký tự và chuỗi), với chuỗi hiển thị mong muốn trong dấu ngoặc kép và các phép toán thống kê trong dấu ngoặc nhọn. Bạn có thể thêm các phép thống kê như là “n” (số lượng), “N” (mẫu số), “mean”, “median”, “sd”, “max”, “min”, phân vị “p##” như là “p25”, hoặc phần trăm của một tổng như là “p”. Xem ?tbl_summary để biết thêm chi tiết.Đối với phía bên trái của phương trình, bạn có thể chỉ định các cột theo tên (ví dụ: age hoặc c(age, gender)) hoặc sử dụng các hàm trợ giúp như all_continuous(), all_categorical(), contains(), starts_with(), v.v.Một ví dụ đơn giản về phương trình statistic = có thể tham khảo ở bên dưới, để chỉ giá trị trung bình của cột age_years:\n          1\n          \n           \n          Mean\n          Một phương trình phức tạp hơn một chút có thể như\"({min}, {max})\", kết hợp các giá trị max và min trong dấu ngoặc đơn và được phân tách bằng dấu phẩy:\n          1\n          \n           \n          (Range)\n          Bạn cũng có thể phân biệt cú pháp cho các cột hoặc loại cột riêng biệt. Trong ví dụ phức tạp hơn bên dưới, giá trị được cung cấp cho statistc = là một danh sách chỉ ra rằng đối với tất cả các cột dạng số thì bảng sẽ ra giá trị trung bình và độ lệch chuẩn bên trong ngoặc, trong khi các cột dạng danh sách thì sẽ ra n, mẫu số, và phần trăm.digits =\nĐiều chỉnh các chữ số và làm tròn. Theo tùy chọn, điều này có thể được chỉ định chỉ dành cho các cột dạng số liên tục (như bên dưới).label =\nĐiều chỉnh cách hiển thị tên cột. Cung cấp tên cột và nhãn mong muốn của nó được phân tách bằng dấu ngã. Theo mặc định thì tên cột được hiển thị.missing_text =\nĐiều chỉnh cách giá trị missing được hiển thị. Mặc định hiển thị là “Unknown”.type =\nSử dụng để điều chỉnh số lượng cấp độ của thống kê được hiển thị Cú pháp tương tự như statistic = trong đó bạn cung cấp một phương trình với các cột ở bên trái và một giá trị ở bên phải. Hai trường hợp phổ biến bao gồm:type = all_categorical() ~ \"categorical\" Buộc các cột nhị phân (ví dụ: fever có/không) hiển thị tất cả các cấp độ thay vì chỉ hiện thị hàng “có”type = all_continuous() ~ \"continuous2\" Cho phép các kết quả thống kê được trình bày theo nhiều dòng cho mỗi biến, như được trình bày trong phần sauTrong ví dụ dưới đây, mỗi đối số này được sử dụng để điều chỉnh bảng ban đầu:\n          1\n          \n           \n          Mean (SD); n / N (%)\n          ","code":"\nlinelist %>% \n  select(age_years) %>%         # keep only columns of interest \n  tbl_summary(                  # create summary table\n    statistic = age_years ~ \"{mean}\") # print mean of age\nlinelist %>% \n  select(age_years) %>%                       # keep only columns of interest \n  tbl_summary(                                # create summary table\n    statistic = age_years ~ \"({min}, {max})\") # print min and max of age\nlinelist %>% \n  select(age_years, gender, outcome, fever, temp, hospital) %>% # keep only columns of interest\n  tbl_summary(     \n    by = outcome,                                               # stratify entire table by outcome\n    statistic = list(all_continuous() ~ \"{mean} ({sd})\",        # stats and format for continuous columns\n                     all_categorical() ~ \"{n} / {N} ({p}%)\"),   # stats and format for categorical columns\n    digits = all_continuous() ~ 1,                              # rounding for continuous columns\n    type   = all_categorical() ~ \"categorical\",                 # force all categorical levels to display\n    label  = list(                                              # display labels for column names\n      outcome   ~ \"Outcome\",                           \n      age_years ~ \"Age (years)\",\n      gender    ~ \"Gender\",\n      temp      ~ \"Temperature\",\n      hospital  ~ \"Hospital\"),\n    missing_text = \"Missing\"                                    # how missing values should display\n  )## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"tables-descriptive.html","id":"thống-kê-nhiều-dòng-cho-các-biến-liên-tục","chapter":"17 Bảng mô tả","heading":"Thống kê nhiều dòng cho các biến liên tục","text":"Nếu bạn muốn nhiều dòng thống kê cho các biến liên tục, bạn có thể thiết lập type = thành “continuous2”. Bạn có thể kết hợp tất cả các yếu tố được hiển thị trước đó trong một bảng bằng cách chọn thống kê bạn muốn hiển thị. Để làm điều này, bạn cần cho hàm biết rằng bạn muốn khôi phục bảng bằng cách nhập type là “continuous2”. Số lượng các giá trị missing được hiển thị là “Unknown”.Có nhiều cách khác để chỉnh sửa các bảng này, bao gồm thêm giá trị p, chỉnh sửa màu sắc và tiêu đề, v.v. Các phần này được đề cập trong tài liệu trợ giúp đính kèm (nhập ?tbl_summary trong cửa sổ Console), và một số được đề cập trong chương Các kiểm định thống kê cơ bản.","code":"\nlinelist %>% \n  select(age_years, temp) %>%                      # keep only columns of interest\n  tbl_summary(                                     # create summary table\n    type = all_continuous() ~ \"continuous2\",       # indicate that you want to print multiple statistics \n    statistic = all_continuous() ~ c(\n      \"{mean} ({sd})\",                             # line 1: mean and SD\n      \"{median} ({p25}, {p75})\",                   # line 2: median and IQR\n      \"{min}, {max}\")                              # line 3: min and max\n    )"},{"path":"tables-descriptive.html","id":"base-r-1","chapter":"17 Bảng mô tả","heading":"17.6 base R","text":"Bạn có thể sử dụng hàm table() để tạo bảng đơn và bảng chéo các cột. Không giống như các cách ở trên, bạn phải chỉ định data frame mỗi khi bạn tham chiếu đến tên cột, như được trình bày dưới đây.THẬN TRỌNG: Giá trị NA (missing) sẽ không sẽ không được lập bảng trừ khi bạn bao gồm đối số useNA = \"always\" (cũng có thể được đặt thành “” hoặc “ifany”).MẸO: Bạn có thể sử dụng %$% từ package magrittr để loại bỏ việc lặp lại các data frame trong các hàm base. Chẳng hạn, ví dụ bên dưới có thể được viết lại thành linelist %$% table(outcome, useNA = \"always\")Có thể lập bảng chéo từ nhiều cột bằng cách liệt kê chúng nối tiếp nhau, phân tách bằng dấu phẩy. Hoặc là, bạn có thể gán cho mỗi cột một “tên” như Outcome = linelist$outcome.","code":"\ntable(linelist$outcome, useNA = \"always\")## \n##   Death Recover    <NA> \n##    2582    1983    1323\nage_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = \"always\") # save table as object\nage_by_outcome   # print table##        \n##         Death Recover <NA>\n##   0-4     471     364  260\n##   5-9     476     391  228\n##   10-14   438     303  200\n##   15-19   323     251  169\n##   20-29   477     367  229\n##   30-49   329     238  187\n##   50-69    33      38   24\n##   70+       3       3    0\n##   <NA>     32      28   26"},{"path":"tables-descriptive.html","id":"tỷ-lệ","chapter":"17 Bảng mô tả","heading":"Tỷ lệ","text":"Để trả về tỷ lệ, hãy chuyển bảng trên vào hàm prop.table(). Sử dụng đối số margins = để chỉ định xem bạn muốn tỷ lệ của hàng (1), của cột (2) hay của toàn bảng (3). Để dễ nhìn, chúng ta pipe bảng trên vào hàm round() của base R, chỉ định 2 chữ số sau dấu phẩy.","code":"\n# get proportions of table defined above, by rows, rounded\nprop.table(age_by_outcome, 1) %>% round(2)##        \n##         Death Recover <NA>\n##   0-4    0.43    0.33 0.24\n##   5-9    0.43    0.36 0.21\n##   10-14  0.47    0.32 0.21\n##   15-19  0.43    0.34 0.23\n##   20-29  0.44    0.34 0.21\n##   30-49  0.44    0.32 0.25\n##   50-69  0.35    0.40 0.25\n##   70+    0.50    0.50 0.00\n##   <NA>   0.37    0.33 0.30"},{"path":"tables-descriptive.html","id":"tổng","chapter":"17 Bảng mô tả","heading":"Tổng","text":"Để thêm tổng hàng và tổng cột, hãy chuyển bảng vào hàm addmargins(). Cách này hoạt động cho cả số lượng và tỷ lệ.","code":"\naddmargins(age_by_outcome)##        \n##         Death Recover <NA>  Sum\n##   0-4     471     364  260 1095\n##   5-9     476     391  228 1095\n##   10-14   438     303  200  941\n##   15-19   323     251  169  743\n##   20-29   477     367  229 1073\n##   30-49   329     238  187  754\n##   50-69    33      38   24   95\n##   70+       3       3    0    6\n##   <NA>     32      28   26   86\n##   Sum    2582    1983 1323 5888"},{"path":"tables-descriptive.html","id":"chuyển-đổi-thành-data-frame","chapter":"17 Bảng mô tả","heading":"Chuyển đổi thành data frame","text":"Chuyển đổi trực tiếp một đối tượng dạng table() sang một data frame không phải là một đường thẳng. Cách tiếp cận được trình bày như dưới đây:Tạo một bảng, mà không sử dụng useNA = \"always\". Thay vào đó chuyển giá trị NA thành “(Missing)” với hàm fct_explicit_na() của package forcats.Thêm tổng (tùy chọn) bằng cách piping tới addmargins()Pipe tới hàm .data.frame.matrix() của base RPipe bảng trên vào hàm rownames_to_column() của package tibble, ghi rõ tên cho cột đầu tiênIn, Xem hoặc xuất bảng như mong muốn. Trong ví dụ này, chúng ta sử dụng hàm flextable() từ package flextable như đã được mô tả trong chương Kết quả sẽ được ra cửa sổ RStudio viewer dưới dạng một hình ảnh HTML đẹp.Age CategoryDeathRecover(Missing)Sum0-44713642601,0955-94763912281,09510-1443830320094115-1932325116974320-294773672291,07330-4932923818775450-693338249570+3306(Missing)32282686Sum2,5821,9831,3235,888","code":"\ntable(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% \n  addmargins() %>% \n  as.data.frame.matrix() %>% \n  tibble::rownames_to_column(var = \"Age Category\") %>% \n  flextable::flextable()"},{"path":"tables-descriptive.html","id":"nguồn-3","chapter":"17 Bảng mô tả","heading":"17.7 Nguồn","text":"Phần lớn thông tin trong chương này được tham khảo từ các nguồn và bản tóm tắt trực tuyến dưới đây:gtsummarydplyr","code":""},{"path":"stat-tests.html","id":"stat-tests","chapter":"18 Các kiểm định thống kê cơ bản","heading":"18 Các kiểm định thống kê cơ bản","text":"Chương này sẽ trình bày cách để thực hiện các phép kiểm định thống kê cơ bản bằng cách sử dụng base R, rstatix, và gtsummary.Kiểm định tKiểm định Shapiro-WilkKiểm định tổng thứ hạng WilcoxonKiểm định Kruskal-WallisKiểm định Chi-squared (Chi bình phương)Tương quan giữa các biến định lượng…nhiều kiểm định khác có thể được thực hiện, nhưng chúng tôi chỉ trình bày các kiểm định thông dụng và kết nối với các phần khác trong cuốn sổ tay này.Mỗi package được đề cập bên trên đều có một số ưu điểm và khuyết điểm nhất định:Sử dụng các câu lệnh của base để các kết quả đầu ra thống kê trong R ConsoleSử dụng các câu lệnh của rstatix để cho kết quả dưới dạng data frame hoặc khi muốn thực hiện các kiểm định theo nhómSử dụng các câu lệnh của gtsummary khi muốn kết quả là các bảng biểu có thể sử dụng được ngay","code":""},{"path":"stat-tests.html","id":"các-bước-chuẩn-bị","chapter":"18 Các kiểm định thống kê cơ bản","heading":"18.1 Các bước chuẩn bị","text":"","code":""},{"path":"stat-tests.html","id":"gọi-các-packages","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Gọi các packages","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() trong package pacman, cài đặt gói lệnh nếu cần thiết và gọi chúng ra để sử dụng. Các package đã cài đặt cũng có thể được gọi ra bằng library() từ base R. Xem thêm thông tin các package của R trong chương R cơ bản.","code":"\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  skimr,        # get overview of data\n  tidyverse,    # data management + ggplot2 graphics, \n  gtsummary,    # summary statistics and tests\n  rstatix,      # statistics\n  corrr,        # correlation analayis for numeric variables\n  janitor,      # adding totals and percents to tables\n  flextable     # converting tables to HTML\n  )"},{"path":"stat-tests.html","id":"nhập-số-liệu","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Nhập số liệu","text":"Chúng ta nhập bộ số liệu của các ca bệnh về một vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải bộ số liệu linelist “đã được làm sạch” (.rds file). Nhập số liệu bằng hàm import() từ package rio package (nó chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị như dưới đây.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"stat-tests.html","id":"các-kiểm-định-trong-base-r","chapter":"18 Các kiểm định thống kê cơ bản","heading":"18.2 Các kiểm định trong base R","text":"Các lệnh trong base R functions conduct statistical tests. có thể được sử dụng để thực hiện các kiểm định thống kê. Các câu lệnh tương đối đơn giản và kết quả sẽ hiển thị trong bảng điều khiển R Console. Tuy nhiên, kết quả đầu ra thường dưới dạng liệt kê, vì thế sẽ khó thao tác hơn nếu muốn sử dụng kết quả trong các thao tác tiếp theo.","code":""},{"path":"stat-tests.html","id":"kiểm-định-t","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định t","text":"Một kiểm định t, hay còn được gọi là “Student’s t-Test”, thường được sử dụng để xác định có sự khác biệt có ý nghĩa thống kê giữa giá trị trung bình của hai nhóm. Bên dưới là cú pháp để thực hiện kiểm định này tùy thuộc vào các cột có trong cùng một data frame hay không.Cú pháp 1: Đây là cú pháp khi cột của biến liên tục và phân loại nằm trong cùng một data frame. Đặt biến liên tục bên trái và biến phân loại bên phải của phương trình. Ghi rõ bộ số liệu sau data =. Các tùy chọn khác như số liệu bắt cặp, viết thêm paired = TRUE, khoảng tin cậy, viết thêm conf.level = (mặc định là 0.95), và giả thuyết thay thế alternative = (hai đuôi - “two.sided”, hoặc một đuôi nhỏ hơn hay lớn hơn - “less”, “greater”). Gõ ?t.test để biết thêm chi tiết.Cú pháp 2: Đây là cú pháp khi sánh hai véc tơ dạng số. Ví dụ như hai cột nằm trong hai bộ số liệu khác nhau.Kiểm định t cũng được sử dụng để xác định có sự khác biệt có ý nghĩa thống kê giữa giá trị trung bình của mẫu với một số giá trị cụ thể. Đây là phép kiểm định t cho một mẫu với trung bình quần thể giả thuyết/đã biết như mu =:","code":"\n## compare mean age by outcome group with a t-test\nt.test(age_years ~ gender, data = linelist)## \n##  Welch Two Sample t-test\n## \n## data:  age_years by gender\n## t = -21.344, df = 4902.3, p-value < 2.2e-16\n## alternative hypothesis: true difference in means between group f and group m is not equal to 0\n## 95 percent confidence interval:\n##  -7.571920 -6.297975\n## sample estimates:\n## mean in group f mean in group m \n##        12.60207        19.53701\nt.test(df1$age_years, df2$age_years)\nt.test(linelist$age_years, mu = 45)"},{"path":"stat-tests.html","id":"kiểm-định-shapiro-wilk","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định Shapiro-Wilk","text":"Kiểm định Shapiro-Wilk có thể được sử để xác định xem một mẫu có phân bố bình thường/phân bố chuản hay không (một giả định của nhiều kiểm định khác, ví dụ như kiểm định t). Tuy nhiên, phép kiểm định này chỉ có thể được sử dụng cho một mẫu có từ 3 đến 5000 quan sát. Đối với cỡ mẫu lớn hơn, nên sử dụng biểu đồ quantile-quantile plot.","code":"\nshapiro.test(linelist$age_years)"},{"path":"stat-tests.html","id":"kiểm-định-tổng-thứ-hạng-wilcoxon","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định tổng thứ hạng Wilcoxon","text":"Kiểm định tổng thứ hạng Wilcoxon, hay còn gọi là kiểm định Mann–Whitney U, thường được sử dụng để giúp xác định xem hai mẫu có cùng phân bố hay không khi quần thể của chúng không có phân bố chuẩn hoặc có phương sai không bằng nhau.","code":"\n## compare age distribution by outcome group with a wilcox test\nwilcox.test(age_years ~ outcome, data = linelist)## \n##  Wilcoxon rank sum test with continuity correction\n## \n## data:  age_years by outcome\n## W = 2501868, p-value = 0.8308\n## alternative hypothesis: true location shift is not equal to 0"},{"path":"stat-tests.html","id":"kiểm-định-kruskal-wallis","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định Kruskal-Wallis","text":"Kiểm định Kruskal-Wallis là một phần mở rộng của kiểm định tổng thứ hạng Wilcoxon mà có thể được sử dụng để kiểm định sự khác biệt trong phân bố của nhiều hơn hai mẫu. Khi có hai mẫu được sử dụng, nó cho kết quả giống như của kiểm định tổng thứ hạng Wilcoxon.","code":"\n## compare age distribution by outcome group with a kruskal-wallis test\nkruskal.test(age_years ~ outcome, linelist)## \n##  Kruskal-Wallis rank sum test\n## \n## data:  age_years by outcome\n## Kruskal-Wallis chi-squared = 0.045675, df = 1, p-value = 0.8308"},{"path":"stat-tests.html","id":"kiểm-định-chi-bình-phương","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định Chi bình phương","text":"Kiểm định Chi bình phương của Pearson được sử dụng trong kiểm tra sự khác biệt có ý nghĩa thống kê giữa các biến phân loại.","code":"\n## compare the proportions in each group with a chi-squared test\nchisq.test(linelist$gender, linelist$outcome)## \n##  Pearson's Chi-squared test with Yates' continuity correction\n## \n## data:  linelist$gender and linelist$outcome\n## X-squared = 0.0011841, df = 1, p-value = 0.9725"},{"path":"stat-tests.html","id":"rstatix-package","chapter":"18 Các kiểm định thống kê cơ bản","heading":"18.3 rstatix package","text":"Package rstatix cho phép thực hiện các kiểm định thống kê và truy xuất kết quả “dễ sử dụng cho các tính toán tiếp theo”. Có nghĩa là kết quả xuất tự động thành một data frame để có thể thực hiện các thao tác tiếp theo. Nó cũng dễ dàng để nhóm dữ liệu mà sẽ được chuyền vào các hàm, ở đó các thống kê được thực hiện cho từng nhóm.","code":""},{"path":"stat-tests.html","id":"tóm-tắt-thống-kê","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Tóm tắt thống kê","text":"Hàm get_summary_stats() là một cách thực hiện tóm tắt thống kê nhanh. Chỉ cần đưa bộ số liệu và chỉ định các cột muốn phân tích vào hàm này. Nếu không có cột nào được cụ thể, tóm tắt thống kê sẽ tính toán cho tất cả các cột.Tóm tắt thống kê đầy đủ sẽ cho kết quả mặc định như sau: số quan sát (n), giá trị nhỏ nhất, giá trị lớn nhất, trung vị, giá trị tứ phân vị thứ nhất (25%), giá trị tứ phân vị thứ ba (75%), khoảng tứ phân vị, độ lệch tuyệt đối của trung vị (mad), trung bình, độ lệch chuẩn, sai số chuẩn và khoảng tin cậy của trung bình.Có thể tóm tắt một số giá trị thống kê bằng cách cung cấp một trong số các giá trị sau đến type =: “full”, “common”, “robust”, “five_number”, “mean_sd”, “mean_se”, “mean_ci”, “median_iqr”, “median_mad”, “quantile”, “mean”, “median”, “min”, “max”.Nó cũng có thể được sử dụng để nhóm số liệu, sao cho một hàng được trả về cho mỗi biến nhóm:Bạn cũng có thể sử dụng rstatix để thực hiện các kiểm định thống kê:","code":"\nlinelist %>%\n  rstatix::get_summary_stats(age, temp)## # A tibble: 2 x 13\n##   variable     n   min   max median    q1    q3   iqr    mad  mean     sd    se    ci\n##   <chr>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl>  <dbl> <dbl>  <dbl> <dbl> <dbl>\n## 1 age       5802   0    84     13     6    23      17 11.9    16.1 12.6   0.166 0.325\n## 2 temp      5739  35.2  40.8   38.8  38.2  39.2     1  0.741  38.6  0.977 0.013 0.025\nlinelist %>%\n  group_by(hospital) %>%\n  rstatix::get_summary_stats(age, temp, type = \"common\")## # A tibble: 12 x 11\n##    hospital                             variable     n   min   max median   iqr  mean     sd    se    ci\n##    <chr>                                <chr>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>\n##  1 Central Hospital                     age        445   0    58     12    15    15.7 12.5   0.591 1.16 \n##  2 Central Hospital                     temp       450  35.2  40.4   38.8   1    38.5  0.964 0.045 0.089\n##  3 Military Hospital                    age        884   0    72     14    18    16.1 12.4   0.417 0.818\n##  4 Military Hospital                    temp       873  35.3  40.5   38.8   1    38.6  0.952 0.032 0.063\n##  5 Missing                              age       1441   0    76     13    17    16.0 12.9   0.339 0.665\n##  6 Missing                              temp      1431  35.8  40.6   38.9   1    38.6  0.97  0.026 0.05 \n##  7 Other                                age        873   0    69     13    17    16.0 12.5   0.422 0.828\n##  8 Other                                temp       862  35.7  40.8   38.8   1.1  38.5  1.01  0.034 0.067\n##  9 Port Hospital                        age       1739   0    68     14    18    16.3 12.7   0.305 0.598\n## 10 Port Hospital                        temp      1713  35.5  40.6   38.8   1.1  38.6  0.981 0.024 0.046\n## 11 St. Mark's Maternity Hospital (SMMH) age        420   0    84     12    15    15.7 12.4   0.606 1.19 \n## 12 St. Mark's Maternity Hospital (SMMH) temp       410  35.9  40.6   38.8   1.1  38.5  0.983 0.049 0.095"},{"path":"stat-tests.html","id":"kiểm-định-t-1","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định t","text":"USử dụng cú pháp để chỉ định cột biến liên tục và cột biến phân loại:Hoặc sử dụng ~ 1 và ghi rõ mu = cho kiểm định t một mẫu. Cú pháp này có thể sử dụng để thực hiện cho nhóm.Nếu có thể, các kiểm định thống kê có thể thực hiện theo nhóm, như được trình bày bên dưới.","code":"\nlinelist %>% \n  t_test(age_years ~ gender)## # A tibble: 1 x 10\n##   .y.       group1 group2    n1    n2 statistic    df        p    p.adj p.adj.signif\n## * <chr>     <chr>  <chr>  <int> <int>     <dbl> <dbl>    <dbl>    <dbl> <chr>       \n## 1 age_years f      m       2807  2803     -21.3 4902. 9.89e-97 9.89e-97 ****\nlinelist %>% \n  t_test(age_years ~ 1, mu = 30)## # A tibble: 1 x 7\n##   .y.       group1 group2         n statistic    df     p\n## * <chr>     <chr>  <chr>      <int>     <dbl> <dbl> <dbl>\n## 1 age_years 1      null model  5888     -84.2  5801     0\nlinelist %>% \n  group_by(gender) %>% \n  t_test(age_years ~ 1, mu = 18)## # A tibble: 3 x 8\n##   gender .y.       group1 group2         n statistic    df         p\n## * <chr>  <chr>     <chr>  <chr>      <int>     <dbl> <dbl>     <dbl>\n## 1 f      age_years 1      null model  2807    -29.8   2806 7.52e-170\n## 2 m      age_years 1      null model  2803      5.70  2802 1.34e-  8\n## 3 <NA>   age_years 1      null model   278     -3.80   191 1.96e-  4"},{"path":"stat-tests.html","id":"kiểm-định-shapiro-wilk-1","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định Shapiro-Wilk","text":"Như đã đề cập bên trên, cỡ mẫu phải nằm trong khoảng từ 3 đến 5000.","code":"\nlinelist %>% \n  head(500) %>%            # first 500 rows of case linelist, for example only\n  shapiro_test(age_years)## # A tibble: 1 x 3\n##   variable  statistic        p\n##   <chr>         <dbl>    <dbl>\n## 1 age_years     0.917 6.67e-16"},{"path":"stat-tests.html","id":"kiểm-định-tổng-thứ-hạng-wilcoxon-1","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định tổng thứ hạng Wilcoxon","text":"","code":"\nlinelist %>% \n  wilcox_test(age_years ~ gender)## # A tibble: 1 x 9\n##   .y.       group1 group2    n1    n2 statistic        p    p.adj p.adj.signif\n## * <chr>     <chr>  <chr>  <int> <int>     <dbl>    <dbl>    <dbl> <chr>       \n## 1 age_years f      m       2807  2803   2829274 3.47e-74 3.47e-74 ****"},{"path":"stat-tests.html","id":"kiểm-định-kruskal-wallis-1","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định Kruskal-Wallis","text":"Cũng được biết như kiểm định Mann-Whitney U.","code":"\nlinelist %>% \n  kruskal_test(age_years ~ outcome)## # A tibble: 1 x 6\n##   .y.           n statistic    df     p method        \n## * <chr>     <int>     <dbl> <int> <dbl> <chr>         \n## 1 age_years  5888    0.0457     1 0.831 Kruskal-Wallis"},{"path":"stat-tests.html","id":"kiểm-định-chi-bình-phương-1","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định Chi bình phương","text":"Hàm kiểm định Chi bình phương chấp nhận một bảng, vì vậy đầu tiên là tạo một bảng chéo. Có nhiều cách để tạo một bảng chéo (xem chương Bảng mô tả) nhưng ở đây chúng ta sử dụng hàm tabyl() từ janitor avà bỏ cột ngoài cùng bên trái của nhãn giá trị trước khi đưa vào hàm chisq_test().Có rất nhiều hàm và kiểm định thống kê có thể được thực hiện bằng các hàm trong package rstatix. Đọc các tài liệu về rstatix online ở đây hoặc gõ ?rstatix.","code":"\nlinelist %>% \n  tabyl(gender, outcome) %>% \n  select(-1) %>% \n  chisq_test()## # A tibble: 1 x 6\n##       n statistic     p    df method          p.signif\n## * <dbl>     <dbl> <dbl> <int> <chr>           <chr>   \n## 1  5888      3.53 0.473     4 Chi-square test ns"},{"path":"stat-tests.html","id":"stats_gt","chapter":"18 Các kiểm định thống kê cơ bản","heading":"18.4 gtsummary package","text":"Sử dụng package gtsummary nếu bạn đang muốn thêm kết quả của một kiểm định thống kê vào một bảng đẹp được tạo ra bằng package này (như đã được mô tả trong phần gtsummary của chương Bảng mô tả).Khi thực hiện các kiểm định sánh bằng hàm tbl_summary, dùng thêm hàm add_p để đưa cột giá trị p và kiểm định được sử dụng vào bảng. Có thể xuất nhiều giá trị p mà được hiệu chỉnh cho nhiều kiểm định bằng cách dùng thêm hàm add_q. Gõ lệnh ?tbl_summary để biết thêm chi tiết.","code":""},{"path":"stat-tests.html","id":"kiểm-định-chi-bình-phương-2","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định Chi bình phương","text":"Được sử dụng để sánh các tỷ lệ của một biến phân loại trong hai nhóm. Kiểm định thống kê mặc định cho biến phân loại trong hàm add_p() là kiểm định Chi bình phương về tính độc lập với hiệu chỉnh liên tục, nhưng nếu có bất kỳ giá trị kỳ vọng nào nhỏ hơn 5 thì kiểm định chính xác của Fisher sẽ được sử dụng.\n          1\n          \n           \n          n (%)\n          \n          2\n          \n           \n          Pearson's Chi-squared test\n          ","code":"\nlinelist %>% \n  select(gender, outcome) %>%    # keep variables of interest\n  tbl_summary(by = outcome) %>%  # produce summary table and specify grouping variable\n  add_p()                        # specify what test to perform## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"stat-tests.html","id":"kiểm-định-t-2","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định t","text":"Được sử dụng để sánh sự khác biệt về trung bình của một biến trung bình trong hai nhóm. Ví dụ như sánh tuổi trung bình với kết cục của bệnh nhân.\n          1\n          \n           \n          Mean (SD)\n          \n          2\n          \n           \n          Welch Two Sample t-test\n          ","code":"\nlinelist %>% \n  select(age_years, outcome) %>%             # keep variables of interest\n  tbl_summary(                               # produce summary table\n    statistic = age_years ~ \"{mean} ({sd})\", # specify what statistics to show\n    by = outcome) %>%                        # specify the grouping variable\n  add_p(age_years ~ \"t.test\")                # specify what tests to perform## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"stat-tests.html","id":"kiểm-định-tổng-thứ-hạng-wilcoxon-2","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định tổng thứ hạng Wilcoxon","text":"Được dùng để sánh sự phân bố của một biến liên tục trong hai nhóm. Kiểm định mặc định là kiểm định tổng thứ hang Wilcoxon và trung vị (khoảng tứ phân vị IQR) khi sánh hai nhóm. Tuy nhiên, đối với số liệu không có phân bố chuẩn hoặc sánh nhiều nhóm, kiểm định Kruskal-wallis là kiểm định thích hợp hơn.\n          1\n          \n           \n          Median (IQR)\n          \n          2\n          \n           \n          Wilcoxon rank sum test\n          ","code":"\nlinelist %>% \n  select(age_years, outcome) %>%                       # keep variables of interest\n  tbl_summary(                                         # produce summary table\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # specify what statistic to show (this is default so could remove)\n    by = outcome) %>%                                  # specify the grouping variable\n  add_p(age_years ~ \"wilcox.test\")                     # specify what test to perform (default so could leave brackets empty)## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"stat-tests.html","id":"kiểm-định-kruskal-wallis-2","chapter":"18 Các kiểm định thống kê cơ bản","heading":"Kiểm định Kruskal-wallis","text":"Được sử dụng để sánh sự phân bố của một biến liên tục trong hai hay nhiều nhóm, bất kể số liệu có phân bố chuẩn hay không.\n          1\n          \n           \n          Median (IQR)\n          \n          2\n          \n           \n          Kruskal-Wallis rank sum test\n          ","code":"\nlinelist %>% \n  select(age_years, outcome) %>%                       # keep variables of interest\n  tbl_summary(                                         # produce summary table\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # specify what statistic to show (default, so could remove)\n    by = outcome) %>%                                  # specify the grouping variable\n  add_p(age_years ~ \"kruskal.test\")                    # specify what test to perform## 1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_explicit_na()` on `outcome` column before passing to `tbl_summary()`."},{"path":"stat-tests.html","id":"tương-quan","chapter":"18 Các kiểm định thống kê cơ bản","heading":"18.5 Tương quan","text":"Mối tương quan giữa các biến định lượng có thể được kiển bằng cách sử dụng lệnh corrr từ package tidyverse. Lệnh này cũng cho phép tính các hệ số tương quan bằng phương pháp Pearson, Kendall hoặc Spearman. Gói lệnh này tạo ra một bảng kết quả và cũng có chức năng tự động vẽ các giá trị.","code":"\ncorrelation_tab <- linelist %>% \n  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # keep numeric variables of interest\n  correlate()      # create correlation table (using default pearson)\n\ncorrelation_tab    # print## # A tibble: 6 x 7\n##   term            generation       age ct_blood days_onset_hosp    wt_kg    ht_cm\n##   <chr>                <dbl>     <dbl>    <dbl>           <dbl>    <dbl>    <dbl>\n## 1 generation        NA       -0.0222    0.179         -0.288    -0.0302  -0.00942\n## 2 age               -0.0222  NA         0.00849       -0.000635  0.833    0.877  \n## 3 ct_blood           0.179    0.00849  NA             -0.600    -0.00636  0.0181 \n## 4 days_onset_hosp   -0.288   -0.000635 -0.600         NA         0.0153  -0.00953\n## 5 wt_kg             -0.0302   0.833    -0.00636        0.0153   NA        0.884  \n## 6 ht_cm             -0.00942  0.877     0.0181        -0.00953   0.884   NA\n## remove duplicate entries (the table above is mirrored) \ncorrelation_tab <- correlation_tab %>% \n  shave()\n\n## view correlation table \ncorrelation_tab## # A tibble: 6 x 7\n##   term            generation       age ct_blood days_onset_hosp  wt_kg ht_cm\n##   <chr>                <dbl>     <dbl>    <dbl>           <dbl>  <dbl> <dbl>\n## 1 generation        NA       NA        NA              NA       NA        NA\n## 2 age               -0.0222  NA        NA              NA       NA        NA\n## 3 ct_blood           0.179    0.00849  NA              NA       NA        NA\n## 4 days_onset_hosp   -0.288   -0.000635 -0.600          NA       NA        NA\n## 5 wt_kg             -0.0302   0.833    -0.00636         0.0153  NA        NA\n## 6 ht_cm             -0.00942  0.877     0.0181         -0.00953  0.884    NA\n## plot correlations \nrplot(correlation_tab)"},{"path":"stat-tests.html","id":"nguồn-4","chapter":"18 Các kiểm định thống kê cơ bản","heading":"18.6 Nguồn","text":"Phần lớn thông tin trong phần này được phỏng theo các nguồn sau:gtsummary\ndplyr\ncorrr\nsthda correlation","code":""},{"path":"regression.html","id":"regression","chapter":"19 Hồi quy đơn và đa biến","heading":"19 Hồi quy đơn và đa biến","text":"Trong chương này, chúng tôi trình bày cách sử dụng các hàm hồi quy trong base R rnhư hàm glm() và package gtsummary để xem xét các mối liên quan giữa các biến (ví dụ như tỷ số chênh, tỷ số nguy cơ, tỷ số rủi ro). Chúng tôi cũng trình bày cách sử dụng các hàm như tidy() trong package broom để sắp xếp các kết quả hồi quy.Phân tích đơn biến: bảng 2 x 2Phân tích phân tầng: ước lượng của mantel-haenszelPhân tích đa biến: lựa chọn biến số, lựa chọn mô hình, mô hình cuối cùngBiểu đồ Forest plotĐối với hồi quy Cox, xem chương Phân tích sống còn.CHÚ Ý: Chúng tôi sử dụng thuật ngữ đa biến (multivariable) để nói đến một hồi quy có nhiều biến giải thích. Thuật ngữ này khác với mô hình đa biến (multivariate model), là một mô hình đa biến có nhiều biến kết cục – xem chi tiết trong bài xã luận này","code":""},{"path":"regression.html","id":"chuẩn-bị-9","chapter":"19 Hồi quy đơn và đa biến","heading":"19.1 Chuẩn bị","text":"","code":""},{"path":"regression.html","id":"gọi-packages-5","chapter":"19 Hồi quy đơn và đa biến","heading":"Gọi packages","text":"Đoạn mã này hiển thị cách tải các gói lệnh cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh hàm p_load() thuộc package pacman, giúp cài đặt package khi cần thiết và gọi nó ra để sử dụng. Có thể gọi các package đã cài đặt bằng hàm library() trong base R. Xem thêm thông tin về các package của R trong chương R cơ bản.","code":"\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  tidyverse,    # data management + ggplot2 graphics, \n  stringr,      # manipulate text strings \n  purrr,        # loop over objects in a tidy way\n  gtsummary,    # summary statistics and tests \n  broom,        # tidy up results from regressions\n  lmtest,       # likelihood-ratio tests\n  parameters,   # alternative to tidy up results from regressions\n  see          # alternative to visualise forest plots\n  )"},{"path":"regression.html","id":"nhập-số-liệu-1","chapter":"19 Hồi quy đơn và đa biến","heading":"Nhập số liệu","text":"Chúng tôi nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Để tiện làm theo, bấm để tải số liệu linelist “đã được làm sạch” (dưới dạng tệp .rds ). Nhập số liệu này bằng hàm import() trong package rio (nó chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv – xem chi tiết trong chương Nhập xuất dữ liệu).Bên dưới là hiển thị của 50 hàng đầu tiên của bộ số liệu linelist.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"regression.html","id":"làm-sạch-số-liệu","chapter":"19 Hồi quy đơn và đa biến","heading":"Làm sạch số liệu","text":"","code":""},{"path":"regression.html","id":"lưu-trữ-các-biến-giải-thích","chapter":"19 Hồi quy đơn và đa biến","heading":"Lưu trữ các biến giải thích","text":"Tên của các biến giải thích sẽ được lưu trữ dưới dạng một véc tơ ký tự. Véc tơ này sẽ được đề cập về sau.","code":"\n## define variables of interest \nexplanatory_vars <- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")"},{"path":"regression.html","id":"chuyển-đổi-sang-số-1-và-số-0","chapter":"19 Hồi quy đơn và đa biến","heading":"Chuyển đổi sang số 1 và số 0","text":"Sau đây, giá trị của các biến giải thích được chuyển đổi từ “có”/“không”, “nam”/“nữ” và “chết”/“sống” thành 1 / 0, để hợp với các đặc tính của mô hình hồi quy logistic. TĐể thực hiện việc này một cách hiệu quả, sử dụng hàm across() từ dplyr để chuyển đổi nhiều biến cùng một lúc. Để áp dụng cho mỗi biến, dùng hàm case_when() (cũng trong package dplyr) để chuyển đổi các giá trị cụ thể thành 1 và 0. Xem các mục về across() và case_when() trong chương Làm sạch số liệu và các hàm quan trọng).Chú ý: dấu “.” bên dưới đại diện cho cột`````đang được xử lý trong hàmacross()` tại thời điểm đó.","code":"\n## convert dichotomous variables to 0/1 \nlinelist <- linelist %>%  \n  mutate(across(                                      \n    .cols = all_of(c(explanatory_vars, \"outcome\")),  ## for each column listed and \"outcome\"\n    .fns = ~case_when(                              \n      . %in% c(\"m\", \"yes\", \"Death\")   ~ 1,           ## recode male, yes and death to 1\n      . %in% c(\"f\", \"no\",  \"Recover\") ~ 0,           ## female, no and recover to 0\n      TRUE                            ~ NA_real_)    ## otherwise set to missing\n    )\n  )"},{"path":"regression.html","id":"loại-bỏ-các-hàng-có-giá-trị-missing","chapter":"19 Hồi quy đơn và đa biến","heading":"Loại bỏ các hàng có giá trị missing","text":"Để bỏ các hàng có giá trị missing, dùng hàm drop_na() trong package tidyr. Tuy nhiên, chúng ta chỉ muốn thực hiện điều này cho các hàng có giá trị missing đối với các cột đang được quan tâm.Trước hết, chúng ta phải đảm bảo rằng vectơ explanatory_vars bao gồm các biến age (age có thể tạo ra một lỗi trong thao tác của hàm case_when() trước đó, mà chỉ dành cho biến nhị phân). Sau đó chúng ta pipe bộ dữ liệu linelist tới hàm drop_na() để bỏ các hàng có giá trị missing cho biến outcome hoặc bất kỳ biển giải thích explanatory_vars nào.Trước khi thực hiện các lệnh này, kiểm tra số hàng trong bộ số liệu linelist bằng hàm nrow(linelist).Kiểm tra số hàng còn lại của linelist bằng hàm nrow(linelist).","code":"\n## add in age_category to the explanatory vars \nexplanatory_vars <- c(explanatory_vars, \"age_cat\")\n\n## drop rows with missing information for variables of interest \nlinelist <- linelist %>% \n  drop_na(any_of(c(\"outcome\", explanatory_vars)))"},{"path":"regression.html","id":"phân-tích-đơn-biến","chapter":"19 Hồi quy đơn và đa biến","heading":"19.2 Phân tích đơn biến","text":"Cũng giống như chương Bảng mô tả, chúng ta cần xác định packahe nào trong R mà chúng ta muốn sử dụng. Chúng tôi trình bày hai chọn lựa để thực hiện các phân tích đơn biến:Dùng hàm có sẵn trong base để nhanh kết quả ra console. Sử dụng package broom để làm gọn kết quả.Dùng package gtsummary để lập mô hình và nhận các kết quả đầu ra sẵn sàng để công bố","code":""},{"path":"regression.html","id":"base-r-2","chapter":"19 Hồi quy đơn và đa biến","heading":"base R","text":"","code":""},{"path":"regression.html","id":"hồi-quy-tuyến-tính","chapter":"19 Hồi quy đơn và đa biến","heading":"Hồi quy tuyến tính","text":"Hàm lm() trong base cho phép thực hiện hồi quy tuyến tính để đánh giá mối quan hệ giữa biến đầu ra dạng số (numeric) và các biến giải thích mà được giả định là có mối quan hệ tuyến tính.Cung cấp phương trình dưới dạng công thức với tên của biến đầu ra và các biến giải thích được phân tách bằng dấu ngã ~. Bên cạnh đó, chỉ rõ bộ số liệu nào được sử dụng với data =. Kết quả của mô hình được định nghĩa dưới dạng đối tượng của R để sử dụng về sau.Sau đó tóm tắt kết quả của mô hình bằng hàm summary() để xem các hệ số (ước tính), P-value, phần dư và các đo lường khác.Ngoài ra, có thể dùng hàm tidy() trong package broom để xuất kết quả vào trong một bảng. Kết quả bên dưới cho chúng ta biết khi tăng thêm một tuổi thì chiều cao tăng 3,5 cm và mối quan hệ này có ý nghĩa thống kê.Sau đó, có thể sử dụng kết quả hồi quy này để đưa vào ggplot. Để thực hiện điều này, trước tiên chúng ta đưa các giá trị quan sát và đường thẳng hồi quy (fitted line) vào một data frame bằng cách dùng hàm augment() trong package broom.Bạn cũng có thể vẽ đường hồi quy tuyến tính đơn bằng package ggplot thông qua hàm geom_smooth().Xem thêm các hướng dẫn chi tiết trong mục Nguồn ở cuối chương này.","code":"\nlm_results <- lm(ht_cm ~ age, data = linelist)\nsummary(lm_results)## \n## Call:\n## lm(formula = ht_cm ~ age, data = linelist)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -128.579  -15.854    1.177   15.887  175.483 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept)  69.9051     0.5979   116.9   <2e-16 ***\n## age           3.4354     0.0293   117.2   <2e-16 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 23.75 on 4165 degrees of freedom\n## Multiple R-squared:  0.7675, Adjusted R-squared:  0.7674 \n## F-statistic: 1.375e+04 on 1 and 4165 DF,  p-value: < 2.2e-16\ntidy(lm_results)## # A tibble: 2 x 5\n##   term        estimate std.error statistic p.value\n##   <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n## 1 (Intercept)    69.9     0.598       117.       0\n## 2 age             3.44    0.0293      117.       0\n## pull the regression points and observed data in to one dataset\npoints <- augment(lm_results)\n\n## plot the data using age as the x-axis \nggplot(points, aes(x = age)) + \n  ## add points for height \n  geom_point(aes(y = ht_cm)) + \n  ## add your regression line \n  geom_line(aes(y = .fitted), colour = \"red\")\n## add your data to a plot \n ggplot(linelist, aes(x = age, y = ht_cm)) + \n  ## show points\n  geom_point() + \n  ## add a linear regression \n  geom_smooth(method = \"lm\", se = FALSE)## `geom_smooth()` using formula 'y ~ x'"},{"path":"regression.html","id":"hồi-quy-logistic","chapter":"19 Hồi quy đơn và đa biến","heading":"Hồi quy Logistic","text":"Hàm glm() trong package stats (một phần của base R) được sử dụng để fit (chọn mô hình dự đoán tối ưu dựa trên số liệu quan sát) đối với Mô hình Tuyến tính Tổng quát (GLM).glm() có thể được sử dụng cho cả hồi quy logistic đơn biến và đa biến (ví dụ như để tính tỷ số chênh ). Sau đây là những thành phần chính của hàm:formula = Mô hình được cung cấp cho glm() dưới dạng một phương trình với biến kết cục ở bên trái và biến giải thích ở bên phải dấu ngã ~.family = Xác định loại mô hình sẽ thực hiện. Đối với hồi quy logistic, sử dụng family = \"binomial\", đối với hồi quy poisson sử dụng family = \"poisson\". Các ví dụ khác được trình bày trong bảng bên dưới.data = Cụ thể bộ số liệuNếu cần, có thể cụ thể hàm liên kết bằng cú pháp family = familytype(link = \"linkfunction\")). Bạn có thể tìm đọc thêm về các họ hồi quy khác và các tùy chọn đối số như là weights = và subset = bằng cách gõ (?glm).Khi thực hiện glm() , phổ biến nhất là lưu kết quả dưới dạng một đối tượng của R được đặt tên. Sau đó, có thể xuất kết quả ra console bằng cách sử dụng hàm summary() như được trình bày bên dưới, hoặc thực hiện các thao tác khác từ kết quả (ví dụ như lấy lũy thừa).Nếu cần thực hiện một hồi quy nhị thức âm, có thể sử dụng package MASS. Hàn glm.nb() uses cũng sử dụng cùng cú pháp như glm(). Để xem qua các hồi quy khác, xem trên trang thống kê của UCLA.","code":"\n# arguments for glm()\nglm(formula, family, data, weights, subset, ...)"},{"path":"regression.html","id":"phân-tích-đơn-biến-sử-dụng-glm","chapter":"19 Hồi quy đơn và đa biến","heading":"Phân tích đơn biến sử dụng glm()","text":"Trong ví dụ này, chúng tôi đánh giá mối liên quan giữa nhóm tuổi và biến kết cục tử vong (được mã hóa là 1 trong phần chuẩn bị). Bên dưới là một mô hình đơn biến của biến kết cục outcome theo age_cat. Chúng tôi lưu kết quả đầu ra được đặt tên là model và sau đó kết quả đến console bằng hàm summary(). Lưu ý, các ước tính được tạo ra là các giá trị lôgarít của tỷ số chênh (log odds) và giá trị tham chiếu là giá trị đầu tiên của biến age_cat (“0-4”).Để thay đổi giá trị tham chiếu của một biến Factor và chuyển giá trị mong muốn lên vị trí đầu tiên, dùng hàm fct_relevel() (xem chương Factors). Ở ví dụ bên dưới, chúng tôi lấy biến age_cat và đặt nhóm tuổi “20-29” làm giá trị tham chiếu trước khi chuyển số liệu đã sửa đổi vào hàm glm().","code":"\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nsummary(model)## \n## Call:\n## glm(formula = outcome ~ age_cat, family = \"binomial\", data = linelist)\n## \n## Deviance Residuals: \n##    Min      1Q  Median      3Q     Max  \n## -1.339  -1.278   1.024   1.080   1.354  \n## \n## Coefficients:\n##               Estimate Std. Error z value Pr(>|z|)   \n## (Intercept)   0.233738   0.072805   3.210  0.00133 **\n## age_cat5-9   -0.062898   0.101733  -0.618  0.53640   \n## age_cat10-14  0.138204   0.107186   1.289  0.19726   \n## age_cat15-19 -0.005565   0.113343  -0.049  0.96084   \n## age_cat20-29  0.027511   0.102133   0.269  0.78765   \n## age_cat30-49  0.063764   0.113771   0.560  0.57517   \n## age_cat50-69 -0.387889   0.259240  -1.496  0.13459   \n## age_cat70+   -0.639203   0.915770  -0.698  0.48518   \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5705.1  on 4159  degrees of freedom\n## AIC: 5721.1\n## \n## Number of Fisher Scoring iterations: 4\nlinelist %>% \n  mutate(age_cat = fct_relevel(age_cat, \"20-29\", after = 0)) %>% \n  glm(formula = outcome ~ age_cat, family = \"binomial\") %>% \n  summary()## \n## Call:\n## glm(formula = outcome ~ age_cat, family = \"binomial\", data = .)\n## \n## Deviance Residuals: \n##    Min      1Q  Median      3Q     Max  \n## -1.339  -1.278   1.024   1.080   1.354  \n## \n## Coefficients:\n##              Estimate Std. Error z value Pr(>|z|)    \n## (Intercept)   0.26125    0.07163   3.647 0.000265 ***\n## age_cat0-4   -0.02751    0.10213  -0.269 0.787652    \n## age_cat5-9   -0.09041    0.10090  -0.896 0.370220    \n## age_cat10-14  0.11069    0.10639   1.040 0.298133    \n## age_cat15-19 -0.03308    0.11259  -0.294 0.768934    \n## age_cat30-49  0.03625    0.11302   0.321 0.748390    \n## age_cat50-69 -0.41540    0.25891  -1.604 0.108625    \n## age_cat70+   -0.66671    0.91568  -0.728 0.466546    \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5705.1  on 4159  degrees of freedom\n## AIC: 5721.1\n## \n## Number of Fisher Scoring iterations: 4"},{"path":"regression.html","id":"in-kết-quả","chapter":"19 Hồi quy đơn và đa biến","heading":"In kết quả","text":"Đối với hầu hết các mục đích sử dụng, kết quả đầu ra cần phải có một số sửa đổi. Hàm làm gọn tidy() trong package broom có những tiện lợi để hiển thị kết quả của mô hình.Ở đây, chúng tôi trình bày cách để kết hợp các kết quả đầu ra của mô hình vào trong một bảng.Lấy lũy thừa logarit của ước lượng tỉ số chênh và khoảng tin cậy bằng cách đưa mô hình vào hàm tidy() và thiết lập lũy thừa exponentiate = TRUE và conf.int = TRUE.Bên dưới là bảng kết quả đầu ra của model:Kết hợp các kết quả của mô hình vào trong một bảng đếm. Dưới đây, chúng tôi tạo một bảng đếm bằng hàm tabyl() từ package janitor, như được đề cập trong chương Bảng mô tả.Đây là cách mà bảng counts_table được hiển thị:Bây giờ chúng ta có thể nối bảng counts_table và kết quả của mô hình model lại với nhau theo chiều ngang bằng hàm nối cột bind_cols() (dplyr). Hãy nhớ rằng đối với hàm bind_cols() các hàng trong hai cấu trúc dữ liệu trên phải được căn chỉnh hoàn hảo. Trong đoạn code này, bởi vì chúng ta đang thực hiện một chuỗi các thuật toán pipe, chúng ta sử dụng dấu . để đại diện cho đối tượng được nối trong bảng đếm counts_table khi chúng tôi nối nó với kết quả mô hình model. Để kết thúc quy trình này, chúng ta sử dụng hàm select() để chọn các cột mong muốn và thứ tự của nó, và cuối cùng áp dụng hàm round() trong base R để làm tròn với hai chữ số thập phân cho tất cả các cột.Đây là hiển thị của cấu trúc đã được kết hợp, nó được xuất gọn gẽ dưới dạng một hình bằng thông qua một hàm trong package flextable. Chương Trình bày bảng giải thích cách tùy chỉnh các bảng như vậy bằng flextable, hoặc có thể sử dụng các gói lệnh khác như knitr hoặc GT.","code":"\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist) %>% \n  tidy(exponentiate = TRUE, conf.int = TRUE) %>%        # exponentiate and produce CIs\n  mutate(across(where(is.numeric), round, digits = 2))  # round all numeric columns\ncounts_table <- linelist %>% \n  janitor::tabyl(age_cat, outcome)\ncombined <- counts_table %>%           # begin with table of counts\n  bind_cols(., model) %>%              # combine with the outputs of the regression \n  select(term, 2:3, estimate,          # select and re-order cols\n         conf.low, conf.high, p.value) %>% \n  mutate(across(where(is.numeric), round, digits = 2)) ## round to 2 decimal places\ncombined <- combined %>% \n  flextable::qflextable()"},{"path":"regression.html","id":"vòng-lặp-cho-nhiều-mô-hình-đơn-biến","chapter":"19 Hồi quy đơn và đa biến","heading":"Vòng lặp cho nhiều mô hình đơn biến","text":"Sau đây chúng tôi trình bày một phương pháp sử dụng glm() và tidy() để có một cách tiếp cận đơn giản hơn, xem thêm ở phần gtsummary.Để thực hiện các mô hình cho một số biến giải thích và cho ra các tỷ số chênh trong phân tích đơn biến (nghĩa là không có kiểm soát lẫn nhau), chúng ta có thể sử dụng các cách tiếp cận dưới đây. Sử dụng hàm str_c() từ package stringr để tạo ra các công thức cho phân tích đơn biến (xem chương Ký tự và chuỗi), thực hiện hàm glm() cho mỗi công thức, chuyển mỗi kết quả đầu ra của glm() đến hàm tidy() và cuối cùng thu gọn lại tất các kết quả đầu ra của mô hình bằng hàm nối dòng bind_rows() từ tidyr. Phương pháp này sử dụng hàm map() từ package purrr để lặp - xem chương [Lặp, vòng lặp và danh sách] để biết thêm thông tin về công cụ này.Tạo một véctơ tên các cột của biến giải thích. Chúng ta đã tạo biến này explanatory_vars trong phần chuẩn bị của chương này.Tạo một véctơ tên các cột của biến giải thích. Chúng ta đã tạo biến này explanatory_vars trong phần chuẩn bị của chương này.Sử dụng hàm str_c() để tạo các công thức chuỗi với biến kết cục outcome ở bên trái và tên một cột của véctơ explanatory_vars ở bên phải. Dấu chấm . trong hàm này thay thế cho tên cột trong véctơ explanatory_vars.Sử dụng hàm str_c() để tạo các công thức chuỗi với biến kết cục outcome ở bên trái và tên một cột của véctơ explanatory_vars ở bên phải. Dấu chấm . trong hàm này thay thế cho tên cột trong véctơ explanatory_vars.Đưa các công thức chuỗi này vào hàm map() và đặt ~glm() làm hàm áp dụng cho mỗi đầu vào. Bên trong hàm glm(), thiết lập công thức hồi quy .formula(.x) trong đó .x sẽ được thay thế bằng các công thức chuỗi đã được tạo bên trên. Hàm map() sẽ lặp từng công thức chuỗi và thực hiện hồi quy cho từng công thức.Đưa các công thức chuỗi này vào hàm map() và đặt ~glm() làm hàm áp dụng cho mỗi đầu vào. Bên trong hàm glm(), thiết lập công thức hồi quy .formula(.x) trong đó .x sẽ được thay thế bằng các công thức chuỗi đã được tạo bên trên. Hàm map() sẽ lặp từng công thức chuỗi và thực hiện hồi quy cho từng công thức.Kết quả đầu ra của hàm map() đầu tiên sẽ được chuyển đến hàm map() thứ hai mà sử dụng hàm tidy() để làm gọn các kết quả đầu ra.Kết quả đầu ra của hàm map() đầu tiên sẽ được chuyển đến hàm map() thứ hai mà sử dụng hàm tidy() để làm gọn các kết quả đầu ra.Cuối cùng, kết quả đầu ra của hàm map() thứ hai (một danh sách các data frames đã được làm gọn) được tóm tắt bằng hàm nối dòng bind_rows(), kết quả cho ra một data frame với tất cả các kết quả đơn biến.Cuối cùng, kết quả đầu ra của hàm map() thứ hai (một danh sách các data frames đã được làm gọn) được tóm tắt bằng hàm nối dòng bind_rows(), kết quả cho ra một data frame với tất cả các kết quả đơn biến.Lúc này, kết quả xuất ra của models dài hơn bởi vì kết quả bây giờ bao gồm các kết quả đầu ra của một số hồi quy đơn biến. Nhấp nút tiếp theo để xem tất cả các hàng của model.Như lúc trước, chúng ta có thể tạo một bảng đếm từ bộ số liệu linelist cho mỗi biến giải thích, gắn chúng với models, và tạo ra một bảng đẹp. Chúng ta bắt đầu với các biến giải thích này, và lặp lại các biến này thông qua hàm map(). Chúng ta lặp lại qua một hàm người dùng tạo ra mà liên quan đến việc tạo ra một bảng đếm bằng cách dùng các hàm trong package dplyr Sau đó, kết quả được kết nối trình tự với kết quả của mô hình models.Bên dưới là cấu trúc số liệu kết nối được tạo ra. Xem chương Trình bày bảng để có thêm ý tưởng về cách chuyển đổi bảng số liệu này thành một bảng đẹp trên HTML (ví dụ như với package flextable).","code":"\nexplanatory_vars %>% str_c(\"outcome ~ \", .)## [1] \"outcome ~ gender\"  \"outcome ~ fever\"   \"outcome ~ chills\"  \"outcome ~ cough\"   \"outcome ~ aches\"   \"outcome ~ vomit\"   \"outcome ~ age_cat\"\nmodels <- explanatory_vars %>%       # begin with variables of interest\n  str_c(\"outcome ~ \", .) %>%         # combine each variable into formula (\"outcome ~ variable of interest\")\n  \n  # iterate through each univariate formula\n  map(                               \n    .f = ~glm(                       # pass the formulas one-by-one to glm()\n      formula = as.formula(.x),      # within glm(), the string formula is .x\n      family = \"binomial\",           # specify type of glm (logistic)\n      data = linelist)) %>%          # dataset\n  \n  # tidy up each of the glm regression outputs from above\n  map(\n    .f = ~tidy(\n      .x, \n      exponentiate = TRUE,           # exponentiate \n      conf.int = TRUE)) %>%          # return confidence intervals\n  \n  # collapse the list of regression outputs in to one data frame\n  bind_rows() %>% \n  \n  # round all numeric columns\n  mutate(across(where(is.numeric), round, digits = 2))\n## for each explanatory variable\nuniv_tab_base <- explanatory_vars %>% \n  map(.f = \n    ~{linelist %>%                ## begin with linelist\n        group_by(outcome) %>%     ## group data set by outcome\n        count(.data[[.x]]) %>%    ## produce counts for variable of interest\n        pivot_wider(              ## spread to wide format (as in cross-tabulation)\n          names_from = outcome,\n          values_from = n) %>% \n        drop_na(.data[[.x]]) %>%         ## drop rows with missings\n        rename(\"variable\" = .x) %>%      ## change variable of interest column to \"variable\"\n        mutate(variable = as.character(variable))} ## convert to character, else non-dichotomous (categorical) variables come out as factor and cant be merged\n      ) %>% \n  \n  ## collapse the list of count outputs in to one data frame\n  bind_rows() %>% \n  \n  ## merge with the outputs of the regression \n  bind_cols(., models) %>% \n  \n  ## only keep columns interested in \n  select(term, 2:3, estimate, conf.low, conf.high, p.value) %>% \n  \n  ## round decimal places\n  mutate(across(where(is.numeric), round, digits = 2))"},{"path":"regression.html","id":"reg_gt_uni","chapter":"19 Hồi quy đơn và đa biến","heading":"gtsummary package","text":"Sau đây chúng tôi sẽ trình bày cách sử dụng hàm tbl_uvregression() từ package gtsummary. Cũng giống như trong chương Bảng mô tả, các hàm trong gtsummary thực hiện tốt các thống kê và xuất ra các kết quả khá chuyên nghiệp. Hàm này xuất ra một bảng kết quả của hồi quy đơn biến.Chúng ta chỉ chọn các cột cần thiết từ bộ số liệu linelist (ecác biến giải thích và biến kết cục) và pipe chúng vào hàm tbl_uvregression(). Chúng ta sẽ thực hiện hồi quy đơn biến cho mỗi cột như được xác định trong véctơ explanatory_vars trong mục Chuẩn bị (gender, fever, chills, cough, aches, vomit, và age_cat).Trong hàm này, chúng ta cung cấp thêm phương pháp thực hiện method = là glm (không có dấu ngoặc kép), biến kết cục y = cột kết quả (biến outcome), cụ thể method.args = mà chúng ta muốn thực hiện hồi quy logistic qua family = binomial, và lấy lũy thừa của kết quả.Kết quả đầu ra dưới dạng HTML và chứa cột đếm\n          1\n          \n           \n          = Odds Ratio, CI = Confidence Interval\n          Chúng ta có thể sửa đổi đối với kết quả đầu ra của bảng này, ví dụ như điều chỉnh các nhãn, tô đậm các hàng theo giá trị p, .v.v. Xem hướng dẫn tại đây và các tài liệu trực tuyến khác.","code":"\nuniv_tab <- linelist %>% \n  dplyr::select(explanatory_vars, outcome) %>% ## select variables of interest\n\n  tbl_uvregression(                         ## produce univariate table\n    method = glm,                           ## define regression want to run (generalised linear model)\n    y = outcome,                            ## define outcome variable\n    method.args = list(family = binomial),  ## define what type of glm want to run (logistic)\n    exponentiate = TRUE                     ## exponentiate to produce odds ratios (rather than log odds)\n  )\n\n## view univariate results table \nuniv_tab"},{"path":"regression.html","id":"phân-tích-phân-tầng","chapter":"19 Hồi quy đơn và đa biến","heading":"19.3 Phân tích phân tầng","text":"Hiện tại, phân tích phần tầng sử dụng package gtsummary đang được xây dựng, phần này sẽ được cập nhật trong thời gian thích hợp.","code":""},{"path":"regression.html","id":"phân-tích-đa-biến","chapter":"19 Hồi quy đơn và đa biến","heading":"19.4 Phân tích đa biến","text":"Đối với phân tích đa biến, chúng tôi trình bày hai cách tiếp cận:glm() và tidy()Package gtsummaryQuy trình thực hiện khá tương tự và chỉ khác ở bước cuối cùng để kết nối kết quả lại với nhau.","code":""},{"path":"regression.html","id":"thực-hiện-phân-tích-đa-biến","chapter":"19 Hồi quy đơn và đa biến","heading":"Thực hiện phân tích đa biến","text":"Ở đây chúng tôi sử dụng hàm glm() nhưng thêm nhiều biến hơn vào bên phải của phương trình và được phân tách với nhau bằng dấu cộng (+).Để thực hiện mô hình với tất cả các biến giải thích, chúng ta thực hiện lệnh sau:Nếu muốn bao gồm hai biến và tương tác của hai biến này, chúng ta có thể phân tách chúng bằng dấu hoa thị * thay cho dấu +. Nếu chúng ta chỉ muốn cụ thể sự tương tác, phân tách chúng bằng dấu hai chấm :. Ví dụ:Một tùy chọn khác, chúng ta có thể sử dụng đoạn mã này để sử dụng một véc tơ đã được định nghĩa trước của các cột và tạo lại lệnh trên bằng cách sử dụng hàm str_c(). Điều này có thể hữu ích nếu chúng ta thay đổi tên các biến giải thích, hoặc bạn không muốn gõ lại tất cả mọi thứ.","code":"\nmv_reg <- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = \"binomial\", data = linelist)\n\nsummary(mv_reg)## \n## Call:\n## glm(formula = outcome ~ gender + fever + chills + cough + aches + \n##     vomit + age_cat, family = \"binomial\", data = linelist)\n## \n## Deviance Residuals: \n##    Min      1Q  Median      3Q     Max  \n## -1.383  -1.279   1.029   1.078   1.346  \n## \n## Coefficients:\n##               Estimate Std. Error z value Pr(>|z|)\n## (Intercept)   0.069054   0.131726   0.524    0.600\n## gender        0.002448   0.065133   0.038    0.970\n## fever         0.004309   0.080522   0.054    0.957\n## chills        0.034112   0.078924   0.432    0.666\n## cough         0.138584   0.089909   1.541    0.123\n## aches        -0.070705   0.104078  -0.679    0.497\n## vomit         0.086098   0.062618   1.375    0.169\n## age_cat5-9   -0.063562   0.101851  -0.624    0.533\n## age_cat10-14  0.136372   0.107275   1.271    0.204\n## age_cat15-19 -0.011074   0.113640  -0.097    0.922\n## age_cat20-29  0.026552   0.102780   0.258    0.796\n## age_cat30-49  0.059569   0.116402   0.512    0.609\n## age_cat50-69 -0.388964   0.262384  -1.482    0.138\n## age_cat70+   -0.647443   0.917375  -0.706    0.480\n## \n## (Dispersion parameter for binomial family taken to be 1)\n## \n##     Null deviance: 5712.4  on 4166  degrees of freedom\n## Residual deviance: 5700.2  on 4153  degrees of freedom\n## AIC: 5728.2\n## \n## Number of Fisher Scoring iterations: 4\nglm(outcome ~ gender + age_cat * fever, family = \"binomial\", data = linelist)\n## run a regression with all variables of interest \nmv_reg <- explanatory_vars %>%  ## begin with vector of explanatory column names\n  str_c(collapse = \"+\") %>%     ## combine all names of the variables of interest separated by a plus\n  str_c(\"outcome ~ \", .) %>%    ## combine the names of variables of interest with outcome in formula style\n  glm(family = \"binomial\",      ## define type of glm as logistic,\n      data = linelist)          ## define your dataset"},{"path":"regression.html","id":"xây-dựng-mô-hình","chapter":"19 Hồi quy đơn và đa biến","heading":"Xây dựng mô hình","text":"Chúng ta có thể xây dựng mô hình theo từng bước, lưu các mô hình khác nhau với một số biến giải thích. Chúng ta có thể sử dụng kiểm định tỷ số khả dĩ (likelihood-ratio tests) để sánh các mô hình này bằng cách sử dụng hàm lrtest() từ package lmtest, như dưới đây:CHÚ Ý: Sử dụng hàn anova(model1, model2, test = \"Chisq) trong base R cũng cho kết quả tương tựMột tùy chọn khác là lấy đối tượng của mô hình và sử dụng hàm step() từ package stats. Chỉ rõ hướng lựa chọn biến mà chúng ta muốn sử dụng khi xây dựng mô hình.Để hiển thị rõ số, chúng ta có thể tắt ký hiệu khoa học trong R bằng lệnh sauNhư được mô tả trong phần phân tích đơn biến, chuyển kết quả đầu ra của mô hình vào hàm tidy() để lấy lũy thừa cho các hệ số và khoảng tin cậy (CIs). Cuối cùng, làm tròn tất cả các cột số với hai số thập phân. Kéo qua để xem tất cả các hàng.Đây là hiển thị kết quả dưới dạng data frame looks:","code":"\nmodel1 <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nmodel2 <- glm(outcome ~ age_cat + gender, family = \"binomial\", data = linelist)\n\nlmtest::lrtest(model1, model2)## Likelihood ratio test\n## \n## Model 1: outcome ~ age_cat\n## Model 2: outcome ~ age_cat + gender\n##   #Df  LogLik Df  Chisq Pr(>Chisq)\n## 1   8 -2852.6                     \n## 2   9 -2852.6  1 0.0002     0.9883\n## choose a model using forward selection based on AIC\n## you can also do \"backward\" or \"both\" by adjusting the direction\nfinal_mv_reg <- mv_reg %>%\n  step(direction = \"forward\", trace = FALSE)\noptions(scipen=999)\nmv_tab_base <- final_mv_reg %>% \n  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %>%  ## get a tidy dataframe of estimates \n  mutate(across(where(is.numeric), round, digits = 2))          ## round "},{"path":"regression.html","id":"gộp-kết-quả-phân-tích-đơn-biến-và-đa-biến","chapter":"19 Hồi quy đơn và đa biến","heading":"Gộp kết quả phân tích đơn biến và đa biến","text":"","code":""},{"path":"regression.html","id":"gộp-bằng-package-gtsummary","chapter":"19 Hồi quy đơn và đa biến","heading":"Gộp bằng package gtsummary","text":"Hàm tbl_regression() trong package gtsummary sẽ lấy kết quả đầu tra từ một hồi quy (hàm glm() trong trường hợp này) và tạo ra một bảng tóm tắt đẹp.Hãy xem bảng sau:\n          1\n          \n           \n          = Odds Ratio, CI = Confidence Interval\n          Chúng ta cũng có thể kết hợp một số bảng kết quả đầu ra bằng cách dùng hàm tbl_merge() trong package gtsummary. Bây giờ chúng ta hộp các kết quả đa biến với kết quả đơn biến đã được tạo bên trên bằng package gtsummary:\n          1\n          \n           \n          = Odds Ratio, CI = Confidence Interval\n          ","code":"\n## show results table of final regression \nmv_tab <- tbl_regression(final_mv_reg, exponentiate = TRUE)\nmv_tab\n## combine with univariate results \ntbl_merge(\n  tbls = list(univ_tab, mv_tab),                          # combine\n  tab_spanner = c(\"**Univariate**\", \"**Multivariable**\")) # set header names"},{"path":"regression.html","id":"gộp-bằng-package-dplyr","chapter":"19 Hồi quy đơn và đa biến","heading":"Gộp bằng package dplyr","text":"Một cách khác để gộp các kết quả đơn biến và đa biến từ các hàm glm()/tidy() bằng cách sử dụng các hàm kết nối từ package dplyr.Kết nối kết quả đơn biến trước đó (univ_tab_base, chứa được các cột đếm) với kết quả đa biến đã được làm gọn mv_tab_baseSử dụng hàm select() để giữ lại, sắp xếp lại thứ tự và đặt lại tên các cột mà chúng ta muốnSử dụng hàm round() để làm tròn tất cả các cột với hai số thập phân","code":"\n## combine univariate and multivariable tables \nleft_join(univ_tab_base, mv_tab_base, by = \"term\") %>% \n  ## choose columns and rename them\n  select( # new name =  old name\n    \"characteristic\" = term, \n    \"recovered\"      = \"0\", \n    \"dead\"           = \"1\", \n    \"univ_or\"        = estimate.x, \n    \"univ_ci_low\"    = conf.low.x, \n    \"univ_ci_high\"   = conf.high.x,\n    \"univ_pval\"      = p.value.x, \n    \"mv_or\"          = estimate.y, \n    \"mvv_ci_low\"     = conf.low.y, \n    \"mv_ci_high\"     = conf.high.y,\n    \"mv_pval\"        = p.value.y \n  ) %>% \n  mutate(across(where(is.double), round, 2))   ## # A tibble: 20 x 11\n##    characteristic recovered  dead univ_or univ_ci_low univ_ci_high univ_pval mv_or mvv_ci_low mv_ci_high mv_pval\n##    <chr>              <dbl> <dbl>   <dbl>       <dbl>        <dbl>     <dbl> <dbl>      <dbl>      <dbl>   <dbl>\n##  1 (Intercept)          909  1168    1.28        1.18         1.4       0     1.07       0.83       1.39    0.6 \n##  2 gender               916  1174    1           0.88         1.13      0.97  1          0.88       1.14    0.97\n##  3 (Intercept)          340   436    1.28        1.11         1.48      0     1.07       0.83       1.39    0.6 \n##  4 fever               1485  1906    1           0.85         1.17      0.99  1          0.86       1.18    0.96\n##  5 (Intercept)         1472  1877    1.28        1.19         1.37      0     1.07       0.83       1.39    0.6 \n##  6 chills               353   465    1.03        0.89         1.21      0.68  1.03       0.89       1.21    0.67\n##  7 (Intercept)          272   309    1.14        0.97         1.34      0.13  1.07       0.83       1.39    0.6 \n##  8 cough               1553  2033    1.15        0.97         1.37      0.11  1.15       0.96       1.37    0.12\n##  9 (Intercept)         1636  2114    1.29        1.21         1.38      0     1.07       0.83       1.39    0.6 \n## 10 aches                189   228    0.93        0.76         1.14      0.51  0.93       0.76       1.14    0.5 \n## 11 (Intercept)          931  1144    1.23        1.13         1.34      0     1.07       0.83       1.39    0.6 \n## 12 vomit                894  1198    1.09        0.96         1.23      0.17  1.09       0.96       1.23    0.17\n## 13 (Intercept)          338   427    1.26        1.1          1.46      0     1.07       0.83       1.39    0.6 \n## 14 age_cat5-9           365   433    0.94        0.77         1.15      0.54  0.94       0.77       1.15    0.53\n## 15 age_cat10-14         273   396    1.15        0.93         1.42      0.2   1.15       0.93       1.41    0.2 \n## 16 age_cat15-19         238   299    0.99        0.8          1.24      0.96  0.99       0.79       1.24    0.92\n## 17 age_cat20-29         345   448    1.03        0.84         1.26      0.79  1.03       0.84       1.26    0.8 \n## 18 age_cat30-49         228   307    1.07        0.85         1.33      0.58  1.06       0.85       1.33    0.61\n## 19 age_cat50-69          35    30    0.68        0.41         1.13      0.13  0.68       0.4        1.13    0.14\n## 20 age_cat70+             3     2    0.53        0.07         3.2       0.49  0.52       0.07       3.19    0.48"},{"path":"regression.html","id":"biểu-đồ-forest-plot","chapter":"19 Hồi quy đơn và đa biến","heading":"19.5 Biểu đồ Forest plot","text":"Phần này hướng dẫn cách tạo ra một biểu đồ của các kết quả hồi quy. Có hai lựa chọn để tạo biểu đồ, chúng ta có thể tự tạo một biểu đồ bằng cách sử dụng package ggplot2 hoặc sử dụng một meta-package có tên easystats (một package gồm nhiều package).Nếu chưa quen thuộc với gói lệnh tạo biểu đồ ggplot2, xem thêm chương ggplot cơ bản.","code":""},{"path":"regression.html","id":"ggplot2-package","chapter":"19 Hồi quy đơn và đa biến","heading":"ggplot2 package","text":"Bạn có thể xây dựng một forest plot với hàm ggplot() bằng cách vẽ các thành phần của kết quả hồi quy đa biến. Thêm các lớp của biều đồ bằng cách sử dụng các “geoms”:Các ước lượng bằng hàm geom_point()Khoảng tin cậy bằng hàm geom_errorbar()Đường thẳng đứng ở vị trí = 1 bằng hàm geom_vline()Trước khi tạo biểu đồ, chúng ta sử dụng hàm fct_relevel() từ package forcats để đặt thứ tự các biến trên trục y. Hàm ggplot() cho phép hiển thị theo thứ tự chữ-số mà có thể không hiển thị tốt cho các giá trị của biến tuổi (“30” có thể hiển thị trước “5”). Xem chương Factors để biết thêm chi tiết.","code":"\n## remove the intercept term from your multivariable results\nmv_tab_base %>% \n  \n  #set order of levels to appear along y-axis\n  mutate(term = fct_relevel(\n    term,\n    \"vomit\", \"gender\", \"fever\", \"cough\", \"chills\", \"aches\",\n    \"age_cat5-9\", \"age_cat10-14\", \"age_cat15-19\", \"age_cat20-29\",\n    \"age_cat30-49\", \"age_cat50-69\", \"age_cat70+\")) %>%\n  \n  # remove \"intercept\" row from plot\n  filter(term != \"(Intercept)\") %>% \n  \n  ## plot with variable on the y axis and estimate (OR) on the x axis\n  ggplot(aes(x = estimate, y = term)) +\n  \n  ## show the estimate as a point\n  geom_point() + \n  \n  ## add in an error bar for the confidence intervals\n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + \n  \n  ## show where OR = 1 is for reference as a dashed line\n  geom_vline(xintercept = 1, linetype = \"dashed\")"},{"path":"regression.html","id":"easystats-packages","chapter":"19 Hồi quy đơn và đa biến","heading":"easystats packages","text":"Lựa chọn thứ hai là sử dụng một sự kết hợp của các package trong easystats, nếu chúng ta không muốn mức độ kiểm soát chặt chẽ mà package ggplot2 cung cấp.Hàm model_parameters() từ package parameters thực hiện tương đương với hàm tidy() trong package broom . Sau đó, package see chấp nhận các kết quả đầu ra và tạo một biểu đồ forest plot mặc định giống như cho một đối tượng ggplot().","code":"\npacman::p_load(easystats)\n\n## remove the intercept term from your multivariable results\nfinal_mv_reg %>% \n  model_parameters(exponentiate = TRUE) %>% \n  plot()"},{"path":"regression.html","id":"nguồn-5","chapter":"19 Hồi quy đơn và đa biến","heading":"19.6 Nguồn","text":"Nội dung của chương này được tham khảo từ các nguồn sau:Linear regression RgtsummaryUCLA stats pagesthda stepwise regression","code":""},{"path":"missing-data.html","id":"missing-data","chapter":"20 Dữ liệu Missing","heading":"20 Dữ liệu Missing","text":"Chương này sẽ bao gồm cách để:Đánh giá số liệu bị thiếuLọc ra các hàng có số liệu bị thiếuVẽ biểu đồ số liệu bị thiếu theo thời gianXử lý cách NA được hiển thị trong biểu đồThực hiện gán số liệu bị thiếu: MCAR, MAR, MNAR","code":""},{"path":"missing-data.html","id":"chuẩn-bị-10","chapter":"20 Dữ liệu Missing","heading":"20.1 Chuẩn bị","text":"","code":""},{"path":"missing-data.html","id":"gọi-package-5","chapter":"20 Dữ liệu Missing","heading":"Gọi package","text":"Đoạn code này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, mà hàm này sẽ cài đặt package khi cần thiết và gọi nó ra để sử dụng. Bạn cũng có thể gọi các gói lệnh đã cài đặt bằng hàm library() trong base R. Xem chương R cơ bản để biết thêm thông tin về các R packages.","code":"\npacman::p_load(\n  rio,           # import/export\n  tidyverse,     # data mgmt and viz\n  naniar,        # assess and visualize missingness\n  mice           # missing data imputation\n)"},{"path":"missing-data.html","id":"nhập-số-liệu-2","chapter":"20 Dữ liệu Missing","heading":"Nhập số liệu","text":"Chúng ta nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Để tiện làm theo, bấm để tải số liệu linelist “đã làm sạch” (.rds file). Nhập số liệu này bằng hàm import() trong package rio (nó chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv – xem chi tiết trong chương Nhập xuất dữ liệu).Bên dưới là hiển thị của 50 hàng đầu tiên của bộ số liệu linelist.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"missing-data.html","id":"chuyển-đổi-missing-khi-nhập-dữ-liệu","chapter":"20 Dữ liệu Missing","heading":"Chuyển đổi missing khi nhập dữ liệu","text":"Khi nhập số liệu, hãy lưu ý các giá trị có thể được phân loại là các giá trị missing. Ví dụ: 99, 999, “Missing”, ô trống (““), hoặc các ô có khoảng trống (” “). Bạn có thể chuyển đổi các giá trị này thành NA (cách R lưu trữ số liệu missing) trong khi thực hiện lệnh nhập số liệu.\nXem phần nhập số liệu trong chương Dữ liệu missing để biết thêm chi tiết, vì cú pháp chính xác sẽ khác nhau tùy theo loại tệp.","code":""},{"path":"missing-data.html","id":"giá-trị-missing-trong-r","chapter":"20 Dữ liệu Missing","heading":"20.2 Giá trị missing trong R","text":"Sau đây chúng ta sẽ khảo sát rõ cách số liệu bị thiếu được trình bày và đánh giá trong R bởi các giá trị liền kề và các hàm.","code":""},{"path":"missing-data.html","id":"na","chapter":"20 Dữ liệu Missing","heading":"NA","text":"Trong R, giá trị bị thiếu được đại diện bởi một giá trị dành riêng (đặc biệt) - NA. Lưu ý rằng giá trị này được nhập không có dấu ngoặc kép. “NA” là khác biệt và cũng chỉ là một giá trị ký tự bình thường (như lời bài hát của Beatles trong bài Hey Jude).Số liệu của chúng ta có thể có các cách khác để biểu thị giá trị bị thiếu, như là “99”, hoặc “Giá trị bị thiếu / Missing”, hoặc “Không biết / Unknown”, thậm chí chúng ta có giá trị ký tự trống “” như “để trống / blank”, hoặc một khoảng trắng ” “. Cần lưu ý những giá trị này và xem xét có nên chuyển đổi chúng thành NA khi nhập vào R hoặc trong khi làm sạch số liệu bằng hàm na_if() hay không.Trong lúc làm sạch số liệu, chúng ta cũng có thể muốn chuyển đổi số liệu theo một cách khác – chuyển đổi tất cả NA thành “Missing” hoặc làm tương tự với hàm replace_na() hoặc với hàm fct_explicit_na() cho các factors.","code":""},{"path":"missing-data.html","id":"các-phiên-bản-của-na","chapter":"20 Dữ liệu Missing","heading":"Các phiên bản của NA","text":"Trong hầu hết trường hợp, NA đại diện cho giá trị bị thiếu và mọi thứ đều vận hành tốt. Tuy nhiên, trong một số trường hợp, chúng ta có thể gặp phải những tình huống khó khăn đối với các biến thể của NA mà đặc trưng cho một lớp đối tượng (ký tự, số, .v.v.). Điều này rất hiếm, nhưng chúng ta cần phải lưu ý.\nTình huống điển hình cho trường hợp này là khi tạo một cột mới bằng hàm case_when() trong package dplyr. Như được mô tả trong chương Làm sạch số liệu và các hàm quan trọng, hàm này lượng giá mọi hàng trong data frame, đánh giá xem các hàng có đáp ứng với các tiêu chí logic cụ thể hay không (phía bên phải của code), và gán giá trị chính xác mới (phía bên trái của code). Quan trọng: tất cả các giá trị bên phải phải cùng một lớp biến số.Nếu bạn muốn NA ở phía bên phải, có thể cần phải chỉ định một trong các tùy chọn đặc biệt của NA được liệt kê bên dưới. Nếu các giá trị bên phải khác là ký tự, cân nhắc sử dụng “Missing” hoặc sử dụng NA_character_. Nếu chúng là các giá trị số, sử dụng NA_real_. Nếu tất cả các giá trị là ngày tháng hoặc logic, chúng ta có thể sử dụng NA.NA - dùng cho biến ngày tháng hoặc biến số logic TRUE/FALSENA_character_ - dùng cho biến số ký tựNA_real_ - dùng cho biến dạng sốMột lần nữa, chúng ta sẽ không gặp các loại biến thể này trừ khi chúng ta sử dụng hàm case_when() để tạo biến mới. Xem phần Tài liệu về NA trong R để biết thêm thông tin.","code":"\nlinelist <- linelist %>% \n  \n  # Create new \"age_years\" column from \"age\" column\n  mutate(age_years = case_when(\n    age_unit == \"years\"  ~ age,       # if age is given in years, assign original value\n    age_unit == \"months\" ~ age/12,    # if age is given in months, divide by 12\n    is.na(age_unit)      ~ age,       # if age UNIT is missing, assume years\n    TRUE                 ~ NA_real_)) # any other circumstance, assign missing"},{"path":"missing-data.html","id":"null","chapter":"20 Dữ liệu Missing","heading":"NULL","text":"NULL là một giá trị dành riêng khác nữa trong R. Nó đại điện cho một mệnh đề không đúng cũng không sai. Nó là kết quả của các biểu thức hoặc hàm có giá trị không xác định. Nói chung, không gán NULL như một giá trị, trừ khi viết hàm hoặc khi viết mộ [Ứng dụng shiny][Dashboards Shiny] để trả về NULL trong các tình huống cụ thể.Null có thể được đánh giá bằng cách sử dụng hàm .null() và có thể chuyển đổi thành bằng hàm .null().Xem bài viết trên blog này để biết về sự khác biệt giữa NULL và NA.","code":""},{"path":"missing-data.html","id":"nan","chapter":"20 Dữ liệu Missing","heading":"NaN","text":"Các giá trị không thể được đại diện bằng một giá trị đặc biệt NaN. Một ví dụ cho giá trị này là khi chúng ta bắt buộc R chia 0 cho 0. Chúng ta có thể đánh giá giá trị này bằng cách dùng hàm .nan(). Chúng ta cũng có thể gặp các hàm bổ sung bao gồm .infinite() và .finite().","code":""},{"path":"missing-data.html","id":"inf","chapter":"20 Dữ liệu Missing","heading":"Inf","text":"Inf đại diện cho giá trị vô hạn như là khi chia một số nào đó cho 0.Một ví dụ về cách mà giá trị này ảnh hưởng đến số liệu của chúng ta: giả sử chúng ta có một véctơ hay một cột z chứa các giá trị sau: z <- c(1, 22, NA, Inf, NaN, 5)Nếu bạn muốn sử dụng hàm max() của cột bên trên để tìm giá trị lớn nhất, bạn có thể sử dụng na.rm = TRUE để loại bỏ NA khỏi phép tính, nhưng Inf và NaN vẫn còn, và Inf sẽ được trả về. Để giải quyết vấn đề này, chúng ta có thể sử dụng dấu ngoặc vuông [ ] và hàm .finite() để tạo tập hợp con mà chỉ có các giá trị hữu hạn được sử dụng để tính toán: max(z[.finite(z)]).","code":"\nz <- c(1, 22, NA, Inf, NaN, 5)\nmax(z)                           # returns NA\nmax(z, na.rm=T)                  # returns Inf\nmax(z[is.finite(z)])             # returns 22"},{"path":"missing-data.html","id":"các-ví-dụ-1","chapter":"20 Dữ liệu Missing","heading":"Các ví dụ","text":"“NAs introduced coercion (NAs được tạo ra ép buộc)” là một cảnh báo phổ biến. Điều này có thể xảy ra khi chúng ta cố gắng thực hiện một chuyển đổi không hợp lệ như chèn một giá trị ký tự vào trong một véctơ dạng số.NULL được bỏ qua trong một véctơ.Phương sai của một số cho kết quả là NA.","code":"\nas.numeric(c(\"10\", \"20\", \"thirty\", \"40\"))## Warning: NAs introduced by coercion## [1] 10 20 NA 40\nmy_vector <- c(25, NA, 10, NULL)  # define\nmy_vector                         # print## [1] 25 NA 10\nvar(22)## [1] NA"},{"path":"missing-data.html","id":"các-hàm-hữu-dụng","chapter":"20 Dữ liệu Missing","heading":"20.3 Các hàm hữu dụng","text":"Dưới đây là các hàm hữu dụng trong base R khi đánh giá hoặc xử lý các giá trị bị thiếu:","code":""},{"path":"missing-data.html","id":"is.na-và-is.na","chapter":"20 Dữ liệu Missing","heading":"is.na() và !is.na()","text":"Sử dụng hàm .na() để nhận ra các giá trị bị thiếu hoặc sử dụng hàm đối của nó (với dấu ! ở phía trước) để nhận ra các giá trị không phải là missing. Cả hai hàm trên đều trả kết quả về một giá trị logic (TRUE hoặc FALSE). Nhớ rằng bạn có thể dùng hàm sum() đối với véc tơ kết quả/đầu ra để đếm số lượng TRUE, vd: sum(.na(linelist$date_outcome)).","code":"\nmy_vector <- c(1, 4, 56, NA, 5, NA, 22)\nis.na(my_vector)## [1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n!is.na(my_vector)## [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nsum(is.na(my_vector))## [1] 2"},{"path":"missing-data.html","id":"na.omit","chapter":"20 Dữ liệu Missing","heading":"na.omit()","text":"Hàm này, nếu được áp dụng trên một data frame, sẽ loại bỏ các hàng có bất kỳ giá trị nào bị thiếu. Hàm này cũng từ base R.\nNếu áp dụng cho một véctơ, hàm này sẽ loại bỏ các giá trị NA của véctơ này. Ví dụ:","code":"\nna.omit(my_vector)## [1]  1  4 56  5 22\n## attr(,\"na.action\")\n## [1] 4 6\n## attr(,\"class\")\n## [1] \"omit\""},{"path":"missing-data.html","id":"drop_na","chapter":"20 Dữ liệu Missing","heading":"drop_na()","text":"Đây là một hàm của package tidyr mà rất hữu dụng trong một [pipeline làm sạch số liệu][Cleaning data core functions]. Nếu thực hiện hàm với dấu ngoặc trống, nó sẽ loại bỏ các hàng có bất kỳ giá trị nào bị thiếu. Nếu cụ thể tên cột trong dấu ngoặc, các hàng nào có giá trị bị thiếu trong những cột này sẽ bị loại bỏ. Chúng ta có thể sử dụng cú pháp “tidyselect” để chỉ định các cột này.","code":"\nlinelist %>% \n  drop_na(case_id, date_onset, age) # drops rows missing values for any of these columns"},{"path":"missing-data.html","id":"na.rm-true","chapter":"20 Dữ liệu Missing","heading":"na.rm = TRUE","text":"Khi chúng ta thực hiện một hàm toán học như max(), min(), sum() hoặc mean(), nếu có sự hiện diện của bất kỳ giá trị NA, kết quả sẽ là NA. Cách xử lý mặc định này là có chủ ý để cảnh báo chúng ta khi có số liệu bị thiếu.Bạn có thể tránh việc này bằng cách loại bỏ các giá trị bị thiếu ra khỏi phép tính. Để thực hiện, hãy thêm đối số na.rm = TRUE (“na.rm” là viết tắt của “remove NA”).","code":"\nmy_vector <- c(1, 4, 56, NA, 5, NA, 22)\n\nmean(my_vector)     ## [1] NA\nmean(my_vector, na.rm = TRUE)## [1] 17.6"},{"path":"missing-data.html","id":"đánh-giá-tính-không-đầy-đủ-của-một-data-frame","chapter":"20 Dữ liệu Missing","heading":"20.4 Đánh giá tính không đầy đủ của một data frame","text":"Bạn có thể sử dụng package naniar để đánh giá và trực quan hóa các giá trị bị thiếu trong bộ số liệu linelist.","code":"\n# install and/or load package\npacman::p_load(naniar)"},{"path":"missing-data.html","id":"định-lượng-tính-không-đầy-đủ","chapter":"20 Dữ liệu Missing","heading":"Định lượng tính không đầy đủ","text":"Để tìm phần trăm của tất cả các giá trị bị thiếu, sử dụng hàm pct_miss(). Để biết số lượng bị thiếu, sử dụng hàm n_miss().Hai hàm bên dưới trả về phần trăm số hàng có bất kỳ giá trị bị thiếu hoặc hoàn toàn đầy đủ. Hãy nhớ rằng NA có nghĩa là giá trị missing, và `\"\" hoặc \" \" sẽ không được đếm là giá trị missing.","code":"\n# percent of ALL data frame values that are missing\npct_miss(linelist)## [1] 6.688745\n# Percent of rows with any value missing\npct_miss_case(linelist)   # use n_complete() for counts## [1] 69.12364\n# Percent of rows that are complete (no values missing)  \npct_complete_case(linelist) # use n_complete() for counts## [1] 30.87636"},{"path":"missing-data.html","id":"trực-quan-hóa-tính-không-đầy-đủ","chapter":"20 Dữ liệu Missing","heading":"Trực quan hóa tính không đầy đủ","text":"Hàm gg_miss_var() sẽ hiển thị cho chúng ta số lượng (hoặc %) của các giá trị bị thiếu trong mỗi cột. Một vài sắc thái như sau:Chúng ta có thể thêm tên cột (không ở trong dấu ngoặc kép) vào đối số facet = để xem biểu đồ theo nhómTheo mặc định, số đếm sẽ được hiển thị thay vì con số phần trăm, để thay đổi điều này bằng cách sử dụng thêm show_pct = TRUEChúng ta có thể thêm nhãn các trục và tiêu đề như đối với các hàm ggplot() thông thường với + labs(...)Ở đây số liệu được dẫn bằng ký hiệu %>% vào trong hàm. Đối số facet = cũng được sử dụng để phân chia số liệu.Bạn có thể sử dụng hàm vis_miss() để hình ảnh hóa số liệu dưới dạng một bản đồ nhiệt, mà cho biết từng giá trị có bị thiếu hay không. Chúng ta cũng có thể sử dụng hàm select() để lựa chọn một số cột nhất định từ data frame và chỉ cung cấp các cột đó vào trong hàm.","code":"\ngg_miss_var(linelist, show_pct = TRUE)\nlinelist %>% \n  gg_miss_var(show_pct = TRUE, facet = outcome)\n# Heatplot of missingness across the entire data frame  \nvis_miss(linelist)"},{"path":"missing-data.html","id":"khám-phá-và-trực-quan-hóa-các-mối-quan-hệ-của-dữ-liệu-bị-thiếu","chapter":"20 Dữ liệu Missing","heading":"Khám phá và trực quan hóa các mối quan hệ của dữ liệu bị thiếu","text":"Làm thế nào chúng ta hình ảnh hóa một cái gì đó mà không có ở đó??? Theo mặc định, hàm ggplot() sẽ loại bỏ các giá trị bị thiếu ra khỏi biểu đồ.Package naniar cung cấp một giải pháp thông qua hàm geom_miss_point(). Khi tạo biểu đồ phân tán của hai cột, các bản ghi có một trong các giá trị bị thiếu và sự hiện diện của giá trị khác được hiển thị bằng cách đặt các giá trị bị thiếu thấp hơn 10% với giá trị thấp nhất trong cột đó và và tô màu để dễ phân biệt.Trong biểu đồ phân tán bên dưới, các chấm màu đỏ là các bản ghi khi có giá trị của một cột nhưng thiếu giá trị của cột còn lại. Điều này cho phép chúng ta thấy được sự phân bố của các giá trị bị thiếu tương quan với giá trị không bị thiếu.Để đánh giá giá trị bị thiếu trong một data frame được phân tầng bởi một cột khác, hãy lưu ý đến hàm gg_miss_fct(), mà sẽ trả về một bản đồ nhiệt chứa thông tin về phần trăm giá trị bị thiếu trong một data frame bởi một cột của biến số factor/phân loại (hoặc ngày):Hàm này cũng có thể được sử dụng đối với cột dạng ngày tháng để xem mức độ của số liệu bị thiếu thay đổi theo thời gian:","code":"\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, y = temp)) +     \n  geom_miss_point()\ngg_miss_fct(linelist, age_cat5)\ngg_miss_fct(linelist, date_onset)## Warning: Removed 29 rows containing missing values (geom_tile)."},{"path":"missing-data.html","id":"các-cột-hình-bóng","chapter":"20 Dữ liệu Missing","heading":"Các cột “hình bóng”","text":"Một cách khác để trực quan hóa số liệu bị thiếu trong một cột bởi các giá trị của cột thứ hai là sử dụng “hình bóng/shadow” mà package naniar có thể tạo ra. Hàm bind_shadow() tạo ra một cột biến số nhị phân NA/không NA cho mọi cột hiện có và liên kết tất cả các cột mới này với bộ số liệu gốc bằng phần phụ “_NA”. Điều này làm tăng gấp đôi số cột – xem bên dưới:Các cột “hình bóng” này có thể được sử dụng để vẽ biểu đồ tỷ lệ các giá trị bị thiếu theo bất kỳ cột nào khác.Ví dụ: biểu đồ bên dưới cho thấy tỷ lệ các giá trị bị thiếu của các bản ghi trong biến số days_onset_hosp (số ngày từ ngày khởi phát triệu chứng đến ngày nhập viện), theo giá trị của bản ghi đó trong biến số date_hospitalisation. Về bản chất là chúng ta đang vẽ biểu độ mật độ của cột này trên trục x, nhưng phân tầng kết quả (color =) bằng cột hình bóng đang được quan tâm. Phân tích này thể hiện tốt nhất khi trục x là cột số hoặc cột ngày.Bạn cũng có thể sử dụng cột “hình bóng” để phân tầng một bảng tóm tắt thống kê, như được hiển thị bên dưới:Bên dưới là một cách khác để vẽ biểu đồ tỷ lệ các giá trị bị thiếu của một cột theo thời gian. Nó không liên quan đến package naniar. Ví dụ này cho thấy phần trăm số liệu bị thiếu theo tuần.Tổng hợp số liệu thành một đơn vị thời gian muốn sử dụng (ngày, tuần, .v.v.), tóm tắt tỷ lệ quan sát theo NA (và bất kỳ các giá trị quan tâm khác)Vẽ biểu đồ tỷ lệ giá trị bị thiếu dưới dạng một dòng bằng cách sử dụng hàm ggplot()Bên dưới, chúng ta lấy bộ số liệu linelist, thêm một cột mới cho tuần, nhóm số liệu theo tuần và sau đó tính phần trăm của các bản ghi có số liệu bị thiếu theo tuần. (lưu ý: nếu chúng ta muốn % của 7 ngày, việc tính toán sẽ hơi khác một chút).Sau đó, chúng ta vẽ biểu đồ tỷ lệ các giá trị bị thiếu dưới dạng một dòng theo tuần. Xem thêm chương ggplot cơ bản nếu bạn chưa quen với package vẽ biểu đồ ggplot2.","code":"\nshadowed_linelist <- linelist %>% \n  bind_shadow()\n\nnames(shadowed_linelist)##  [1] \"case_id\"                 \"generation\"              \"date_infection\"          \"date_onset\"              \"date_hospitalisation\"    \"date_outcome\"           \n##  [7] \"outcome\"                 \"gender\"                  \"age\"                     \"age_unit\"                \"age_years\"               \"age_cat\"                \n## [13] \"age_cat5\"                \"hospital\"                \"lon\"                     \"lat\"                     \"infector\"                \"source\"                 \n## [19] \"wt_kg\"                   \"ht_cm\"                   \"ct_blood\"                \"fever\"                   \"chills\"                  \"cough\"                  \n## [25] \"aches\"                   \"vomit\"                   \"temp\"                    \"time_admission\"          \"bmi\"                     \"days_onset_hosp\"        \n## [31] \"case_id_NA\"              \"generation_NA\"           \"date_infection_NA\"       \"date_onset_NA\"           \"date_hospitalisation_NA\" \"date_outcome_NA\"        \n## [37] \"outcome_NA\"              \"gender_NA\"               \"age_NA\"                  \"age_unit_NA\"             \"age_years_NA\"            \"age_cat_NA\"             \n## [43] \"age_cat5_NA\"             \"hospital_NA\"             \"lon_NA\"                  \"lat_NA\"                  \"infector_NA\"             \"source_NA\"              \n## [49] \"wt_kg_NA\"                \"ht_cm_NA\"                \"ct_blood_NA\"             \"fever_NA\"                \"chills_NA\"               \"cough_NA\"               \n## [55] \"aches_NA\"                \"vomit_NA\"                \"temp_NA\"                 \"time_admission_NA\"       \"bmi_NA\"                  \"days_onset_hosp_NA\"\nggplot(data = shadowed_linelist,          # data frame with shadow columns\n  mapping = aes(x = date_hospitalisation, # numeric or date column\n                colour = age_years_NA)) + # shadow column of interest\n  geom_density()                          # plots the density curves\nlinelist %>%\n  bind_shadow() %>%                # create the shows cols\n  group_by(date_outcome_NA) %>%    # shadow col for stratifying\n  summarise(across(\n    .cols = age_years,             # variable of interest for calculations\n    .fns = list(\"mean\" = mean,     # stats to calculate\n                \"sd\" = sd,\n                \"var\" = var,\n                \"min\" = min,\n                \"max\" = max),  \n    na.rm = TRUE))                 # other arguments for the stat calculations## # A tibble: 2 x 6\n##   date_outcome_NA age_years_mean age_years_sd age_years_var age_years_min age_years_max\n##   <fct>                    <dbl>        <dbl>         <dbl>         <dbl>         <dbl>\n## 1 !NA                       16.0         12.6          158.             0            84\n## 2 NA                        16.2         12.9          167.             0            69\noutcome_missing <- linelist %>%\n  mutate(week = lubridate::floor_date(date_onset, \"week\")) %>%   # create new week column\n  group_by(week) %>%                                             # group the rows by week\n  summarise(                                                     # summarize each week\n    n_obs = n(),                                                  # number of records\n    \n    outcome_missing = sum(is.na(outcome) | outcome == \"\"),        # number of records missing the value\n    outcome_p_miss  = outcome_missing / n_obs,                    # proportion of records missing the value\n  \n    outcome_dead    = sum(outcome == \"Death\", na.rm=T),           # number of records as dead\n    outcome_p_dead  = outcome_dead / n_obs) %>%                   # proportion of records as dead\n  \n  tidyr::pivot_longer(-week, names_to = \"statistic\") %>%         # pivot all columns except week, to long format for ggplot\n  filter(stringr::str_detect(statistic, \"_p_\"))                  # keep only the proportion values\nggplot(data = outcome_missing)+\n    geom_line(\n      mapping = aes(x = week, y = value, group = statistic, color = statistic),\n      size = 2,\n      stat = \"identity\")+\n    labs(title = \"Weekly outcomes\",\n         x = \"Week\",\n         y = \"Proportion of weekly records\") + \n     scale_color_discrete(\n       name = \"\",\n       labels = c(\"Died\", \"Missing outcome\"))+\n    scale_y_continuous(breaks = c(seq(0,1,0.1)))+\n  theme_minimal()+\n  theme(legend.position = \"bottom\")"},{"path":"missing-data.html","id":"sử-dụng-dữ-liệu-có-giá-trị-missing","chapter":"20 Dữ liệu Missing","heading":"20.5 Sử dụng dữ liệu có giá trị missing","text":"","code":""},{"path":"missing-data.html","id":"lọc-bỏ-các-hàng-có-giá-trị-bị-thiếu","chapter":"20 Dữ liệu Missing","heading":"Lọc bỏ các hàng có giá trị bị thiếu","text":"Để loại bỏ nhanh các hàng có giá trị bị thiếu, sử dụng hàm drop_na() trong package dplyr.Bộ số liệu gốc linelist có nrow(linelist) hàng. Số hàng sau khi hiệu chỉnh được hiển thị bên dưới:Bạn có thể chỉ định loại bỏ các hàng có giá trị bị thiếu trong một số hàng nhất định:Bạn có thể liệt kê lần lượt từng cột một, hoặc sử dụng các hàm trợ giúp trong “tidyselect”:","code":"\nlinelist %>% \n  drop_na() %>%     # remove rows with ANY missing values\n  nrow()## [1] 1818\nlinelist %>% \n  drop_na(date_onset) %>% # remove rows missing date_onset \n  nrow()## [1] 5632\nlinelist %>% \n  drop_na(contains(\"date\")) %>% # remove rows missing values in any \"date\" column \n  nrow()## [1] 3029"},{"path":"missing-data.html","id":"xử-lý-na-trong-hàm-ggplot","chapter":"20 Dữ liệu Missing","heading":"Xử lý NA trong hàm ggplot()","text":"Thường là khôn ngoan khi báo cáo số lượng các giá trị bị loại ra trong phần chú thích của biểu đồ. Bên dưới là một ví dụ:Trong hàm ggplot(), bạn có thể thêm labs() và bên trong nó là một chú thích caption =. Trong phần chú thích này, chúng ta có thể sử dụng hàm str_glue() từ package stringr để dán các giá trị lại với nhau thành một câu có tính chất động (dynamic), vì vậy nó sẽ điều chỉnh theo số liệu. Bên dưới là một ví dụ:Lưu ý sử dụng \\n để tạo một hàng mới (ngắt chữ xuống hàng).Lưu ý rằng nếu nhiều cột góp phần tạo ra các giá trị, thì sẽ không vẽ được trên biểu đồ (ví dụ như tuổi hoặc giới nếu chúng được phản ánh trên biểu đồ, thì chúng ta cũng phải lọc trên các cột đó để tính toán chính xác số lượng không được hiển thị.Thỉnh thoảng, có thể dễ dàng hơn để lưu chuỗi này dưới dạng một đối tượng trong các lệnh trước khi dùng lệnh ggplot(), và chỉ cần tham chiếu tên của đối tượng chuỗi bên trong hàm str_glue().","code":"\nlabs(\n  title = \"\",\n  y = \"\",\n  x = \"\",\n  caption  = stringr::str_glue(\n  \"n = {nrow(central_data)} from Central Hospital;\n  {nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown.\"))  "},{"path":"missing-data.html","id":"na-trong-các-factors","chapter":"20 Dữ liệu Missing","heading":"NA trong các factors","text":"Nếu cột đang quan tâm là một factor, sử dụng hàm fct_explicit_na() thuộc package forcats để chuyển đổi các giá trị NA thành giá trị ký tự. Xem thêm chi tiết trong chương Factors. Theo mặc định, giá trị mới là “(Missing)” nhưng nó có thể được điều chỉnh thông qua đối số na_level =.","code":"\npacman::p_load(forcats)   # load package\n\nlinelist <- linelist %>% \n  mutate(gender = fct_explicit_na(gender, na_level = \"Missing\"))\n\nlevels(linelist$gender)## [1] \"f\"       \"m\"       \"Missing\""},{"path":"missing-data.html","id":"thay-thế-missing---imputation","chapter":"20 Dữ liệu Missing","heading":"20.6 Thay thế missing - Imputation","text":"Thỉnh thoảng, khi phân tích số liệu, điều quan trọng là phải “làm đầy khoảng trống” và gán giá trị cho số liệu bị thiếu. Trong khi chúng ta luôn luôn có thể chỉ cần phân tích một bộ số liệu sau khi đã loại bỏ tất cả các giá trị bị thiếu, nhưng điều này có thể đưa đến các vấn đề theo nhiều cách. Đây là các ví dụ:Bằng cách loại bỏ tất cả các quan sát có giá trị bị thiếu hoặc các biến số có một số lượng lớn giá trị bị thiếu, chúng ta có thể giảm lực thống kê hay khả năng thực hiện một số loại phân tích. Ví dụ như khi chúng ta đã phát hiện trước đó, chỉ có một phần nhỏ của các quan sát trong bộ số liệu linelist không có số liệu bị thiếu trên tất cả các biến số. Nếu chúng ta xóa phần lớn số liệu, chúng ta sẽ mất rất nhiều thông tin! Và hầu hết các biến của bộ số liệu trên đều có một số lượng dữ liệu missing – đối với hầu hết các phân tích, hầu như là không hợp lý để loại bỏ tất cả các biến có nhiều số liệu bị missing.Bằng cách loại bỏ tất cả các quan sát có giá trị bị thiếu hoặc các biến số có một số lượng lớn giá trị bị thiếu, chúng ta có thể giảm lực thống kê hay khả năng thực hiện một số loại phân tích. Ví dụ như khi chúng ta đã phát hiện trước đó, chỉ có một phần nhỏ của các quan sát trong bộ số liệu linelist không có số liệu bị thiếu trên tất cả các biến số. Nếu chúng ta xóa phần lớn số liệu, chúng ta sẽ mất rất nhiều thông tin! Và hầu hết các biến của bộ số liệu trên đều có một số lượng dữ liệu missing – đối với hầu hết các phân tích, hầu như là không hợp lý để loại bỏ tất cả các biến có nhiều số liệu bị missing.Tùy thuộc vào lý tại sao số liệu bị thiếu, nhưng chỉ phân tích số liệu không bị thiếu có thể dẫn đến kết quả sai lệch. Ví dụ như khi chúng ta đã biết trước đó, chúng ta đang thiếu số liệu của một số bệnh nhân về việc họ có một số triệu chứng quan trọng như sốt hoặc ho hay không. Nhưng có một khả năng là có thể thông tin đó không được ghi nhận đối với những người mà rõ ràng không bị bệnh nặng. Trong trường hợp đó, nếu chúng ta chỉ loại bỏ những quan sát này, chúng ta sẽ loại trừ một số người khỏe nhất trong bộ số liệu và điều đó thật sự có thể làm sai lệch bất kỳ kết quả nào.Tùy thuộc vào lý tại sao số liệu bị thiếu, nhưng chỉ phân tích số liệu không bị thiếu có thể dẫn đến kết quả sai lệch. Ví dụ như khi chúng ta đã biết trước đó, chúng ta đang thiếu số liệu của một số bệnh nhân về việc họ có một số triệu chứng quan trọng như sốt hoặc ho hay không. Nhưng có một khả năng là có thể thông tin đó không được ghi nhận đối với những người mà rõ ràng không bị bệnh nặng. Trong trường hợp đó, nếu chúng ta chỉ loại bỏ những quan sát này, chúng ta sẽ loại trừ một số người khỏe nhất trong bộ số liệu và điều đó thật sự có thể làm sai lệch bất kỳ kết quả nào.Điều quan trọng là suy nghĩ tại sao số liệu có thể bị thiếu cũng như là thiếu bao nhiêu. Làm điều này có thể giúp chúng ta xác định mức độ quan trọng của việc gán giá trị bị thiếu và lựa chọn phương pháp tốt nhất để imputing giá trị missing trong tình huống của chúng ta.","code":""},{"path":"missing-data.html","id":"các-loại-số-liệu-bị-thiếu","chapter":"20 Dữ liệu Missing","heading":"Các loại số liệu bị thiếu","text":"Dưới đây là ba loại số liệu bị thiếu điển hình:Missing Completely Random (MCAR): Số liệu bị thiếu hoàn toàn ngẫu nhiên. Điều này có nghĩa là không có mối quan hệ giữa xác suất số liệu bị thiếu và bất kỳ biến số nào trong bộ số liệu. Xác suất số liệu bị thiếu là ngang nhau đối với tất cả các trường hợp. Đây là một tình huống hiếm gặp. Nhưng nếu chúng ta có lý chính đáng để tin rằng số liệu của chúng ta là MCAR, thì chỉ phân tích số liệu không bị thiếu (mà không imputing giá trị bị thiếu) sẽ không làm sai lệch kết quả (mặc dù chúng ta có thể mất một ít lực thống kê). [CẦN LÀM: lưu ý đến các thảo luận về các kiểm định thống kê cho MCAR]Missing Completely Random (MCAR): Số liệu bị thiếu hoàn toàn ngẫu nhiên. Điều này có nghĩa là không có mối quan hệ giữa xác suất số liệu bị thiếu và bất kỳ biến số nào trong bộ số liệu. Xác suất số liệu bị thiếu là ngang nhau đối với tất cả các trường hợp. Đây là một tình huống hiếm gặp. Nhưng nếu chúng ta có lý chính đáng để tin rằng số liệu của chúng ta là MCAR, thì chỉ phân tích số liệu không bị thiếu (mà không imputing giá trị bị thiếu) sẽ không làm sai lệch kết quả (mặc dù chúng ta có thể mất một ít lực thống kê). [CẦN LÀM: lưu ý đến các thảo luận về các kiểm định thống kê cho MCAR]Missing Random (MAR). Số liệu bị thiếu Ngẫu nhiên. Tên của loại số liệu này thực sự gây ra một ít hiểu lầm vì MAR có nghĩa là số liệu bị thiếu một cách có hệ thống, có thể dự đoán dựa trên các thông tin khác mà chúng ta có. Ví dụ như có lẽ giá trị bị thiếu đối với biến số sốt của mọi quan sát trong bộ số liệu là thật sự không được ghi nhận vì mọi bệnh nhân có ớn lạnh và đau nhức được giả định là bị sốt, vì vậy thân nhiệt của họ không bao giờ được đo. Nếu đúng như vậy, chúng ta có thể dễ dàng dự đoán rằng, mọi quan sát bị thiếu khi có ớn lạnh và đau nhức cũng sẽ bị sốt và chúng ta sẽ sử dụng thông tin này để gán các giá trị bị thiếu. Trong thực tế, đây là loại nhiều hơn. Có thể nếu một bệnh nhân có cả ớn lạnh và đau nhức, thì hầu như họ cũng sẽ bị sốt nếu thân nhiệt không được đo, nhưng không phải lúc nào cũng như vậy. Điều này vẫn có thể dự đoán được ngay cả khi nó không thể dự đoán một cách hoàn toàn, nhưng không phải là luôn luôn. Đây là một loại số liệu bị thiếu phổ biếnMissing Random (MAR). Số liệu bị thiếu Ngẫu nhiên. Tên của loại số liệu này thực sự gây ra một ít hiểu lầm vì MAR có nghĩa là số liệu bị thiếu một cách có hệ thống, có thể dự đoán dựa trên các thông tin khác mà chúng ta có. Ví dụ như có lẽ giá trị bị thiếu đối với biến số sốt của mọi quan sát trong bộ số liệu là thật sự không được ghi nhận vì mọi bệnh nhân có ớn lạnh và đau nhức được giả định là bị sốt, vì vậy thân nhiệt của họ không bao giờ được đo. Nếu đúng như vậy, chúng ta có thể dễ dàng dự đoán rằng, mọi quan sát bị thiếu khi có ớn lạnh và đau nhức cũng sẽ bị sốt và chúng ta sẽ sử dụng thông tin này để gán các giá trị bị thiếu. Trong thực tế, đây là loại nhiều hơn. Có thể nếu một bệnh nhân có cả ớn lạnh và đau nhức, thì hầu như họ cũng sẽ bị sốt nếu thân nhiệt không được đo, nhưng không phải lúc nào cũng như vậy. Điều này vẫn có thể dự đoán được ngay cả khi nó không thể dự đoán một cách hoàn toàn, nhưng không phải là luôn luôn. Đây là một loại số liệu bị thiếu phổ biếnMissing Random (MNAR): Số liệu bị thiếu không ngẫu nhiên. Thỉnh thoảng, loại này được gọi là Missing Random - Không bị Thiếu Ngẫu nhiên (NMAR). Loại này giả định rằng xác suất của một giá trị bị thiếu là KHÔNG có hệ thống hoặc không thể dự đoán được bằng cách sử dụng thông tin khác mà chúng ta có, nhưng nó cũng không là giá trị bị thiếu một cách ngẫu nhiên. Trong tình huống này, số liệu bị thiếu không rõ lý hoặc vì các lý mà chúng ta không có bất kỳ thông tin nào. Ví dụ: trong bộ số liệu có thể thiếu thông tin về tuổi bởi vì một số bệnh nhân rất cao tuổi hoặc không biết hoặc từ chối cho biết tuổi. Trong tình huống này, số liệu bị thiếu về tuổi có liên quan đến giá trị của chính nó (và vì thế nó không phải là ngẫu nhiên) và không thể dự đoán được dựa trên các thông tin khác mà chúng ta có. MNAR là phức tạp và cách tốt nhất để giải quyết loại số liệu này thường là cố gắng thu thập thêm số liệu hoặc thông tin tại sao số liệu bị thiếu thay vì cố gắng gán giá trị cho nó.Missing Random (MNAR): Số liệu bị thiếu không ngẫu nhiên. Thỉnh thoảng, loại này được gọi là Missing Random - Không bị Thiếu Ngẫu nhiên (NMAR). Loại này giả định rằng xác suất của một giá trị bị thiếu là KHÔNG có hệ thống hoặc không thể dự đoán được bằng cách sử dụng thông tin khác mà chúng ta có, nhưng nó cũng không là giá trị bị thiếu một cách ngẫu nhiên. Trong tình huống này, số liệu bị thiếu không rõ lý hoặc vì các lý mà chúng ta không có bất kỳ thông tin nào. Ví dụ: trong bộ số liệu có thể thiếu thông tin về tuổi bởi vì một số bệnh nhân rất cao tuổi hoặc không biết hoặc từ chối cho biết tuổi. Trong tình huống này, số liệu bị thiếu về tuổi có liên quan đến giá trị của chính nó (và vì thế nó không phải là ngẫu nhiên) và không thể dự đoán được dựa trên các thông tin khác mà chúng ta có. MNAR là phức tạp và cách tốt nhất để giải quyết loại số liệu này thường là cố gắng thu thập thêm số liệu hoặc thông tin tại sao số liệu bị thiếu thay vì cố gắng gán giá trị cho nó.Nhìn chung, việc gán số liệu cho MCAR thường khá đơn giản, trong khi cho MNAR là khá thách thức nếu không muốn nói là không thể. Có nhiều phương pháp gán số liệu phổ biến cho các số liệu được cho là MAR.","code":""},{"path":"missing-data.html","id":"các-packages-hữu-dụng","chapter":"20 Dữ liệu Missing","heading":"Các packages hữu dụng","text":"Một số package hữu dụng để gán số liệu bị thiếu là Mmisc, missForest (mà sử dụng kỹ thuật Random Forests để gán số liệu bị thiếu), và package mice (viết tắt của Multivariate Imputation Chained Equations). Đối với phần này, chúng ta chỉ sử dụng package mice để thực hiện nhiều kỹ thuật khác nhau. Người bảo trì package mice xuất bản một cuốn sách trực tuyến về gán số liệu bị thiếu, xem chi tiết hơn tại đây (https://stefvanbuuren.name/fimd/).Đây là code để tải package mice:","code":"\npacman::p_load(mice)"},{"path":"missing-data.html","id":"gán-bằng-giá-trị-trung-bình","chapter":"20 Dữ liệu Missing","heading":"Gán bằng giá trị trung bình","text":"Thỉnh thoảng, nếu chúng ta thực hiện một phân tích đơn giản hoặc chúng ta có một lý chính đáng để nghĩ rằng chúng ta có thể giả định số liệu bị thiếu là hoàn toàn ngẫu nhiên (MCAR), chúng ta có thể chỉ cần gán các giá trị bị thiếu bằng giá trị trung bình của biến số đó. Có lẽ chúng ta có thể giả định rằng các giá trị bị thiếu của thân nhiệt trong bộ số liệu là MCAR hoặc chỉ là các giá trị bình thường. Đây là code để tạo một biến số mới để thay thế các giá trị thân nhiệt bị thiếu bằng giá trị thân nhiệt trung bình trong bộ số liệu. Tuy nhiên, trong nhiều tình huống, việc thay thế số liệu bằng giá trị trung bình có thể dẫn đến sai lệch, vì thế hãy cẩn thận.Bạn cũng có thể thực hiện một quy trình tương tự để thay thế số liệu của biến phân loại bằng một giá trị cụ thể. Đối với bộ số liệu linelist, giả sử là bạn đã biết tất cả các quan sát có giá trị bị thiếu của biến số kết cục (mà có thể là “Tử vong” hoặc “Hồi phục”) thực sự là những người đã chết (lưu ý: điều này không thực sự đúng đối với bộ số liệu này):","code":"\nlinelist <- linelist %>%\n  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))\nlinelist <- linelist %>%\n  mutate(outcome_replace_na_with_death = replace_na(outcome, \"Death\"))"},{"path":"missing-data.html","id":"gán-bằng-hồi-quy","chapter":"20 Dữ liệu Missing","heading":"Gán bằng hồi quy","text":"Một phương pháp nâng hơi cao hơn là sử dụng một số loại mô hình thống kê để dự đoán giá trị có lẽ bị thiếu và thay thế nó bằng giá trị dự đoán. Đây là một ví dụ về việc tạo ra các giá trị dự đoán cho tất cả các quan sát bị thiếu của biến số thân nhiệt (temperature), nhưng biến số tuổi (age) và biến số sốt (fever) thì không bị thiếu, bằng cách sử dụng hồi quy tuyến tính đơn giản với biến số dự đoán là tình trạng sốt và tuổi theo năm. Trong thực tế, chúng ta muốn sử dụng một mô hình tốt hơn kiểu tiếp cận đơn giản này..Hoặc sử dụng cùng phương pháp mô hình hóa thông qua gói lệnh mice để tạo ra các giá trị gán cho các quan sát thân nhiệt bị thiếu:Cách trên có cùng cách tiếp cận với một số phương pháp nâng cao hơn như sử dụng package missForest để thay thế giá trị bị thiếu bằng các giá trị dự đoán. Trong trường hợp đó, mô hình dự đoán là một random forest thay vì là một hồi quy tuyến tính. Chúng ta cũng có thể sử dụng các loại mô hình khác để làm điều này. Tuy nhiên, phương pháp này thực hiện tốt với số liệu loại MCAR, nhưng chúng ta nên cẩn thận một chút nếu chúng ta tin rằng loại số liệu của chúng ta chính xác hơn là MAR hoặc MNAR. Chất lượng của việc gán giá trị bị thiếu sẽ phụ thuộc vào mô hình dự đoán tốt như thế nào, và ngay cả khi với một mô hình dự đoán rất tốt, tính biến thiên của số liệu được gán có thể đưa đến một ước lượng non.","code":"\nsimple_temperature_model_fit <- lm(temp ~ fever + age_years, data = linelist)\n\n#using our simple temperature model to predict values just for the observations where temp is missing\npredictions_for_missing_temps <- predict(simple_temperature_model_fit,\n                                        newdata = linelist %>% filter(is.na(temp))) \nmodel_dataset <- linelist %>%\n  select(temp, fever, age_years)  \n\ntemp_imputed <- mice(model_dataset,\n                            method = \"norm.predict\",\n                            seed = 1,\n                            m = 1,\n                            print = F)## Warning: Number of logged events: 1\ntemp_imputed_values <- temp_imputed$imp$temp"},{"path":"missing-data.html","id":"locf-và-bocf","chapter":"20 Dữ liệu Missing","heading":"LOCF và BOCF","text":"LOCF (viết tắt của Last observation carried forward) và BOCF (viết tắt của baseline observation carried forward) là các phương pháp gán số liệu bị thiếu đối với số liệu chuỗi thời gian/số liệu dọc. Ý tưởng là lấy giá trị được quan sát trước đó để thay thế cho số liệu bị thiếu. Khi có nhiều giá trị bị thiếu liên tiếp, phương pháp này sẽ tìm kiếm giá trị được quan sát cuối cùng.Hàm fill() từ package tidyr có thể được sử dụng cho cả phương pháp gán LOCF và BOCF (tuy nhiên, các package khác như HMISC, zoo, và data.table cũng có các phương pháp để làm điều này). Để hiển thị cú pháp của hàmfill(), chúng ta sẽ tạo một bộ số liệu chuỗi thời gian đơn giản mà bao gồm một số ca của một bệnh trong các quý của năm 2000 và 2001. Tuy nhiên, giá trị năm cho các quý tiếp theo sau Q1 bị thiếu, vì thế chúng ta cần gán các số liệu bị thiếu này. Hàm fill() cũng được trình bày chi tiết trong chương Xoay trục dữ liệu.Lưu ý: cần đảm bảo số liệu được sắp xếp chính xác trước khi sử dụng hàm fill(). Mặc định của hàm fill() là điền “xuống” nhưng chúng ta cũng có thể gán giá trị bị thiếu theo các hướng khác nhau bằng cách thay đổi tham số .direction. WChúng ta có thể tạo một tập số liệu tương tự mà giá trị của năm chỉ được ghi nhận vào cuối năm và bị thiếu ở các quý trước đó:Trong ví dụ này, rõ ràng LOCF và BOCF thực hiện đúng các công việc, nhưng trong những tình huống phức tạp hơn, có thể là khó khăn hơn để quyết định những phương pháp này có phù hợp hay không. Ví dụ: chúng ta có thể thiếu các giá trị xét nghiệm của một bệnh nhân nằm viện sau ngày đầu tiên. Đôi lúc, điều này có thể có nghĩa là các giá trị xét nghiệm không thay đổi … nhưng cũng có thể là bệnh nhân đã hồi phục và những giá trị xét nghiệm của bệnh nhân này có thể là rất khác sau ngày đầu tiên! Hãy sử dụng những phương pháp này một cách thận trọng.","code":"\n#creating our simple dataset\ndisease <- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",    2000,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",      NA,    21001,\n  \"Q1\",    2001,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",      NA,    50197)\n\n#imputing the missing year values:\ndisease %>% fill(year)## # A tibble: 8 x 3\n##   quarter  year cases\n##   <chr>   <dbl> <dbl>\n## 1 Q1       2000 66013\n## 2 Q2       2000 69182\n## 3 Q3       2000 53175\n## 4 Q4       2000 21001\n## 5 Q1       2001 46036\n## 6 Q2       2001 58842\n## 7 Q3       2001 44568\n## 8 Q4       2001 50197\n#creating our slightly different dataset\ndisease <- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",      NA,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",    2000,    21001,\n  \"Q1\",      NA,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",    2001,    50197)\n\n#imputing the missing year values in the \"up\" direction:\ndisease %>% fill(year, .direction = \"up\")## # A tibble: 8 x 3\n##   quarter  year cases\n##   <chr>   <dbl> <dbl>\n## 1 Q1       2000 66013\n## 2 Q2       2000 69182\n## 3 Q3       2000 53175\n## 4 Q4       2000 21001\n## 5 Q1       2001 46036\n## 6 Q2       2001 58842\n## 7 Q3       2001 44568\n## 8 Q4       2001 50197"},{"path":"missing-data.html","id":"gán-số-liệu-nhiều-lần","chapter":"20 Dữ liệu Missing","heading":"Gán số liệu nhiều lần","text":"Cuốn sách trực tuyến mà chúng tôi đã đề cập trước đây bởi tác giả của package mice (https://stefvanbuuren.name/fimd/) bao gồm một giải thích chi tiết về gán số liệu nhiều lần và lý tại sao chúng ta muốn sử dụng nó. Dưới đây là một giải thích cơ bản của phương pháp này:Khi chúng ta thực hiện gán nhiều lần, chúng ta tạo nhiều bộ số liệu với các giá trị bị thiếu mà được gán các giá trị hợp lý (tùy thuộc vào số liệu của chúng ta, chúng ta có thể muốn tạo nhiều hay ít các bộ số liệu được gán này, nhưng package mice đặt con số mặc định là 5). TSự khác biệt là thay vì một giá trị đơn lẻ cụ thể, mỗi giá trị được gán được rút ra từ một phân phối được ước tính (vì vậy nó bao gồm một số đặc tính ngẫu nhiên). Kết quả là, mỗi bộ số liệu này sẽ có các giá trị được gán khác nhau một chút (tuy nhiên, số liệu không bị thiếu sẽ giống nhau trong mỗi bộ số liệu được gán này). Chúng ta vẫn sử dụng một số loại mô hình dự đoán để thực hiện việc gán số liệu bị thiếu cho mỗi bộ số liệu mới này (package mice có nhiều tùy chọn cho các phương pháp dự đoán bao gồm Predictive Mean Matching, logistic regression, và random forest), nhưng package mice có thể đảm nhận nhiều chi tiết của mô hình.Sau đó, một khi chúng ta đã tạo các bộ số liệu mới được gán giá trị bị thiếu này, chúng ta có thể áp dụng bất kỳ mô hình thống kê hoặc phân tích nào mà chúng ta dự định thực hiện cho mỗi bộ số liệu mới này và gộp kết quả của các mô hình này lại với nhau. Thao tác này rất tốt để giảm sai lệch đối với cả MCAR và MAR và thường cho các ước tính sai số chuẩn chính xác hơn.Đây là một ví dụ về việc áp dụng quy trình Gán Nhiều lần để dự đoán thân nhiệt trong bộ số liệu linelist bằng cách sử dụng tuổi và sốt (bộ số liệu mô hình đơn giản hóa bên trên):Ở đây, chúng tôi sử dụng phương pháp gán mặc định của gói lệnh mice, đó là Predictive Mean Matching. Sau đó, chúng tôi sử dụng các bộ số liệu đã được gán này để ước tính riêng rẽ và gộp kết quả từ các hồi quy tuyến tính đơn giản trên mỗi bộ số liệu này. Có nhiều chi tiết mà chúng tôi đã phớt lờ và nhiều chỗ mà chúng ta có thể điều chỉnh trong suốt quá trình Gán Nhiều lần trong khi sử dụng gói lệnh mice. Ví dụ: chúng ta không phải lúc nào cũng có số liệu dạng số và có thể cần các phương pháp gán khác (chúng ta vẫn có thể sử dụng gói lệnh mice cho nhiều loại số liệu và phương pháp khác). Để một phân tích thiết thực hơn khi số liệu bị thiếu là một mối quan tâm đáng chú ý, Gán số liệu Nhiều lần là một giải pháp tốt, nhưng không phải lúc nào cũng hiệu quả hơn việc thực hiện một phân tích của các trường hợp hoàn chỉnh.","code":"\n# imputing missing values for all variables in our model_dataset, and creating 10 new imputed datasets\nmultiple_imputation = mice(\n  model_dataset,\n  seed = 1,\n  m = 10,\n  print = FALSE) ## Warning: Number of logged events: 1\nmodel_fit <- with(multiple_imputation, lm(temp ~ age_years + fever))\n\nbase::summary(mice::pool(model_fit))##          term     estimate    std.error     statistic        df   p.value\n## 1 (Intercept) 3.703143e+01 0.0270863456 1367.16240465  26.83673 0.0000000\n## 2   age_years 3.867829e-05 0.0006090202    0.06350905 171.44363 0.9494351\n## 3    feveryes 1.978044e+00 0.0193587115  102.17849544 176.51325 0.0000000"},{"path":"missing-data.html","id":"tài-nguyên-học-liệu-5","chapter":"20 Dữ liệu Missing","heading":"20.7 Tài nguyên học liệu","text":"Mô tả của naniar packageThư viện trực quan hóa giá trị MissingSách trực tuyến về multiple imputation trong R bởi người bảo trì của package mice","code":""},{"path":"standardization.html","id":"standardization","chapter":"21 Tỷ suất chuẩn hóa","heading":"21 Tỷ suất chuẩn hóa","text":"Chương này sẽ hướng dẫn hai cách để chuẩn hóa một kết quả như là tỷ suất tử vong hoặc nhập viện theo các đặc điểm của tuổi và giới.Sử dụng package dsrSử dụng package PHEindicatormethodsChúng ta bắt đầu bằng cách làm rõ quá trình chuẩn bị/làm sạch/kết nối số liệu, vì việc này thường được thực hiện khi kết nối số liệu dân số từ nhiều quốc gia, số liệu dân số chuẩn, tử vong,.v.v.","code":""},{"path":"standardization.html","id":"tổng-quan-1","chapter":"21 Tỷ suất chuẩn hóa","heading":"21.1 Tổng quan","text":"Có hai cách để chuẩn hóa: trực tiếp và gián tiếp. Giả sử chúng ta muốn chuẩn hóa tỷ suất tử vong theo tuổi và giới của quốc gia và quốc gia B, và sánh tỷ suất chuẩn hóa giữa hai quốc gia nàyĐối với chuẩn hóa trực tiếp, chúng ta phải biết dân số nguy cơ và số tử vong theo từng tầng của tuổi và giới của quốc gia và B. Một tầng trong ví dụ của chúng ta là phụ nữ trong nhóm tuổi từ 15-44.Đối với chuẩn hóa gián tiếp, chúng ta chỉ cần biết tổng số tử vong và cấu trúc tuổi và giới của mỗi quốc gia. Vì thế, phương án này là khả khi tỷ suất tử vong hoặc dân số theo tuổi và giới không có sẵn. Hơn nữa, chuẩn hóa gián tiếp được ưa chuộng hơn khi có số lượng nhỏ trong các tầng, vì các ước tính trong chuẩn hóa trực tiếp sẽ bị ảnh hưởng bởi các thay đổi quan trọng khi lấy mẫu.","code":""},{"path":"standardization.html","id":"chuẩn-bị-11","chapter":"21 Tỷ suất chuẩn hóa","heading":"21.2 Chuẩn bị","text":"Để chỉ dẫn cách thực hiện chuẩn hóa, chúng ta tạo ra dân số và số tử vong của quốc gia và B theo tuổi (trong các nhóm tuổi của mỗi 5 tuổi) và giới (nữ, nam). Để các bộ số liệu có thể sử dụng được, chúng ta sẽ thực hiện các bước chuẩn bị như sau:Gọi các packagesTải các bộ số liệuNối số liệu dân số và tử vong của hai quốc giaXoay trục bộ số liệu dọc/dài hơn để có một hàng là một tầng theo tuổi-giớiLàm sạch quần thể tham chiếu (dân số thế giới chuẩn) và kết nối nó với số liệu của quốc giaTrong trường hợp này, số liệu của chúng ta có thể có các định dạng khác nhau. Có lẽ số liệu của chúng ta theo tỉnh, thành phố, hoặc khu vực dịch vụ khác. Chúng ta có thể có một hàng cho mỗi ca tử vong và các thông tin về tuổi và giới cho mỗi trường hợp (hoặc một tỷ lệ có ý nghĩa) của các ca tử vong này. Trong trường hợp này, hãy xem các chương về Nhóm dữ liệu, Xoay trục dữ liệu, và Bảng mô tả để tạo một bộ số liệu với số lượng tử vong và dân số theo tầng của tuổi-giới tính.Chúng ta cũng cần một quần thể tham chiếu, dân số chuẩn. Với mục đích của thực hành này, chúng ta sẽ sử dụng bộ số liệu world_standard_population_by_sex. Dân số chuẩn này dựa trên dân số của 46 quốc gia và được tạo ra vào năm 1960. Có rất nhiều dân số “chuẩn” – ví dụ, trang web của NHS Scotland cung cấp khá nhiều thông tin về Dân số Chuẩn của châu u, Dân số Chuẩn Thế giới, Dân số Chuẩn của Scotland.","code":""},{"path":"standardization.html","id":"gọi-packages-6","chapter":"21 Tỷ suất chuẩn hóa","heading":"Gọi packages","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.CẨN TRỌNG: Nếu đang sử dụng một phiên bản mới hơn của R, chúng ta không thể tải gói lệnh dsr trực tiếp từ CRAN. Tuy nhiên, nó vẫn còn trong mục lưu trữ của CRAN. Chúng ta có thể cài đặt và sử dụng nó. Đối với người không sử dụng hệ điều hành Mac:Đối với người sử dụng hệ điều hành Mac:","code":"\npacman::p_load(\n     rio,                 # import/export data\n     here,                # locate files\n     tidyverse,           # data management and visualization\n     stringr,             # cleaning characters and strings\n     frailtypack,         # needed for dsr, for frailty models\n     dsr,                 # standardise rates\n     PHEindicatormethods) # alternative for rate standardisation\npackageurl <- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n# Other solution that may work\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"http:/cran.us.r.project.org\")\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"https://mac.R-project.org\")"},{"path":"standardization.html","id":"tải-số-liệu-dân-số","chapter":"21 Tỷ suất chuẩn hóa","heading":"Tải số liệu dân số","text":"Xem chương Tải sách và dữ liệu để biết các hướng dẫn về cách tải tất cả các bộ số liệu mẫu trong cuốn số tay này. Chúng ta có thể nhập trực tiếp dữ liệu trong chương Chuẩn hóa này tới R thông qua kho lưu trữ Github của chúng tôi bằng cách thực hiện lệnh sau import():Trước tiên, chúng ta tải số liệu nhân khẩu (số lượng nam và nữ theo nhóm mỗi 5 tuổi) của hai quốc gia mà chúng ta sẽ sánh, “Quốc gia ” và “Quốc gia B”.","code":"\n# import demographics for country A directly from Github\nA_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# import deaths for country A directly from Github\nA_deaths <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n# import demographics for country B directly from Github\nB_demo <- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# import deaths for country B directly from Github\nB_deaths <- import(\"https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/deaths_countryB.csv\")\n\n# import demographics for country B directly from Github\nstandard_pop_data <- import(\"https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n# Country A\nA_demo <- import(\"country_demographics.csv\")\n# Country B\nB_demo <- import(\"country_demographics_2.csv\")"},{"path":"standardization.html","id":"tải-số-liệu-tử-vong","chapter":"21 Tỷ suất chuẩn hóa","heading":"Tải số liệu tử vong","text":"Để thuận tiện cho việc thực hành, chúng ta cũng có số lượng tử vong theo tuổi và giới trong khoảng thời gian quan tâm. Số lượng tử vong của mỗi quốc gia nằm trong một tập tin riêng, được hiện thị bên dưới.Số tử vong ở Quốc gia ASố tử vong ở Quốc gia B","code":""},{"path":"standardization.html","id":"làm-sạch-số-liệu-dân-số-và-tử-vong","chapter":"21 Tỷ suất chuẩn hóa","heading":"Làm sạch số liệu dân số và tử vong","text":"Chúng ta cần kết nối và chuyển đổi các số liệu này theo những cách sau:Liên kết dân số của các quốc gia vào một bộ số liệu và xoay trục thành bộ số liệu dạng “dọc/dài” để mỗi tầng tuổi-giới là một hàngLiên kết số liệu tử vong của các quốc gia vào một bộ số liệu và xoay trục thành bộ số liệu dạng “dọc/dài” để mỗi tầng tuổi-giới là một hàngNối số liệu tử vong với số liệu dân sốĐầu tiên, chúng ta liên kết các bộ số liệu dân số quốc gia, chuyển đổi thành số liệu dạng dọc/dài hơn, và làm sạch số liệu. Xem chương Xoay trục dữ liệu để biết thêm chi tiết.Số liệu dân số đã liên kết bây giờ trông giống như sau (nhấp qua để xem cột quốc gia và B):Và bây giờ, chúng ta thực hiện các thao tác tương tự trên hai bộ số liệu tử vong.Số liệu tử vong bây giờ trông giống như sau và chứa số liệu của cả hai quốc gia:Bây giờ, chúng ta nối số liệu tử vong và số liệu dân số dựa trên các cột chung Country, age_cat5, và Sex. Thao tác này sẽ thêm cột Deaths.Bây giờ, chúng ta có thể phân loại các biến số Sex, age_cat5, và Country thành dạng factors và đặt thứ tự các giá trị của biến số bằng cách sử dụng hàm fct_relevel() từ package forcats, như được mô tả trong chương Factors. Lưu ý rằng việc phân loại giá trị biến không thay đổi số liệu một cách rõ ràng, nhưng lệnh arrange() sẽ sắp xếp nó theo Quốc gia, nhóm tuổi và giới tính.CẨN TRỌNG: Nếu số trường hợp tử vong mỗi tầng là nhỏ, hãy cân nhắc chia nhóm tuổi mỗi 10-15 năm thay vì mỗi 5 năm cho các nhóm.","code":"\npop_countries <- A_demo %>%  # begin with country A dataset\n     bind_rows(B_demo) %>%        # bind rows, because cols are identically named\n     pivot_longer(                       # pivot longer\n          cols = c(m, f),                   # columns to combine into one\n          names_to = \"Sex\",                 # name for new column containing the category (\"m\" or \"f\") \n          values_to = \"Population\") %>%     # name for new column containing the numeric values pivoted\n     mutate(Sex = recode(Sex,            # re-code values for clarity\n          \"m\" = \"Male\",\n          \"f\" = \"Female\"))\ndeaths_countries <- A_deaths %>%    # begin with country A deaths dataset\n     bind_rows(B_deaths) %>%        # bind rows with B dataset, because cols are identically named\n     pivot_longer(                  # pivot longer\n          cols = c(Male, Female),        # column to transform into one\n          names_to = \"Sex\",              # name for new column containing the category (\"m\" or \"f\") \n          values_to = \"Deaths\") %>%      # name for new column containing the numeric values pivoted\n     rename(age_cat5 = AgeCat)      # rename for clarity\ncountry_data <- pop_countries %>% \n     left_join(deaths_countries, by = c(\"Country\", \"age_cat5\", \"Sex\"))\ncountry_data <- country_data %>% \n  mutate(\n    Country = fct_relevel(Country, \"A\", \"B\"),\n      \n    Sex = fct_relevel(Sex, \"Male\", \"Female\"),\n        \n    age_cat5 = fct_relevel(\n      age_cat5,\n      \"0-4\", \"5-9\", \"10-14\", \"15-19\",\n      \"20-24\", \"25-29\",  \"30-34\", \"35-39\",\n      \"40-44\", \"45-49\", \"50-54\", \"55-59\",\n      \"60-64\", \"65-69\", \"70-74\",\n      \"75-79\", \"80-84\", \"85\")) %>% \n          \n  arrange(Country, age_cat5, Sex)"},{"path":"standardization.html","id":"tải-dân-số-tham-chiếu","chapter":"21 Tỷ suất chuẩn hóa","heading":"Tải dân số tham chiếu","text":"Cuối cùng, để chuẩn hóa trực tiếp, chúng ta nhập dân số tham chiếu (“dân số chuẩn” thế giới theo giới tính)","code":"\n# Reference population\nstandard_pop_data <- import(\"world_standard_population_by_sex.csv\")"},{"path":"standardization.html","id":"làm-sach-dân-số-tham-chiếu","chapter":"21 Tỷ suất chuẩn hóa","heading":"Làm sach dân số tham chiếu","text":"Các giá trị của biến tuổi trong bộ số liệu country_data và standard_pop_data cần phải được căn chỉnh.Hiện tại, các giá trị của cột biến phân loại age_cat5 trong bộ số liệu standard_pop_data có chứa từ “years” và “plus”, trong khi không có các từ này trong trong bộ số liệu country_data. Chúng ta cần phải chuyển đổi các giá trị này giống nhau. Chúng ta sẽ sử dụng hàm str_replace_all() từ package stringr, như được mô tả trong chương Ký tự và chuỗi, để thay thế thành những kiểu mẫu không có khoảng trắng \"\".Hơn nữa, package dsr đòi hỏi cột chứa số lượng trong bộ số liệu dân số chuẩn phải được gọi là \"pop\". Vì vậy, chúng ta đổi tên cột này cho phù hợp.CẨN TRỌNG: Nếu chúng ta cố gắng sử dụng hàm str_replace_all() để loại bỏ biểu tượng dấu cộng, hàm này sẽ không thực hiện bởi vì nó là một biểu tượng đặc biệt. “Xử lý” các biểu tượng này bằng cách đặt hai dấu gạch chéo phía trước như trong lệnh str_replace_call(column, \"\\\\+\", \"\"). ","code":"\n# Remove specific string from column values\nstandard_pop_clean <- standard_pop_data %>%\n     mutate(\n          age_cat5 = str_replace_all(age_cat5, \"years\", \"\"),   # remove \"year\"\n          age_cat5 = str_replace_all(age_cat5, \"plus\", \"\"),    # remove \"plus\"\n          age_cat5 = str_replace_all(age_cat5, \" \", \"\")) %>%   # remove \" \" space\n     \n     rename(pop = WorldStandardPopulation)   # change col name to \"pop\", as this is expected by dsr package"},{"path":"standardization.html","id":"standard_all","chapter":"21 Tỷ suất chuẩn hóa","heading":"Tạo bộ số liệu với dân số chuẩn","text":"Cuối cùng, sử dụng package PHEindicatormethods, được trình bày chi tiết bên dưới, để nối dân số chuẩn vào biến tử vong và dân số của các quốc gia. Vì vậy, chúng ta sẽ tạo một bộ số liệu với tên all_data cho mục đích đó.Bộ số liệu hoàn chỉnh trông sẽ như thế này:","code":"\nall_data <- left_join(country_data, standard_pop_clean, by=c(\"age_cat5\", \"Sex\"))"},{"path":"standardization.html","id":"package-dsr","chapter":"21 Tỷ suất chuẩn hóa","heading":"21.3 Package dsr","text":"Bên dưới, chúng tôi trình bày việc tính toán và sánh các tỷ suất được chuẩn hóa trực tiếp bằng cách sử dụng package dsr. Package dsr cho phép chúng ta tính toán và sánh các tỷ suất được chuẩn hóa trực tiếp (không phải các tỷ suất được chuẩn hóa gián tiếp!).Trong phần Chuẩn bị số liệu, chúng ta đã tạo các bộ số liệu riêng biệt cho các quốc gia và dân số chuẩn:đối tượng country_data mà là một bảng dân số với số lượng dân số và số tử vong theo tầng cho mỗi quốc giađối tượng standard_pop_clean, bao gồm số lượng dân số theo tầng cho dân số tham chiếu, Dân số Chuẩn Thế giớiChúng ta sẽ sử dụng các bộ số liệu riêng rẽ này cho cách tiếp cận sử dụng package dsr.","code":""},{"path":"standardization.html","id":"tỷ-suất-chuẩn-hóa","chapter":"21 Tỷ suất chuẩn hóa","heading":"Tỷ suất chuẩn hóa","text":"Bên dưới, chúng ta tính toán các tỷ suất theo quốc gia được chuẩn hóa trực tiếp theo tuổi và giới. Chúng ta sử dụng hàm dsr().Lưu ý - dsr() đòi hỏi một bộ số liệu dân số của các quốc gia và số lượng sự kiện (tử vong), và một bộ số liệu riêng rẽ với dân số tham chiếu. Nó cũng đòi hỏi trong bộ số liệu của dân số tham chiếu này tên cột đơn vị-thời gian là “pop” (chúng ta đã đảm bảo điều này trong phần Chuẩn bị số liệu).Có nhiều đối số, như được chú thích bên dưới. Đáng chú ý, đối số event = được đặt thành cột Deaths, và đối số fu = (“follow-”) được đặt thành cột Population. Chúng ta đặt các nhóm sánh là cột Country và chuẩn hóa dựa trên cột age_cat5 và Sex. Hai cột cuối cùng này không được gán với một đối số có tên cụ thể. Gõ ?dsr để biết thêm chi tiết.Bên trên, chúng ta thấy rằng tỷ suất tử vong thô của quốc gia thấp hơn quốc gia B, nhưng tỷ suất được chuẩn hóa trực tiếp theo tuổi và giới thì cao hơn.","code":"\n# Calculate rates per country directly standardized for age and sex\nmortality_rate <- dsr::dsr(\n     data = country_data,  # specify object containing number of deaths per stratum\n     event = Deaths,       # column containing number of deaths per stratum \n     fu = Population,      # column containing number of population per stratum\n     subgroup = Country,   # units we would like to compare\n     age_cat5,             # other columns - rates will be standardized by these\n     Sex,\n     refdata = standard_pop_clean, # reference population data frame, with column called pop\n     method = \"gamma\",      # method to calculate 95% CI\n     sig = 0.95,            # significance level\n     mp = 100000,           # we want rates per 100.000 population\n     decimals = 2)          # number of decimals)\n\n\n# Print output as nice-looking HTML table\nknitr::kable(mortality_rate) # show mortality rate before and after direct standardization"},{"path":"standardization.html","id":"tỷ-số-của-các-tỷ-suất-chuẩn-hóa","chapter":"21 Tỷ suất chuẩn hóa","heading":"Tỷ số của các tỷ suất chuẩn hóa","text":"Tỷ suất tử vong chuẩn hóa của quốc gia cao gấp 1.22 lần với quốc gia B (95% CI 1.17-1.27).","code":"\n# Calculate RR\nmortality_rr <- dsr::dsrr(\n     data = country_data, # specify object containing number of deaths per stratum\n     event = Deaths,      # column containing number of deaths per stratum \n     fu = Population,     # column containing number of population per stratum\n     subgroup = Country,  # units we would like to compare\n     age_cat5,\n     Sex,                 # characteristics to which we would like to standardize \n     refdata = standard_pop_clean, # reference population, with numbers in column called pop\n     refgroup = \"B\",      # reference for comparison\n     estimate = \"ratio\",  # type of estimate\n     sig = 0.95,          # significance level\n     mp = 100000,         # we want rates per 100.000 population\n     decimals = 2)        # number of decimals\n\n# Print table\nknitr::kable(mortality_rr) "},{"path":"standardization.html","id":"khác-biệt-của-các-tỷ-suất-chuẩn-hóa","chapter":"21 Tỷ suất chuẩn hóa","heading":"Khác biệt của các tỷ suất chuẩn hóa","text":"Quốc gia có hơn 4,24 ca tử vong trên 100,000 dân (95% CI 3.24-5.24) với quốc gia B.","code":"\n# Calculate RD\nmortality_rd <- dsr::dsrr(\n     data = country_data,       # specify object containing number of deaths per stratum\n     event = Deaths,            # column containing number of deaths per stratum \n     fu = Population,           # column containing number of population per stratum\n     subgroup = Country,        # units we would like to compare\n     age_cat5,                  # characteristics to which we would like to standardize\n     Sex,                        \n     refdata = standard_pop_clean, # reference population, with numbers in column called pop\n     refgroup = \"B\",            # reference for comparison\n     estimate = \"difference\",   # type of estimate\n     sig = 0.95,                # significance level\n     mp = 100000,               # we want rates per 100.000 population\n     decimals = 2)              # number of decimals\n\n# Print table\nknitr::kable(mortality_rd) "},{"path":"standardization.html","id":"standard_phe","chapter":"21 Tỷ suất chuẩn hóa","heading":"21.4 Package PHEindicatormethods","text":"Một cách khác để tính tỷ suất chuẩn hóa là dùng package PHEindicatormethods. Package này cho phép chúng ta tính toán tỷ suất chuẩn hóa trực tiếp cũng như gián tiếp. Chúng tôi sẽ hướng dẫn cả hai.Phần này chúng ta sẽ sử dụng bộ số liệu all_data được tạo ở cuối phần Chuẩn bị. Bộ số liệu này bao gồm dân số quốc gia, số tử vong và dân số tham chiếu. Bạn có thể xem nó ở đây.","code":""},{"path":"standardization.html","id":"tỷ-suất-chuẩn-hóa-trực-tiếp","chapter":"21 Tỷ suất chuẩn hóa","heading":"Tỷ suất chuẩn hóa trực tiếp","text":"Đầu tiên, chúng ta nhóm số liệu theo Quốc gia như bên dưới và sau đó chuyển số liệu vào hàm phe_dsr() để có được tỷ suất chuẩn hóa trực tiếp theo quốc gia.Lưu ý, dân số tham chiếu (chuẩn) có thể được cung cấp dưới dạng một cột bên trong số liệu của một quốc gia cụ thể hoặc dưới dạng một véctơ riêng biệt. Nếu được cung cấp bên trong số liệu của một quốc gia cụ thể, bạn phải đặt stdpoptype = \"field\". Nếu được cung cấp như một véc tơ, đặt stdpoptype = \"vector\". Trong trường hợp thứ hai, chúng ta phải đảm bảo thứ tự của các hàng theo tầng tương tự nhau trong cả khung số liệu quốc gia và dân số tham chiếu, vì vị trí các bản ghi/các hàng phải khớp với nhau. Trong ví dụ bên dưới, chúng tôi đã cung cấp dân số tham chiếu dưới dạng một cột bên trong khung số liệu của một quốc gia cụ thể.Xem trợ giúp bằng cách gõ ?phr_dsr hoặc các liên kết trong phần Tài nguyên học liệu để biết thêm thông tin.","code":"\n# Calculate rates per country directly standardized for age and sex\nmortality_ds_rate_phe <- all_data %>%\n     group_by(Country) %>%\n     PHEindicatormethods::phe_dsr(\n          x = Deaths,                 # column with observed number of events\n          n = Population,             # column with non-standard pops for each stratum\n          stdpop = pop,               # standard populations for each stratum\n          stdpoptype = \"field\")       # either \"vector\" for a standalone vector or \"field\" meaning std populations are in the data  \n\n# Print table\nknitr::kable(mortality_ds_rate_phe)"},{"path":"standardization.html","id":"standard_indirect","chapter":"21 Tỷ suất chuẩn hóa","heading":"Tỷ suất chuẩn hóa gián tiếp","text":"Để chuẩn hóa gián tiếp, chúng ta cần dân số tham chiếu có số lượng tử vong và dân số theo tầng. Trong ví dụ này, chúng ta sẽ tính tỷ suất của quốc gia bằng cách sử dụng quốc gia B làm dân số tham chiếu, vì dân số tham chiếu trong bộ số liệu standard_pop_clean không có số lượng tử vong theo tầng.Trước tiên, chúng ta tạo dân số tham chiếu từ quốc gia B như bên dưới. Sau đó, chúng ta chuyển số liệu tử vong và dân số của quốc gia , kết nối nó với dân số tham chiếu và chuyển nó vào hàm phe_isr(), để có được tỷ suất chuẩn hóa gián tiếp. Dĩ nhiên, chúng ta cũng có thể làm ngược lại.Lưu ý - trong ví dụ bên dưới, dân số tham chiếu được cung cấp dưới dạng một data frame riêng rẽ. Trong trường hợp này, chúng ta cần đảm bảo rằng các véctơ x =, n =, x_ref = và n_ref = tất cả được sắp đặt cùng giá trị với loại chuẩn hóa (theo đúng tầng) như được sắp đặt trong data frame quốc gia, vì vị trí các bản ghi/các hàng phải khớp với nhau.Xem trợ giúp bằng cách gõ ?phr_isr hoặc các liên kết trong phần Tài nguyên học liệu để biết thêm thông tin.","code":"\n# Create reference population\nrefpopCountryB <- country_data %>% \n  filter(Country == \"B\") \n\n# Calculate rates for country A indirectly standardized by age and sex\nmortality_is_rate_phe_A <- country_data %>%\n     filter(Country == \"A\") %>%\n     PHEindicatormethods::phe_isr(\n          x = Deaths,                 # column with observed number of events\n          n = Population,             # column with non-standard pops for each stratum\n          x_ref = refpopCountryB$Deaths,  # reference number of deaths for each stratum\n          n_ref = refpopCountryB$Population)  # reference population for each stratum\n\n# Print table\nknitr::kable(mortality_is_rate_phe_A)"},{"path":"standardization.html","id":"tài-nguyên-học-liệu-6","chapter":"21 Tỷ suất chuẩn hóa","heading":"21.5 Tài nguyên học liệu","text":"Nếu bạn muốn tìm thêm các ví dụ có thể tái lập được sử dụng package dsr, vui lòng xem hướng dẫn nàyVới các ví dụ khác sử dụng package PHEindicatormethods, vui lòng xem tại website nàyXem thêm PHEindicatormethods tài liệu dưới dạng tệp pdf","code":""},{"path":"moving-average.html","id":"moving-average","chapter":"22 Đường trung bình động","heading":"22 Đường trung bình động","text":"Chương này bao gồm hai phương pháp tính toán và biểu diễn đường trung bình động:Tính toán với package sliderTính toán bên trong lệnh ggplot() với package tidyquant","code":""},{"path":"moving-average.html","id":"chuẩn-bị-12","chapter":"22 Đường trung bình động","heading":"22.1 Chuẩn bị","text":"","code":""},{"path":"moving-average.html","id":"gọi-package-6","chapter":"22 Đường trung bình động","heading":"Gọi package","text":"Đoạn code này hiển thị những package cần tải cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ pacman, hàm sẽ cài đặt package nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với library() từ base R. Xem chương R cơ bản để có thêm thông tin về các R package.","code":"\npacman::p_load(\n  tidyverse,      # for data management and viz\n  slider,         # for calculating moving averages\n  tidyquant       # for calculating moving averages within ggplot\n)"},{"path":"moving-average.html","id":"nhập-dữ-liệu-11","chapter":"22 Đường trung bình động","heading":"Nhập dữ liệu","text":"Chúng ta nhập các trường hợp trong linelist đã được làm sạch từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, bấm để tải xuống linelist “đã được làm sạch” (tệp .rds). Nhập dữ liệu với hàm import() từ package rio (hàm này xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương Nhập xuất dữ liệu để biết thêm chi tiết).50 hàng đầu tiên của linelist được hiển thị dưới đây.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"moving-average.html","id":"tính-toán-với-slider","chapter":"22 Đường trung bình động","heading":"22.2 Tính toán với slider","text":"Sử dụng cách tiếp cận này để tính toán đường trung bình động trong một data frame trước khi vẽ biểu đồ.Package slider cung cấp một số hàm tạo “cửa sổ trượt” giúp tính toán trung bình động, tổng tích lũy, hồi quy động (rolling regression), v.v. Nó coi data frame như một vectơ của các hàng, cho phép lặp lại hàng qua một data frame.Dưới đây là một số hàm phổ biến:slide_dbl() - lặp qua một cột dạng số (từ “_dbl”) để thực hiện thao tác sử dụng cửa sổ trượt\nslide_sum() - hàm tắt tính tổng động (rolling sum) cho slide_dbl()\nslide_mean() - hàm tắt tính trung bình động (rolling average) cho slide_dbl()\nslide_dbl() - lặp qua một cột dạng số (từ “_dbl”) để thực hiện thao tác sử dụng cửa sổ trượtslide_sum() - hàm tắt tính tổng động (rolling sum) cho slide_dbl()slide_mean() - hàm tắt tính trung bình động (rolling average) cho slide_dbl()slide_index_dbl() - áp dụng cửa sổ cuộn trên một cột dạng số bằng cách sử dụng một cột riêng biệt để lập chỉ mục cửa sổ tiến trình (hữu ích nếu cuộn theo ngày mà một số ngày bị thiếu)\nslide_index_sum() - hàm tắt tính tổng động với chỉ mục\nslide_index_mean() - hàm tắt tính trung bình động với chỉ mục\nslide_index_dbl() - áp dụng cửa sổ cuộn trên một cột dạng số bằng cách sử dụng một cột riêng biệt để lập chỉ mục cửa sổ tiến trình (hữu ích nếu cuộn theo ngày mà một số ngày bị thiếu)slide_index_sum() - hàm tắt tính tổng động với chỉ mụcslide_index_mean() - hàm tắt tính trung bình động với chỉ mụcPackage slider có nhiều hàm khác được đề cập đến trong phần Tài nguyên học liệu của chương này. Ở đây, chúng tôi sẽ đề cập ngắn gọn đến những điểm thông dụng nhất.Những đối số chính.x, đối số đầu tiên theo mặc định, là vectơ để lặp lại và để áp dụng hàm.x, đối số đầu tiên theo mặc định, là vectơ để lặp lại và để áp dụng hàm.= cho các phiên bản “chỉ mục (index)” của hàm slider - cung cấp một cột để “lập chỉ mục” khi cuộn (xem phần dưới đây).= cho các phiên bản “chỉ mục (index)” của hàm slider - cung cấp một cột để “lập chỉ mục” khi cuộn (xem phần dưới đây).f =, đối số thứ hai theo mặc định, có thể dùng theo một trong hai cách:\nMột hàm, được viết không có dấu ngoặc đơn, như mean hoặc\nMột công thức, mà sẽ được chuyển đổi thành một hàm. Ví dụ ~ .x - mean(.x) sẽ trả về kết quả của giá trị hiện tại trừ đi giá trị trung bình của cửa sổ giá trị\n.f =, đối số thứ hai theo mặc định, có thể dùng theo một trong hai cách:Một hàm, được viết không có dấu ngoặc đơn, như mean hoặcMột công thức, mà sẽ được chuyển đổi thành một hàm. Ví dụ ~ .x - mean(.x) sẽ trả về kết quả của giá trị hiện tại trừ đi giá trị trung bình của cửa sổ giá trịĐể biết thêm chi tiết xem tài liệu tham khảo nàyĐể biết thêm chi tiết xem tài liệu tham khảo nàyKích thước cửa sổXác định kích thước của cửa sổ bằng cách sử dụng một trong hai đối số ., ., hoặc cả hai đối số:.= - Cung cấp một số nguyên.= - Cung cấp một số nguyên.complete = - Đặt giá trị này thành TRUE nếu bạn chỉ muốn tính toán được thực hiện trên các cửa sổ hoàn chỉnhVí dụ: Để có cửa sổ 7 ngày liên tục bao gồm giá trị hiện tại và sáu giá trị trước đó, hãy sử dụng .= 6. Để có cửa sổ “trung tâm”, hãy cung cấp cùng một giá trị số cho cả .= và .=.Theo mặc định, .complete = sẽ nhận giá trị FALSE nên nếu cửa sổ hoàn chỉnh của các hàng không tồn tại, các hàm sẽ sử dụng các hàng sẵn có để thực hiện phép tính. Thiết lập giá trị thành TRUE giúp hạn chế việc các phép tính chỉ được thực hiện trên các cửa sổ hoàn chỉnh.Mở rộng cửa sổĐể có các tính toán tích lũy, hãy thiết lập đối số .= thành Inf. Điều này giúp tiến hành tính toán cả trên giá trị hiện tại và tất cả các giá trị trước đó.","code":""},{"path":"moving-average.html","id":"roll_index","chapter":"22 Đường trung bình động","heading":"Cuộn theo ngày","text":"Trường hợp sử dụng có khả năng xảy ra nhất của tính toán biến động trong dịch tễ học ứng dụng là kiểm tra một số liệu theo thời gian. Ví dụ: đo lường động các ca mới mắc, dựa trên số lượng trường hợp hàng ngày.Nếu bạn có dữ liệu chuỗi thời gian đã được làm sạch với đủ giá trị cho tất cả các ngày, bạn có thể sử dụng hàm slide_dbl(), như đã được trình bày trong chương Chuỗi thời gian và phát hiện ổ dịch.Tuy nhiên, trong nhiều trường hợp dịch tễ học ứng dụng, bạn có thể gặp những ngày trống trong dữ liệu của mình, những ngày mà không có sự kiện nào được ghi lại. Trong những trường hợp này, tốt nhất là sử dụng các phiên bản “chỉ mục” của các hàm slider.","code":""},{"path":"moving-average.html","id":"dữ-liệu-được-lập-chỉ-mục","chapter":"22 Đường trung bình động","heading":"Dữ liệu được lập chỉ mục","text":"Dưới đây, chúng tôi trình bày một ví dụ sử dụng slide_index_dbl() đối với các trường hợp của bộ dữ liệu linelist. Giả sử rằng mục tiêu của chúng ta là tính toán tỷ lệ mới mắc liên tục trong 7 ngày - tính tổng các trường hợp bằng cách sử dụng cửa sổ 7 ngày luân phiên. Nếu bạn đang tìm kiếm ví dụ về trung bình động, hãy xem phần bên dưới về cuộn theo nhóm.Để bắt đầu, bộ dữ liệu daily_counts được tạo ra để phản ánh số lượng ca mắc hàng ngày từ linelist, như đã được tính toán với hàm count() trong dplyr.Dưới đây là data frame daily_counts - bao gồm nrow(daily_counts) hàng, mỗi hàng đại diện cho một ngày, nhưng đặc biệt trong giai đoạn đầu của dịch, có một số ngày không xuất hiện (không có ca mắc nào được tiếp nhận vào những ngày đó).Điều quan trọng là phải nhận ra rằng một hàm cuộn tiêu chuẩn (như slide_dbl() sẽ sử dụng cửa sổ của 7 hàng, không phải 7 ngày. Vì vậy, nếu có bất kỳ ngày nào trống, một số cửa sổ sẽ thực sự kéo dài hơn 7 ngày theo lịch!Một cửa sổ động “thông minh” có thể được tạo với hàm slide_index_dbl(). “Chỉ mục” có nghĩa là hàm sử dụng một cột riêng biệt làm “chỉ mục” cho cửa sổ động. Cửa sổ đó không chỉ đơn giản dựa trên các hàng của data frame.Nếu cột chỉ mục là ngày, bạn có thêm khả năng xác định phạm vi cửa sổ cho .= và/hoặc .= theo đơn vị days() và months() của lubridate. Nếu bạn thực hiện những điều này, hàm sẽ bao gồm những ngày trống trong cửa sổ như thể chúng ở đó (dưới dạng giá trị NA).Hãy đưa ra một sánh. Dưới đây, chúng tôi tính toán số trường hợp mới mắc biến động trong 7 ngày với các cửa sổ thông thường và được lập chỉ mục.Quan sát trong cột thông thường cho 7 hàng đầu tiên, cách số lượng ca mắc tăng đều đặn mặc dù các hàng không cách nhau 7 ngày! Cột “được lập chỉ mục” liền kề tính cho những ngày lịch trống này, vì vậy tổng 7 ngày của nó thấp hơn nhiều, ít nhất là khi khoảng thời gian các ca mắc cách nhau xa hơn trong thời kỳ dịch bệnh này.Bây giờ bạn có thể vẽ biểu đồ những dữ liệu này bằng cách sử dụng ggplot():","code":"\n# make dataset of daily counts\ndaily_counts <- linelist %>% \n  count(date_hospitalisation, name = \"new_cases\")\nrolling <- daily_counts %>% \n  mutate(                                # create new columns\n    # Using slide_dbl()\n    ###################\n    reg_7day = slide_dbl(\n      new_cases,                         # calculate on new_cases\n      .f = ~sum(.x, na.rm = T),          # function is sum() with missing values removed\n      .before = 6),                      # window is the ROW and 6 prior ROWS\n    \n    # Using slide_index_dbl()\n    #########################\n    indexed_7day = slide_index_dbl(\n        new_cases,                       # calculate on new_cases\n        .i = date_hospitalisation,       # indexed with date_onset \n        .f = ~sum(.x, na.rm = TRUE),     # function is sum() with missing values removed\n        .before = days(6))               # window is the DAY and 6 prior DAYS\n    )\nggplot(data = rolling)+\n  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)"},{"path":"moving-average.html","id":"biến-động-theo-nhóm","chapter":"22 Đường trung bình động","heading":"Biến động theo nhóm","text":"Nếu bạn nhóm dữ liệu của mình trước khi sử dụng hàm slider, các cửa sổ trượt sẽ được áp dụng theo nhóm. Hãy cẩn thận để sắp xếp các hàng của bạn với thứ tự mong muốn theo nhóm.Mỗi khi một nhóm mới được tạo, cửa sổ trượt sẽ bắt đầu lại. đó, một điều cần lưu ý là nếu dữ liệu của bạn được nhóm lại và bạn đã thiết lập .complete = TRUE, bạn sẽ có các giá trị trống ở mỗi lần dịch chuyển giữa các nhóm. Khi hàm di chuyển xuống dưới qua các hàng, mọi dịch chuyển trong cột được nhóm sẽ bắt đầu lại việc cộng dồn kích thước cửa sổ tối thiểu để cho phép tính toán.Xem chương Nhóm dữ liệu trong sổ tay này để biết thêm chi tiết về nhóm dữ liệu.Dưới đây, chúng tôi đếm các ca mắc trong linelist theo ngày và theo bệnh viện. Sau đó, chúng tôi sắp xếp các hàng theo thứ tự tăng dần, thứ tự đầu tiên theo bệnh viện và sau đó là theo ngày. Tiếp theo, chúng tôi đặt group_by(). Cuối cùng, chúng tôi có thể tạo trung bình động mới của mình.Đây là bộ dữ liệu mới:Bây giờ chúng ta có thể vẽ các đường trung bình động, hiển thị dữ liệu theo nhóm bằng cách chỉ định ~ hospital tới facet_wrap() trong ggplot(). Để giải trí, chúng tôi vẽ hai biểu đồ - một biểu đồ cột geom_col() thể hiện số lượng ca mắc hàng ngày và một biểu đồ đường geom_line() thể hiện đường trung bình động của 7 ngày.NGUY HIỂM: Nếu bạn gặp lỗi cho biết “slide() deprecated tsibble 0.9.0 now defunct. Please use slider::slide() instead.”, điều đó có nghĩa là hàm slide() từ package tsibble đang đè lên hàm slide() từ package slider. Khắc phục lỗi này bằng cách cụ thể tên package trong lệnh, ví dụ slider::slide_dbl().","code":"\ngrouped_roll <- linelist %>%\n     \n  count(hospital, date_hospitalisation, name = \"new_cases\") %>% \n     \n  arrange(hospital, date_hospitalisation) %>%   # arrange rows by hospital and then by date\n     \n  group_by(hospital) %>%              # group by hospital \n     \n  mutate(                             # rolling average  \n    mean_7day_hosp = slide_index_dbl(\n      .x = new_cases,                 # the count of cases per hospital-day\n      .i = date_hospitalisation,      # index on date of admission\n      .f = mean,                      # use mean()                  \n      .before = days(6)               # use the day and the 6 days prior\n      )\n  )\nggplot(data = grouped_roll)+\n  geom_col(                       # plot daly case counts as grey bars\n    mapping = aes(\n      x = date_hospitalisation,\n      y = new_cases),\n    fill = \"grey\",\n    width = 1)+\n  geom_line(                      # plot rolling average as line colored by hospital\n    mapping = aes(\n      x = date_hospitalisation,\n      y = mean_7day_hosp,\n      color = hospital),\n    size = 1)+\n  facet_wrap(~hospital, ncol = 2)+ # create mini-plots per hospital\n  theme_classic()+                 # simplify background  \n  theme(legend.position = \"none\")+ # remove legend\n  labs(                            # add plot labels\n    title = \"7-day rolling average of daily case incidence\",\n    x = \"Date of admission\",\n    y = \"Case incidence\")"},{"path":"moving-average.html","id":"tính-toán-với-tidyquant-trong-ggplot","chapter":"22 Đường trung bình động","heading":"22.3 Tính toán với tidyquant trong ggplot()","text":"Package tidyquant cung cấp một cách tiếp cận khác để tính toán đường trung bình động - lần này chính là từ bên trong lệnh ggplot().Dữ liệu linelist dưới đây được đếm theo ngày khởi phát và được vẽ dưới dạng một đường mờ (alpha <1). Được phủ lên trên là một đường được tạo bằng hàm geom_ma() từ package tidyquant, với cửa sổ được thiết lập là 7 ngày (n = 7) với màu sắc và độ dày được chỉ định.Theo mặc định, geom_ma() sử dụng một đường trung bình động đơn giản (ma_fun = \"SMA\"), tuy nhiên, hàm này cũng có thể sử dụng các loại đường trung bình khác, chẳng hạn như:“EMA” - đường trung bình động lũy thừa (exponential moving average) (thêm trọng số cho các quan sát gần đây)“WMA” - đường trung bình động có trọng số (weighted moving average) (wts được sử dụng để đánh trọng số các quan sát trong đường trung bình động)Các loại đường trung bình động khác có thể được tìm thấy trong tài liệu về hàmXem tài liệu này để biết thêm chi tiết về các tùy chọn sẵn có trong tidyquant.","code":"\nlinelist %>% \n  count(date_onset) %>%                 # count cases per day\n  drop_na(date_onset) %>%               # remove cases missing onset date\n  ggplot(aes(x = date_onset, y = n))+   # start ggplot\n    geom_line(                          # plot raw values\n      size = 1,\n      alpha = 0.2                       # semi-transparent line\n      )+             \n    tidyquant::geom_ma(                 # plot moving average\n      n = 7,           \n      size = 1,\n      color = \"blue\")+ \n  theme_minimal()                       # simple background"},{"path":"moving-average.html","id":"tài-nguyên-học-liệu-7","chapter":"22 Đường trung bình động","heading":"22.4 Tài nguyên học liệu","text":"Xem thông tin trực tuyến hữu ích về vignette slider packageTrang github về SliderMột vignette slidertidyquant vignetteNếu tình huống sử dụng của bạn yêu cầu “bỏ qua” các ngày cuối tuần và thậm chí là những ngày lễ, bạn có thể quan tâm đến package almanac.","code":""},{"path":"time-series.html","id":"time-series","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23 Chuỗi thời gian và phát hiện ổ dịch","text":"","code":""},{"path":"time-series.html","id":"tổng-quan-2","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23.1 Tổng quan","text":"Chương này minh họa cách sử dụng của một số packages cho phân tích chuỗi thời gian. Các packages chủ yếu đến từ hệ sinh thái tidyverts, ngoài ra cũng sử dụng RECON trending package để fit các mô hình dịch tễ học bệnh truyền nhiễm.VÍ dụ dưới đây chúng ta sẽ sử dụng bộ dữ liệu về Campylobacter ở Germanywe thuộc package surveillance (xem chương Tải sách và dữ liệu để biết thêm chi tiết). Tuy nhiên, nếu bạn muốn thử chạy code này trên bộ dữ liệu lớn hơn (nhiều quốc gia hoặc tầng), bạn có thể tham khảo code mẫu tại repo github của r4epis.Các chủ đề được đề cập bao gồm:Dữ liệu chuỗi thời gianPhân tích mô tảFitting đường hồi quyMối liên hệ của hai chuỗi thời gianPhát hiện dịch bệnhChuỗi thời gian bị gián đoạn","code":""},{"path":"time-series.html","id":"chuẩn-bị-13","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23.2 Chuẩn bị","text":"","code":""},{"path":"time-series.html","id":"packages-1","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Packages","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.","code":"\npacman::p_load(rio,          # File import\n               here,         # File locator\n               tidyverse,    # data management + ggplot2 graphics\n               tsibble,      # handle time series datasets\n               slider,       # for calculating moving averages\n               imputeTS,     # for filling in missing values\n               feasts,       # for time series decomposition and autocorrelation\n               forecast,     # fit sin and cosin terms to data (note: must load after feasts)\n               trending,     # fit and assess models \n               tmaptools,    # for getting geocoordinates (lon/lat) based on place names\n               ecmwfr,       # for interacting with copernicus sateliate CDS API\n               stars,        # for reading in .nc (climate data) files\n               units,        # for defining units of measurement (climate data)\n               yardstick,    # for looking at model accuracy\n               surveillance  # for aberration detection\n               )"},{"path":"time-series.html","id":"nhập-dữ-liệu-12","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Nhập dữ liệu","text":"Bạn có thể tải xuống tất cả dữ liệu được sử dụng trong sổ tay này thông qua các hướng dẫn trong chương Tải sách và dữ liệu.Bộ dữ liệu minh họa được sử dụng trong phần này là số lượng các trường hợp campylobacter hàng tuần được báo cáo ở Đức từ năm 2001 đến 2011. Bạn có thể bấm vào đây để tải xuống bộ dữ liệu này (.xlsx).Bộ dữ liệu này là một phiên bản rút gọn của bộ dữ liệu có sẵn trong package surveillance. (để biết chi tiết, hãy gọi surveillance package ra sau đó nhập ?campyDE)Nhập dữ liệu này với hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).10 hàng đầu tiên được hiển thị như bên dưới.","code":"\n# import the counts into R\ncounts <- rio::import(\"campylobacter_germany.xlsx\")"},{"path":"time-series.html","id":"làm-sạch-dữ-liệu","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Làm sạch dữ liệu","text":"Code dưới đây đảm bảo rằng cột ngày thág đã ở đúng định dạng. Trong chương này chúng ta sẽ sử dụng package tsibble và hàm yearweek sẽ được sử dụng để tạp biến lịch theo tuần. Có một số cách để thực hiện việc này (Xem chương Làm việc với ngày tháng để biết thêm chi tiết), tuy nhiên đối với dữ liệu chuỗi thời gian thì tốt nhất nên sử dụng thống nhất một framework (tsibble).","code":"\n## ensure the date column is in the appropriate format\ncounts$date <- as.Date(counts$date)\n\n## create a calendar week variable \n## fitting ISO definitons of weeks starting on a monday\ncounts <- counts %>% \n     mutate(epiweek = yearweek(date, week_start = 1))"},{"path":"time-series.html","id":"tải-xuống-dữ-liệu-khí-hậu","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Tải xuống dữ liệu khí hậu","text":"Trong mục mối tương quan của hai chuỗi thời gian trong chương này, chúng ta sẽ sánh số lượng trường hợp campylobacter với dữ liệu khí hậu.\nDữ liệu khí hậu tại bất kỳ đâu trên thế giới đều có thể được tải xuống từ EU’s Copernicus Satellite. Đây không phải là các phép đo chính xác, mà dựa trên một mô hình (tương tự như phép nội suy), tuy nhiên lợi ích là mức độ bao phủ toàn cầu hàng giờ cũng như các dự báo.Bạn có thể tải xuống từng tệp dữ liệu khí hậu này từ chương Tải sách và dữ liệu.Với mục đích minh họa ở đây, chúng tôi sẽ trình bày code để sử dụng package ecmwfr để lấy những dữ liệu này từ kho dữ liệu khí hậu Copernicus. Bạn sẽ cần tạo một tài khoản miễn phí để thực hiện. Trang web của package có một hướng dẫn hữu ích về cách thực hiện việc này. Dưới đây là code minh họa về cách thực hiện việc này, khi bạn có các khóa API thích hợp. Bạn phải thay thế X bên dưới bằng ID tài khoản của mình. Bạn sẽ cần tải xuống một năm dữ liệu cùng một lúc nếu không máy chủ sẽ hết thời gian chờ.Nếu bạn không chắc chắn về tọa độ cho vị trí mà bạn muốn tải dữ liệu xuống, bạn có thể sử dụng gói tmaptools để lấy tọa độ ra từ open street maps. Một cách khác là dùng package photon, tuy nhiên nó chưa được chính thức xuất bản lên trên CRAN; cái hay của photon là nó cung cấp nhiều dữ liệu ngữ cảnh hơn khi có một số kết quả phù hợp cho tìm kiếm của bạn.","code":"\n## retrieve location coordinates\ncoords <- geocode_OSM(\"Germany\", geometry = \"point\")\n\n## pull together long/lats in format for ERA-5 querying (bounding box) \n## (as just want a single point can repeat coords)\nrequest_coords <- str_glue_data(coords$coords, \"{y}/{x}/{y}/{x}\")\n\n\n## Pulling data modelled from copernicus satellite (ERA-5 reanalysis)\n## https://cds.climate.copernicus.eu/cdsapp#!/software/app-era5-explorer?tab=app\n## https://github.com/bluegreen-labs/ecmwfr\n\n## set up key for weather data \nwf_set_key(user = \"XXXXX\",\n           key = \"XXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX\",\n           service = \"cds\") \n\n## run for each year of interest (otherwise server times out)\nfor (i in 2002:2011) {\n  \n  ## pull together a query \n  ## see here for how to do: https://bluegreen-labs.github.io/ecmwfr/articles/cds_vignette.html#the-request-syntax\n  ## change request to a list using addin button above (python to list)\n  ## Target is the name of the output file!!\n  request <- request <- list(\n    product_type = \"reanalysis\",\n    format = \"netcdf\",\n    variable = c(\"2m_temperature\", \"total_precipitation\"),\n    year = c(i),\n    month = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"),\n    day = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\",\n            \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\"),\n    time = c(\"00:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\",\n             \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\", \"15:00\",\n             \"16:00\", \"17:00\", \"18:00\", \"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\"),\n    area = request_coords,\n    dataset_short_name = \"reanalysis-era5-single-levels\",\n    target = paste0(\"germany_weather\", i, \".nc\")\n  )\n  \n  ## download the file and store it in the current working directory\n  file <- wf_request(user     = \"XXXXX\",  # user ID (for authentication)\n                     request  = request,  # the request\n                     transfer = TRUE,     # download the file\n                     path     = here::here(\"data\", \"Weather\")) ## path to save the data\n  }"},{"path":"time-series.html","id":"nhập-dữ-liệu-khí-hậu","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Nhập dữ liệu khí hậu","text":"Cho dù bạn đã tải xuống dữ liệu khí hậu thông qua sổ tay này hay sử dụng code ở trên, thì bạn cần phải các tệp dữ liệu khí hậu trong 10 năm có phần mở rộng là “.nc”, được lưu trữ trong cùng một thư mục trong máy tính của bạn.Sử dụng mã bên dưới để nhập các tệp này vào R với package stars.Khi các tệp này đã được nhập vào một đối tượng có tên data, chúng ta sẽ chuyển chúng thành một data frame.","code":"\n## define path to weather folder \nfile_paths <- list.files(\n  here::here(\"data\", \"time_series\", \"weather\"), # replace with your own file path \n  full.names = TRUE)\n\n## only keep those with the current name of interest \nfile_paths <- file_paths[str_detect(file_paths, \"germany\")]\n\n## read in all the files as a stars object \ndata <- stars::read_stars(file_paths)## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp, \n## t2m, tp,\n## change to a data frame \ntemp_data <- as_tibble(data) %>% \n  ## add in variables and correct units\n  mutate(\n    ## create an calendar week variable \n    epiweek = tsibble::yearweek(time), \n    ## create a date variable (start of calendar week)\n    date = as.Date(epiweek),\n    ## change temperature from kelvin to celsius\n    t2m = set_units(t2m, celsius), \n    ## change precipitation from metres to millimetres \n    tp  = set_units(tp, mm)) %>% \n  ## group by week (keep the date too though)\n  group_by(epiweek, date) %>% \n  ## get the average per week\n  summarise(t2m = as.numeric(mean(t2m)), \n            tp = as.numeric(mean(tp)))## `summarise()` has grouped output by 'epiweek'. You can override using the `.groups` argument."},{"path":"time-series.html","id":"dữ-liệu-chuỗi-thời-gian","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23.3 Dữ liệu chuỗi thời gian","text":"Có một số package khác nhau để cấu trúc và xử lý dữ liệu chuỗi thời gian. Như đã nói, chúng ta sẽ tập trung vào họ các package thuộc tidyverts và sẽ sử dụng package tsibble để xác định đối tượng chuỗi thời gian. Việc có một tập dữ liệu được xác định là một đối tượng chuỗi thời gian có nghĩa là việc cấu trúc phân tích của chúng ta sẽ trở nên dễ dàng hơn nhiều.Để thực hiện, chúng ta sử dụng hàm tsibble() và cụ thể “chỉ mục (index)”, vd: biến số cụ thể đơn vị thời gian quan tâm. Trong trường hợp của chúng ta, biến số này có tên epiweek.Ví dụ: nếu chúng ta có một tập dữ liệu với số lượng hàng tuần theo tỉnh, chúng ta cũng có thể cụ thể biến nhóm bằng cách cụ sử dụng đối số key =. Điều này sẽ cho phép chúng ta thực hiện phân tích cho từng nhóm.Nhìn vào class(counts), ta thấy ngoài việc là một data frame gọn gàng (“tbl_df”, “tbl”, “data.frame”), nó có các thuộc tính bổ sung của một khung dữ liệu chuỗi thời gian (“tbl_ts”).Bạn có thể xem nhanh dữ liệu của mình bằng cách sử dụng ggplot2. Từ biểu đồ ta thấy có một xu hướng theo mùa, và không có bất kỳ giá trị bị thiếu nào. Tuy nhiên, dường như có vấn đề với việc báo cáo vào đầu mỗi năm; số ca mắc bệnh giảm vào tuần cuối cùng của năm và sau đó tăng vào tuần đầu tiên của năm tiếp theo.NGUY HIỂM: Không giống như ví dụ này, phần lớn các bộ dữ liệu sẽ chưa được làm sạch. Bạn sẽ cần phải kiểm tra các bản ghi trùng lặp và bản ghi bị thiếu như bên dưới.","code":"\n## define time series object \ncounts <- tsibble(counts, index = epiweek)\n## plot a line graph of cases by week\nggplot(counts, aes(x = epiweek, y = case)) + \n     geom_line()"},{"path":"time-series.html","id":"trùng-lặp","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Trùng lặp","text":"tsibble không cho phép các quan sát trùng lặp. Vì vậy, mỗi hàng sẽ cần phải là duy nhất, hoặc duy nhất trong nhóm (biến key). Package này có một số hàm để xác định các bản ghi trùng lặp. Chúng bao gồm các hàm: are_duplicated() trả về một vectơ có giá trị TRUE/FALSE vector, truy vấn xem hàng có là duy nhất không; và hàm duplicates() sẽ cung cấp cho bạn một data frame chứa các hàng trùng lặp.Xem chương Loại bỏ trùng lặp để biết thêm chi tiết về cách lựa chọn các hàng bạn muốn.","code":"\n## get a vector of TRUE/FALSE whether rows are duplicates\nare_duplicated(counts, index = epiweek) \n\n## get a data frame of any duplicated rows \nduplicates(counts, index = epiweek) "},{"path":"time-series.html","id":"bản-ghi-bị-thiếu","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Bản ghi bị thiếu","text":"Chúng ta đã thấy từ cuộc khảo sát tóm tắt bên trên, không có bất kỳ giá trị missing nào được phát hiện, nhưng chúng ta cũng đã thấy rằng dường như có vấn đề với việc báo cáo chậm trễ vào khoảng năm mới. Một cách để giải quyết vấn đề này có thể là đặt các giá trị này thành missing và sau đó impute các giá trị. Dạng đơn giản nhất của khi impute chuỗi thời gian là vẽ một đường thẳng giữa giá trị không bị thiếu cuối cùng và giá trị không bị thiếu tiếp theo. Để làm điều này, chúng ta sẽ sử dụng hàm na_interpolation() từ package imputeTS .Xem chương Dữ liệu Missing để biết các tùy chọn khác của imputation.Một giải pháp thay thế khác sẽ là tính toán đường trung bình động, để thử và giải quyết các vấn đề báo cáo rõ ràng này (xem phần tiếp theo và chương Đường trung bình động.","code":"\n## create a variable with missings instead of weeks with reporting issues\ncounts <- counts %>% \n     mutate(case_miss = if_else(\n          ## if epiweek contains 52, 53, 1 or 2\n          str_detect(epiweek, \"W51|W52|W53|W01|W02\"), \n          ## then set to missing \n          NA_real_, \n          ## otherwise keep the value in case\n          case\n     ))\n\n## alternatively interpolate missings by linear trend \n## between two nearest adjacent points\ncounts <- counts %>% \n  mutate(case_int = imputeTS::na_interpolation(case_miss)\n         )\n\n## to check what values have been imputed compared to the original\nggplot_na_imputations(counts$case_miss, counts$case_int) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()"},{"path":"time-series.html","id":"phân-tích-mô-tả","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23.4 Phân tích mô tả","text":"","code":""},{"path":"time-series.html","id":"timeseries_moving","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Đường trung bình động","text":"Nếu dữ liệu rất nhiễu (dao động lên và xuống), việc tính toán đường trung bình động có thể sẽ hữu ích. Trong ví dụ dưới đây, với mỗi tuần chúng ta sẽ tính toán số trường hợp trung bình từ bốn tuần trước đó. Việc này sẽ giúp dữ liệu dễ diễn giải hơn. Trong trường hợp của chúng ta, điều này không thực sự bổ sung nhiều, vì vậy chúng ta sẽ bám vào dữ liệu nội suy để phân tích thêm. Xem chương Đường trung bình động để biết thêm chi tiết.","code":"\n## create a moving average variable (deals with missings)\ncounts <- counts %>% \n     ## create the ma_4w variable \n     ## slide over each row of the case variable\n     mutate(ma_4wk = slider::slide_dbl(case, \n                               ## for each row calculate the name\n                               ~ mean(.x, na.rm = TRUE),\n                               ## use the four previous weeks\n                               .before = 4))\n\n## make a quick visualisation of the difference \nggplot(counts, aes(x = epiweek)) + \n     geom_line(aes(y = case)) + \n     geom_line(aes(y = ma_4wk), colour = \"red\")"},{"path":"time-series.html","id":"tính-chu-kỳ","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Tính chu kỳ","text":"Sau đây chúng ta sẽ định nghĩa một hàm để tạo một biểu đồ chu kỳ. Xem chương Viết hàm để biết cách tạo một hàm trong R.Đầu tiên, hàm được định nghĩa. Các đối số của nó bao gồm một bộ dữ liệu với cột counts, start_week = là tuần đầu tiên của bộ dữ liệu, một con số để cho biết có bao nhiêu chu kỳ mỗi năm (ví dụ: 52, 12), và cuối cùng là kiểu đầu ra (xem chi tiết trong đoạn mã bên dưới).LƯU Ý: Có thể sử dụng các tuần ở trên để thêm chúng vào các chu kỳ sin và cosin, tuy nhiên chúng ta sẽ sử dụng một hàm để tạo ra các chu kỳ này (xem phần hồi quy bên dưới) ","code":"\n## Function arguments\n#####################\n## x is a dataset\n## counts is variable with count data or rates within x \n## start_week is the first week in your dataset\n## period is how many units in a year \n## output is whether you want return spectral periodogram or the peak weeks\n  ## \"periodogram\" or \"weeks\"\n\n# Define function\nperiodogram <- function(x, \n                        counts, \n                        start_week = c(2002, 1), \n                        period = 52, \n                        output = \"weeks\") {\n  \n\n    ## make sure is not a tsibble, filter to project and only keep columns of interest\n    prepare_data <- dplyr::as_tibble(x)\n    \n    # prepare_data <- prepare_data[prepare_data[[strata]] == j, ]\n    prepare_data <- dplyr::select(prepare_data, {{counts}})\n    \n    ## create an intermediate \"zoo\" time series to be able to use with spec.pgram\n    zoo_cases <- zoo::zooreg(prepare_data, \n                             start = start_week, frequency = period)\n    \n    ## get a spectral periodogram not using fast fourier transform \n    periodo <- spec.pgram(zoo_cases, fast = FALSE, plot = FALSE)\n    \n    ## return the peak weeks \n    periodo_weeks <- 1 / periodo$freq[order(-periodo$spec)] * period\n    \n    if (output == \"weeks\") {\n      periodo_weeks\n    } else {\n      periodo\n    }\n    \n}\n\n## get spectral periodogram for extracting weeks with the highest frequencies \n## (checking of seasonality) \nperiodo <- periodogram(counts, \n                       case_int, \n                       start_week = c(2002, 1),\n                       output = \"periodogram\")\n\n## pull spectrum and frequence in to a dataframe for plotting\nperiodo <- data.frame(periodo$freq, periodo$spec)\n\n## plot a periodogram showing the most frequently occuring periodicity \nggplot(data = periodo, \n                aes(x = 1/(periodo.freq/52),  y = log(periodo.spec))) + \n  geom_line() + \n  labs(x = \"Period (Weeks)\", y = \"Log(density)\")\n## get a vector weeks in ascending order \npeak_weeks <- periodogram(counts, \n                          case_int, \n                          start_week = c(2002, 1), \n                          output = \"weeks\")"},{"path":"time-series.html","id":"tách-nhỏ-chuỗi-thời-gian","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Tách nhỏ chuỗi thời gian","text":"Phân tách cổ điển được sử dụng để chia nhỏ một chuỗi thời gian thành một số phần, khi kết hợp lại với nhau sẽ tạo nên xu hướng mà bạn nhìn thấy. Các phần khác nhau này là:Chu kỳ xu hướng (hướng dài hạn của dữ liệu)Theo mùa (lặp lại xu hướng)Sự ngẫu nhiên (những gì còn lại sau khi loại bỏ xu hướng và theo mùa)","code":"\n## decompose the counts dataset \ncounts %>% \n  # using an additive classical decomposition model\n  model(classical_decomposition(case_int, type = \"additive\")) %>% \n  ## extract the important information from the model\n  components() %>% \n  ## generate a plot \n  autoplot()"},{"path":"time-series.html","id":"tự-tương-quan","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Tự tương quan","text":"Tự tương quan cho bạn biết về mối quan hệ giữa số lượng của mỗi tuần và các tuần trước đó (được gọi là trễ).Sử dụng hàm ACF(), chúng ta có thể tạo ra một biểu đồ cho chúng ta thấy số lượng đường có mối quan hệ ở các độ trễ khác nhau. Khi độ trễ bằng 0 (x = 0), đường này sẽ luôn là 1 vì nó cho thấy mối quan hệ giữa một quan sát và chính nó (không được hiển thị). Đường đầu tiên hiển thị ở đây (x = 1) cho thấy mối quan hệ giữa mỗi quan sát và quan sát trước nó (độ trễ bằng 1), đường thứ hai cho thấy mối quan hệ giữa mỗi quan sát và quan sát trước quan sát cuối cùng (độ trễ là 2) và cứ như thế cho đến khi độ trễ là 52, cho thấy mối quan hệ giữa mỗi quan sát và quan sát từ 1 năm (52 tuần trước đó).Sử dụng hàm ACF() (cho tự tương quan một phần) hiển thị cùng một loại quan hệ nhưng được hiệu chỉnh cho tất cả các tuần khác nằm giữa. Nó sẽ ít thông tin hơn để xác định tính chu kỳ.Bạn có thể kiểm định giả thuyết không về tính độc lập trong một chuỗi thời gian (vd: không tự tương quan) sử dụng kiểm định Ljung-Box (trong package stats). Giá trị p có ý nghĩa cho thấy rằng có sự tự tương quan trong dữ liệu.","code":"\n## using the counts dataset\ncounts %>% \n  ## calculate autocorrelation using a full years worth of lags\n  ACF(case_int, lag_max = 52) %>% \n  ## show a plot\n  autoplot()\n## using the counts data set \ncounts %>% \n  ## calculate the partial autocorrelation using a full years worth of lags\n  PACF(case_int, lag_max = 52) %>% \n  ## show a plot\n  autoplot()\n## test for independance \nBox.test(counts$case_int, type = \"Ljung-Box\")## \n##  Box-Ljung test\n## \n## data:  counts$case_int\n## X-squared = 462.65, df = 1, p-value < 2.2e-16"},{"path":"time-series.html","id":"fit-mô-hình-hồi-quy","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23.5 Fit mô hình hồi quy","text":"Có thể fit một số lượng lớn các hồi quy khác nhau vào một chuỗi thời gian, tuy nhiên ở đây chúng tôi sẽ trình bày cách để fit một hồi quy nhị thức âm - vì nó thường phù hợp nhất cho dữ liệu về trường hợp bệnh trong các bệnh truyền nhiễm.","code":""},{"path":"time-series.html","id":"chu-kỳ-fourier","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Chu kỳ Fourier","text":"Chu kỳ Fourier tương đương với các đường cong sin và cosin. Sự khác biệt là chúng được dựa trên việc tìm ra sự kết hợp thích hợp nhất của các đường cong để giải thích dữ liệu của bạn.fitting một chu kỳ Fourier, điều này sẽ tương đương với việc fitting một đường sin và cosin cho độ trễ xảy ra thường xuyên nhất được thấy trong biểu đồ chu kỳ của bạn (trong trường hợp của chúng ta là 52 tuần). Chúng ta sử dụng hàm fourier() từ package forecast.Trong code dưới đây, chúng ta gán bằng cách sử dụng $, vì hàm fourier() trả về hai cột (một cho sin và một cho cosin) và vì vậy chúng được thêm vào tập dữ liệu dưới dạng danh sách, được gọi là “fourier” - nhưng danh sách này sau đó có thể được sử dụng như một biến bình thường trong hồi quy.","code":"\n## add in fourier terms using the epiweek and case_int variabless\ncounts$fourier <- select(counts, epiweek, case_int) %>% \n  fourier(K = 1)"},{"path":"time-series.html","id":"hồi-quy-nhị-thức-âm","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Hồi quy nhị thức âm","text":"Bạn có thể fit các mô hình hồi quy sử dụng các hàm từ package stats hoặc MASS trong base R (vd: lm(), glm() và glm.nb()). Tuy nhiên, chúng ta sẽ sử dụng các hàm từ package trending, vì nó cho phép tính khoảng tin cậy và khoảng tiên lượng phù hợp (các hàm khác không có sẵn). Cú pháp vẫn như vậy, bạn cụ thể biến đầu ra và theo sau bởi dấu ngã (~), sau đó thêm các biến giải thích vào, phân cách nhau bởi dấu cộng (+).Sự khác biệt là đầu tiên chúng ta phải xác định model trước, và sau đó fit() nó vào dữ liệu. Điều này rất hữu ích vì nó cho phép sánh nhiều mô hình khác nhau với cùng một cú pháp..MẸO: Nếu bạn muốn sử dụng tỷ suất hơn là số lượng, bạn có thể bao gồm biến dân số dưới dạng thuật ngữ bù logarit, bằng cách thêm offset(log(population). Sau đó, bạn sẽ cần đặt dân số là 1, trước khi sử dụng hàm predict() để tạo ra tỷ suất. MẸO: Để fit những mô hình phức tạp hơn chẳng hạn như ARIMA hoặc prophet, hãy tham khảo package fable.","code":"\n## define the model you want to fit (negative binomial) \nmodel <- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the fourier terms to account for seasonality\n    fourier)\n\n## fit your model using the counts dataset\nfitted_model <- trending::fit(model, counts)\n\n## calculate confidence intervals and prediction intervals \nobserved <- predict(fitted_model, simulate_pi = FALSE)\n\n## plot your regression \nggplot(data = observed, aes(x = epiweek)) + \n  ## add in a line for the model estimate\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## add in a band for the prediction intervals \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## add in a line for your observed case counts\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()"},{"path":"time-series.html","id":"phần-dư","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Phần dư","text":"Để xem mô hình của chúng ta phù hợp với dữ liệu quan sát như thế nào, chúng ta cần xem xét phần dư. Phần dư là sự khác biệt giữa số lượng được quan sát và số lượng được ước tính từ mô hình. Chúng ta có thể tính toán nó một cách đơn giản bằng cách dùng hàm case_int - estimate, nhưng hàm residuals() trích xuất nó trực tiếp từ mô hình hồi quy cho chúng ta.Những gì chúng ta thấy dưới đây là chúng ta không giải thích tất cả các sự dao động mà chúng ta có thể có với mô hình. Có thể chúng ta cần fit nhiều chu kỳ fourier hơn, và gủau quyết biên độ. Tuy nhiên đối với ví dụ này, chúng ta sẽ để nguyên như vậy. Các biểu đồ cho thấy mô hình của chúng ta hoạt động kém hơn ở các đỉnh và đáy (khi số lượng ở mức cao nhất và thấp nhất) và có nhiều khả năng ước tính không đầy đủ các số lượng quan sát được.","code":"\n## calculate the residuals \nobserved <- observed %>% \n  mutate(resid = residuals(fitted_model$fitted_model, type = \"response\"))\n\n## are the residuals fairly constant over time (if not: outbreaks? change in practice?)\nobserved %>%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n## is there autocorelation in the residuals (is there a pattern to the error?)  \nobserved %>% \n  as_tsibble(index = epiweek) %>% \n  ACF(resid, lag_max = 52) %>% \n  autoplot()\n## are residuals normally distributed (are under or over estimating?)  \nobserved %>%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n## compare observed counts to their residuals \n  ## should also be no pattern \nobserved %>%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n## formally test autocorrelation of the residuals\n## H0 is that residuals are from a white-noise series (i.e. random)\n## test for independence \n## if p value significant then non-random\nBox.test(observed$resid, type = \"Ljung-Box\")## \n##  Box-Ljung test\n## \n## data:  observed$resid\n## X-squared = 346.64, df = 1, p-value < 2.2e-16"},{"path":"time-series.html","id":"mối-quan-hệ-của-hai-chuỗi-thời-gian","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23.6 Mối quan hệ của hai chuỗi thời gian","text":"Ở đây chúng ta xem xét việc sử dụng dữ liệu thời tiết (đặc biệt là nhiệt độ) để giải thích số lượng trường hợp campylobacter.","code":""},{"path":"time-series.html","id":"nối-hai-bộ-dữ-liệu","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Nối hai bộ dữ liệu","text":"Bạn có thể nối các tập dữ liệu của mình sử dụng biến tuần. Để biết thêm về nối dữ liệu, xem chương Nối dữ liệu.","code":"\n## left join so that we only have the rows already existing in counts\n## drop the date variable from temp_data (otherwise is duplicated)\ncounts <- left_join(counts, \n                    select(temp_data, -date),\n                    by = \"epiweek\")"},{"path":"time-series.html","id":"phân-tích-mô-tả-1","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Phân tích mô tả","text":"Đầu tiên hãy trực quan hóa dữ liệu của bạn để kiểm tra xem có bất kỳ mối tương quan rõ ràng nào không. Biểu đồ dưới đây cho thấy một mối quan hệ rõ ràng về tính mùa vụ của các biến, và nhiệt độ có thể đạt đỉnh vài tuần trước khi các trường hợp xảy ra. Để biết thêm về xoay trục dữ liệu, xem chương Xoay trục dữ liệu.","code":"\ncounts %>% \n  ## keep the variables we are interested \n  select(epiweek, case_int, t2m) %>% \n  ## change your data in to long format\n  pivot_longer(\n    ## use epiweek as your key\n    !epiweek,\n    ## move column names to the new \"measure\" column\n    names_to = \"measure\", \n    ## move cell values to the new \"values\" column\n    values_to = \"value\") %>% \n  ## create a plot with the dataset above\n  ## plot epiweek on the x axis and values (counts/celsius) on the y \n  ggplot(aes(x = epiweek, y = value)) + \n    ## create a separate plot for temperate and case counts \n    ## let them set their own y-axes\n    facet_grid(measure ~ ., scales = \"free_y\") +\n    ## plot both as a line\n    geom_line()"},{"path":"time-series.html","id":"lags-và-tương-quan-chéo","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Lags và tương quan chéo","text":"Để kiểm định xem những tuần nào có tương quan nhiều nhất tới các trường hợp và nhiệt độ, bạn có thể sử dụng hàm tương quan chéo (CCF()) từ package feasts. Bạn cũng có thể trực quan hóa (hơn là sử dụng arrange) sử dụng hàm autoplot().Chúng ta thấy rằng độ trễ 4 tuần có mối tương quan cao nhất, vì vậy chúng ta tạo một biến nhiệt độ trễ để đưa vào mô hình hồi quy.NGUY HIỂM: Lưu ý rằng bốn tuần đầu tiên dữ liệu của chúng ta trong biến nhiệt độ trễ bị thiếu (NA) - bởi vì không có bốn tuần trước đó để lấy dữ liệu. Để sử dụng bộ dữ liệu này với hàm trending predict(), chúng ta cần phải sử dụng đối số simulate_pi = FALSE bên trong hàm predict(). Nếu chúng ta muốn sử dụng tùy chọn mô phỏng, thì chúng ta phải loại bỏ các giá trị missings và lưu thành một bộ dữ liệu mới bằng cách thêm hàm drop_na(t2m_lag4) vào đoạn code dưới đây.","code":"\ncounts %>% \n  ## calculate cross-correlation between interpolated counts and temperature\n  CCF(case_int, t2m,\n      ## set the maximum lag to be 52 weeks\n      lag_max = 52, \n      ## return the correlation coefficient \n      type = \"correlation\") %>% \n  ## arange in decending order of the correlation coefficient \n  ## show the most associated lags\n  arrange(-ccf) %>% \n  ## only show the top ten \n  slice_head(n = 10)## # A tsibble: 10 x 2 [1W]\n##      lag   ccf\n##    <lag> <dbl>\n##  1    4W 0.749\n##  2    5W 0.745\n##  3    3W 0.735\n##  4    6W 0.729\n##  5    2W 0.727\n##  6    7W 0.704\n##  7    1W 0.695\n##  8    8W 0.671\n##  9    0W 0.649\n## 10  -47W 0.638\ncounts <- counts %>% \n  ## create a new variable for temperature lagged by four weeks\n  mutate(t2m_lag4 = lag(t2m, n = 4))"},{"path":"time-series.html","id":"hồi-quy-nhị-thức-âm-với-hai-biến-số","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Hồi quy nhị thức âm với hai biến số","text":"Chúng ta sẽ fit một mô hình hồi quy nhị thức âm như đã thực hiện trước đó. Lần này chúng ta thêm biến nhiệt độ có độ trễ là bốn tuần.CẨN TRỌNG: Lưu ý cách sử dụng của đối số simulate_pi = FALSE bên trong hàm predict(). Điều này là bởi hành vi mặc định của trending là sử dụng package ciTools để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị NA, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem ?trending::predict.trending_model_fit để biết thêm chi tiết. Để khảo sát các chu kỳ đơn lẻ, chúng ta có thể lấy mô hình hồi quy nhị thức âm gốc ra khỏi định dạng trending bằng cách sử dụng hàm get_model() và chuyển nó tới hàm tidy() của package broom để truy xuất các ước tính được lũy thừa hóa và các khoảng tin cậy.Điều này cho chúng ta thấy là nhiệt độ trễ, sau khi kiểm soát xu hướng và tính theo mùa, tương tự như số lượng trường hợp (ước tính ~ 1) và sự liên quan có ý nghĩa. Điều này cho thấy rằng nó có thể là một biến số tốt để sử dụng trong việc dự báo các ca bệnh trong tương lai (các dữ liệu dự báo khí hậu luôn có sẵn).Đánh giá nhanh mô hình cho thấy nó có thể thực hiện tốt hơn công việc ước tính số ca bệnh quan sát được.","code":"\n## define the model you want to fit (negative binomial) \nmodel <- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the fourier terms to account for seasonality\n    fourier + \n    ## use the temperature lagged by four weeks \n    t2m_lag4\n    )\n\n## fit your model using the counts dataset\nfitted_model <- trending::fit(model, counts)\n\n## calculate confidence intervals and prediction intervals \nobserved <- predict(fitted_model, simulate_pi = FALSE)\nfitted_model %>% \n  ## extract original negative binomial regression\n  get_model() %>% \n  ## get a tidy dataframe of results\n  tidy(exponentiate = TRUE, \n       conf.int = TRUE)## # A tibble: 5 x 7\n##   term           estimate  std.error statistic  p.value   conf.low  conf.high\n##   <chr>             <dbl>      <dbl>     <dbl>    <dbl>      <dbl>      <dbl>\n## 1 (Intercept)   5.83      0.108          53.8  0         5.61       6.04     \n## 2 epiweek       0.0000846 0.00000774     10.9  8.13e-28  0.0000695  0.0000998\n## 3 fourierS1-52 -0.285     0.0214        -13.3  1.84e-40 -0.327     -0.243    \n## 4 fourierC1-52 -0.195     0.0200         -9.78 1.35e-22 -0.234     -0.157    \n## 5 t2m_lag4      0.00667   0.00269         2.48 1.30e- 2  0.00139    0.0119\n## plot your regression \nggplot(data = observed, aes(x = epiweek)) + \n  ## add in a line for the model estimate\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## add in a band for the prediction intervals \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## add in a line for your observed case counts\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()"},{"path":"time-series.html","id":"phần-dư-1","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Phần dư","text":"Chúng ta một lần nữa lại khảo sát phần dư để xem mô hình của chúng ta phù hợp với dữ liệu quan sát như thế nào. Các kết quả và phiên giải ở đây tương tự như kết quả của hồi quy trước đó, vì vậy sẽ khả thi hơn khi chọn mô hình đơn giản hơn mà không có nhiệt độ.","code":"\n## calculate the residuals \nobserved <- observed %>% \n  mutate(resid = case_int - estimate)\n\n## are the residuals fairly constant over time (if not: outbreaks? change in practice?)\nobserved %>%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")## Warning: Removed 4 row(s) containing missing values (geom_path).## Warning: Removed 4 rows containing missing values (geom_point).\n## is there autocorelation in the residuals (is there a pattern to the error?)  \nobserved %>% \n  as_tsibble(index = epiweek) %>% \n  ACF(resid, lag_max = 52) %>% \n  autoplot()\n## are residuals normally distributed (are under or over estimating?)  \nobserved %>%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") ## Warning: Removed 4 rows containing non-finite values (stat_bin).\n## compare observed counts to their residuals \n  ## should also be no pattern \nobserved %>%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")## Warning: Removed 4 rows containing missing values (geom_point).\n## formally test autocorrelation of the residuals\n## H0 is that residuals are from a white-noise series (i.e. random)\n## test for independence \n## if p value significant then non-random\nBox.test(observed$resid, type = \"Ljung-Box\")## \n##  Box-Ljung test\n## \n## data:  observed$resid\n## X-squared = 339.52, df = 1, p-value < 2.2e-16"},{"path":"time-series.html","id":"phát-hiện-ổ-dịch","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23.7 Phát hiện ổ dịch","text":"Chúng tôi sẽ trình bày hai phương pháp (tương tự) để phát hiện các ổ dịch ở đây. Cách đầu tiên được xây dựng dựa vào phần bên trên. Chúng ta sử dụng package trending để fit các mô hình hồi quy cho các năm trước đó, sau đó dự báo cho các năm tiếp theo. Nếu số lượng quan sát được cao hơn những gì chúng tôi dự báo, thì khả năng là đã có một đợt bùng phát. Phương pháp thứ hai dựa trên nguyên tắc tương tự nhưng sử dụng package surveillance, cung cấp nhiều thuật toán khác nhau để phát hiện các thay đổi bất thường.CẨN TRỌNG: Thông thường, bạn quan tâm đến năm hiện tại (bạn chỉ biết số ca bệnh đến tuần hiện tại). Vì vậy, trong ví dụ này, chúng tôi đang giả định là tuần 39 của năm 2011.","code":""},{"path":"time-series.html","id":"package-trending","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Package trending","text":"Đối với phương pháp này, chúng ta xác định một mốc (baseline) (thường là khoảng 5 năm dữ liệu). Chúng ta fit một mô hình hồi quy tới dữ liệu baseline, và sau đó sử dụng nó để ước tính cho năm sau.","code":""},{"path":"time-series.html","id":"điểm-cắt-ngày","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Điểm cắt ngày","text":"Sẽ dễ dàng hơn khi xác định ngày của bạn ở một nơi và sau đó sử dụng những ngày này trong suốt phần còn lại trong của bạn.Ở đây chúng ta xác định ngày bắt đầu (khi các quan sát của chúng ta bắt đầu) và ngày làm điểm cắt (cut-date) (kết thúc giai đoạn baseline - và giai đoạn chúng ta muốn dự đoán cho sự bắt đầu). ~Chúng ta cũng xác định có bao nhiêu tuần trong năm mà chúng tôi sẽ dự đoán)~. Chúng ta cũng xác định có bao nhiêu tuần mà chúng ta đang muốn dự báo nằm giữa điểm cắt baseline và ngày kết thúc.LƯU Ý: Trong ví dụ này, chúng tôi giả sử hiện đang ở cuối tháng 9 năm 2011 (“2011 W39”).","code":"\n## define start date (when observations began)\nstart_date <- min(counts$epiweek)\n\n## define a cut-off week (end of baseline, start of prediction period)\ncut_off <- yearweek(\"2010-12-31\")\n\n## define the last date interested in (i.e. end of prediction)\nend_date <- yearweek(\"2011-12-31\")\n\n## find how many weeks in period (year) of interest\nnum_weeks <- as.numeric(end_date - cut_off)"},{"path":"time-series.html","id":"thêm-hàng-1","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Thêm hàng","text":"Để có thể dự báo ở định dạng tidyverse, chúng ta cần có số hàng phù hợp trong tập dữ liệu của mình, tức là một hàng cho mỗi tuần cho tới ngày kết thúc end_date đã được xác định bên trên. Đoạn mã bên dưới cho phép bạn thêm các hàng này theo một biến nhóm - ví dụ: nếu chúng ta có nhiều quốc gia trong một tập dữ liệu, chúng ta có thể nhóm theo quốc gia và sau đó thêm các hàng một cách thích hợp cho từng quốc gia. Hàm group_by_key() trong package tsibble cho phép chúng ta thực hiện điều này và sau đó chuyển dữ liệu đã nhóm tới các hàm dplyr như group_modify() và add_row(). Sau đó, chúng ta cụ thể trình tự các tuần giữa một tuần sau tuần tối đa hiện có trong dữ liệu và tuần kết thúc.","code":"\n## add in missing weeks till end of year \ncounts <- counts %>%\n  ## group by the region\n  group_by_key() %>%\n  ## for each group add rows from the highest epiweek to the end of year\n  group_modify(~add_row(.,\n                        epiweek = seq(max(.$epiweek) + 1, \n                                      end_date,\n                                      by = 1)))"},{"path":"time-series.html","id":"chu-kỳ-fourier-1","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Chu kỳ Fourier","text":"Chúng ta phải định nghĩa lại chu kỳ Fourier - bởi vì chúng ta chỉ muốn fit chúng tới ngày baseline và sau đó dự báo (ngoại suy) các chu kỳ này cho năm sau. Để làm điều này, chúng ta cần kết hợp hai danh sách đầu ra từ hàm fourier() lại với nhau; cái đầu tiên dành cho dữ liệu baseline, và cái thứ hai dự đoán cho năm quan tâm (bằng cách xác định đối số h).Lưu ý để nối dòng chúng ta phải sử dụng hàm rbind() (thay vì hàm tidyverse bind_rows) bởi vì các cột fourier ở định dạng danh sách (vì vậy không được đặt tên riêng lẻ).","code":"\n## define fourier terms (sincos) \ncounts <- counts %>% \n  mutate(\n    ## combine fourier terms for weeks prior to  and after 2010 cut-off date\n    ## (nb. 2011 fourier terms are predicted)\n    fourier = rbind(\n      ## get fourier terms for previous years\n      fourier(\n        ## only keep the rows before 2011\n        filter(counts, \n               epiweek <= cut_off), \n        ## include one set of sin cos terms \n        K = 1\n        ), \n      ## predict the fourier terms for 2011 (using baseline data)\n      fourier(\n        ## only keep the rows before 2011\n        filter(counts, \n               epiweek <= cut_off),\n        ## include one set of sin cos terms \n        K = 1, \n        ## predict 52 weeks ahead\n        h = num_weeks\n        )\n      )\n    )"},{"path":"time-series.html","id":"chia-dữ-liệu-và-fit-mô-hình-hồi-quy","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Chia dữ liệu và fit mô hình hồi quy","text":"Chúng ta bây giờ cần phải chia dữ liệu của mình thành 2 giai đoạn: giai đoạn baseline và giai đoạn dự báo. Nó có thể thực hiện được với hàm dplyr group_split() sau khi nhóm bởi group_by(), và sẽ tạo ra một danh sách gồm hai data frame, một trước thời điểm cut-và một cái ở thời điểm sau cut-.Chúng ta sau đó sử dụng hàm pluck() từ package purrr để kéo tập dữ liệu ra khỏi danh sách (tương đương với việc sử dụng ngoặc vuông, vd: dat[[1]]), và sau đó có thể fit mô hình của chúng ta tới dữ liệu nền,và sau đó sử dụng hàm predict() cho dữ liệu mà chúng ta quan tâm sau cut-.Xem chương Lặp, vòng lặp, và danh sách để biết thêm về purrr.CẨN TRỌNG: Lưu ý cách sử dụng của đối số simulate_pi = FALSE bên trong hàm predict(). Điều này là bởi hành vi mặc định của trending là sử dụng package ciTools để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị NA, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem ?trending::predict.trending_model_fit để biết thêm chi tiết. Như bên trên, chúng ta có thể trực quan hóa mô hình với ggplot. Chúng ta đánh dấu các cảnh báo bằng các chấm màu đỏ cho các trường hợp quan sát được phía trên 95% khoảng dự đoán. Lần này, chúng ta cũng thêm một đường dọc để dán nhãn khi dự báo bắt đầu.","code":"\n# split data for fitting and prediction\ndat <- counts %>% \n  group_by(epiweek <= cut_off) %>%\n  group_split()\n\n## define the model you want to fit (negative binomial) \nmodel <- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the furier terms to account for seasonality\n    fourier\n)\n\n# define which data to use for fitting and which for predicting\nfitting_data <- pluck(dat, 2)\npred_data <- pluck(dat, 1) %>% \n  select(case_int, epiweek, fourier)\n\n# fit model \nfitted_model <- trending::fit(model, fitting_data)\n\n# get confint and estimates for fitted data\nobserved <- fitted_model %>% \n  predict(simulate_pi = FALSE)\n\n# forecast with data want to predict with \nforecasts <- fitted_model %>% \n  predict(pred_data, simulate_pi = FALSE)\n\n## combine baseline and predicted datasets\nobserved <- bind_rows(observed, forecasts)\n## plot your regression \nggplot(data = observed, aes(x = epiweek)) + \n  ## add in a line for the model estimate\n  geom_line(aes(y = estimate),\n            col = \"grey\") + \n  ## add in a band for the prediction intervals \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## add in a line for your observed case counts\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## plot in points for the observed counts above expected\n  geom_point(\n    data = filter(observed, case_int > upper_pi), \n    aes(y = case_int), \n    colour = \"red\", \n    size = 2) + \n  ## add vertical line and label to show where forecasting started\n  geom_vline(\n           xintercept = as.Date(cut_off), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Forecast\", \n           x = cut_off, \n           y = max(observed$upper_pi) - 250, \n           angle = 90, \n           vjust = 1\n           ) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()## Warning: Removed 13 row(s) containing missing values (geom_path)."},{"path":"time-series.html","id":"đánh-giá-dự-báo","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Đánh giá dự báo","text":"Ngoài việc kiểm tra các phần dư, cũng quan trọng khi đánh giá xem mô hình của bạn tốt như thế nào trong việc dự đoán các trường hợp trong tương lai. Điều này cung cấp cho bạn ý tưởng về mức độ đáng tin cậy của các ngưỡng cảnh báo của bạn.Cách kiểm định truyền thống là xem bạn có thể dự đoán năm gần nhất trước năm hiện tại tốt như thế nào (bởi vì bạn chưa biết số lượng cho “năm hiện tại”). Ví dụ: trong tập dữ liệu của chúng ta, chúng ta sẽ sử dụng dữ liệu từ năm 2002 đến năm 2009 để dự đoán năm 2010 và sau đó xem mức độ chính xác của những dự đoán đó. Sau đó, fit lại mô hình có bao gồm dữ liệu năm 2010 và sử dụng dữ liệu đó để dự đoán cho năm 2011.Bạn có thể xem ảnh minh họa bên dưới bởi Hyndman và cộng sự trong cuốn “Các nguyên tắc dự báo và thực hành”.hình sử dụng lại với sự cho phép của các tác giảNhược điểm của cách này là bạn không sử dụng tất cả dữ liệu có sẵn và nó không phải là mô hình cuối cùng mà bạn đang sử dụng để dự đoán.Một giải pháp thay thế là sử dụng một phương pháp được gọi là xác thực chéo (cross-validation). Trong trường hợp này, bạn cuộn qua tất cả dữ liệu có sẵn để fit nhiều mô hình để dự đoán một năm tới. Bạn sẽ sử dụng nhiều dữ liệu hơn trong các mô hình, như được trình bày dưới đây từ cùng cuốn sách của Hyndman và cộng sự. Ví dụ, mô hình đầu tiên sử dụng 2002 để dự đoán năm 2003, mô hình thứ hai sử dụng 2002 và 2003 để dự đoán năm 2004, v.v.hình sử dụng lại với sự cho phép của các tác giảDưới đây chúng ta sử dụng hàm map() từ package purrr để chạy vòng lặp trên từng tập dữ liệu. Sau đó, chúng ta đặt các ước tính vào một tập dữ liệu và hợp nhất với số lượng trường hợp ban đầu để sử dụng package yardstick để tính toán các đo lường về độ chính xác. Chúng ta sẽ tính toán bốn giá trị bao gồm: Root mean squared error (RMSE), Mean absolute error (MAE), Mean absolute scaled error (MASE), Mean absolute percent error (MAPE).CẨN TRỌNG: Lưu ý cách sử dụng của đối số simulate_pi = FALSE bên trong hàm predict(). Điều này là bởi hành vi mặc định của trending là sử dụng package ciTools để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị NA, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem ?trending::predict.trending_model_fit để biết thêm chi tiết. ","code":"\n## Cross validation: predicting week(s) ahead based on sliding window\n\n## expand your data by rolling over in 52 week windows (before + after) \n## to predict 52 week ahead\n## (creates longer and longer chains of observations - keeps older data)\n\n## define window want to roll over\nroll_window <- 52\n\n## define weeks ahead want to predict \nweeks_ahead <- 52\n\n## create a data set of repeating, increasingly long data\n## label each data set with a unique id\n## only use cases before year of interest (i.e. 2011)\ncase_roll <- counts %>% \n  filter(epiweek < cut_off) %>% \n  ## only keep the week and case counts variables\n  select(epiweek, case_int) %>% \n    ## drop the last x observations \n    ## depending on how many weeks ahead forecasting \n    ## (otherwise will be an actual forecast to \"unknown\")\n    slice(1:(n() - weeks_ahead)) %>%\n    as_tsibble(index = epiweek) %>% \n    ## roll over each week in x after windows to create grouping ID \n    ## depending on what rolling window specify\n    stretch_tsibble(.init = roll_window, .step = 1) %>% \n  ## drop the first couple - as have no \"before\" cases\n  filter(.id > roll_window)\n\n\n## for each of the unique data sets run the code below\nforecasts <- purrr::map(unique(case_roll$.id), \n                        function(i) {\n  \n  ## only keep the current fold being fit \n  mini_data <- filter(case_roll, .id == i) %>% \n    as_tibble()\n  \n  ## create an empty data set for forecasting on \n  forecast_data <- tibble(\n    epiweek = seq(max(mini_data$epiweek) + 1,\n                  max(mini_data$epiweek) + weeks_ahead,\n                  by = 1),\n    case_int = rep.int(NA, weeks_ahead),\n    .id = rep.int(i, weeks_ahead)\n  )\n  \n  ## add the forecast data to the original \n  mini_data <- bind_rows(mini_data, forecast_data)\n  \n  ## define the cut off based on latest non missing count data \n  cv_cut_off <- mini_data %>% \n    ## only keep non-missing rows\n    drop_na(case_int) %>% \n    ## get the latest week\n    summarise(max(epiweek)) %>% \n    ## extract so is not in a dataframe\n    pull()\n  \n  ## make mini_data back in to a tsibble\n  mini_data <- tsibble(mini_data, index = epiweek)\n  \n  ## define fourier terms (sincos) \n  mini_data <- mini_data %>% \n    mutate(\n    ## combine fourier terms for weeks prior to  and after cut-off date\n    fourier = rbind(\n      ## get fourier terms for previous years\n      forecast::fourier(\n        ## only keep the rows before cut-off\n        filter(mini_data, \n               epiweek <= cv_cut_off), \n        ## include one set of sin cos terms \n        K = 1\n        ), \n      ## predict the fourier terms for following year (using baseline data)\n      fourier(\n        ## only keep the rows before cut-off\n        filter(mini_data, \n               epiweek <= cv_cut_off),\n        ## include one set of sin cos terms \n        K = 1, \n        ## predict 52 weeks ahead\n        h = weeks_ahead\n        )\n      )\n    )\n  \n  \n  # split data for fitting and prediction\n  dat <- mini_data %>% \n    group_by(epiweek <= cv_cut_off) %>%\n    group_split()\n\n  ## define the model you want to fit (negative binomial) \n  model <- glm_nb_model(\n    ## set number of cases as outcome of interest\n    case_int ~\n      ## use epiweek to account for the trend\n      epiweek +\n      ## use the furier terms to account for seasonality\n      fourier\n  )\n\n  # define which data to use for fitting and which for predicting\n  fitting_data <- pluck(dat, 2)\n  pred_data <- pluck(dat, 1)\n  \n  # fit model \n  fitted_model <- trending::fit(model, fitting_data)\n  \n  # forecast with data want to predict with \n  forecasts <- fitted_model %>% \n    predict(pred_data, simulate_pi = FALSE) %>% \n    ## only keep the week and the forecast estimate\n    select(epiweek, estimate)\n    \n  }\n  )\n\n## make the list in to a data frame with all the forecasts\nforecasts <- bind_rows(forecasts)\n\n## join the forecasts with the observed\nforecasts <- left_join(forecasts, \n                       select(counts, epiweek, case_int),\n                       by = \"epiweek\")\n\n## using {yardstick} compute metrics\n  ## RMSE: Root mean squared error\n  ## MAE:  Mean absolute error  \n  ## MASE: Mean absolute scaled error\n  ## MAPE: Mean absolute percent error\nmodel_metrics <- bind_rows(\n  ## in your forcasted dataset compare the observed to the predicted\n  rmse(forecasts, case_int, estimate), \n  mae( forecasts, case_int, estimate),\n  mase(forecasts, case_int, estimate),\n  mape(forecasts, case_int, estimate),\n  ) %>% \n  ## only keep the metric type and its output\n  select(Metric  = .metric, \n         Measure = .estimate) %>% \n  ## make in to wide format so can bind rows after\n  pivot_wider(names_from = Metric, values_from = Measure)\n\n## return model metrics \nmodel_metrics## # A tibble: 1 x 4\n##    rmse   mae  mase  mape\n##   <dbl> <dbl> <dbl> <dbl>\n## 1  252.  199.  1.96  17.3"},{"path":"time-series.html","id":"package-surveillance","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"package surveillance","text":"Trong phần này chúng ta sẽ sử dụng package surveillance để tạo các ngưỡng cảnh báo dựa trên thuật toán phát hiện ổ dịch. Có một số phương pháp khác có sẵn trong package, tuy nhiên chúng ta sẽ tập trung vào hai tùy chọn ở đây. Để biết chi tiết, xem các bài báo sau về sự ứng dụng và lý thuyết về các thuật toán được sử dụng.Lựa chọn đầu tiên là sử dụng phương pháp Farrington cải tiến. Nó fit một mô hình nhị thức âm tổng quát (bao gồm xu hướng) và -weights các đợt bùng phát trong quá khứ (giá trị ngoại lai) để tạo một mức ngưỡng.Lựa chọn thứ hai là dùng phương pháp glrnb. Nó cũng fit một mô hình nhị thức âm tổng quát nhưng bao gồm cả xu hướng và chu kỳ fourier (vì vậy được ưu ái ở đây). Mô hình hồi quy được sử dụng để tính toán “control mean” (~fitted values) - nó sau đó sử dụng một phép thống kê tính toán likelihood ratio statistic tổng quát hóa để đánh giá nếu có sự thay đổi trung bình cho mỗi tuần. Lưu ý rằng ngưỡng cho mỗi tuần sẽ tính đến các tuần trước, vì vậy nếu có sự thay đổi liên tục, một cảnh báo sẽ được kích hoạt. (Cũng lưu ý rằng sau mỗi lần cảnh báo, thuật toán sẽ được đặt lại)Để làm việc được với package surveillance, trước tiên chúng ta cần xác định đối tượng “chuỗi thời gian giám sát” (sử dụng hàm sts()) để fit vào bên trong framework.","code":"\n## define surveillance time series object\n## nb. you can include a denominator with the population object (see ?sts)\ncounts_sts <- sts(observed = counts$case_int[!is.na(counts$case_int)],\n                  start = c(\n                    ## subset to only keep the year from start_date \n                    as.numeric(str_sub(start_date, 1, 4)), \n                    ## subset to only keep the week from start_date\n                    as.numeric(str_sub(start_date, 7, 8))), \n                  ## define the type of data (in this case weekly)\n                  freq = 52)\n\n## define the week range that you want to include (ie. prediction period)\n## nb. the sts object only counts observations without assigning a week or \n## year identifier to them - so we use our data to define the appropriate observations\nweekrange <- cut_off - start_date"},{"path":"time-series.html","id":"phương-pháp-farrington","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Phương pháp Farrington","text":"Sau đó chúng ta xác định từng tham số cho phương pháp Farrington trong một danh sách list. Sau đó, chúng ta chạy thuật toán bằng cách sử dụng hàm farringtonFlexible() và sau đó chúng ta có thể trích xuất ngưỡng cảnh báo bằng hàm farringtonmethod@upperbound để thêm vào tệp dữ liệu của chúng ta. Bạn cũng có thể trích xuất giá trị TRUE/FALSE cho từng tuần nếu nó kích hoạt một cảnh báo (cao hơn ngưỡng) bằng cách sử dụng farringtonmethod@alarm.Sau đó, chúng ta có thể trực quan hóa kết quả với ggplot như đã thực hiện ở trên.","code":"\n## define control\nctrl <- list(\n  ## define what time period that want threshold for (i.e. 2011)\n  range = which(counts_sts@epoch > weekrange),\n  b = 9, ## how many years backwards for baseline\n  w = 2, ## rolling window size in weeks\n  weightsThreshold = 2.58, ## reweighting past outbreaks (improved noufaily method - original suggests 1)\n  ## pastWeeksNotIncluded = 3, ## use all weeks available (noufaily suggests drop 26)\n  trend = TRUE,\n  pThresholdTrend = 1, ## 0.05 normally, however 1 is advised in the improved method (i.e. always keep)\n  thresholdMethod = \"nbPlugin\",\n  populationOffset = TRUE\n  )\n\n## apply farrington flexible method\nfarringtonmethod <- farringtonFlexible(counts_sts, ctrl)\n\n## create a new variable in the original dataset called threshold\n## containing the upper bound from farrington \n## nb. this is only for the weeks in 2011 (so need to subset rows)\ncounts[which(counts$epiweek >= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold\"] <- farringtonmethod@upperbound\nggplot(counts, aes(x = epiweek)) + \n  ## add in observed case counts as a line\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## add in upper bound of aberration algorithm\n  geom_line(aes(y = threshold, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## define colours\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic() + \n  ## remove title of legend \n  theme(legend.title = element_blank())"},{"path":"time-series.html","id":"phương-pháp-glrnb","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"Phương pháp GLRNB","text":"Tương tự với phương pháp GLRNB, chúng ta xác định từng tham số vào một danh sách list, sau đó fit thuật toán và trích xuất các giới hạn trên.CẨN TRỌNG: Phương pháp này sử dụng “brute force” (tương tự như bootstrapping) để tính toán các ngưỡng, vì vậy có thể mất nhiều thời gian!Xem GLRNB vignette để biết thêm chi tiết.Trực quan hóa kết quả đầu ra như bên trên.","code":"\n## define control options\nctrl <- list(\n  ## define what time period that want threshold for (i.e. 2011)\n  range = which(counts_sts@epoch > weekrange),\n  mu0 = list(S = 1,    ## number of fourier terms (harmonics) to include\n  trend = TRUE,   ## whether to include trend or not\n  refit = FALSE), ## whether to refit model after each alarm\n  ## cARL = threshold for GLR statistic (arbitrary)\n     ## 3 ~ middle ground for minimising false positives\n     ## 1 fits to the 99%PI of glm.nb - with changes after peaks (threshold lowered for alert)\n   c.ARL = 2,\n   # theta = log(1.5), ## equates to a 50% increase in cases in an outbreak\n   ret = \"cases\"     ## return threshold upperbound as case counts\n  )\n\n## apply the glrnb method\nglrnbmethod <- glrnb(counts_sts, control = ctrl, verbose = FALSE)\n\n## create a new variable in the original dataset called threshold\n## containing the upper bound from glrnb \n## nb. this is only for the weeks in 2011 (so need to subset rows)\ncounts[which(counts$epiweek >= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold_glrnb\"] <- glrnbmethod@upperbound\nggplot(counts, aes(x = epiweek)) + \n  ## add in observed case counts as a line\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## add in upper bound of aberration algorithm\n  geom_line(aes(y = threshold_glrnb, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## define colours\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic() + \n  ## remove title of legend \n  theme(legend.title = element_blank())"},{"path":"time-series.html","id":"chuỗi-thời-gian-bị-gián-đoạn","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23.8 Chuỗi thời gian bị gián đoạn","text":"Chuỗi thời gian bị gián đoạn (còn được gọi là hồi quy phân đoạn hoặc phân tích can thiệp), thường được sử dụng để đánh giá tác động của vắc-xin đối với tỷ lệ mắc mới của bệnh. Nhưng nó có thể được sử dụng để đánh giá tác động của một loạt các can thiệp hoặc sự giới thiệu. Ví dụ như những thay đổi trong quy trình của bệnh viện hoặc sự xuất hiện của chủng bệnh mới vào quần thể. Trong ví dụ này, chúng ta sẽ giả định rằng một chủng mới của Campylobacter đã xuất hiện ở Đức vào cuối năm 2008, và xem liệu điều đó có ảnh hưởng đến số lượng trường hợp. Chúng ta sẽ sử dụng hồi quy nhị thức âm một lần nữa. Sự hồi quy lần này sẽ được chia thành hai phần, một phần trước khi can thiệp (hoặc sự xuất hiện của chủng mới) và một phần sau (trước và sau giai đoạn). Điều này cho phép chúng ta tính toán tỷ số tỷ lệ mới mắc giữa hai khoảng thời gian. Giải thích phương trình có thể làm cho điều này rõ ràng hơn (nếu không thì chỉ cần bỏ qua!).Hồi quy nhị thức âm có thể được định nghĩa như sau:\\[\\log(Y_t)= β_0 + β_1 \\times t+ β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+ + log(pop_t) + e_t\\]Trong đó:\\(Y_t\\) là số trường hợp quan sát được tại thời điểm \\(t\\)\\(pop_t\\) nếu kích thước quần thể trong 100,000s tại thời điểm \\(t\\) (không sử dụng tại đây)\\(t_0\\) là năm cuối cùng của giai đoạn trước (bao gồm cả thời gian chuyển tiếp nếu có)\\(δ(x\\) là hàm chỉ báo (nó là 0 nếu x ≤ 0 và 1 nếu x > 0)\\((x)^+\\) là toán tử cut (nó là x nếu x > 0 và ngược lại sẽ bằng 0)\\(e_t\\) biểu thị phần dưCác chu kỳ bổ sung có xu hướng hoặc theo mùa có thể được thêm vào nếu cần thiết.\\(β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+\\) là một phần của mô hình tuyến tỉnh tổng quát hóa của giai đoạn sau và bằng không ở giai đoạn trước. Điều này có nghĩa là \\(β_2\\) và \\(β_3\\) ước tính các hiệu quả của can thiệp.Chúng ta cần tính toán lại chu kỳ Fourier mà không có dự báo ở đây, vì chúng ta sẽ sử dụng tất cả dữ liệu có sẵn (vd: hồi cứu). Ngoài ra, chúng ta cần tính toán các điều khoản bổ sung cần thiết cho hồi quy. thực tế là chúng ta cần tính chu kỳ mở rộng (extra terms) cho đường hồi quy.Chúng ta sau đó sử dụng các chi kỳ này để fit một mô hình hồi quy nhị thức âm, và tạo một bảng với phần trăm thay đổi. Những gì ví dụ này cho thấy là không có thay đổi đáng kể.CẨN TRỌNG: Lưu ý cách sử dụng của đối số simulate_pi = FALSE bên trong hàm predict(). Điều này là bởi hành vi mặc định của trending là sử dụng package ciTools để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị NA, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem ?trending::predict.trending_model_fit để biết thêm chi tiết. Như bên trên, chúng ta có thể trực quan hóa các đầu ra của mô hình hồi quy.","code":"\n## add in fourier terms using the epiweek and case_int variabless\ncounts$fourier <- select(counts, epiweek, case_int) %>% \n  as_tsibble(index = epiweek) %>% \n  fourier(K = 1)\n\n## define intervention week \nintervention_week <- yearweek(\"2008-12-31\")\n\n## define variables for regression \ncounts <- counts %>% \n  mutate(\n    ## corresponds to t in the formula\n      ## count of weeks (could probably also just use straight epiweeks var)\n    # linear = row_number(epiweek), \n    ## corresponds to delta(t-t0) in the formula\n      ## pre or post intervention period\n    intervention = as.numeric(epiweek >= intervention_week), \n    ## corresponds to (t-t0)^+ in the formula\n      ## count of weeks post intervention\n      ## (choose the larger number between 0 and whatever comes from calculation)\n    time_post = pmax(0, epiweek - intervention_week + 1))\n## define the model you want to fit (negative binomial) \nmodel <- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the furier terms to account for seasonality\n    fourier + \n    ## add in whether in the pre- or post-period \n    intervention + \n    ## add in the time post intervention \n    time_post\n    )\n\n## fit your model using the counts dataset\nfitted_model <- trending::fit(model, counts)\n\n## calculate confidence intervals and prediction intervals \nobserved <- predict(fitted_model, simulate_pi = FALSE)\n\n\n\n## show estimates and percentage change in a table\nfitted_model %>% \n  ## extract original negative binomial regression\n  get_model() %>% \n  ## get a tidy dataframe of results\n  tidy(exponentiate = TRUE, \n       conf.int = TRUE) %>% \n  ## only keep the intervention value \n  filter(term == \"intervention\") %>% \n  ## change the IRR to percentage change for estimate and CIs \n  mutate(\n    ## for each of the columns of interest - create a new column\n    across(\n      all_of(c(\"estimate\", \"conf.low\", \"conf.high\")), \n      ## apply the formula to calculate percentage change\n            .f = function(i) 100 * (i - 1), \n      ## add a suffix to new column names with \"_perc\"\n      .names = \"{.col}_perc\")\n    ) %>% \n  ## only keep (and rename) certain columns \n  select(\"IRR\" = estimate, \n         \"95%CI low\" = conf.low, \n         \"95%CI high\" = conf.high,\n         \"Percentage change\" = estimate_perc, \n         \"95%CI low (perc)\" = conf.low_perc, \n         \"95%CI high (perc)\" = conf.high_perc,\n         \"p-value\" = p.value)## # A tibble: 1 x 7\n##       IRR `95%CI low` `95%CI high` `Percentage change` `95%CI low (perc)` `95%CI high (perc)` `p-value`\n##     <dbl>       <dbl>        <dbl>               <dbl>              <dbl>               <dbl>     <dbl>\n## 1 -0.0661      -0.135      0.00305               -107.              -113.               -99.7    0.0645\nggplot(observed, aes(x = epiweek)) + \n  ## add in observed case counts as a line\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## add in a line for the model estimate\n  geom_line(aes(y = estimate, col = \"Estimate\")) + \n  ## add in a band for the prediction intervals \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## add vertical line and label to show where forecasting started\n  geom_vline(\n           xintercept = as.Date(intervention_week), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Intervention\", \n           x = intervention_week, \n           y = max(observed$upper_pi), \n           angle = 90, \n           vjust = 1\n           ) + \n  ## define colours\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Estimate\" = \"red\")) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()## Warning: Removed 13 row(s) containing missing values (geom_path)."},{"path":"time-series.html","id":"nguồn-tham-khảo-1","chapter":"23 Chuỗi thời gian và phát hiện ổ dịch","heading":"23.9 Nguồn tham khảo","text":"forecasting: principles practice textbookEPIET timeseries analysis case studiesPenn State course\nSurveillance package manuscript","code":""},{"path":"epidemic-models.html","id":"epidemic-models","chapter":"24 Mô hình hóa dịch bệnh","heading":"24 Mô hình hóa dịch bệnh","text":"","code":""},{"path":"epidemic-models.html","id":"tổng-quan-3","chapter":"24 Mô hình hóa dịch bệnh","heading":"24.1 Tổng quan","text":"Ngày càng có nhiều công cụ để tạo một mô hình dịch bệnh cho phép chúng ta tiến hành các phân tích khá phức tạp và tiết kiệm nguồn lực. Chương này sẽ cung cấp một cái nhìn tổng quan về cách sử dụng các công cụ để:ước tính hệ số lây nhiễm hiệu quả Rt và các thống kê liên quan chẳng hạn như thời gian tăng gấp đôiđưa ra các dự báo ngắn hạn về số mắc mới trong tương laiChương này không tổng quan về các phương pháp luận và phương pháp thống kê cơ bản của các công cụ này, vì vậy vui lòng tham khảo mục Tài liệu tham khảo để đọc các bài báo có đề cập tới. Hãy chắc chắn rằng bạn có kiến thức cơ bản về các phương pháp trước khi sử dụng các công cụ này; điều này sẽ đảm bảo bạn có thể giải thích chính xác các kết quả của chúng.Dưới đây là một ví dụ về những kết quả đầu ra mà chúng ta sẽ thực hiện trong chương này.","code":""},{"path":"epidemic-models.html","id":"chuẩn-bị-14","chapter":"24 Mô hình hóa dịch bệnh","heading":"24.2 Chuẩn bị","text":"Chúng ta sẽ sử dụng hai phương pháp và package khác nhau để ước tính Rt, cụ thể là package EpiNow và package EpiEstim, cũng như package projections cho dự báo các trường hợp mới mắc.Đoạn code này hiển thị tải các package cần thiết cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, để cài đặt package nếu cần thiết và gọi package để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem thêm chương R cơ bản để biết thêm thông tin về package R.Chúng ta sẽ sử dụng bộ dữ liệu các trường hợp linelist đã được làm sạch cho tất cả các phân tích trong chương này. Để tiện theo dõi,  bấm để tải xuống bộ dữ liệu linelist đã được “làm sạch”  (dưới dạng tệp .rds). Xem chương Tải sách và dữ liệu để tải xuống tất cả các dữ liệu minh họa được sử dụng trong sổ tay này.","code":"\npacman::p_load(\n   rio,          # File import\n   here,         # File locator\n   tidyverse,    # Data management + ggplot2 graphics\n   epicontacts,  # Analysing transmission networks\n   EpiNow2,      # Rt estimation\n   EpiEstim,     # Rt estimation\n   projections,  # Incidence projections\n   incidence2,   # Handling incidence data\n   epitrix,      # Useful epi functions\n   distcrete     # Discrete delay distributions\n)\n# import the cleaned linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"epidemic-models.html","id":"ước-tính-rt","chapter":"24 Mô hình hóa dịch bệnh","heading":"24.3 Ước tính Rt","text":"","code":""},{"path":"epidemic-models.html","id":"epinow2-và-epiestim","chapter":"24 Mô hình hóa dịch bệnh","heading":"EpiNow2 và EpiEstim","text":"Hệ số lây nhiễm R là thước đo khả năng lây truyền của một bệnh và được định nghĩa là số ca thứ phát kỳ vọng trên mỗi trường hợp nhiễm bệnh. Trong một quần thể cảm nhiễm toàn bộ, giá trị này đại diện cho hệ số lây nhiễm cơ bản R0. Tuy nhiên, vì số lượng các cá thể cảm nhiễm trong một quần thể thay đổi trong suốt vụ dịch hoặc đại dịch và khi các biện pháp ứng phó khác nhau được thực hiện, chỉ số đo lường khả năng lây truyền thường được sử dụng phổ biến nhất là hệ số lây nhiễm hiệu quả Rt; nó được định nghĩa là số trường hợp thứ cấp kỳ vọng trên mỗi trường hợp bị nhiễm tại một thời điểm t nhất định.Package EpiNow2 cung cấp một framework phức tạp nhất cho việc ước tính Rt. Package này có hai điểm mạnh chính với package thường dùng khác là EpiEstim như sau:Nó giải thích cho thời gian trì hoãn (delay) trong báo cáo và đó có thể ước tính Rt ngay cả khi dữ liệu không đầy đủ.Nó ước tính Rt dựa vào ngày nhiễm bệnh hơn là ngày khởi phát được báo cáo, có nghĩa là ảnh hưởng của một can thiệp sẽ được thể hiện ngay lập tức bởi sự thay đổi của Rt, thay vì có một sự trì hoãn.Tuy nhiên, nó cũng có hai nhược điểm chính:Nó yêu cầu kiến thức về phân phối thời gian phát sinh một thế hệ (generation time: tức là phân phối khoảng thời gian giữa ca nhiễm trùng sơ cấp và các ca thứ cấp), phân bố thời gian ủ bệnh (incubation period: tức là phân bố khoảng thời gian giữa nhiễm trùng và khởi phát triệu chứng) và bất kỳ phân phối khoảng thời gian nào khác có liên quan đến dữ liệu của bạn (ví dụ: nếu bạn có ngày báo cáo, bạn cần thông tin phân phối độ trễ từ khi bắt đầu có triệu chứng đến khi được báo cáo). Trong khi điều này sẽ cho phép ước tính Rt chính xác hơn thì package EpiEstim chỉ yêu cầu phân bố của khoảng thời gian liên tiếp (serial interval: khoảng thời gian từ lúc bệnh nhân ban đầu khởi phát triệu chứng đến lúc bệnh nhân thứ phát có triệu chứng khởi phát), mà đó có thể là phân phối duy nhất có sẵn cho bạn.Package EpiNow2 chậm hơn đáng kể với package EpiEstim theo một hệ số khoảng 100-1000 (tin đồn)! Ví dụ: ước tính Rt đối với đợt bùng phát được lấy ví dụ trong phần này mất khoảng bốn giờ (được chạy lặp lại một số lượng lớn lần để đảm bảo độ chính xác và tất nhiên có thể giảm nếu cần thiết, tuy nhiên nói chung là thuật toán chậm). Điều này có thể không khả thi nếu bạn thường xuyên phải cập nhật ước tính Rt.đó, package bạn chọn sử dụng sẽ phụ thuộc vào dữ liệu, thời gian và tài nguyên tính toán có sẵn cho bạn.###Package EpiNow2 {.unnumbered}","code":""},{"path":"epidemic-models.html","id":"ước-tính-phân-phối-thời-gian-trì-hoãn","chapter":"24 Mô hình hóa dịch bệnh","heading":"Ước tính phân phối thời gian trì hoãn","text":"Phân phối độ trễ yêu cầu chạy package EpiNow2 tùy thuộc vào dữ liệu bạn có. Về cơ bản, bạn cần có khả năng mô tả độ trễ từ ngày nhiễm bệnh đến ngày diễn ra sự kiện bạn muốn sử dụng để ước tính Rt. Nếu bạn đang sử dụng ngày bắt đầu, thì nó sẽ chỉ đơn giản là phân bố thời kỳ ủ bệnh. Nếu bạn đang sử dụng ngày báo cáo, bạn yêu cầu thời gian trì hoãn từ khi lây nhiễm đến khi báo cáo. Bởi vì phân phối này khó có thể được biết trực tiếp, package EpiNow2 cho phép bạn xâu chuỗi nhiều phân phối trì hoãn với nhau; trong trường hợp này, đó là thời gian trì hoãn từ khi nhiễm trùng đến khi khởi phát triệu chứng (ví dụ: thời kỳ ủ bệnh, thường có khả năng biết) và từ khi bắt đầu có triệu chứng đến khi báo cáo ca bệnh (mà bạn có thể thường xuyên ước tính từ dữ liệu).Vì chúng ta có ngày bắt đầu cho tất cả các trường hợp trong ví dụ của bộ dữ liệu linelist, chúng ta sẽ chỉ cần phân phối thời gian ủ bệnh để liên kết dữ liệu của chúng ta (ví dụ: ngày bắt đầu có triệu chứng) đến ngày nhiễm bệnh. Chúng ta có thể ước tính phân phối này từ dữ liệu hoặc sử dụng các giá trị từ y văn.Tài liệu về ước tính thời gian ủ bệnh của Ebola (trích dẫn từ bài báo này) với giá trị trung bình là 9.1, độ lệch chuẩn là 7.3 và giá trị lớn nhất là 30 sẽ được chỉ định như sau:Lưu ý rằng package EpiNow2 yêu cầu các phân phối thời gian trì hoãn này phải được cung cấp trên thang đo log bằng cách dùng lệnh gọi log xung quanh mỗi giá trị (ngoại trừ tham số max, hơi rắc rối, cung cấp theo thang đo tự nhiên). mean_sd và sd_sd xác định độ lệch chuẩn của ước tính giá trị trung bình và độ lệch chuẩn. Vì chúng không được biết trong trường hợp này, chúng tôi chọn giá trị khá tùy ý là 0.1.Trong phân tích này, thay vào đó, chúng ta ước tính phân phối thời gian ủ bệnh từ chính bộ dữ liệu linelist bằng cách sử dụng hàm bootstrapped_dist_fit, để fit một phân phối lognormal cho thời gian trì hoãn giữa nhiễm trùng và khởi phát quan sát được trong linelist.Phân phối khác mà chúng ta cần là thời gian phát sinh một thế hệ. Vì chúng ta có dữ liệu về thời gian nhiễm bệnh và đường lây truyền, chúng ta có thể ước tính phân phối này từ linelist bằng cách tính toán đỗ trễ giữa các lần lây nhiễm của các cặp người lây nhiễm-người bị lây nhiễm. Để làm điều này, chúng ta sử dụng hàm get_pairwise từ package epicontacts, cho phép chúng ta tính toán sự khác biệt từng cặp trường hợp lây nhiễm của linelist. Đầu tiên, chúng ta tạo một đối tượng epicontacts (xem chương Chuỗi lây nhiễm để biết thêm chi tiết):Sau đó, chúng ta fit một phân phối gamma cho sự khác biệt về thời gian nhiễm bệnh giữa các cặp lây nhiễm (được tính toán bằng cách sử dụng hàm get_pairwise)","code":"\nincubation_period_lit <- list(\n  mean = log(9.1),\n  mean_sd = log(0.1),\n  sd = log(7.3),\n  sd_sd = log(0.1),\n  max = 30\n)\n## estimate incubation period\nincubation_period <- bootstrapped_dist_fit(\n  linelist$date_onset - linelist$date_infection,\n  dist = \"lognormal\",\n  max_value = 100,\n  bootstraps = 1\n)\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## generate epicontacts object\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## estimate gamma generation time\ngeneration_time <- bootstrapped_dist_fit(\n  get_pairwise(epic, \"date_infection\"),\n  dist = \"gamma\",\n  max_value = 20,\n  bootstraps = 1\n)"},{"path":"epidemic-models.html","id":"chạy-epinow2","chapter":"24 Mô hình hóa dịch bệnh","heading":"Chạy EpiNow2","text":"Bây giờ chúng ta chỉ cần tính toán số mới mắc hàng ngày từ linelist mà có thể thực hiện dễ dàng với các hàm group_by() và n() từ package dplyr. Lưu ý rằng EpiNow2 yêu cầu tên cột phải là date và confirm.Sau đó, chúng ta có thể ước tính Rt bằng cách sử dụng hàm epinow. Một vài lưu ý về các dữ liệu đầu vào:Chúng ta có thể cung cấp một số lượng bất kỳ các ‘chuỗi’ phân phối thời gian trì hoãn tới đối số delays; chúng ta chỉ cần chèn chúng cùng với đối tượng incubation_period bên trong hàm delay_opts.return_output đảm bảo đầu ra được trả về trong R chứ không chỉ được lưu vào một tệp.verbose nếu chúng ta muốn đọc tiến trình.horizon để yêu cầu hiển thị số ngày chúng ta muốn tính số mới mắc trong tương laiChúng ta chuyển các tùy chọn bổ sung cho đối số stan để chỉ định cách chúng ta muốn chạy suy luận. Tăng số lượng mẫu samples và chuỗi chain sẽ cung cấp cho bạn một ước tính chính xác hơn với những phẩm chất tốt hơn cho sự không chắc chắn, tuy nhiên sẽ mất nhiều thời gian hơn để chạy.","code":"\n## get incidence from onset dates\ncases <- linelist %>%\n  group_by(date = date_onset) %>%\n  summarise(confirm = n())\n## run epinow\nepinow_res <- epinow(\n  reported_cases = cases,\n  generation_time = generation_time,\n  delays = delay_opts(incubation_period),\n  return_output = TRUE,\n  verbose = TRUE,\n  horizon = 21,\n  stan = stan_opts(samples = 750, chains = 4)\n)"},{"path":"epidemic-models.html","id":"phân-tích-kết-quả-đầu-ra","chapter":"24 Mô hình hóa dịch bệnh","heading":"Phân tích kết quả đầu ra","text":"Khi code đã chạy xong, chúng ta có thể vẽ biểu đồ tóm tắt rất dễ dàng như sau. Cuộn hình ảnh để xem toàn bộ.Chúng ta cũng có thể xem xét các thống kê tóm tắt khác nhau:Để có các phân tích sâu hơn và vẽ biểu đồ tùy chỉnh, bạn có thể truy cập vào phần ước tính hàng ngày tổng hợp thông qua $estimates$summarised. Chúng ta sẽ chuyển nó từ định dạng mặc định data.table thành định dạng tibble để dễ dàng sử dụng với package dplyr.Để ví dụ, chúng ta hãy vẽ một biểu đồ về thời gian nhân đôi và Rt. Chúng ta sẽ chỉ xem xét vài tháng đầu tiên của đợt bùng phát khi Rt chỉ cao hơn một, để tránh vẽ biểu đồ số lần nhân đôi quá cao.Chúng ta sử dụng công thức log(2)/growth_rate để tính thời gian nhân đôi từ tốc độ tăng trưởng ước tính.","code":"\n## plot summary figure\nplot(epinow_res)\n## summary table\nepinow_res$summary##                                  measure                  estimate  numeric_estimate\n## 1: New confirmed cases by infection date                4 (2 -- 6) <data.table[1x9]>\n## 2:        Expected change in daily cases                    Unsure              0.56\n## 3:            Effective reproduction no.        0.88 (0.73 -- 1.1) <data.table[1x9]>\n## 4:                        Rate of growth -0.012 (-0.028 -- 0.0052) <data.table[1x9]>\n## 5:          Doubling/halving time (days)          -60 (130 -- -25) <data.table[1x9]>\n## extract summary and convert to tibble\nestimates <- as_tibble(epinow_res$estimates$summarised)\nestimates\n## make wide df for median plotting\ndf_wide <- estimates %>%\n  filter(\n    variable %in% c(\"growth_rate\", \"R\"),\n    date < as.Date(\"2014-09-01\")\n  ) %>%\n  ## convert growth rates to doubling times\n  mutate(\n    across(\n      c(median, lower_90:upper_90),\n      ~ case_when(\n        variable == \"growth_rate\" ~ log(2)/.x,\n        TRUE ~ .x\n      )\n    ),\n    ## rename variable to reflect transformation\n    variable = replace(variable, variable == \"growth_rate\", \"doubling_time\")\n  )\n\n## make long df for quantile plotting\ndf_long <- df_wide %>%\n  ## here we match matching quantiles (e.g. lower_90 to upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## make plot\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  ## use label_parsed to allow subscript label\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(R = \"R[t]\", doubling_time = \"Doubling~time\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## manually define quantile transparency\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credibel\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )"},{"path":"epidemic-models.html","id":"epiestim","chapter":"24 Mô hình hóa dịch bệnh","heading":"EpiEstim","text":"Để chạy EpiEstim, chúng ta cần cung cấp dữ liệu về số trường hợp mới mắc hàng ngày và cụ thể khoảng thời gian nối tiếp (tức là phân bố thời gian trì hoãn khởi phát triệu chứng giữa các trường hợp sơ cấp và thứ cấp).Dữ liệu về con số mới mắc có thể được cung cấp cho EpiEstim dưới dạng một vectơ, một bảng số liệu, hoặc một đối tượng incidence nguyên bản từ package incidence. Bạn thậm chí có thể phân biệt giữa ca nhiễm bệnh từ nơi khác đến và tại địa phương; xem tài liệu hướng dẫn bằng cách gõ ?estimate_R để biết thêm chi tiết.Chúng ta sẽ tạo dữ liệu đầu vào bằng cách sử dụng package incidence2. Xem chương Đường cong dịch bệnh để xem thêm các ví dụ về package incidence2. có một số cập nhật của package incidence2 khiến nó không hoàn toàn phù hợp với đầu vào kỳ vọng của hàm estimateR(), bạn cần thực hiện một số bước bổ sung cần thiết. Đối tượng incidence bao gồm một tibble với thông tin về ngày tháng và số lượng trường hợp tương ứng. Chúng ta sử dụng hàm complete() từ package tidyr để đảm bảo tất cả các ngày đều được bao gồm (kể cả những ngày không có trường hợp), và sau đó dùng hàm rename() để đổi tên các cột để căn chỉnh sao cho phù hợp với hàm estimate_R() ở bước sau.Package này cung cấp một số tùy chọn để cụ thể khoảng thời gian nối tiếp, chi tiết được cung cấp trong tài liệu hướng dẫn bằng cách gõ ?estimate_R. Chúng tôi sẽ đề cập đến hai trong số chúng ở đây.","code":"\n## get incidence from onset date\ncases <- incidence2::incidence(linelist, date_index = date_onset) %>% # get case counts by day\n  tidyr::complete(date_index = seq.Date(                              # ensure all dates are represented\n    from = min(date_index, na.rm = T),\n    to = max(date_index, na.rm=T),\n    by = \"day\"),\n    fill = list(count = 0)) %>%                                       # convert NA counts to 0\n  rename(I = count,                                                   # rename to names expected by estimateR\n         dates = date_index)## 256 missing observations were removed."},{"path":"epidemic-models.html","id":"sử-dụng-ước-tính-khoảng-thời-gian-nối-tiếp-từ-y-văn","chapter":"24 Mô hình hóa dịch bệnh","heading":"Sử dụng ước tính khoảng thời gian nối tiếp từ y văn","text":"Sử dụng tùy chọn method = \"parametric_si\", chúng ta có thể chỉ định thủ công trung bình và độ lệch chuẩn của khoảng thời gian nối tiếp của đối tượng config được tạo bằng hàm make_config. Chúng ta sử dụng giá trị trung bình và độ lệch chuẩn tương ứng là 12.0 và 5.2, được xác định trong bài báo này:Sau đó, chúng ta có thể ước tính Rt bằng hàm estimate_R:và vẽ tóm tắt các kết quả đầu ra:","code":"\n## make config\nconfig_lit <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2\n)\nepiestim_res_lit <- estimate_R(\n  incid = cases,\n  method = \"parametric_si\",\n  config = config_lit\n)## Default config will estimate R on weekly sliding windows.\n##     To change this change the t_start and t_end arguments.\nplot(epiestim_res_lit)"},{"path":"epidemic-models.html","id":"sử-dụng-ước-tính-khoảng-thời-gian-nối-tiếp-từ-dữ-liệu","chapter":"24 Mô hình hóa dịch bệnh","heading":"Sử dụng ước tính khoảng thời gian nối tiếp từ dữ liệu","text":"Vì chúng ta có dữ liệu về ngày khởi phát triệu chứng và các liên kết lây truyền, chúng ta cũng có thể ước tính khoảng thời gian nối tiếp từ bộ số liệu linelist bằng cách tính toán độ trễ giữa ngày khởi phát của các cặp người truyền bệnh-người nhiễm bệnh. Như chúng ta đã làm trong mục EpiNow2, chúng ta sẽ sử dụng hàm get_pairwise từ package epicontacts, cho phép chúng ta tính toán theo từng cặp sự khác biệt giữa các cặp lây truyền trong bộ số liệu linelist. Chúng ta trước hết tạo một đối tượng epicontacts (xem chương Chuỗi lây nhiễm để biết thêm chi tiết):Sau đó, chúng ta fit một phân phối gamma cho sự khác biệt về ngày khởi phát giữa các cặp lây truyền (được tính toán bằng hàm get_pairwise). Chúng ta sử dụng hàm fit_disc_gamma từ package epitrix cho quy trình kết hợp này, vì chúng ta yêu cầu một phân phối rời rạc (discretised).Sau đó, chúng ta chuyển thông tin này đến đối tượng config, và chạy EpiEstim một lần nữa và vẽ biểu đồ kết quả:","code":"\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## generate epicontacts object\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## estimate gamma serial interval\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n## make config\nconfig_emp <- make_config(\n  mean_si = serial_interval$mu,\n  std_si = serial_interval$sd\n)\n\n## run epiestim\nepiestim_res_emp <- estimate_R(\n  incid = cases,\n  method = \"parametric_si\",\n  config = config_emp\n)## Default config will estimate R on weekly sliding windows.\n##     To change this change the t_start and t_end arguments.\n## plot outputs\nplot(epiestim_res_emp)"},{"path":"epidemic-models.html","id":"cụ-thể-thời-gian-bắt-đầu-ước-tính","chapter":"24 Mô hình hóa dịch bệnh","heading":"Cụ thể thời gian bắt đầu ước tính","text":"Các tùy chọn mặc định này sẽ cung cấp một ước tính theo tuần và có thể hoạt động như một cảnh báo rằng bạn đang ước tính Rt quá sớm trong đợt bùng phát để có một ước tính chính xác. Bạn có thể thay đổi điều này bằng cách đặt ngày bắt đầu ước tính muộn hơn như dưới đây. Thật không may, EpiEstim chỉ cung cấp một cách rất khó hiểu để cụ thể thời gian ước tính này, trong đó bạn phải cung cấp một vectơ số nguyên đề cập đến ngày bắt đầu và ngày kết thúc cho mỗi cửa sổ thời gian.Bây giờ chúng ta chạy lại EpiEstim và có thể thấy rằng các ước tính chỉ bắt đầu từ tháng 6:","code":"\n## define a vector of dates starting on June 1st\nstart_dates <- seq.Date(\n  as.Date(\"2014-06-01\"),\n  max(cases$dates) - 7,\n  by = 1\n) %>%\n  ## subtract the starting date to convert to numeric\n  `-`(min(cases$dates)) %>%\n  ## convert to integer\n  as.integer()\n\n## add six days for a one week sliding window\nend_dates <- start_dates + 6\n  \n## make config\nconfig_partial <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2,\n  t_start = start_dates,\n  t_end = end_dates\n)\n## run epiestim\nepiestim_res_partial <- estimate_R(\n  incid = cases,\n  method = \"parametric_si\",\n  config = config_partial\n)\n\n## plot outputs\nplot(epiestim_res_partial)"},{"path":"epidemic-models.html","id":"phân-tích-kết-quả-đầu-ra-1","chapter":"24 Mô hình hóa dịch bệnh","heading":"Phân tích kết quả đầu ra","text":"Các đầu ra chính có thể được truy cập thông qua $R. Ví dụ: chúng ta sẽ tạo một biểu đồ của Rt và một thước đo “khả năng truyền bệnh” được đưa ra bởi sản phẩm của Rt và số trường hợp được báo cáo vào ngày đó; điều này thể hiện số trường hợp dự kiến trong thế hệ lây nhiễm tiếp theo.","code":"\n## make wide dataframe for median\ndf_wide <- epiestim_res_lit$R %>%\n  rename_all(clean_labels) %>%\n  rename(\n    lower_95_r = quantile_0_025_r,\n    lower_90_r = quantile_0_05_r,\n    lower_50_r = quantile_0_25_r,\n    upper_50_r = quantile_0_75_r,\n    upper_90_r = quantile_0_95_r,\n    upper_95_r = quantile_0_975_r,\n    ) %>%\n  mutate(\n    ## extract the median date from t_start and t_end\n    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],\n    var = \"R[t]\"\n  ) %>%\n  ## merge in daily incidence data\n  left_join(cases, \"dates\") %>%\n  ## calculate risk across all r estimates\n  mutate(\n    across(\n      lower_95_r:upper_95_r,\n      ~ .x*I,\n      .names = \"{str_replace(.col, '_r', '_risk')}\"\n    )\n  ) %>%\n  ## seperate r estimates and risk estimates\n  pivot_longer(\n    contains(\"median\"),\n    names_to = c(\".value\", \"variable\"),\n    names_pattern = \"(.+)_(.+)\"\n  ) %>%\n  ## assign factor levels\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## make long dataframe from quantiles\ndf_long <- df_wide %>%\n  select(-variable, -median) %>%\n  ## seperate r/risk estimates and quantile levels\n  pivot_longer(\n    contains(c(\"lower\", \"upper\")),\n    names_to = c(\".value\", \"quantile\", \"variable\"),\n    names_pattern = \"(.+)_(.+)_(.+)\"\n  ) %>%\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## make plot\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = dates, y = median),\n    alpha = 0.2\n  ) +\n  ## use label_parsed to allow subscript label\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(r = \"R[t]\", risk = \"Transmission~potential\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## manually define quantile transparency\n  scale_alpha_manual(\n    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )"},{"path":"epidemic-models.html","id":"dự-đoán-số-trường-hợp-mắc-mới","chapter":"24 Mô hình hóa dịch bệnh","heading":"24.4 Dự đoán số trường hợp mắc mới","text":"","code":""},{"path":"epidemic-models.html","id":"epinow2","chapter":"24 Mô hình hóa dịch bệnh","heading":"EpiNow2","text":"Bên cạnh ước tính Rt, package EpiNow2 cũng hỗ trợ dự báo Rt và dự báo các số trường hợp bằng cách tích hợp với package EpiSoon. Tất cả những gì bạn cần làm là chỉ định đối số horizon trong hàm epinow của bạn, cho biết số ngày bạn muốn dự báo trong tương lai; xem phần EpiNow2 trong mục “Ước tính Rt” để biết chi tiết về cách thiết lập và chạy EpiNow2. Trong phần này, chúng ta sẽ chỉ vẽ các kết quả đầu ra từ phân tích đó, được lưu trữ trong đối tượng epinow_res.","code":"\n## define minimum date for plot\nmin_date <- as.Date(\"2015-03-01\")\n\n## extract summarised estimates\nestimates <-  as_tibble(epinow_res$estimates$summarised)\n\n## extract raw data on case incidence\nobservations <- as_tibble(epinow_res$estimates$observations) %>%\n  filter(date > min_date)\n\n## extract forecasted estimates of case numbers\ndf_wide <- estimates %>%\n  filter(\n    variable == \"reported_cases\",\n    type == \"forecast\",\n    date > min_date\n  )\n\n## convert to even longer format for quantile plotting\ndf_long <- df_wide %>%\n  ## here we match matching quantiles (e.g. lower_90 to upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## make plot\nggplot() +\n  geom_histogram(\n    data = observations,\n    aes(x = date, y = confirm),\n    stat = 'identity',\n    binwidth = 1\n  ) +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  geom_vline(xintercept = min(df_long$date), linetype = 2) +\n  ## manually define quantile transparency\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = \"Daily reported cases\",\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14)"},{"path":"epidemic-models.html","id":"dự-đoán","chapter":"24 Mô hình hóa dịch bệnh","heading":"Dự đoán","text":"Package projections RECON phát triển giúp bạn dễ dàng đưa ra dự báo số trường hợp mắc mới trong ngắn hạn, chỉ yêu cầu kiến thức về hệ số lây nhiễm hiệu quả Rt và khoảng thời gian nối tiếp. Ở đây chúng tôi sẽ trình bày cách sử dụng ước tính khoảng thời gian nối tiếp từ y văn và từ ước tính của riêng chúng ta từ dữ liệu linelist.","code":""},{"path":"epidemic-models.html","id":"sử-dụng-ước-tính-khoảng-thời-gian-nối-tiếp-từ-y-văn-1","chapter":"24 Mô hình hóa dịch bệnh","heading":"Sử dụng ước tính khoảng thời gian nối tiếp từ y văn","text":"projections yêu cầu một phân phối rời rạc của khoảng thời gian nối tiếp của class distcrete từ package distcrete. Chúng ta sẽ sử dụng phân phối gamma với giá trị trung bình là 12.0 và và độ lệch chuẩn là 5.2 được lấy từ bài báo này. Để chuyển đổi các giá trị này thành các tham số shape và scale cần thiết cho phân phối gamma, chúng ta sẽ sử dụng hàm gamma_mucv2shapescale từ package epitrix.Sau đây là một cách kiểm tra nhanh để đảm bảo rằng khoảng thời gian nối tiếp chính xác. Chúng ta truy cập mật độ của phân phối gamma mà chúng ta vừa xác định thông qua $d, tương đương với cách gọi dgamma:","code":"\n## get shape and scale parameters from the mean mu and the coefficient of\n## variation (e.g. the ratio of the standard deviation to the mean)\nshapescale <- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)\n\n## make distcrete object\nserial_interval_lit <- distcrete::distcrete(\n  name = \"gamma\",\n  interval = 1,\n  shape = shapescale$shape,\n  scale = shapescale$scale\n)\n## check to make sure the serial interval looks correct\nqplot(\n  x = 0:50, y = serial_interval_lit$d(0:50), geom = \"area\",\n  xlab = \"Serial interval\", ylab = \"Density\"\n)"},{"path":"epidemic-models.html","id":"sử-dụng-ước-tính-khoảng-thời-gian-nối-tiếp-từ-dữ-liệu-1","chapter":"24 Mô hình hóa dịch bệnh","heading":"Sử dụng ước tính khoảng thời gian nối tiếp từ dữ liệu","text":"Vì chúng ta có dữ liệu về ngày khởi phát triệu chứng và các liên kết lây truyền, chúng ta cũng có thể ước tính khoảng thời gian nối tiếp từ bộ số liệu linelist bằng cách tính toán độ trễ giữa ngày khởi phát của các cặp người truyền bệnh-người nhiễm bệnh. Như chúng ta đã làm trong mục EpiNow2, chúng ta sẽ sử dụng hàm get_pairwise từ package epicontacts, cho phép chúng ta tính toán theo từng cặp sự khác biệt giữa các cặp lây truyền trong bộ số liệu linelist. Chúng ta trước hết tạo một đối tượng epicontacts (xem chương Chuỗi lây nhiễm để biết thêm chi tiết):Sau đó, chúng ta fit một phân phối gamma cho sự khác biệt về ngày khởi phát giữa các cặp lây truyền (được tính toán bằng hàm get_pairwise). Chúng ta sử dụng hàm fit_disc_gamma từ package epitrix cho quy trình kết hợp này, vì chúng ta yêu cầu một phân phối rời rạc (discretised).","code":"\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## generate epicontacts object\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n## estimate gamma serial interval\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\n## inspect estimate\nserial_interval[c(\"mu\", \"sd\")]## $mu\n## [1] 11.51242\n## \n## $sd\n## [1] 7.700005"},{"path":"epidemic-models.html","id":"dự-đoán-số-trường-hợp-mắc-mới-1","chapter":"24 Mô hình hóa dịch bệnh","heading":"Dự đoán số trường hợp mắc mới","text":"Để dự đoán số mắc mới trong tương lai, chúng ta vẫn cần cung cấp lịch sử số mới mắc dưới dạng một đối tượng incidence, cũng như một mẫu các giá trị Rt khả dĩ. Chúng ta sẽ tạo các giá trị này bằng cách sử dụng ước tính Rt được sinh ra bởi EpiEstim trong phần trước (trong mục “Ước tính Rt”) và được lưu trữ trong đối tượng epiestim_res_emp. Trong đoạn code dưới đây, chúng ta trích xuất các ước tính trung bình và độ lệch chuẩn của Rt cho khoảng thời gian cửa sổ cuối cùng của đợt bùng phát (sử dụng hàm tail để truy cập giá trị cuối cùng trong một vectơ) và mô phỏng 1000 giá trị từ phân phối gamma bằng cách sử dụng hàm rgamma. Bạn cũng có thể cung cấp vectơ của các giá trị Rt của riêng mình mà bạn muốn sử dụng để dự báo.Sau đó, chúng ta sử dụng hàm project() để đưa ra dự báo thực tế. Chúng ta cụ thể số ngày chúng ta muốn dự báo qua đối số n_days và chỉ định số lượng mô phỏng bằng cách sử dụng đối số n_sim.Sau đó, chúng ta có thể vẽ biểu đồ số trường hợp mắc mới và số dự báo bằng cách sử dụng các hàm plot() và add_projections(). Chúng ta có thể dễ dàng lấy tập con của đối tượng incidence để chỉ hiển thị các trường hợp gần đây nhất bằng cách sử dụng toán tử dấu ngoặc vuông.Bạn cũng có thể dễ dàng trích xuất các ước tính thô của số trường hợp hàng ngày bằng cách chuyển đổi đầu ra thành một dataframe.","code":"\n## create incidence object from dates of onset\ninc <- incidence::incidence(linelist$date_onset)## 256 missing observations were removed.\n## extract plausible r values from most recent estimate\nmean_r <- tail(epiestim_res_emp$R$`Mean(R)`, 1)\nsd_r <- tail(epiestim_res_emp$R$`Std(R)`, 1)\nshapescale <- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)\nplausible_r <- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)\n\n## check distribution\nqplot(x = plausible_r, geom = \"histogram\", xlab = expression(R[t]), ylab = \"Counts\")## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n## make projection\nproj <- project(\n  x = inc,\n  R = plausible_r,\n  si = serial_interval$distribution,\n  n_days = 21,\n  n_sim = 1000\n)\n## plot incidence and projections\nplot(inc[inc$dates > as.Date(\"2015-03-01\")]) %>%\n  add_projections(proj)\n## convert to data frame for raw data\nproj_df <- as.data.frame(proj)\nproj_df"},{"path":"epidemic-models.html","id":"tài-liệu-tham-khảo-1","chapter":"24 Mô hình hóa dịch bệnh","heading":"24.5 Tài liệu tham khảo","text":"Bài báo này mô tả phương pháp được thực hiện trong EpiEstim.Bài báo này mô tả phương pháp được thực hiện trong EpiNow2.Bài báo này mô tả các cân nhắc phương pháp luận và thực tế khác nhau để ước tính Rt.","code":""},{"path":"contact-tracing.html","id":"contact-tracing","chapter":"25 Truy vết tiếp xúc","heading":"25 Truy vết tiếp xúc","text":"Chương này trình bày phân tích mô tả về dữ liệu truy vết tiếp xúc, bổ sung một số cân nhắc chính và cách tiếp cận độc đáo đối với kiểu dữ liệu này.Chương này đề cập nhiều đến năng lực quản lý dữ liệu và trực quan hóa mà đã được đề cập đến trong các chương khác (ví dụ: làm sạch dữ liệu, xoay trục dữ liệu, data table, phân tích chuỗi thời gian), nhưng chúng tôi sẽ nêu bật các ví dụ cụ thể về truy vết tiếp xúc, năng lực hữu ích cho việc đưa ra quyết định hành động. Ví dụ, nó bao gồm việc trực quan hóa dữ liệu truy vết tiếp xúc theo thời gian hoặc trên các khu vực địa lý, hay tạo bảng Chỉ Số Đánh Giá Hiệu Quả Công Việc (Key Performance Indicator - KPI) rõ ràng hỗ trợ cho người giám sát truy vết tiếp xúc.Với mục đích minh họa, chúng tôi sẽ sử dụng dữ liệu truy vết tiếp xúc mẫu từ nền tảng Go.Data. Các nguyên tắc được đề cập ở đây sẽ áp dụng cho cả dữ liệu truy vết tiếp xúc từ những nền tảng khác - bạn có thể chỉ cần trải qua các bước xử lý trước dữ liệu khác nhau tùy thuộc vào cấu trúc dữ liệu của bạn.Bạn có thể đọc thêm về dự án Go.Data trên Trang tài liệu Github và Cộng đồng thực hành.","code":""},{"path":"contact-tracing.html","id":"chuẩn-bị-15","chapter":"25 Truy vết tiếp xúc","heading":"25.1 Chuẩn bị","text":"","code":""},{"path":"contact-tracing.html","id":"gọi-package-7","chapter":"25 Truy vết tiếp xúc","heading":"Gọi package","text":"Đoạn code này hiển thị những package cần cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ pacman, hàm sẽ cài đặt package nếu cần và gọi nó để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để có thêm thông tin về các R package.","code":"\npacman::p_load(\n  rio,          # importing data  \n  here,         # relative file pathways  \n  janitor,      # data cleaning and tables\n  lubridate,    # working with dates\n  epikit,       # age_categories() function\n  apyramid,     # age pyramids\n  tidyverse,    # data manipulation and visualization\n  RColorBrewer, # color palettes\n  formattable,  # fancy tables\n  kableExtra    # table formatting\n)"},{"path":"contact-tracing.html","id":"nhập-dữ-liệu-13","chapter":"25 Truy vết tiếp xúc","heading":"Nhập dữ liệu","text":"Chúng ta sẽ nhập bộ dữ liệu mẫu về những người tiếp xúc và thông tin “theo dõi” của họ. Những dữ liệu này đã được truy xuất và không được lồng ghép với Go.Data API, đồng thời được lưu trữ dưới dạng tệp “.rds”.Bạn có thể tải xuống tất cả dữ liệu mẫu cho sổ tay này từ chương Tải sách và dữ liệu.Nếu bạn muốn tải xuống dữ liệu truy vết tiếp xúc mẫu cụ thể cho chương này, hãy sử dụng ba liên kết tải xuống dưới đây:Bấm để tải xuống dữ liệu điều tra ca mắc (file .rds)Bấm để tải xuống dữ liệu khai báo tiếp xúc (file .rds)Bấm để tải xuống dữ liệu theo dõi tiếp xúc (file .rds)Ở dạng gốc các các tệp có thể tải xuống được, dữ liệu thể hiện dữ liệu gốc được cung cấp bởi Go.Data API (tìm hiểu thêm về APIs ở đây). Đối với mục đích ví dụ ở đây, chúng ta sẽ làm sạch dữ liệu để giúp bạn đọc chương này dễ dàng hơn. Nếu bạn đang sử dụng một phiên bản Go.Data, bạn có thể xem hướng dẫn đầy đủ về cách truy xuất dữ liệu của mình tại đây.Dưới đây, các bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương về Nhập xuất dữ liệu để biết những cách nhập dữ liệu khác nhau. Chúng tôi sử dụng hàm () để xác định đường dẫn tệp - bạn nên cung cấp đường dẫn tệp cụ thể cho máy tính của mình. Sau đó, chúng tôi sử dụng hàm select() để chỉ chọn một số cột nhất định của dữ liệu, nhằm đơn giản hóa cho mục đích diễn giải.","code":""},{"path":"contact-tracing.html","id":"dữ-liệu-ca-mắc","chapter":"25 Truy vết tiếp xúc","heading":"Dữ liệu ca mắc","text":"Dữ liệu này là một bảng các ca mắc và thông tin về họ.Dưới đây là nrow(cases) các trường hợp :","code":"\ncases <- import(here(\"data\", \"godata\", \"cases_clean.rds\")) %>% \n  select(case_id, firstName, lastName, gender, age, age_class,\n         occupation, classification, was_contact, hospitalization_typeid)"},{"path":"contact-tracing.html","id":"dữ-liệu-tiếp-xúc","chapter":"25 Truy vết tiếp xúc","heading":"Dữ liệu tiếp xúc","text":"Những dữ liệu này là một bảng gồm tất cả những người tiếp xúc và thông tin về họ. Một lần nữa, hãy cung cấp đường dẫn tệp của riêng bạn. Sau khi nhập, chúng tôi thực hiện một số bước làm sạch dữ liệu sơ bộ bao gồm:Thiết lập age_class là biến kiểu factor và đảo ngược thứ tự giá trị của biến sao cho những người trẻ hơn nằm ở trên đầuChỉ chọn một số cột nhất định, và đặt lại tên cho một trong số chúngGiả định gán các hàng missing ở cột admin_2_name thành “Djembe”, để cải thiện sự rõ ràng ở một số ví dụ trực quan hóa.Đây là nrow(contacts) các hàng của bộ dữ liệu contacts:","code":"\ncontacts <- import(here(\"data\", \"godata\", \"contacts_clean.rds\")) %>% \n  mutate(age_class = forcats::fct_rev(age_class)) %>% \n  select(contact_id, contact_status, firstName, lastName, gender, age,\n         age_class, occupation, date_of_reporting, date_of_data_entry,\n         date_of_last_exposure = date_of_last_contact,\n         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %>% \n  mutate(admin_2_name = replace_na(admin_2_name, \"Djembe\"))"},{"path":"contact-tracing.html","id":"dữ-liệu-theo-dõi","chapter":"25 Truy vết tiếp xúc","heading":"Dữ liệu theo dõi","text":"Những dữ liệu này là bản ghi của các tương tác được “theo dõi” với những người tiếp xúc. Mỗi người tiếp xúc được cho là có một cuộc gặp gỡ mỗi ngày với ca mắc trong vòng 14 ngày sau khi phơi nhiễm.Chúng ta nhập dữ liệu và thực hiện một số bước làm sạch. Chúng ta chọn một số cột nhất định và cũng chuyển đổi tất cả các giá trị thành chữ thường ở một cột định dạng ký tự.Đây là 50 hàng đầu tiên của nrow(followups) - hàng của bộ dữ liệu followups (mỗi hàng là một người tiếp xúc được theo dõi, với trạng thái kết quả trong cột followup_status):","code":"\nfollowups <- rio::import(here::here(\"data\", \"godata\", \"followups_clean.rds\")) %>% \n  select(contact_id, followup_status, followup_number,\n         date_of_followup, admin_2_name, admin_1_name) %>% \n  mutate(followup_status = str_to_lower(followup_status))"},{"path":"contact-tracing.html","id":"dữ-liệu-mối-quan-hệ","chapter":"25 Truy vết tiếp xúc","heading":"Dữ liệu mối quan hệ","text":"Ở đây chúng ta nhập dữ liệu cho thấy mối quan hệ giữa các ca mắc và người tiếp xúc. Chúng ta chọn một số cột nhất định để hiển thị.Dưới đây là 50 hàng đầu tiên của bộ dữ liệu relationships, bộ dữ liệu này ghi lại tất cả mối quan hệ giữa các ca mắc và những người tiếp xúc.","code":"\nrelationships <- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %>% \n  select(source_visualid, source_gender, source_age, date_of_last_contact,\n         date_of_data_entry, target_visualid, target_gender,\n         target_age, exposure_type)"},{"path":"contact-tracing.html","id":"phân-tích-mô-tả-2","chapter":"25 Truy vết tiếp xúc","heading":"25.2 Phân tích mô tả","text":"Bạn có thể sử dụng các kỹ thuật được đề cập đến trong những chương khác của sổ tay này để tiến hành các phân tích mô tả về những ca mắc, người tiếp xúc và mối quan hệ của họ. Dưới đây là một số ví dụ.","code":""},{"path":"contact-tracing.html","id":"nhân-khẩu-học","chapter":"25 Truy vết tiếp xúc","heading":"Nhân khẩu học","text":"Như được trình bày trong chương Tháp dân số và thang đo Likert, bạn có thể trực quan hóa phân bố theo độ tuổi và giới tính (ở đây chúng tôi sử dụng package apyramid).","code":""},{"path":"contact-tracing.html","id":"tuổi-và-giới-tính-của-người-tiếp-xúc","chapter":"25 Truy vết tiếp xúc","heading":"Tuổi và Giới tính của người tiếp xúc","text":"Kim tự tháp dưới đây sánh sự phân bố độ tuổi của những người tiếp xúc theo giới tính. Lưu ý rằng những người tiếp xúc bị missing tuổi được đưa vào thanh riêng của họ ở trên cùng. Bạn có thể thay đổi hiển thị mặc định này, nhưng sau đó hãy xem xét liệt kê số bị missing trong chú thích.Với cấu trúc dữ liệu Go.Data, bộ dữ liệu relationships bao gồm độ tuổi của cả các ca mắc và những người tiếp xúc, vì vậy bạn có thể sử dụng bộ dữ liệu đó và tạo tháp tuổi cho thấy sự khác biệt giữa hai nhóm người này. Data frame relationships sẽ được biến đổi để chuyển các cột tuổi ở dạng số số thành các nhóm định danh (xem chương Làm sạch số liệu và các hàm quan trọng). Chúng ta cũng sẽ xoay trục dataframe sang định dạng dọc nhằm vẽ biểu đồ dễ dàng hơn với ggplot2 (xem chương Xoay trục dữ liệu).Bây giờ chúng ta có thể vẽ biểu đồ bộ dữ liệu đã chuyển đổi này với hàm age_pyramid() như trước đây, nhưng thay thế gender bởi category (người tiếp xúc, hoặc ca mắc).Chúng ta cũng có thể xem xét các đặc điểm khác như cơ cấu nghề nghiệp (ví dụ: ở dạng biểu đồ tròn).","code":"\napyramid::age_pyramid(\n  data = contacts,                                   # use contacts dataset\n  age_group = \"age_class\",                           # categorical age column\n  split_by = \"gender\") +                             # gender for halfs of pyramid\n  labs(\n    fill = \"Gender\",                                 # title of legend\n    title = \"Age/Sex Pyramid of COVID-19 contacts\")+ # title of the plot\n  theme_minimal()                                    # simple background\nrelation_age <- relationships %>% \n  select(source_age, target_age) %>% \n  transmute(                              # transmute is like mutate() but removes all other columns not mentioned\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),\n    ) %>% \n  pivot_longer(cols = contains(\"class\"), names_to = \"category\", values_to = \"age_class\")  # pivot longer\n\n\nrelation_age## # A tibble: 200 x 2\n##    category         age_class\n##    <chr>            <fct>    \n##  1 source_age_class 80+      \n##  2 target_age_class 15-19    \n##  3 source_age_class <NA>     \n##  4 target_age_class 50-54    \n##  5 source_age_class <NA>     \n##  6 target_age_class 20-24    \n##  7 source_age_class 30-34    \n##  8 target_age_class 45-49    \n##  9 source_age_class 40-44    \n## 10 target_age_class 30-34    \n## # ... with 190 more rows\napyramid::age_pyramid(\n  data = relation_age,                               # use modified relationship dataset\n  age_group = \"age_class\",                           # categorical age column\n  split_by = \"category\") +                           # by cases and contacts\n  scale_fill_manual(\n    values = c(\"orange\", \"purple\"),                  # to specify colors AND labels\n    labels = c(\"Case\", \"Contact\"))+\n  labs(\n    fill = \"Legend\",                                           # title of legend\n    title = \"Age/Sex Pyramid of COVID-19 contacts and cases\")+ # title of the plot\n  theme_minimal()                                              # simple background\n# Clean dataset and get counts by occupation\nocc_plot_data <- cases %>% \n  mutate(occupation = forcats::fct_explicit_na(occupation),  # make NA missing values a category\n         occupation = forcats::fct_infreq(occupation)) %>%   # order factor levels in order of frequency\n  count(occupation)                                          # get counts by occupation\n  \n# Make pie chart\nggplot(data = occ_plot_data, mapping = aes(x = \"\", y = n, fill = occupation))+\n  geom_bar(width = 1, stat = \"identity\") +\n  coord_polar(\"y\", start = 0) +\n  labs(\n    fill = \"Occupation\",\n    title = \"Known occupations of COVID-19 cases\")+\n  theme_minimal() +                    \n  theme(axis.line = element_blank(),\n        axis.title = element_blank(),\n        axis.text = element_blank())"},{"path":"contact-tracing.html","id":"số-người-tiếp-xúc-trên-mỗi-ca-mắc","chapter":"25 Truy vết tiếp xúc","heading":"Số người tiếp xúc trên mỗi ca mắc","text":"Số người tiếp xúc trên mỗi ca mắc có thể là một thước đo quan trọng để đánh giá chất lượng của việc điều tra số người tiếp xúc và mức độ tuân thủ của người dân với việc ứng phó sức khỏe cộng đồng.Tùy thuộc vào cấu trúc dữ liệu của bạn, điều này có thể được đánh giá thông qua bộ dữ liệu chứa thông tin tất cả các ca mắc và những người tiếp xúc. Trong bộ dữ liệu Go.Data, liên kết giữa các ca mắc (“nguồn”) và những người tiếp xúc (“mục tiêu”) được lưu trữ trong bộ dữ liệu relationships.Trong bộ dữ liệu này, mỗi hàng là một người tiếp xúc và trong đó có liệt kê ca mắc nguồn. Không có người tiếp xúc nào có mối quan hệ với nhiều ca mắc, nhưng nếu điều này tồn tại, bạn có thể cần tính toán những người đó trước khi vẽ biểu đồ (và khám phá chúng nữa!).Chúng ta bắt đầu bằng cách đếm số hàng (người tiếp xúc) trên mỗi ca mắc nguồn. Kết quả này được lưu dưới dạng một data frame.Chúng ta sử dụng hàm geom_histogram() để vẽ các dữ liệu này dưới dạng biểu đồ histogram.","code":"\ncontacts_per_case <- relationships %>% \n  count(source_visualid)\n\ncontacts_per_case## # A tibble: 23 x 2\n##    source_visualid     n\n##    <chr>           <int>\n##  1 CASE-2020-0001     13\n##  2 CASE-2020-0002      5\n##  3 CASE-2020-0003      2\n##  4 CASE-2020-0004      4\n##  5 CASE-2020-0005      5\n##  6 CASE-2020-0006      3\n##  7 CASE-2020-0008      3\n##  8 CASE-2020-0009      3\n##  9 CASE-2020-0010      3\n## 10 CASE-2020-0012      3\n## # ... with 13 more rows\nggplot(data = contacts_per_case)+        # begin with count data frame created above\n  geom_histogram(mapping = aes(x = n))+  # print histogram of number of contacts per case\n  scale_y_continuous(expand = c(0,0))+   # remove excess space below 0 on y-axis\n  theme_light()+                         # simplify background\n  labs(\n    title = \"Number of contacts per case\",\n    y = \"Cases\",\n    x = \"Contacts per case\"\n  )"},{"path":"contact-tracing.html","id":"theo-dõi-người-tiếp-xúc","chapter":"25 Truy vết tiếp xúc","heading":"25.3 Theo dõi người tiếp xúc","text":"Dữ liệu truy vết tiếp xúc thường chứa dữ liệu “theo dõi”, dữ liệu này ghi lại kết quả kiểm tra triệu chứng hàng ngày của những người trong diện cách ly. Phân tích dữ liệu này có thể xác định chiến lược ứng phó, xác định những người tiếp xúc có nguy cơ mất theo dõi hoặc có nguy cơ phát triển bệnh.","code":""},{"path":"contact-tracing.html","id":"làm-sạch-dữ-liệu-1","chapter":"25 Truy vết tiếp xúc","heading":"Làm sạch dữ liệu","text":"Những dữ liệu này có thể tồn tại ở nhiều định dạng khác nhau. Chúng có thể tồn tại dưới dạng trang tính Excel định dạng “ngang” với một hàng cho mỗi người tiếp xúc và một cột cho mỗi “ngày” theo dõi. Xem chương Xoay trục dữ liệu để hiểu về mô tả dữ liệu “dọc” và “ngang”, và cả cách xoay trục dữ liệu sang định dạng ngang hoặc dọc.Trong ví dụ Go.Data của chúng tôi, những dữ liệu này được lưu trữ trong data frame followups, data frame này có định dạng “dọc” với một hàng cho mỗi tương tác theo dõi. 50 hàng đầu tiên như sau:CẨN TRỌNG: Cẩn thận với các bản trùng lặp khi xử lý dữ liệu theo dõi; vì có thể có một vài lần theo dõi sai sót trong cùng một ngày cho một người tiếp xúc nhất định. Nó dường như có vẻ là một lỗi nhưng lại phản ánh đúng thực tế - ví dụ: người theo dõi trường hợp tiếp xúc có thể gửi biểu mẫu theo dõi từ sớm trong ngày dù họ chưa liên hệ được với người tiếp xúc và gửi biểu mẫu thứ hai khi họ đã liên hệ được sau đó. Việc này sẽ phụ thuộc vào quy trình thực hiện hoạt động đối với cách bạn muốn xử lý các bản trùng lặp - chỉ cần đảm bảo ghi lại cách tiếp cận của bạn một cách rõ ràng.Hãy xem chúng ta có bao nhiêu trường hợp hàng “trùng lặp”:Trong dữ liệu ví dụ của chúng ta, các bản ghi duy nhất áp dụng điều này là những bản ghi missing ID! Chúng ta có thể loại bỏ chúng. Tuy nhiên, với mục đích diễn giải, chúng ta sẽ trình bày các bước nhằm loại bỏ trùng lặp để mỗi người tiếp xúc chỉ có một lần theo dõi truy vết mỗi ngày. Xem chương Loại bỏ trùng lặp để biết thêm chi tiết. Chúng ta sẽ giả định rằng bản ghi cuộc gọi truy vết mới nhất là bản ghi chính xác. Chúng ta cũng tận dụng cơ hội để làm sạch cột followup_number (“ngày” theo dõi sẽ nằm trong khoảng 1 - 14).Đối với mỗi cuộc gọi truy vết tiếp theo, chúng ta có một trạng thái theo dõi (chẳng hạn như cuộc gọi truy vết có xảy ra hay không và nếu có, người tiếp xúc có triệu chứng hay không). Để xem tất cả các giá trị, chúng ta có thể chạy nhanh lệnh tabyl() (từ janitor) hoặc table() (từ base R) (xem chương Bảng mô tả) bằng followup_status để xem tần suất của từng kết quả.Trong bộ dữ liệu này, “seen_not_ok” có nghĩa là “được thấy có triệu chứng” và “seen_ok” có nghĩa là “được thấy không có triệu chứng”.","code":"\nfollowups %>% \n  count(contact_id, date_of_followup) %>%   # get unique contact_days\n  filter(n > 1)                             # view records where count is more than 1  ## # A tibble: 3 x 3\n##   contact_id date_of_followup     n\n##   <chr>      <date>           <int>\n## 1 <NA>       2020-09-03           2\n## 2 <NA>       2020-09-04           2\n## 3 <NA>       2020-09-05           2\nfollowups_clean <- followups %>%\n  \n  # De-duplicate\n  group_by(contact_id, date_of_followup) %>%        # group rows per contact-day\n  arrange(contact_id, desc(date_of_followup)) %>%   # arrange rows, per contact-day, by date of follow-up (most recent at top)\n  slice_head() %>%                                  # keep only the first row per unique contact id  \n  ungroup() %>% \n  \n  # Other cleaning\n  mutate(followup_number = replace(followup_number, followup_number > 14, NA)) %>% # clean erroneous data\n  drop_na(contact_id)                               # remove rows with missing contact_id\nfollowups_clean %>% \n  tabyl(followup_status)##  followup_status   n    percent\n##           missed  10 0.02325581\n##    not_attempted   5 0.01162791\n##    not_performed 319 0.74186047\n##      seen_not_ok   6 0.01395349\n##          seen_ok  90 0.20930233"},{"path":"contact-tracing.html","id":"vẽ-biểu-đồ-theo-thời-gian","chapter":"25 Truy vết tiếp xúc","heading":"Vẽ biểu đồ theo thời gian","text":"Vì dữ liệu ngày là liên tục, chúng ta sẽ sử dụng biểu đồ histogram để vẽ chúng với biến date_of_followup được gán cho trục x. Chúng ta có thể vẽ được biểu đồ histogram “xếp chồng” bằng cách chỉ định đối số fill = trong aes(), đối số mà chúng ta gán cho cột followup_status. đó, bạn có thể thiết lập chú thích bằng cách sử dụng đối số fill = của labs().Chúng ta có thể thấy rằng những người tiếp xúc được xác định theo từng đợt (có lẽ là tương ứng với các đợt dịch) và việc hoàn thành theo dõi dường như không cải thiện trong suốt đợt dịch.CẨN TRỌNG: Nếu bạn đang chuẩn bị nhiều biểu đồ (ví dụ: cho nhiều khu vực pháp lý), bạn sẽ muốn các chú thích xuất hiện giống hệt nhau ngay cả với các mức độ hoàn thiện dữ liệu hoặc thành phần dữ liệu khác nhau. Có thể có những biểu đồ mà không phải tất cả các trạng thái theo dõi đều có trong dữ liệu, nhưng bạn vẫn muốn các danh mục đó xuất hiện trong chú thích. Trong ggplots (như trên), bạn có thể chỉ định đối số drop = FALSE của hàm scale_fill_discrete(). Trong bảng, hãy sử dụng tabyl() để hiển thị số lượng cho tất cả các thực bậc của factor hoặc nếu sử dụng count() từ dplyr, hãy thêm đối số .drop = FALSE để bao gồm số lượng của tất cả các thứ bậc factors.","code":"\nggplot(data = followups_clean)+\n  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +\n  scale_fill_discrete(drop = FALSE)+   # show all factor levels (followup_status) in the legend, even those not used\n  theme_classic() +\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Daily Contact Followup Status\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups$date_of_followup, na.rm=T)}\"))   # dynamic subtitle"},{"path":"contact-tracing.html","id":"theo-dõi-cá-nhân-hàng-ngày","chapter":"25 Truy vết tiếp xúc","heading":"Theo dõi cá nhân hàng ngày","text":"Nếu sự bùng phát dịch của bạn đủ nhỏ, bạn có thể muốn xem xét từng người tiếp xúc và xem trạng thái của họ trong suốt quá trình theo dõi. May mắn rằng, bộ dữ liệu followups này đã chứa sẵn một cột với “số” ngày theo dõi (1-14). Nếu cột này không tồn tại trong dữ liệu của bạn, bạn có thể tạo ra nó bằng cách tính toán sự khác biệt giữa ngày truy vết và ngày dự định bắt đầu theo dõi người tiếp xúc.Một cơ chế trực quan hóa thuận tiện (nếu số lượng ca mắc không quá lớn) có thể là một biểu đồ nhiệt, được tạo bằng geom_tile(). Xem thêm chi tiết trong chương Biểu đồ nhiệt.","code":"\nggplot(data = followups_clean)+\n  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),\n            color = \"grey\")+       # grey gridlines\n  scale_fill_manual( values = c(\"yellow\", \"grey\", \"orange\", \"darkred\", \"darkgreen\"))+\n  theme_minimal()+\n  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))"},{"path":"contact-tracing.html","id":"phân-tích-theo-nhóm","chapter":"25 Truy vết tiếp xúc","heading":"Phân tích theo nhóm","text":"Có lẽ những dữ liệu theo dõi này đang được kiểm tra hàng ngày hoặc hàng tuần để đưa ra quyết định hành động. Bạn có thể muốn những phân tách có ý nghĩa hơn theo khu vực địa lý hoặc theo nhóm truy vết tiếp xúc. Chúng ta có thể làm điều này bằng cách điều chỉnh các cột được cung cấp tới hàm group_by().","code":"\nplot_by_region <- followups_clean %>%                                        # begin with follow-up dataset\n  count(admin_1_name, admin_2_name, followup_status) %>%   # get counts by unique region-status (creates column 'n' with counts)\n  \n  # begin ggplot()\n  ggplot(                                         # begin ggplot\n    mapping = aes(x = reorder(admin_2_name, n),     # reorder admin factor levels by the numeric values in column 'n'\n                  y = n,                            # heights of bar from column 'n'\n                  fill = followup_status,           # color stacked bars by their status\n                  label = n))+                      # to pass to geom_label()              \n  geom_col()+                                     # stacked bars, mapping inherited from above \n  geom_text(                                      # add text, mapping inherited from above\n    size = 3,                                         \n    position = position_stack(vjust = 0.5), \n    color = \"white\",           \n    check_overlap = TRUE,\n    fontface = \"bold\")+\n  coord_flip()+\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Contact Followup Status, by Region\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups_clean$date_of_followup, na.rm=T)}\")) +\n  theme_classic()+                                                                      # Simplify background\n  facet_wrap(~admin_1_name, strip.position = \"right\", scales = \"free_y\", ncol = 1)      # introduce facets \n\nplot_by_region"},{"path":"contact-tracing.html","id":"bảng-kpi","chapter":"25 Truy vết tiếp xúc","heading":"25.4 Bảng KPI","text":"Có một số Chỉ Số Đánh Giá Hiệu Quả Công Việc (KPI) khác nhau có thể được tính toán và theo dõi ở các mức độ phân tách khác nhau và trong những khoảng thời gian khác nhau để theo dõi hiệu suất thực hiện truy vết tiếp xúc. Khi bạn đã tính toán xong và có định dạng bảng cơ bản; khá dễ dàng để hoán đổi các KPI khác nhau.Có nhiều nguồn KPI truy vết tiếp xúc, chẳng hạn như nguồn này từ ResolveToSaveLives.org. Phần lớn công việc sẽ là xem xét cấu trúc dữ liệu và suy nghĩ về tất cả các tiêu chí bao gồm/loại trừ. Chúng tôi đưa ra một vài ví dụ dưới đây; sử dụng cấu trúc siêu dữ liệu Go.Data:Sau đây chúng tôi sẽ giới thiệu một bài tập mẫu về cách tạo bảng đẹp mắt để hiển thị thông tin theo dõi người tiếp xúc trên các khu vực hành chính. Cho tới bước cuối cùng, chúng tôi sẽ tạo bảng phù hợp để trình bày với package formattable (nhưng bạn có thể sử dụng các package khác như flextable - xem chương Trình bày bảng).Cách bạn tạo một bảng như thế nào sẽ phụ thuộc vào cấu trúc của dữ liệu truy vết tiếp xúc của bạn. Sử dụng chương Bảng mô tả để tìm hiểu cách tóm tắt dữ liệu bằng các hàm dplyr.Chúng tôi sẽ tạo một bảng động và thay đổi khi dữ liệu thay đổi. Để làm cho kết quả thú vị, chúng tôi sẽ thiết lập report_date nhằm cho phép chúng tôi mô phỏng việc chạy bảng vào một ngày nhất định (chúng tôi chọn ngày 10 tháng 6 năm 2020). Dữ liệu được lọc cho ngày đó.Bây giờ, dựa trên cấu trúc dữ liệu, chúng ta sẽ làm như sau:Bắt đầu với dữ liệu followups và tóm tắt nó để chứa cho mỗi liên hệ duy nhất:Ngày của bản ghi gần nhất (bất kể tình trạng của truy vết)Ngày truy vết gần nhất mà người tiếp xúc được “seen”Trạng thái truy vết ở lần truy vết “seen” cuối cùng (ví dụ: có triệu chứng, không có triệu chứng)Nối dữ liệu này với dữ liệu người tiếp xúc, dữ liệu mà chứa các thông tin khác như trạng thái tổng thể của người tiếp xúc, ngày tiếp xúc cuối với một ca mắc, v.v. Ngoài ra, chúng ta sẽ tính toán các số liệu được quan tâm cho mỗi người tiếp xúc, chẳng hạn như số ngày kể từ lần phơi nhiễm cuốiChúng ta nhóm dữ liệu người tiếp xúc nâng cao theo vùng địa lý (admin_2_name) và tính toán tóm tắt thống kê cho mỗi khu vựcCuối cùng, chúng ta định dạng bảng thích hợp để trình bàyĐầu tiên, chúng ta tóm tắt dữ liệu theo dõi để có được thông tin quan tâm:Đây là cách những dữ liệu này được nhìn thấy:Bây giờ chúng ta sẽ thêm thông tin này vào bộ dữ liệu contacts và tính toán một số cột bổ sung.Đây là cách những dữ liệu này được nhìn thấy. Lưu ý cột contacts nằm ở bên phải và cột mới được tính toán nằm ở ngoài cùng bên phải.Tiếp theo, chúng ta tổng hợp dữ liệu người tiếp xúc theo khu vực, để có một data frame ngắn gọn của các cột thống kê đã tóm tắt.Và bây giờ chúng ta áp dụng kiểu bảng từ các package formattable và knitr, bao gồm một chú thích cuối trang hiển thị “kể từ” ngày.","code":"\n# Set \"Report date\" to simulate running the report with data \"as of\" this date\nreport_date <- as.Date(\"2020-06-10\")\n\n# Create follow-up data to reflect the report date.\ntable_data <- followups_clean %>% \n  filter(date_of_followup <= report_date)\nfollowup_info <- table_data %>% \n  group_by(contact_id) %>% \n  summarise(\n    date_last_record   = max(date_of_followup, na.rm=T),\n    date_last_seen     = max(date_of_followup[followup_status %in% c(\"seen_ok\", \"seen_not_ok\")], na.rm=T),\n    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %>% \n  ungroup()\ncontacts_info <- followup_info %>% \n  right_join(contacts, by = \"contact_id\") %>% \n  mutate(\n    database_date       = max(date_last_record, na.rm=T),\n    days_since_seen     = database_date - date_last_seen,\n    days_since_exposure = database_date - date_of_last_exposure\n    )\ncontacts_table <- contacts_info %>% \n  \n  group_by(`Admin 2` = admin_2_name) %>%\n  \n  summarise(\n    `Registered contacts` = n(),\n    `Active contacts`     = sum(contact_status == \"UNDER_FOLLOW_UP\", na.rm=T),\n    `In first week`       = sum(days_since_exposure < 8, na.rm=T),\n    `In second week`      = sum(days_since_exposure >= 8 & days_since_exposure < 15, na.rm=T),\n    `Became case`         = sum(contact_status == \"BECAME_CASE\", na.rm=T),\n    `Lost to follow up`   = sum(days_since_seen >= 3, na.rm=T),\n    `Never seen`          = sum(is.na(date_last_seen)),\n    `Followed up - signs` = sum(status_last_record == \"Seen_not_ok\" & date_last_record == database_date, na.rm=T),\n    `Followed up - no signs` = sum(status_last_record == \"Seen_ok\" & date_last_record == database_date, na.rm=T),\n    `Not Followed up`     = sum(\n      (status_last_record == \"NOT_ATTEMPTED\" | status_last_record == \"NOT_PERFORMED\") &\n        date_last_record == database_date, na.rm=T)) %>% \n    \n  arrange(desc(`Registered contacts`))\ncontacts_table %>%\n  mutate(\n    `Admin 2` = formatter(\"span\", style = ~ formattable::style(\n      color = ifelse(`Admin 2` == NA, \"red\", \"grey\"),\n      font.weight = \"bold\",font.style = \"italic\"))(`Admin 2`),\n    `Followed up - signs`= color_tile(\"white\", \"orange\")(`Followed up - signs`),\n    `Followed up - no signs`= color_tile(\"white\", \"#A0E2BD\")(`Followed up - no signs`),\n    `Became case`= color_tile(\"white\", \"grey\")(`Became case`),\n    `Lost to follow up`= color_tile(\"white\", \"grey\")(`Lost to follow up`), \n    `Never seen`= color_tile(\"white\", \"red\")(`Never seen`),\n    `Active contacts` = color_tile(\"white\", \"#81A4CE\")(`Active contacts`)\n  ) %>%\n  kable(\"html\", escape = F, align =c(\"l\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\")) %>%\n  kable_styling(\"hover\", full_width = FALSE) %>%\n  add_header_above(c(\" \" = 3, \n                     \"Of contacts currently under follow up\" = 5,\n                     \"Status of last visit\" = 3)) %>% \n  kableExtra::footnote(general = str_glue(\"Data are current to {format(report_date, '%b %d %Y')}\"))"},{"path":"contact-tracing.html","id":"ma-trận-lây-truyền","chapter":"25 Truy vết tiếp xúc","heading":"25.5 Ma trận lây truyền","text":"Như đã thảo luận trong chương Biểu đồ nhiệt, bạn có thể tạo ma trận “ai đã lây nhiễm cho ai” bằng cách sử dụng hàm geom_tile().Khi những ca tiếp xúc mới được tạo, Go.Data lưu trữ thông tin về mối quan hệ này tại điểm cuối API relationships; chúng ta có thể thấy 50 hàng đầu tiên của bộ dữ liệu này bên dưới. Điều này có nghĩa là chúng ta có thể tạo một biểu đồ nhiệt với một vài bước với mỗi tiếp điểm được nối với ca mắc nguồn của nó.Như đã thực hiện ở trên đối với tháp tuổi sánh các ca mắc và những người tiếp xúc, chúng ta có thể chọn một vài biến số chúng ta cần và tạo các cột nhóm tuổi được phân loại cho cả dữ liệu nguồn (ca mắc) và mục tiêu (người tiếp xúc).Như đã mô tả bên trên, chúng ta tạo bảng chéo;chuyển đổi thành định dạng dọc với những tỷ lệ;và tạo biểu đồ nhiệt cho độ tuổi.","code":"\nheatmap_ages <- relationships %>% \n  select(source_age, target_age) %>% \n  mutate(                              # transmute is like mutate() but removes all other columns\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) \ncross_tab <- table(\n  source_cases = heatmap_ages$source_age_class,\n  target_cases = heatmap_ages$target_age_class)\n\ncross_tab##             target_cases\n## source_cases 0-4 5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54 55-59 60-64 65-69 70-74 75-79 80+\n##        0-4     0   0     0     0     0     0     0     0     0     1     0     1     0     0     0     0   0\n##        5-9     0   0     1     0     0     0     0     1     0     0     0     1     0     0     0     0   0\n##        10-14   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        15-19   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        20-24   1   1     0     1     2     0     2     1     0     0     0     1     0     0     0     0   1\n##        25-29   1   2     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        30-34   0   0     0     0     0     0     0     0     1     1     0     1     0     0     0     0   0\n##        35-39   0   2     0     0     0     0     0     0     0     1     0     0     0     0     0     0   0\n##        40-44   0   0     0     0     1     0     2     1     0     3     1     1     0     0     0     1   1\n##        45-49   1   2     2     0     0     0     3     0     1     0     3     2     1     0     0     0   1\n##        50-54   1   2     1     2     0     0     1     0     0     3     4     1     0     1     0     0   1\n##        55-59   0   1     0     0     1     1     2     0     0     0     0     0     0     0     0     0   0\n##        60-64   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        65-69   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        70-74   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        75-79   0   0     0     0     0     0     0     0     0     0     0     0     0     0     0     0   0\n##        80+     1   0     0     2     1     0     0     0     1     0     0     0     0     0     0     0   0\nlong_prop <- data.frame(prop.table(cross_tab))\nggplot(data = long_prop)+       # use long data, with proportions as Freq\n  geom_tile(                    # visualize it in tiles\n    aes(\n      x = target_cases,         # x-axis is case age\n      y = source_cases,     # y-axis is infector age\n      fill = Freq))+            # color of the tile is the Freq column in the data\n  scale_fill_gradient(          # adjust the fill color of the tiles\n    low = \"blue\",\n    high = \"orange\")+\n  theme(axis.text.x = element_text(angle = 90))+\n  labs(                         # labels\n    x = \"Target case age\",\n    y = \"Source case age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # legend title\n  )"},{"path":"contact-tracing.html","id":"tài-nguyên-học-liệu-8","chapter":"25 Truy vết tiếp xúc","heading":"25.6 Tài nguyên học liệu","text":"https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reportinghttps://worldhealthorganization.github.io/godata/https://community-godata..int/","code":""},{"path":"survey-analysis.html","id":"survey-analysis","chapter":"26 Phân tích khảo sát","heading":"26 Phân tích khảo sát","text":"","code":""},{"path":"survey-analysis.html","id":"tổng-quan-4","chapter":"26 Phân tích khảo sát","heading":"26.1 Tổng quan","text":"Chương này trình bày việc sử dụng một số packages để phân tích khảo sát.Hầu hết các packages R dùng để phân tích khảo sát đều dựa trên survey package cho phân tích có trọng số. Chúng tôi sẽ sử dụng survey cũng như srvyr (cho phép survey mã hóa theo kiểu tidyverse) và gtsummary (cho phép survey tạo các bảng sẵn sàng cho xuất bản). Trong khi package survey ban đầu không cho phép mã hóa theo kiểu tidyverse, nhưng nó có điểm cộng là cho phép khảo sát được trọng số hóa mô hình tuyến tính tổng quát (sẽ được thêm vào chương này sau). Chúng tôi cũng sẽ minh họa bằng cách sử dụng một hàm từ package sitrep để tạo mẫu trọng số (lưu ý package này hiện chưa có trên CRAN, nhưng có thể được cài đặt từ github).Hầu hết chương này dựa trên công việc đã hoàn thành của dự án “R4Epis”; để biết code chi tiết và mẫu R-markdown xem trang github của “R4Epis”. Một số package survey dựa trên các phiên bản đầu tiên của các nghiên cứuu trường hợp EPIET.Hiện tại, chương này không đề cập đến các phép tính cỡ mẫu hoặc lấy mẫu. Để tính cỡ mẫu đơn giản, hãy xem OpenEpi. Chương GIS cơ bản trong sổ tay này sẽ có một phần về lấy mẫu ngẫu nhiên theo không gian và chương này cũng sẽ đề cập một phần về khung lấy mẫu cũng như tính toán cỡ mẫu.Dữ liệu khảo sátThời gian quan sátÁp dụng trọng sốĐối tượng thiết kế nghiên cứuPhân tích mô tảTỷ lệ được áp dụng trọng sốTỷ suất được áp dụng trọng số","code":""},{"path":"survey-analysis.html","id":"chuẩn-bị-16","chapter":"26 Phân tích khảo sát","heading":"26.2 Chuẩn bị","text":"","code":""},{"path":"survey-analysis.html","id":"packages-2","chapter":"26 Phân tích khảo sát","heading":"Packages","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R. Ở đây chúng tôi cũng minh họa việc sử dụng hàm p_load_gh() từ pacman để cài đặt một package tải từ github mà chưa được công bố trên CRAN.","code":"\n## load packages from CRAN\npacman::p_load(rio,          # File import\n               here,         # File locator\n               tidyverse,    # data management + ggplot2 graphics\n               tsibble,      # handle time series datasets\n               survey,       # for survey functions\n               srvyr,        # dplyr wrapper for survey package\n               gtsummary,    # wrapper for survey package to produce tables\n               apyramid,     # a package dedicated to creating age pyramids\n               patchwork,    # for combining ggplots\n               ggforce       # for alluvial/sankey plots\n               ) \n\n## load packages from github\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # for observation time / weighting functions\n)"},{"path":"survey-analysis.html","id":"nạp-dữ-liệu","chapter":"26 Phân tích khảo sát","heading":"Nạp dữ liệu","text":"Bộ dữ liệu ví dụ được sử dụng trong phần này:dữ liệu điều tra tỷ lệ tử vong mô phỏng.số lượng dân cư mô phỏng cho khu vực khảo sát.từ điển dữ liệu cho dữ liệu khảo sát tử vong mô phỏng.Bộ này dựa trên khảo sát đã được phê duyệt trước của hội đồng đạo đức MSF OCA. Các tập dữ liệu mô phỏng được tạo như một phần của Dự án “R4Epis”. Tất cả đều dựa trên dữ liệu được thu thập bằng KoboToolbox, đây là một phần mềm thu thập dữ liệu dựa trên Open Data Kit.Kobo cho phép bạn xuất cả dữ liệu đã thu thập, cũng như từ điển dữ liệu cho tập dữ liệu đó. Chúng tôi thực sự khuyên bạn nên làm điều này vì nó đơn giản hóa việc làm sạch dữ liệu và hữu ích cho việc tra cứu các biến/câu hỏi.MẸO: Từ điển dữ liệu Kobo có tên biến trong cột “name” của sheet “survey” (khảo sát). Các giá trị có thể có cho mỗi biến được chỉ định trong sheet “choices” (lựa chọn). Trong tab lựa chọn, “name” có giá trị rút gọn và các cột “label::english” và “label::french” chứa các nhãn mô tả đầy đủ. Sử dụng hàm msf_dict_survey() của package epidict để nhập tệp excel từ điển Kobo sẽ định dạng lại tệp này cho bạn để bạn có thể dễ dàng sử dụng để code lại.THẬN TRỌNG: Bộ dữ liệu ví dụ không giống nhau dưới dạng xuất (như trong Kobo, bạn xuất từng cấp bảng câu hỏi khác nhau) - xem phần dữ liệu khảo sát bên dưới để hợp nhất các cấp độ khác nhau.Bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương về Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau.10 hàng đầu tiên của khảo sát được hiển thị bên dưới.Chúng ta cũng muốn nhập dữ liệu về quần thể lấy mẫu để có thể tạo ra các trọng số thích hợp. Dữ liệu này có thể ở các định dạng khác nhau, tuy nhiên chúng tôi khuyên bạn nên định dạng như hình bên dưới (dữ liệu này có thể chỉ cần nhập vào excel).10 hàng đầu tiên của khảo sát được hiển thị bên dưới.Đối với khảo sát theo cụm, bạn có thể muốn thêm trọng số khảo sát ở cấp cụm. Bạn có thể đọc dữ liệu này như trên. Ngoài ra, nếu số lượng ít, chúng có thể được nhập như dưới đây dưới dạng một tibble. Trong mọi trường hợp, bạn sẽ cần có một cột với mã định danh cụm khớp với dữ liệu khảo sát của bạn và một cột khác với số lượng hộ gia đình ở từng cụm.","code":"\n# import the survey data\nsurvey_data <- rio::import(\"survey_data.xlsx\")\n\n# import the dictionary into R\nsurvey_dict <- rio::import(\"survey_dict.xlsx\") \n# import the population data\npopulation <- rio::import(\"population.xlsx\")\n## define the number of households in each cluster\ncluster_counts <- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))"},{"path":"survey-analysis.html","id":"làm-sạch-dữ-liệu-2","chapter":"26 Phân tích khảo sát","heading":"Làm sạch dữ liệu","text":"Dưới đây đảm bảo rằng cột ngày ở định dạng thích hợp. Có một số cách khác để thực hiện việc này (xem chương Làm việc với ngày tháng để biết chi tiết), tuy nhiên sử dụng từ điển để xác định ngày sẽ nhanh chóng và dễ dàng.Chúng tôi cũng tạo một biến nhóm tuổi bằng cách sử dụng hàm age_categories() từ epikit - xem phần Làm sạch dữ liệu của sổ tay để biết chi tiết. Ngoài ra, chúng tôi tạo một biến ký tự xác định các cụm khác nhau nằm trong khu vực nào.Cuối cùng, chúng tôi mã hóa lại tất cả các biến yes/thành các biến TRUE/FALSE - nếu không, các biến này không thể được sử dụng bởi các hàm tính tỷ lệ trong package survey.","code":"\n## select the date variable names from the dictionary \nDATEVARS <- survey_dict %>% \n  filter(type == \"date\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filter to match the column names of your data\n  pull(name) # select date vars\n  \n## change to dates \nsurvey_data <- survey_data %>%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## add those with only age in months to the year variable (divide by twelve)\nsurvey_data <- survey_data %>% \n  mutate(age_years = if_else(is.na(age_years), \n                             age_months / 12, \n                             age_years))\n\n## define age group variable\nsurvey_data <- survey_data %>% \n     mutate(age_group = age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## create a character variable based off groups of a different variable \nsurvey_data <- survey_data %>% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## select the yes/no variable names from the dictionary \nYNVARS <- survey_dict %>% \n  filter(type == \"yn\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filter to match the column names of your data\n  pull(name) # select yn vars\n  \n## change to dates \nsurvey_data <- survey_data %>%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))"},{"path":"survey-analysis.html","id":"dữ-liệu-khảo-sát","chapter":"26 Phân tích khảo sát","heading":"26.3 Dữ liệu khảo sát","text":"Có rất nhiều thiết kế lấy mẫu khác nhau có thể được sử dụng cho các khảo sát. Ở đây chúng tôi sẽ trình bày code cho: - Phân tầng - Cụm - Cụm phân tầngNhư đã mô tả ở trên (tùy thuộc vào cách bạn thiết kế bảng câu hỏi của mình), dữ liệu cho mỗi cấp độ sẽ được xuất dưới dạng bộ dữ liệu riêng biệt từ Kobo. Trong ví dụ của chúng tôi, có một cấp cho các hộ gia đình và một cấp cho các cá nhân trong các hộ gia đình đó.Hai cấp độ này được liên kết bởi một mã định danh duy nhất. Đối với bộ dữ liệu Kobo, biến này là “_index” ở cấp hộ gia đình, khớp với “_parent_index” ở cấp cá nhân. Thao tác này sẽ tạo các hàng mới cho hộ gia đình với mỗi cá nhân phù hợp, hãy xem chương Nối dữ liệu để biết chi tiết.","code":"\n## join the individual and household data to form a complete data set\nsurvey_data <- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## create a unique identifier by combining indeces of the two levels \nsurvey_data <- survey_data %>% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))"},{"path":"survey-analysis.html","id":"thời-gian-quan-sát","chapter":"26 Phân tích khảo sát","heading":"26.4 Thời gian quan sát","text":"Đối với các cuộc khảo sát về tỷ lệ tử vong, chúng ta muốn biết mỗi cá nhân đã có mặt tại địa điểm trong bao lâu để có thể tính toán tỷ lệ tử vong thích hợp trong khoảng thời gian nghiên cứu. Điều này không áp dụng đối với tất cả các cuộc điều tra, nhưng đặc biệt rất quan trọng đối với các cuộc điều tra tử vong vì chúng thường được khảo sát ở các quần thể di động hoặc di cư.Để làm điều này, trước tiên chúng ta xác định khoảng thời gian quan tâm, còn được gọi là khoảng thời gian hồi cứu (tức là thời gian mà những người tham gia được yêu cầu báo cáo khi trả lời câu hỏi). Sau đó, chúng ta có thể sử dụng khoảng thời gian này để đặt các ngày không thích hợp thành giá trị missing, vd: các trường hợp tử vong được báo cáo ngoài khoảng thời gian quan tâm.Sau đó, chúng ta có thể sử dụng các biến ngày của mình để xác định ngày bắt đầu và ngày kết thúc cho từng cá nhân. Chúng ta có thể sử dụng hàm find_start_date() từ sitrep để xác định ngày bắt đầu và sau đó sử dụng hàm đó để tính toán sự khác biệt giữa các ngày (người-thời gian).Ngày bắt đầu: Sự kiện phù hợp tới sớm nhất trong khoảng thời gian hồi cứu của bạn. Hoặc là ngày bắt đầu thời gian hồi cứu của bạn (mà bạn xác định trước) hoặc ngày sau khi bắt đầu hồi cứu nếu có (ví dụ: đi đến hoặc sinh ra)Ngày kết thúc: Sự kiện dừng lại thích hợp sớm nhất trong thời gian hồi cứu của bạn. Hoặc là ngày kết thúc thời gian hồi cứu hoặc ngày trước khi kết thúc hồi cứu nếu có (ví dụ: rời đi, tử vong)","code":"\n## set the start/end of recall period\n## can be changed to date variables from dataset \n## (e.g. arrival date & date questionnaire)\nsurvey_data <- survey_data %>% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# set inappropriate dates to NA based on rules \n## e.g. arrivals before start, departures departures after end\nsurvey_data <- survey_data %>%\n      mutate(\n           arrived_date = if_else(arrived_date < recall_start, \n                                 as.Date(NA),\n                                  arrived_date),\n           birthday_date = if_else(birthday_date < recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date > recall_end,\n                              as.Date(NA),\n                               left_date),\n           death_date = if_else(death_date > recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n## create new variables for start and end dates/causes\nsurvey_data <- survey_data %>% \n     ## choose earliest date entered in survey\n     ## from births, household arrivals, and camp arrivals \n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %>%\n     ## choose earliest date entered in survey\n     ## from camp departures, death and end of the study\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               )\n\n\n## label those that were present at the start/end (except births/deaths)\nsurvey_data <- survey_data %>% \n     mutate(\n       ## fill in start date to be the beginning of recall period (for those empty) \n       startdate = if_else(is.na(startdate), recall_start, startdate), \n       ## set the start cause to present at start if equal to recall period \n       ## unless it is equal to the birth date \n       startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause), \n       ## fill in end date to be end of recall period (for those empty) \n       enddate = if_else(is.na(enddate), recall_end, enddate), \n       ## set the end cause to present at end if equall to recall end \n       ## unless it is equal to the death date\n       endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Define observation time in days\nsurvey_data <- survey_data %>% \n  mutate(obstime = as.numeric(enddate - startdate))"},{"path":"survey-analysis.html","id":"áp-dụng-trọng-số","chapter":"26 Phân tích khảo sát","heading":"26.5 Áp dụng trọng số","text":"Điều quan trọng là bạn phải loại bỏ các đối tượng có lỗi trước khi thêm trọng số khảo sát. Ví dụ: nếu bạn có các quan sát với thời gian theo dõi âm, bạn sẽ cần kiểm tra các đối tượng đó (bạn có thể thực hiện việc này với hàm assert_positive_timespan() từ sitrep. Một điều khác là nếu bạn muốn bỏ các hàng trống (ví dụ: với drop_na(uid)) hoặc xóa các bản ghi trùng lặp (xem chương Loại bỏ trùng lặp trong sổ tay này để biết thêm chi tiết). Những đối tượng không có sự đồng ý tham gia nghiên cứu cũng cần phải bị xóa.Trong ví dụ này, chúng ta lọc các trường hợp muốn loại bỏ và lưu trữ chúng trong một dataframe riêng - theo cách này, chúng ta có thể mô tả những trường hợp đã bị loại khỏi khảo sát. Sau đó, chúng ta sử dụng hàm anti_join() từ dplyr để xóa những trường hợp bị loại bỏ này khỏi dữ liệu khảo sát của chúng ta.NGUY HIỂM: Bạn không thể có giá trị missing trong biến trọng số của mình hoặc bất kỳ biến nào có liên quan đến thiết kế khảo sát của bạn (ví dụ: tuổi, giới tính, biến phân tầng hoặc cụm).Như đã đề cập ở trên, chúng tôi trình bày cách thêm trọng số cho ba thiết kế nghiên cứu khác nhau (phân tầng, phân cụm và cụm phân tầng). Chúng yêu cầu thông tin về dân số gốc và/hoặc các cụm được khảo sát. Chúng tôi sẽ sử dụng code cụm phân tầng cho ví dụ này, nhưng hãy sử dụng code nào thích hợp nhất cho thiết kế nghiên cứu của bạn.","code":"\n## store the cases that you drop so you can describe them (e.g. non-consenting \n## or wrong village/cluster)\ndropped <- survey_data %>% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## use the dropped cases to remove the unused rows from the survey data set  \nsurvey_data <- anti_join(survey_data, dropped, by = names(dropped))\n# stratified ------------------------------------------------------------------\n# create a variable called \"surv_weight_strata\"\n# contains weights for each individual - by age group, sex and health district\nsurvey_data <- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## cluster ---------------------------------------------------------------------\n\n# get the number of people of individuals interviewed per household\n# adds a variable with counts of the household (parent) index variable\nsurvey_data <- survey_data %>%\n  add_count(index, name = \"interviewed\")\n\n\n## create cluster weights\nsurvey_data <- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n\n# stratified and cluster ------------------------------------------------------\n# create a survey weight for cluster and strata\nsurvey_data <- survey_data %>%\n  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)"},{"path":"survey-analysis.html","id":"đối-tượng-theo-thiết-kế-nghiên-cứu","chapter":"26 Phân tích khảo sát","heading":"26.6 Đối tượng theo thiết kế nghiên cứu","text":"Tạo đối tượng khảo sát theo thiết kế nghiên cứu của bạn. Sử dụng theo cách tương tự như dataframe để tính toán trọng số cho tỷ lệ, v.v. Đảm bảo rằng tất cả các biến cần thiết đã được tạo trước bước này.Có bốn tùy chọn, hãy đánh dấu thành bình luận những tùy chọn bạn không sử dụng: - Ngẫu nhiên đơn - Phân tầng - Cụm - Cụm phân tầngĐối với mẫu này - chúng ta sẽ giả vờ rằng chúng ta nhóm cụm các cuộc khảo sát theo hai tầng riêng biệt (khu vực và B). Vì vậy, để có được ước tính tổng thể, chúng ta cần có trọng số kết hợp của cụm và tầng.Như đã đề cập trước đây, có hai packages có sẵn để thực hiện việc này. Package cổ điển là survey và một package gọn hơn được gọi là srvyr giúp tạo các đối tượng và hàm theo phong cách tidyverse. Chúng tôi sẽ trình bày cả hai, nhưng lưu ý rằng hầu hết code trong chương này sẽ sử dụng các đối tượng dựa trên srvyr. Một ngoại lệ là package gtsummary chỉ chấp nhận các đối tượng từ package survey.","code":""},{"path":"survey-analysis.html","id":"package-survey","chapter":"26 Phân tích khảo sát","heading":"26.6.1 Package Survey","text":"Package survey sử dụng hiệu quả code base R nên không thể sử dụng các pipes (%>%) hoặc các cú pháp dplyr khác. Với package survey, chúng tôi sử dụng hàm svydesign() để xác định đối tượng khảo sát với các cụm, trọng số và tầng thích hợp.LƯU Ý: chúng ta cần sử dụng dấu ngã (~) trước các biến, điều này là package sử dụng cú pháp base R để gán các biến dựa trên công thức.","code":"\n# simple random ---------------------------------------------------------------\nbase_survey_design_simple <- svydesign(ids = ~1, # 1 for no cluster ids\n                   weights = NULL,               # No weight added\n                   strata = NULL,                # sampling was simple (no strata)\n                   data = survey_data            # have to specify the dataset\n                  )\n\n## stratified ------------------------------------------------------------------\nbase_survey_design_strata <- svydesign(ids = ~1,  # 1 for no cluster ids\n                   weights = ~surv_weight_strata, # weight variable created above\n                   strata = ~health_district,     # sampling was stratified by district\n                   data = survey_data             # have to specify the dataset\n                  )\n\n# cluster ---------------------------------------------------------------------\nbase_survey_design_cluster <- svydesign(ids = ~village_name, # cluster ids\n                   weights = ~surv_weight_cluster, # weight variable created above\n                   strata = NULL,                 # sampling was simple (no strata)\n                   data = survey_data              # have to specify the dataset\n                  )\n\n# stratified cluster ----------------------------------------------------------\nbase_survey_design <- svydesign(ids = ~village_name,      # cluster ids\n                   weights = ~surv_weight_cluster_strata, # weight variable created above\n                   strata = ~health_district,             # sampling was stratified by district\n                   data = survey_data                     # have to specify the dataset\n                  )"},{"path":"survey-analysis.html","id":"package-srvyr","chapter":"26 Phân tích khảo sát","heading":"26.6.2 Package Srvyr","text":"Với package srvyr, chúng ta có thể sử dụng hàm as_survey_design(), nó có tất cả các đối số tương tự như trên nhưng cho phép dùng các pipes (%>%), và vì vậy chúng ta không cần sử dụng dấu ngã (~).","code":"\n## simple random ---------------------------------------------------------------\nsurvey_design_simple <- survey_data %>% \n  as_survey_design(ids = 1, # 1 for no cluster ids \n                   weights = NULL, # No weight added\n                   strata = NULL # sampling was simple (no strata)\n                  )\n## stratified ------------------------------------------------------------------\nsurvey_design_strata <- survey_data %>%\n  as_survey_design(ids = 1, # 1 for no cluster ids\n                   weights = surv_weight_strata, # weight variable created above\n                   strata = health_district # sampling was stratified by district\n                  )\n## cluster ---------------------------------------------------------------------\nsurvey_design_cluster <- survey_data %>%\n  as_survey_design(ids = village_name, # cluster ids\n                   weights = surv_weight_cluster, # weight variable created above\n                   strata = NULL # sampling was simple (no strata)\n                  )\n\n## stratified cluster ----------------------------------------------------------\nsurvey_design <- survey_data %>%\n  as_survey_design(ids = village_name, # cluster ids\n                   weights = surv_weight_cluster_strata, # weight variable created above\n                   strata = health_district # sampling was stratified by district\n                  )"},{"path":"survey-analysis.html","id":"phân-tích-mô-tả-3","chapter":"26 Phân tích khảo sát","heading":"26.7 Phân tích mô tả","text":"Phân tích mô tả và trực quan hóa cơ bản được đề cập nhiều trong các chương khác của cuốn sổ tay, vì vậy chúng tôi sẽ không đi sâu vào nó ở đây. Để biết chi tiết, hãy xem các chương về Bảng mô tả, Các kiểm định thống kê cơ bản, Trình bày bảng, ggplot cơ bản và Báo cáo với R Markdown.Trong phần này, chúng ta sẽ tập trung vào cách điều tra sai số trong mẫu của bạn và trực quan hóa chúng. Chúng ta cũng sẽ xem xét việc trực quan hóa dòng dân cư trong bối cảnh khảo sát bằng cách sử dụng sơ đồ luồng alluvial/sankey.Nhìn chung, bạn nên xem xét đưa vào các phân tích mô tả sau:Số cụm, hộ gia đình và cá nhân cuối cùng được đưa vàoSố lượng cá nhân bị loại trừ và lý loại trừTrung vị (biên độ) số hộ gia đình trên một cụm và số cá thể trên một hộ gia đình","code":""},{"path":"survey-analysis.html","id":"sai-số-chọn-mẫu","chapter":"26 Phân tích khảo sát","heading":"26.7.1 Sai số chọn mẫu","text":"sánh tỷ lệ trong từng nhóm tuổi giữa mẫu của bạn và quần thể gốc. Điều này rất quan trọng để có thể làm nổi bật sai số chọn mẫu tiềm ẩn. Tương tự, bạn có thể lặp lại điều này khi xem xét sự phân bố theo giới tính.Lưu ý rằng các giá trị p từ phép kiểm định hai nhóm chỉ mang tính chất chỉ dẫn và phần thảo luận mang tính mô tả (hoặc trực quan với tháp tuổi bên dưới) về các phân bố trong mẫu nghiên cứu của bạn với quần thể gốc là quan trọng. Đó là bởi vì việc tăng cỡ mẫu sẽ hay dẫn đến những khác biệt có thể không liên quan sau khi áp dụng trọng số vào dữ liệu của bạn.","code":"\n## counts and props of the study population\nag <- survey_data %>% \n  group_by(age_group) %>% \n  drop_na(age_group) %>% \n  tally() %>% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## counts and props of the source population\npropcount <- population %>% \n  group_by(age_group) %>%\n    tally(population) %>%\n    mutate(proportion = n / sum(n))\n\n## bind together the columns of two tables, group by age, and perform a \n## binomial test to see if n/total is significantly different from population\n## proportion.\n  ## suffix here adds to text to the end of columns in each of the two datasets\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %>%\n  group_by(age_group) %>%\n  ## broom::tidy(binom.test()) makes a data frame out of the binomial test and\n  ## will add the variables p.value, parameter, conf.low, conf.high, method, and\n  ## alternative. We will only use p.value here. You can include other\n  ## columns if you want to report confidence intervals\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %>%\n  unnest(cols = c(binom)) %>% # important for expanding the binom.test data frame\n  mutate(proportion_pop = proportion_pop * 100) %>%\n  ## Adjusting the p-values to correct for false positives \n  ## (because testing multiple age groups). This will only make \n  ## a difference if you have many age categories\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %>%\n                      \n  ## Only show p-values over 0.001 (those under report as <0.001)\n  mutate(p.value = ifelse(p.value < 0.001, \n                          \"<0.001\", \n                          as.character(round(p.value, 3)))) %>% \n  \n  ## rename the columns appropriately\n  select(\n    \"Age group\" = age_group,\n    \"Study population (n)\" = n,\n    \"Study population (%)\" = proportion,\n    \"Source population (n)\" = n_pop,\n    \"Source population (%)\" = proportion_pop,\n    \"P-value\" = p.value\n  )## # A tibble: 5 x 6\n## # Groups:   Age group [5]\n##   `Age group` `Study population (n)` `Study population (%)` `Source population (n)` `Source population (%)` `P-value`\n##   <chr>                        <int>                  <dbl>                   <dbl>                   <dbl> <chr>    \n## 1 0-2                             12                 0.0256                    1360                     6.8 <0.001   \n## 2 3-14                            42                 0.0896                    7244                    36.2 <0.001   \n## 3 15-29                           64                 0.136                     5520                    27.6 <0.001   \n## 4 30-44                           52                 0.111                     3232                    16.2 0.002    \n## 5 45+                            299                 0.638                     2644                    13.2 <0.001"},{"path":"survey-analysis.html","id":"tháp-dân-số","chapter":"26 Phân tích khảo sát","heading":"26.7.2 Tháp dân số","text":"Tháp dân số (hoặc tháp tuổi-giới) là một cách dễ dàng để trực quan hóa sự phân bố trong quần thể khảo sát của bạn. Cũng nên xem xét việc tạo Bảng mô tả về độ tuổi và giới tính theo tầng khảo sát. Chúng ta sẽ minh họa bằng package apyramid vì nó cho phép các tỷ lệ được áp dụng trọng số sử dụng đối tượng theo thiết kế nghiên cứu mà chúng ta đã tạo ở trên. Các tùy chọn khác để tạo Tháp dân số được đề cập nhiều hơn trong chương đó của sổ tay. Chúng ta cũng sẽ sử dụng một hàm gọn hơn từ sitrep được gọi là plot_age_pyramid() để lưu một vài dòng code để tạo ra một biểu đồ theo tỷ lệ.Giống như với phép kiểm định sự khác biệt giữa hai nhóm chuẩn được thảo luận ở trên trong phần sai số chọn mẫu, ở đây chúng ta quan tâm đến việc trực quan hóa liệu quần thể mẫu của chúng ta có khác biệt đáng kể với quần thể gốc hay không, và liệu trọng số có sửa chữa được sự khác biệt này hay không. Để làm điều này, chúng ta sẽ sử dụng package patchwork để hiển thị các biểu đồ tạo bởi ggplot song song với nhau; chi tiết xem phần kết hợp các đồ thị trong chương Các tips với ggplot của sổ tay này. Chúng ta sẽ trực quan hóa quần thể gốc, quần thể khảo sát không trọng số và quần thể khảo sát có trọng số. Bạn cũng có thể xem xét trực quan theo từng tầng của khảo sát - bằng cách sử dụng đối số stack_by  = \"health_district\" trong ví dụ của chúng tôi ở đây (xem ?plot_age_pyramid để biết chi tiết).Lưu ý: Trục x và y được lật ngược trong tháp","code":"\n## define x-axis limits and labels ---------------------------------------------\n## (update these numbers to be the values for your graph)\nmax_prop <- 35      # choose the highest proportion you want to show \nstep <- 5           # choose the space you want beween labels \n\n## this part defines vector using the above numbers with axis breaks\nbreaks <- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## this part defines vector using the above numbers with axis limits\nlimits <- c(max_prop/100 * -1, max_prop/100)\n\n## this part defines vector using the above numbers with axis labels\nlabels <-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## create plots individually  --------------------------------------------------\n\n## plot the source population \n## nb: this needs to be collapsed for the overall population (i.e. removing health districts)\nsource_population <- population %>%\n  ## ensure that age and sex are factors\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %>% \n  group_by(age_group, sex) %>% \n  ## add the counts for each health district together \n  summarise(population = sum(population)) %>% \n  ## remove the grouping so can calculate overall proportion\n  ungroup() %>% \n  mutate(proportion = population / sum(population)) %>% \n  ## plot pyramid \n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## only show the y axis label (otherwise repeated in all three plots)\n  labs(title = \"Source population\", \n       y = \"\", \n       x = \"Age group (years)\") + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## plot the unweighted sample population \nsample_population <- plot_age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## only show the x axis label (otherwise repeated in all three plots)\n  labs(title = \"Unweighted sample population\", \n       y = \"Proportion (%)\", \n       x = \"\") + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## plot the weighted sample population \nweighted_population <- survey_design %>% \n  ## make sure the variables are factors\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %>%\n  plot_age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## only show the x axis label (otherwise repeated in all three plots)\n  labs(title = \"Weighted sample population\", \n       y = \"\", \n       x = \"\")  + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## combine all three plots  ----------------------------------------------------\n## combine three plots next to eachother using + \nsource_population + sample_population + weighted_population + \n  ## only show one legend and define theme \n  ## note the use of & for combining theme with plot_layout()\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # move legend to bottom\n        legend.title = element_blank(),                # remove title\n        text = element_text(size = 18),                # change text size\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # turn x-axis text\n       )"},{"path":"survey-analysis.html","id":"sơ-đồ-alluvialsankey","chapter":"26 Phân tích khảo sát","heading":"26.7.3 Sơ đồ alluvial/sankey","text":"Trực quan điểm bắt đầu và kết quả của từng cá nhân có thể rất hữu ích để có được cái nhìn tổng quan. Có một ứng dụng khá rõ ràng cho quần thể di động, tuy nhiên có rất nhiều ứng dụng khác như nhóm thuần tập hoặc bất kỳ tình huống nào khác trong đó có sự chuyển đổi ở các trạng thái của các cá nhân. Các sơ đồ này có một số tên khác nhau bao gồm các tập hợp alluvial, sankey và parallel - chi tiết có trong chương sổ tay về Sơ đồ và biểu đồ.","code":"\n## summarize data\nflow_table <- survey_data %>%\n  count(startcause, endcause, sex) %>%  # get counts \n  gather_set_data(x = c(\"startcause\", \"endcause\")) %>%     # change format for plotting\n  mutate(x = fct_relevel(x, c(\"startcause\", \"endcause\")),  # set startcause as first level\n         x = fct_recode(x, \n                        \"Start \\n cause\" = \"startcause\",   # add line break (\\n) after start\n                        \"End \\n cause\"   = \"endcause\")\n        )\n\n\n## plot your dataset \n  ## on the x axis is the start and end causes\n  ## gather_set_data generates an ID for each possible combination\n  ## splitting by y gives the possible start/end combos\n  ## value as n gives it as counts (could also be changed to proportion)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ## colour lines by sex \n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## fill in the label boxes grey\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## change text colour and angle (needs to be adjusted)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## adjusted y and x axes (probably needs more vertical space)\n  scale_x_discrete(name = NULL, expand = c(0, 0.2)) + \n  ## remove axis labels\n  theme(\n    title = element_text(size = 26),\n    text = element_text(size = 26),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.y = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"bottom\",                    # move legend to bottom\n    legend.title = element_blank(),                # remove title\n  )"},{"path":"survey-analysis.html","id":"tỷ-lệ-được-áp-dụng-trọng-số","chapter":"26 Phân tích khảo sát","heading":"26.8 Tỷ lệ được áp dụng trọng số","text":"Phần này sẽ trình bày chi tiết cách tạo bảng cho số lượng và tỷ lệ được áp dụng trọng số, với khoảng tin cậy và hệ số thiết kế liên quan. Có bốn tùy chọn khác nhau sử dụng các hàm từ các packages sau: survey, srvyr, sitrep và gtsummary. Để tạo ra một bảng dịch tễ học tiêu chuẩn với code tối giản, chúng tôi khuyên bạn nên dùng hàm sitrep - là một hàm có code gọn hơn của srvyr; Tuy nhiên, lưu ý rằng hàm này chưa có trên CRAN và có thể thay đổi trong tương lai. Mặt khác, code của survey có thể là code ổn định nhất trong thời gian dài, trong khi srvyr sẽ phù hợp nhất đối với các luồng công việc sử dụng tidyverse. Mặc dù các hàm gtsummary có rất nhiều tiềm năng, nhưng chúng vẫn đang được thử nghiệm và chưa hoàn thiện tại thời điểm viết chương này.","code":""},{"path":"survey-analysis.html","id":"package-survey-1","chapter":"26 Phân tích khảo sát","heading":"26.8.1 Package survey","text":"Chúng ta có thể sử dụng hàm svyciprop() từ survey để lấy tỷ lệ có trọng số và khoảng tin cậy 95% đi kèm. Một hệ số thiết kế thích hợp có thể được trích xuất bằng cách sử dụng hàm svymean() chứ không phải hàm svyprop(). Cần lưu ý rằng svyprop() dường như chỉ chấp nhận các biến có giá trị từ 0 đến 1 (hoặc TRUE/FALSE), vì vậy các biến phân loại sẽ không hoạt động.LƯU Ý: Các hàm từ survey cũng chấp nhận các đối tượng thiết kế từ srvyr, nhưng ở đây chúng tôi đã sử dụng đối tượng thiết kế từ package survey với mục đích tạo sự nhất quánChúng ta có thể kết hợp các hàm từ survey được hiển thị ở trên với một hàm mà chúng ta tự định nghĩa như bên dưới, được gọi là svy_prop; và sau đó chúng ta có thể sử dụng hàm đó cùng với hàm map() từ package purrr để lặp qua một số biến và tạo một bảng. Xem chương Lặp, vòng lặp, và danh sách để biết chi tiết về purrr.","code":"\n## produce weighted counts \nsvytable(~died, base_survey_design)## died\n##      FALSE       TRUE \n## 1406244.43   76213.01\n## produce weighted proportions\nsvyciprop(~died, base_survey_design, na.rm = T)##               2.5% 97.5%\n## died 0.0514 0.0208  0.12\n## get the design effect \nsvymean(~died, base_survey_design, na.rm = T, deff = T) %>% \n  deff()## diedFALSE  diedTRUE \n##  3.755508  3.755508\n# Define function to calculate weighted counts, proportions, CI and design effect\n# x is the variable in quotation marks \n# design is your survey design object\n\nsvy_prop <- function(design, x) {\n  \n  ## put the variable of interest in a formula \n  form <- as.formula(paste0( \"~\" , x))\n  ## only keep the TRUE column of counts from svytable\n  weighted_counts <- svytable(form, design)[[2]]\n  ## calculate proportions (multiply by 100 to get percentages)\n  weighted_props <- svyciprop(form, design, na.rm = TRUE) * 100\n  ## extract the confidence intervals and multiply to get percentages\n  weighted_confint <- confint(weighted_props) * 100\n  ## use svymean to calculate design effect and only keep the TRUE column\n  design_eff <- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## combine in to one data frame\n  full_table <- cbind(\n    \"Variable\"        = x,\n    \"Count\"           = weighted_counts,\n    \"Proportion\"      = weighted_props,\n    weighted_confint, \n    \"Design effect\"   = design_eff\n    )\n  \n  ## return table as a dataframe\n  full_table <- data.frame(full_table, \n             ## remove the variable names from rows (is a separate column now)\n             row.names = NULL)\n  \n  ## change numerics back to numeric\n  full_table[ , 2:6] <- as.numeric(full_table[, 2:6])\n  \n  ## return dataframe\n  full_table\n}\n\n## iterate over several variables to create a table \npurrr::map(\n  ## define variables of interest\n  c(\"left\", \"died\", \"arrived\"), \n  ## state function using and arguments for that function (design)\n  svy_prop, design = base_survey_design) %>% \n  ## collapse list in to a single data frame\n  bind_rows() %>% \n  ## round \n  mutate(across(where(is.numeric), round, digits = 1))##   Variable    Count Proportion X2.5. X97.5. Design.effect\n## 1     left 701199.1       47.3  39.2   55.5           2.4\n## 2     died  76213.0        5.1   2.1   12.1           3.8\n## 3  arrived 761799.0       51.4  40.9   61.7           3.9"},{"path":"survey-analysis.html","id":"package-srvyr-1","chapter":"26 Phân tích khảo sát","heading":"26.8.2 Package srvyr","text":"Với srvyr chúng ta có thể sử dụng cú pháp của package dplyr để tạo một bảng. Lưu ý rằng hàm survey_mean() được sử dụng, đối số tỷ lệ được chỉ định và hàm tương tự cũng được sử dụng để tính toán hệ số thiết kế. Điều này là srvyr bao gồm cả hai hàm svyciprop() và svymean() của package survey được sử dụng trong phần trên.LƯU Ý: Có vẻ như không thể lấy tỷ lệ từ các biến phân loại bằng srvyr, nếu bạn cần điều này, hãy xem phần bên dưới sử dụng sitrepỞ đây, chúng ta cũng có thể viết một hàm để sau đó lặp qua nhiều biến bằng cách sử dụng package purrr. Xem chương Lặp, vòng lặp, và danh sách trong sổ tay này để biết chi tiết về purrr.","code":"\n## use the srvyr design object\nsurvey_design %>% \n  summarise(\n    ## produce the weighted counts \n    counts = survey_total(died), \n    ## produce weighted proportions and confidence intervals \n    ## multiply by 100 to get a percentage \n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produce the design effect \n    deff = survey_mean(died, deff = TRUE)) %>% \n  ## only keep the rows of interest\n  ## (drop standard errors and repeat proportion calculation)\n  select(counts, props, props_low, props_upp, deff_deff)##     counts    props props_low props_upp deff_deff\n## 1 76213.01 5.140991  2.082773  12.13328  3.755508\n# Define function to calculate weighted counts, proportions, CI and design effect\n# design is your survey design object\n# x is the variable in quotation marks \n\n\nsrvyr_prop <- function(design, x) {\n  \n  summarise(\n    ## using the survey design object\n    design, \n    ## produce the weighted counts \n    counts = survey_total(.data[[x]]), \n    ## produce weighted proportions and confidence intervals \n    ## multiply by 100 to get a percentage \n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produce the design effect \n    deff = survey_mean(.data[[x]], deff = TRUE)) %>% \n  ## add in the variable name\n  mutate(variable = x) %>% \n  ## only keep the rows of interest\n  ## (drop standard errors and repeat proportion calculation)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## iterate over several variables to create a table \npurrr::map(\n  ## define variables of interest\n  c(\"left\", \"died\", \"arrived\"), \n  ## state function using and arguments for that function (design)\n  ~srvyr_prop(.x, design = survey_design)) %>% \n  ## collapse list in to a single data frame\n  bind_rows()##   variable    counts     props props_low props_upp deff_deff\n## 1     left 701199.14 47.299782 39.235598  55.50736  2.379761\n## 2     died  76213.01  5.140991  2.082773  12.13328  3.755508\n## 3  arrived 761799.05 51.387583 40.927349  61.72766  3.925504"},{"path":"survey-analysis.html","id":"package-sitrep","chapter":"26 Phân tích khảo sát","heading":"26.8.3 Package sitrep","text":"Hàm tab_survey() từ sitrep là một hàm gọn hơn cho srvyr, cho phép bạn tạo các bảng có trọng số với code tối giản. Nó cũng cho phép bạn tính toán tỷ lệ có trọng số cho các biến phân loại.","code":"\n## using the survey design object\nsurvey_design %>% \n  ## pass the names of variables of interest unquoted\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # calculate the design effect\n             pretty = TRUE  # merge the proportion and 95%CI\n             )## Warning: removing 257 missing value(s) from `education_level`## # A tibble: 9 x 5\n##   variable        value            n  deff ci                \n##   <chr>           <chr>        <dbl> <dbl> <chr>             \n## 1 arrived         TRUE       761799.  3.93 51.4% (40.9--61.7)\n## 2 arrived         FALSE      720658.  3.93 48.6% (38.3--59.1)\n## 3 left            TRUE       701199.  2.38 47.3% (39.2--55.5)\n## 4 left            FALSE      781258.  2.38 52.7% (44.5--60.8)\n## 5 died            TRUE        76213.  3.76 5.1% (2.1--12.1)  \n## 6 died            FALSE     1406244.  3.76 94.9% (87.9--97.9)\n## 7 education_level higher     171644.  4.70 42.4% (26.9--59.7)\n## 8 education_level primary    102609.  2.37 25.4% (16.2--37.3)\n## 9 education_level secondary  130201.  6.68 32.2% (16.5--53.3)"},{"path":"survey-analysis.html","id":"package-gtsummary","chapter":"26 Phân tích khảo sát","heading":"26.8.4 Package gtsummary","text":"Với gtsummary, dường như vẫn chưa có hàm sẵn có để thêm khoảng tin cậy hoặc hệ số thiết kế. Ở đây chúng tôi trình bày cách định nghĩa một hàm để thêm khoảng tin cậy và sau đó thêm khoảng tin cậy vào bảng được tạo bằng gtsummary với hàm tbl_svysummary().\n          1\n          \n           \n          n (%)\n          ","code":"\nconfidence_intervals <- function(data, variable, by, ...) {\n  \n  ## extract the confidence intervals and multiply to get percentages\n  props <- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## extract the confidence intervals \n  as.numeric(confint(props) * 100) %>% ## make numeric and multiply for percentage\n    round(., digits = 1) %>%           ## round to one digit\n    c(.) %>%                           ## extract the numbers from matrix\n    paste0(., collapse = \"-\")          ## combine to single character\n}\n\n## using the survey package design object\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## define variables want to include\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %>% ## define stats of interest\n  add_n() %>%  ## add the weighted total \n  add_stat(fns = everything() ~ confidence_intervals) %>% ## add CIs\n  ## modify the column headers\n  modify_header(\n    list(\n      n ~ \"**Weighted total (N)**\",\n      stat_0 ~ \"**Weighted Count**\",\n      add_stat_1 ~ \"**95%CI**\"\n    )\n    )"},{"path":"survey-analysis.html","id":"tỷ-suất-được-áp-dụng-trọng-số","chapter":"26 Phân tích khảo sát","heading":"26.9 Tỷ suất được áp dụng trọng số","text":"Tương tự đối với các tỷ lệ được áp dụng trọng số (chẳng hạn như tỷ lệ tử vong), bạn có thể sử dụng package survey hoặc srvyr. Tương tự, bạn có thể viết các hàm (tương tự như ở trên) để lặp qua một số biến. Bạn cũng có thể tạo một hàm cho gtsummary như trên nhưng hiện tại nó không có chức năng sẵn có.","code":""},{"path":"survey-analysis.html","id":"package-survey-2","chapter":"26 Phân tích khảo sát","heading":"26.9.1 Package survey","text":"","code":"\nratio <- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci <- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)##       obstime    2.5 %   97.5 %\n## died 5.981922 1.194294 10.76955"},{"path":"survey-analysis.html","id":"package-srvyr-2","chapter":"26 Phân tích khảo sát","heading":"26.9.2 Package srvyr","text":"","code":"\nsurvey_design %>% \n  ## survey ratio used to account for observation time \n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )##   mortality mortality_low mortality_upp\n## 1  5.981922     0.3490176      11.61483"},{"path":"survey-analysis.html","id":"tài-nguyên-học-liệu-9","chapter":"26 Phân tích khảo sát","heading":"26.10 Tài nguyên học liệu","text":"UCLA stats pageAnalyze survey data freesrvyr packgegtsummary packageEPIET survey case studies","code":""},{"path":"survival-analysis.html","id":"survival-analysis","chapter":"27 Phân tích sống còn","heading":"27 Phân tích sống còn","text":"","code":""},{"path":"survival-analysis.html","id":"tổng-quan-5","chapter":"27 Phân tích sống còn","heading":"27.1 Tổng quan","text":"Phân tích sống còn tập trung mô tả cho một cá thể hay một nhóm cá thể nhất định. Một điểm xác định của một sự kiện được gọi là failure (như là xuất hiện bệnh, chữa khỏi bệnh, tử vong, tái phát sau khi đáp ứng với điều trị…) mà xảy ra sau một khoảng thời gian được gọi là failure time (thời gian dẫn đến sự kiện) (hoặc follow-time (thời gian theo dõi) trong nghiên cứu thuần tập/nghiên cứu dựa vào dân số) trong suốt thời gian các cá thể được quan sát. Để xác định thời gian dẫn đến sự kiện, chúng ta cần xác định thời điểm bắt đầu (có thể là ngày nhận vào, ngày chẩn đoán…).Mục tiêu suy luận đối với phân tích sống còn là khoảng thời gian giữa thời điểm bắt đầu và thời điểm sự kiện xảy ra.\nTrong nghiên cứu y học hiện nay, phân tích sống còn được sử dụng rộng rãi trong các nghiên cứu lâm sàng để đánh giá hiệu quả của một phương phương điều trị hoặc để đánh giá tình trạng sống còn của một số các biện pháp điều trị ung thư.Nó thường được diễn đạt qua survival probability (xác suất sống sót) là xác suất mà sự hiện đang quan tâm không xảy ra trong khoảng thời gian t.Censoring: Censoring xảy ra khi sự kiện đang quan tâm không xảy ra trong một số cá thể ở cuối quá trình theo dõi, và vì thế, thời gian thật dẫn đến sự kiện của những cá thể này là không biết. Trong chương này, chúng tôi tập trung chủ yếu vào sự kiện không xảy ra về phía bên phải. Để biết thêm chi tiết về các loại censoring và phân tích sống còn nói chung, xem thêm các tài liệu tham khảo.","code":""},{"path":"survival-analysis.html","id":"chuẩn-bị-17","chapter":"27 Phân tích sống còn","heading":"27.2 Chuẩn bị","text":"","code":""},{"path":"survival-analysis.html","id":"gọi-packages-7","chapter":"27 Phân tích sống còn","heading":"Gọi packages","text":"Survival là gói lệnh được sử dụng rộng rãi nhất để phân tích sống còn bằng R. Đầu tiên, chúng ta cài đặt và sau đó tải gói lệnh này cũng như các gói lệnh khác sẽ được sử dụng trong phần này:Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, giúp cài đặt package nếu cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các package đã được cài đặt bằng hàm library() trong base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.Chương này sẽ tìm hiểu phân tích sống còn bằng cách dùng bộ số liệu linelist đã được sử dụng trong hầu hết các chương trước và thay đổi một vài điểm để tạo ra bộ số liệu phù hợp cho phân tích sống còn.","code":""},{"path":"survival-analysis.html","id":"nhập-bộ-số-liệu","chapter":"27 Phân tích sống còn","heading":"Nhập bộ số liệu","text":"Chúng ta nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Để tiện làm theo, bấm để tải số liệu linelist “đã được làm sạch” (dưới dạng tệp .rds). Nhập số liệu này bằng hàm import() từ package rio (hàm này chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv – xem chi tiết trong chương [Nhập xuất số liệu].","code":"\n# import linelist\nlinelist_case_data <- rio::import(\"linelist_cleaned.rds\")"},{"path":"survival-analysis.html","id":"quản-lý-và-chuyển-đổi-số-liệu","chapter":"27 Phân tích sống còn","heading":"Quản lý và chuyển đổi số liệu","text":"Nói ngắn gọn, số liệu cho phân tích sống còn có ba đặc điểm sau:biến phụ thuộc hay đáp ứng là khoảng thời gian từ thời điểm bắt đầu đến thời điểm một sự kiện (được xác định rõ) xảy ra,quan sát censored là các quan sát mà sự kiện quan tâm không xảy ra tại thời điểm phân tích số liệu, vàcác biến dự đoán hay giải thích có ảnh hưởng đến thời gian dẫn đến sự kiện mà chúng ta muốn đánh giá hoặc kiểm soát.đó, chúng ta sẽ tạo các biến số khác nhau tuân theo cấu trúc dữ liệu đó và tiến hành phân tích sống còn.Chúng ta định nghĩa:một bộ số liệu mới linelist_surv cho phân tích nàysự kiện quan tâm là “tử vong” (vì thế xác suất sống sót sẽ là xác suất sống trong một khoảng thời gian nhất định sau thời đểm bắt đầu),thời gian theo dõi (futime) là số ngày giữa thời điểm khởi phát bệnh và thời điểm có kết cục,bệnh nhân censored là những người đã hồi phục hoặc những người không biết kết cục, ví dụ như sự kiện “tử vong” không được quan sát (event=0).THẬN TRỌNG: Trong một nghiên cứu thuần tập thực tế, thông tin về thời điểm bắt đầu và thời điểm kết thúc theo dõi của các cá thể là được biết, đó chúng ta sẽ loại bỏ các quan sát không có ngày bắt đầu và ngày có kết cục. Ngoài ra, các trường hợp có ngày khởi phát bệnh trễ hơn ngày có kết cục cũng bị loại bỏ vì các trường hợp này được xem là sai.MẸO: Khi lọc đến các giá trị lớn hơn (>) hoặc nhỏ hơn (<) một ngày có thể loại bỏ các hàng có giá trị missing, nên khi áp dụng lọc sai ngày cũng sẽ loại bỏ các hàng có ngày bị thiếu.Sau đó, chúng ta sử dụng hàm case_when() để tạo ra một cột age_cat_small mà chỉ có 3 giá trị của nhóm tuổi.MẸO: Chúng ta có thể kiểm tra lại các cột mới đã được tạo ra bằng cách thực hiện tóm tắt đối với biến số futime avà bảng chéo giữa biến số event và biến kết cục outcome. Bên cạnh việc kiểm tra này, đây là một thói quen tốt để biết được thời gian theo dõi trung vị khi giải thích kết quả của phân tích sống còn.Bây giờ, chúng ta tạo bảng chéo giữa biến nhóm tuổi mới age_cat_small và biến nhóm tuổi cũ age_cat để đảm bảo tính chính xác của việc chuyển đổi số liệuBây giờ, chúng ta xem lại 10 quan sát đầu tiên của bộ số liệu linelist_surv bằng cách xem xét các biến cụ thể (bao gồm cả các biến mới được tạo ra).Chúng ta cũng có thể tạo bảng chéo giữa cột biến age_cat_small và gender để biết thêm chi tiết về sự phân bố của biến số mới này theo giới tính. Chúng ta sử dụng hàm tabyl() và hàm adorn từ package janitor như được mô tả trong chương Bảng mô tả.","code":"\n#create a new data called linelist_surv from the linelist_case_data\n\nlinelist_surv <-  linelist_case_data %>% \n     \n  dplyr::filter(\n       # remove observations with wrong or missing dates of onset or date of outcome\n       date_outcome > date_onset) %>% \n  \n  dplyr::mutate(\n       # create the event var which is 1 if the patient died and 0 if he was right censored\n       event = ifelse(is.na(outcome) | outcome == \"Recover\", 0, 1), \n    \n       # create the var on the follow-up time in days\n       futime = as.double(date_outcome - date_onset), \n    \n       # create a new age category variable with only 3 strata levels\n       age_cat_small = dplyr::case_when( \n            age_years < 5  ~ \"0-4\",\n            age_years >= 5 & age_years < 20 ~ \"5-19\",\n            age_years >= 20   ~ \"20+\"),\n       \n       # previous step created age_cat_small var as character.\n       # now convert it to factor and specify the levels.\n       # Note that the NA values remain NA's and are not put in a level \"unknown\" for example,\n       # since in the next analyses they have to be removed.\n       age_cat_small = fct_relevel(age_cat_small, \"0-4\", \"5-19\", \"20+\")\n       )\nsummary(linelist_surv$futime)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    1.00    6.00   10.00   11.98   16.00   64.00\n# cross tabulate the new event var and the outcome var from which it was created\n# to make sure the code did what it was intended to\nlinelist_surv %>% \n  tabyl(outcome, event)##  outcome    0    1\n##    Death    0 1952\n##  Recover 1547    0\n##     <NA> 1040    0\nlinelist_surv %>% \n  tabyl(age_cat_small, age_cat)##  age_cat_small 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ NA_\n##            0-4 834   0     0     0     0     0     0   0   0\n##           5-19   0 852   717   575     0     0     0   0   0\n##            20+   0   0     0     0   862   554    69   5   0\n##           <NA>   0   0     0     0     0     0     0   0  71\nlinelist_surv %>% \n  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %>% \n  head(10)##    case_id age_cat_small date_onset date_outcome outcome event futime\n## 1   8689b7           0-4 2014-05-13   2014-05-18 Recover     0      5\n## 2   11f8ea           20+ 2014-05-16   2014-05-30 Recover     0     14\n## 3   893f25           0-4 2014-05-21   2014-05-29 Recover     0      8\n## 4   be99c8          5-19 2014-05-22   2014-05-24 Recover     0      2\n## 5   07e3e8          5-19 2014-05-27   2014-06-01 Recover     0      5\n## 6   369449           0-4 2014-06-02   2014-06-07   Death     1      5\n## 7   f393b4           20+ 2014-06-05   2014-06-18 Recover     0     13\n## 8   1389ca           20+ 2014-06-05   2014-06-09   Death     1      4\n## 9   2978ac          5-19 2014-06-06   2014-06-15   Death     1      9\n## 10  fc15ef          5-19 2014-06-16   2014-07-09 Recover     0     23\nlinelist_surv %>% \n  tabyl(gender, age_cat_small, show_na = F) %>% \n  adorn_totals(c(\"row\", \"col\")) %>% \n  adorn_percentages() %>% \n  adorn_pct_formatting() %>% \n  adorn_ns(position = \"front\")##  gender         0-4         5-19          20+         Total\n##       f 482 (22.4%) 1184 (54.9%)  490 (22.7%) 2156 (100.0%)\n##       m 325 (15.0%)  880 (40.6%)  960 (44.3%) 2165 (100.0%)\n##   Total 807 (18.7%) 2064 (47.8%) 1450 (33.6%) 4321 (100.0%)"},{"path":"survival-analysis.html","id":"cơ-bản-về-phân-tích-sống-còn","chapter":"27 Phân tích sống còn","heading":"27.3 Cơ bản về phân tích sống còn","text":"","code":""},{"path":"survival-analysis.html","id":"tạo-ra-đối-tượng-kiểu-surv","chapter":"27 Phân tích sống còn","heading":"Tạo ra đối tượng kiểu surv","text":"Đầu tiên, chúng ta dùng hàm Surv() từ package survival để tạo ra một ‘đối tượng surv’ từ cột follow-time và event.Kết quả của bước này tạo ra một đối tượng Surv bao gồm thông tin thời gian và có hay không sự kiện quan tâm (tử vong) được nhận thấy. Đối tượng này sẽ được sử dụng sau này ở phía bên phải trong công thức của những mô hình tiếp theo (xem tài liệu).Để xem lại số liệu, đây là 10 hàng đầu tiên của bộ số liệu linelist_surv data, chỉ hiển thị các cột quan trọng.Và đây là 10 thành phần đầu tiên của đối tượng survobj. Về bản chất, nó xuất ra đưới dạng một véc tơ của biến số thời gian theo dõi, dấu “+” là đại điện cho một quan sát censored ở phía bên phải. Xem cách các con số sắp xếp bên trên và bên dưới.","code":"\n# Use Suv() syntax for right-censored data\nsurvobj <- Surv(time = linelist_surv$futime,\n                event = linelist_surv$event)\nlinelist_surv %>% \n  select(case_id, date_onset, date_outcome, futime, outcome, event) %>% \n  head(10)##    case_id date_onset date_outcome futime outcome event\n## 1   8689b7 2014-05-13   2014-05-18      5 Recover     0\n## 2   11f8ea 2014-05-16   2014-05-30     14 Recover     0\n## 3   893f25 2014-05-21   2014-05-29      8 Recover     0\n## 4   be99c8 2014-05-22   2014-05-24      2 Recover     0\n## 5   07e3e8 2014-05-27   2014-06-01      5 Recover     0\n## 6   369449 2014-06-02   2014-06-07      5   Death     1\n## 7   f393b4 2014-06-05   2014-06-18     13 Recover     0\n## 8   1389ca 2014-06-05   2014-06-09      4   Death     1\n## 9   2978ac 2014-06-06   2014-06-15      9   Death     1\n## 10  fc15ef 2014-06-16   2014-07-09     23 Recover     0\n#print the 50 first elements of the vector to see how it presents\nhead(survobj, 10)##  [1]  5+ 14+  8+  2+  5+  5  13+  4   9  23+"},{"path":"survival-analysis.html","id":"thực-hiện-các-phân-tích-ban-đầu","chapter":"27 Phân tích sống còn","heading":"Thực hiện các phân tích ban đầu","text":"Sau đó, chúng ta bắt đầu phân tích bằng cách sử dụng hàm survfit() để tạo ra một đối tượng survfit, phù hợp với các tính toán mặc định cho các ước tính Kaplan Meier (KM) của đường cong sống sót chung (cận biên), mà thực tế là một hàm bước với các bước nhảy tại thời điểm sự kiện được quan sát. Đối tượng survfit object cuối cùng chứa đựng một hoặc nhiều đường cong sống sót và được tạo ra bằng cách sử dụng đối tượng Surv làm biến đáp ứng trong công thức của mô hình.LƯU Ý: Ước tính Kaplan-Meier là một ước tính khả dĩ tối đa phi tham số của hàm sống còn (xem mục Tài nguyên học liệu để biết thêm thông tin).Tóm tắt của đối tượng survfit này sẽ cho một bảng được gọi là life table (bảng sống còn). Đối với mỗi bước thời gian theo dõi (time) là nơi một sự kiện xảy ra (theo thứ tự tăng dần):số người có nguy cơ dẫn đến sự kiện (người chưa có sự kiện cũng như sự kiện chưa xảy ra: n.risk)những người có sự kiện (n.event)và từ những dữ kiện trên tính xác suất không đưa đến sự kiện (xác suất không tử vong, hoặc sống sót sau khoảng thời gian cụ thể đó)cuối cùng, sai số chuẩn và khoảng tin cậy cho xác suất đó được tính toán và trình bàyChúng ta thực hiện các ước tính KM bằng cách sử dụng công thức với đối tượng Surv trước đó “survobj” làm biến đáp ứng. “~ 1” diễn đạt rẳng chúng ta đang thực hiện mô hình sống còn tổng quát.Khi sử dụng hàm summary(), chúng ta có thể thêm tùy chọn times và cụ thể các thời điểm nhất định mà chúng ta muốn xem các thông tin sống cònChúng ta cũng có thể sử dụng hàm print(). Đối số print.rmean = TRUE được sử dụng để có được giá trị trung bình của thời gian sống sót và sai số chuẩn (se).LƯU Ý: Thời gian sống sót trung bình giới hạn là một đo lường sống còn cụ thể ngày càng được sử dụng trong phân tích sống còn của bệnh ung thư và thường được định nghĩa là khu vực dưới đường cong, khi chúng ta quan sát bệnh nhân cho đến thời gian giới hạn T (xem phần Tài nguyên học liệu để biết thêm chi tiết).MẸO: Chúng ta có thể tạo ra đối tượng surv trực tiếp trong hàm survfit() và tiết kiệm một dòng lệnh. Thực hiện điều này như sau: linelistsurv_quick <-  survfit(Surv(futime, event) ~ 1, data=linelist_surv).","code":"\n# fit the KM estimates using a formula where the Surv object \"survobj\" is the response variable.\n# \"~ 1\" signifies that we run the model for the overall survival  \nlinelistsurv_fit <-  survival::survfit(survobj ~ 1)\n\n#print its summary for more details\nsummary(linelistsurv_fit)## Call: survfit(formula = survobj ~ 1)\n## \n##  time n.risk n.event survival std.err lower 95% CI upper 95% CI\n##     1   4539      30    0.993 0.00120        0.991        0.996\n##     2   4500      69    0.978 0.00217        0.974        0.982\n##     3   4394     149    0.945 0.00340        0.938        0.952\n##     4   4176     194    0.901 0.00447        0.892        0.910\n##     5   3899     214    0.852 0.00535        0.841        0.862\n##     6   3592     210    0.802 0.00604        0.790        0.814\n##     7   3223     179    0.757 0.00656        0.745        0.770\n##     8   2899     167    0.714 0.00700        0.700        0.728\n##     9   2593     145    0.674 0.00735        0.660        0.688\n##    10   2311     109    0.642 0.00761        0.627        0.657\n##    11   2081     119    0.605 0.00788        0.590        0.621\n##    12   1843      89    0.576 0.00809        0.560        0.592\n##    13   1608      55    0.556 0.00823        0.540        0.573\n##    14   1448      43    0.540 0.00837        0.524        0.556\n##    15   1296      31    0.527 0.00848        0.511        0.544\n##    16   1152      48    0.505 0.00870        0.488        0.522\n##    17   1002      29    0.490 0.00886        0.473        0.508\n##    18    898      21    0.479 0.00900        0.462        0.497\n##    19    798       7    0.475 0.00906        0.457        0.493\n##    20    705       4    0.472 0.00911        0.454        0.490\n##    21    626      13    0.462 0.00932        0.444        0.481\n##    22    546       8    0.455 0.00948        0.437        0.474\n##    23    481       5    0.451 0.00962        0.432        0.470\n##    24    436       4    0.447 0.00975        0.428        0.466\n##    25    378       4    0.442 0.00993        0.423        0.462\n##    26    336       3    0.438 0.01010        0.419        0.458\n##    27    297       1    0.436 0.01017        0.417        0.457\n##    29    235       1    0.435 0.01030        0.415        0.455\n##    38     73       1    0.429 0.01175        0.406        0.452\n#print its summary at specific times\nsummary(linelistsurv_fit, times = c(5,10,20,30,60))## Call: survfit(formula = survobj ~ 1)\n## \n##  time n.risk n.event survival std.err lower 95% CI upper 95% CI\n##     5   3899     656    0.852 0.00535        0.841        0.862\n##    10   2311     810    0.642 0.00761        0.627        0.657\n##    20    705     446    0.472 0.00911        0.454        0.490\n##    30    210      39    0.435 0.01030        0.415        0.455\n##    60      2       1    0.429 0.01175        0.406        0.452\n# print linelistsurv_fit object with mean survival time and its se. \nprint(linelistsurv_fit, print.rmean = TRUE)## Call: survfit(formula = survobj ~ 1)\n## \n##          n     events     *rmean *se(rmean)     median    0.95LCL    0.95UCL \n##   4539.000   1952.000     33.105      0.539     17.000     16.000     18.000 \n##     * restricted mean with upper limit =  64"},{"path":"survival-analysis.html","id":"mối-nguy-tích-lũy","chapter":"27 Phân tích sống còn","heading":"Mối nguy tích lũy","text":"Bên cạnh hàm summary(), chúng ta có thể sử dụng hàm str(), hàm này cho biết chi tiết hơn vể cấu trúc của các đối tượng trong hàm survfit(). Cấu trúc này là một danh sách của 16 thành phần.Một thành phần quan trọng trong số những thành phần này là: cumhaz, một véc tơ kiểu số. Thành phần này có thể được vẽ để hiển thị mối nguy tích lũy, với mối nguy là tỷ suất xảy ra sự kiện tức thời (xem tài liệu tham khảo).","code":"\nstr(linelistsurv_fit)## List of 16\n##  $ n        : int 4539\n##  $ time     : num [1:59] 1 2 3 4 5 6 7 8 9 10 ...\n##  $ n.risk   : num [1:59] 4539 4500 4394 4176 3899 ...\n##  $ n.event  : num [1:59] 30 69 149 194 214 210 179 167 145 109 ...\n##  $ n.censor : num [1:59] 9 37 69 83 93 159 145 139 137 121 ...\n##  $ surv     : num [1:59] 0.993 0.978 0.945 0.901 0.852 ...\n##  $ std.err  : num [1:59] 0.00121 0.00222 0.00359 0.00496 0.00628 ...\n##  $ cumhaz   : num [1:59] 0.00661 0.02194 0.05585 0.10231 0.15719 ...\n##  $ std.chaz : num [1:59] 0.00121 0.00221 0.00355 0.00487 0.00615 ...\n##  $ type     : chr \"right\"\n##  $ logse    : logi TRUE\n##  $ conf.int : num 0.95\n##  $ conf.type: chr \"log\"\n##  $ lower    : num [1:59] 0.991 0.974 0.938 0.892 0.841 ...\n##  $ upper    : num [1:59] 0.996 0.982 0.952 0.91 0.862 ...\n##  $ call     : language survfit(formula = survobj ~ 1)\n##  - attr(*, \"class\")= chr \"survfit\""},{"path":"survival-analysis.html","id":"vẽ-đường-cong-kaplan-meir","chapter":"27 Phân tích sống còn","heading":"Vẽ đường cong Kaplan-Meir","text":"Sau khi ước tính KM đã được fit, chúng ta có thể hình dung xác suất sống sót qua một thời gian nhất định bằng cách dùng hàm plot() để vẽ “đường cong Kaplan-Meier”. Nói cách khác, đường cong bên dưới là một minh họa đường cong sống sót quy ước của toàn bộ nhóm bệnh nhân.Chúng ta có thể nhanh chóng xác minh thời gian theo dõi tối thiểu và tối đa trên đường cong.Một cách dễ dàng để giải thích là phát biểu rằng, tại thời điểm 0, tất cả người tham gia đều sống và xác suất sống sót khi đó là 100%.Xác suất ngày giảm dần theo thời gian khi có bệnh nhân tử vong. Tỷ lệ người tham gia sống sót sau 60 ngày là khoảng 40%.Khoảng tin cậy của các ước tính KM cũng được vẽ mặc định trên biểu đồ và có thể bị loại bỏ bằng cách thêm tùy chọn conf.int = FALSE vào trong lệnh plot().Vì sự kiện quan tâm là “tử vong”, việc vẽ một đường cong mô tả phần bù tỷ lệ sống sót sẽ đưa đến việc vẽ tỷ lệ tử vong tích lũy. Điều này có thể được thực hiện với hàm lines(), bổ sung thông tin trên biểu đồ hiện có.","code":"\nplot(linelistsurv_fit, \n     xlab = \"Days of follow-up\",    # x-axis label\n     ylab=\"Survival Probability\",   # y-axis label\n     main= \"Overall survival curve\" # figure title\n     )\n# original plot\nplot(\n  linelistsurv_fit,\n  xlab = \"Days of follow-up\",       \n  ylab = \"Survival Probability\",       \n  mark.time = TRUE,              # mark events on the curve: a \"+\" is printed at every event\n  conf.int = FALSE,              # do not plot the confidence interval\n  main = \"Overall survival curve and cumulative mortality\"\n  )\n\n# draw an additional curve to the previous plot\nlines(\n  linelistsurv_fit,\n  lty = 3,             # use different line type for clarity\n  fun = \"event\",       # draw the cumulative events instead of the survival \n  mark.time = FALSE,\n  conf.int = FALSE\n  )\n\n# add a legend to the plot\nlegend(\n  \"topright\",                               # position of legend\n  legend = c(\"Survival\", \"Cum. Mortality\"), # legend text \n  lty = c(1, 3),                            # line types to use in the legend\n  cex = .85,                                # parametes that defines size of legend text\n  bty = \"n\"                                 # no box type to be drawn for the legend\n  )"},{"path":"survival-analysis.html","id":"so-sánh-các-đường-cong-sống-sót","chapter":"27 Phân tích sống còn","heading":"27.4 So sánh các đường cong sống sót","text":"Để sánh các đường cong sống sót của những nhóm người tham gia hoặc bệnh nhân khác nhau, đầu tiên chúng ta có thể cần xem xét các đường cong tương ứng của các nhóm và sau đó thực hiện các kiểm định để lượng giá sự khác biệt giữa các nhóm độc lập. sánh này có thể liên quan đến các nhóm dựa vào giới tính, tuổi tác, điều trị, bệnh đi kèm,…","code":""},{"path":"survival-analysis.html","id":"kiểm-định-log-rank","chapter":"27 Phân tích sống còn","heading":"Kiểm định Log rank","text":"Kiểm định log rank là một kiểm định phổ biến để sánh toàn bộ quá trình sống sót giữa hai hay nhiều nhóm độc lập và có thể xem xét các đường cong sống sót có tương đồng (chồng chéo) hay không (giả thuyết vô hiệu là không có sự khác biệt về sự sống sót giữa các nhóm). Hàm survdiff() trong survival package cho phép thực hiện kiểm định log-rank khi chúng ta cụ thể rho = 0 (mặc định). Kết quả kiểm định cho ra một thống kê chi bình phương cùng với giá trị p vì log-rank phân phối gần giống như thống kê của kiểm định chi bình phương.Đầu tiên, chúng ta thử sánh các đường cong sống sót theo giới tính. Đối với điều này, chúng ta thử hình dung nó (kiểm tra xem hai đường cong sống sót có chồng lên nhau không). Một đối tượng survfit mới sẽ được tạo ra với một công thức hơi khác một chút. Sau đó, đối tượng survdiff sẽ được tạo ra.Bằng cách cung cấp ~ gender ở phía bên phải của công thức, chúng ta không còn vẽ biểu đồ đường cong sống sót chung mà thay vào đó là theo giới tính.Bây giờ, chúng ta có thể vẽ các đường cong sống sót theo giới tính. Hãy xem thứ tự giá trị biến của giới tính trước khi xác định màu sắc và chú giải.Và bây giờ, chúng ta có thể tính toán kiểm định sự khác biệt giữa các đường cong bằng cách sử dụng hàm survdiff()Chúng ta thấy rằng đường cong sống sót cho nữ và đường cong cho nam chồng lên nhau và kiểm định log-rank không đưa ra bằng chứng về sự khác biệt sống sót giữa nam và nữ.Một số package trong R cho phép minh họa các đường cong sống sót cho các nhóm và kiểm định sự khác biệt cùng một lúc. Sử dụng hàm ggsurvplot() từ package survminer, chúng ta cũng có thể bao gồm các bảng nguy cơ với các đường cong này cũng như giá trị p từ kiểm định log-rank.THẬN TRỌNG: Các hàm từ package survminer đòi hỏi chúng ta cụ thể đối tượng sống sót và cụ thể bộ số liệu để sánh đối tượng sống sót. Hãy nhớ làm điều này để tránh thông báo lỗi không cụ thể. Chúng ta có thể cũng muốn kiểm định sự khác biệt về sống còn theo nguồn lây (nguồn ô nhiễm).Trong trường hợp này, kiểm định log-rank cho thấy có đủ bằng chứng về sự khác biệt trong xác suất sống sót với alpha= 0.005. Xác suất sống sót cho những bệnh nhân bị nhiễm tại các đám tang cao hơn xác suất sống sót ở những nơi khác mà gợi ý về lợi ích sống sót.","code":"\n# create the new survfit object based on gender\nlinelistsurv_fit_sex <-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)\n# set colors\ncol_sex <- c(\"lightgreen\", \"darkgreen\")\n\n# create plot\nplot(\n  linelistsurv_fit_sex,\n  col = col_sex,\n  xlab = \"Days of follow-up\",\n  ylab = \"Survival Probability\")\n\n# add legend\nlegend(\n  \"topright\",\n  legend = c(\"Female\",\"Male\"),\n  col = col_sex,\n  lty = 1,\n  cex = .9,\n  bty = \"n\")\n#compute the test of the difference between the survival curves\nsurvival::survdiff(\n  Surv(futime, event) ~ gender, \n  data = linelist_surv\n  )## Call:\n## survival::survdiff(formula = Surv(futime, event) ~ gender, data = linelist_surv)\n## \n## n=4321, 218 observations deleted due to missingness.\n## \n##             N Observed Expected (O-E)^2/E (O-E)^2/V\n## gender=f 2156      924      909     0.255     0.524\n## gender=m 2165      929      944     0.245     0.524\n## \n##  Chisq= 0.5  on 1 degrees of freedom, p= 0.5\nsurvminer::ggsurvplot(\n    linelistsurv_fit_sex, \n    data = linelist_surv,          # again specify the data used to fit linelistsurv_fit_sex \n    conf.int = FALSE,              # do not show confidence interval of KM estimates\n    surv.scale = \"percent\",        # present probabilities in the y axis in %\n    break.time.by = 10,            # present the time axis with an increment of 10 days\n    xlab = \"Follow-up days\",\n    ylab = \"Survival Probability\",\n    pval = T,                      # print p-value of Log-rank test \n    pval.coord = c(40,.91),        # print p-value at these plot coordinates\n    risk.table = T,                # print the risk table at bottom \n    legend.title = \"Gender\",       # legend characteristics\n    legend.labs = c(\"Female\",\"Male\"),\n    font.legend = 10, \n    palette = \"Dark2\",             # specify color palette \n    surv.median.line = \"hv\",       # draw horizontal and vertical lines to the median survivals\n    ggtheme = theme_light()        # simplify plot background\n)\nlinelistsurv_fit_source <-  survfit(\n  Surv(futime, event) ~ source,\n  data = linelist_surv\n  )\n\n# plot\nggsurvplot( \n  linelistsurv_fit_source,\n  data = linelist_surv,\n  size = 1, linetype = \"strata\",   # line types\n  conf.int = T,\n  surv.scale = \"percent\",  \n  break.time.by = 10, \n  xlab = \"Follow-up days\",\n  ylab= \"Survival Probability\",\n  pval = T,\n  pval.coord = c(40,.91),\n  risk.table = T,\n  legend.title = \"Source of \\ninfection\",\n  legend.labs = c(\"Funeral\", \"Other\"),\n  font.legend = 10,\n  palette = c(\"#E7B800\",\"#3E606F\"),\n  surv.median.line = \"hv\", \n  ggtheme = theme_light()\n)## Warning: Vectorized input to `element_text()` is not officially supported.\n## Results may be unexpected or may change in future versions of ggplot2."},{"path":"survival-analysis.html","id":"phân-tích-bằng-hồi-quy-cox","chapter":"27 Phân tích sống còn","heading":"27.5 Phân tích bằng hồi quy Cox","text":"Hồi quy mối nguy theo tỷ lệ Cox (sau này sẽ gọi ngắn gọn là hồi quy Cox) là một trong những kỹ thuật hồi quy phổ biến nhất cho phân tích sống còn. Các mô hình khác cũng có thể được sử dụng, vì để sử dụng thích hợp mô hình Cox, các giả định quan trọng cần phải được xác minh: xem tài liệu tham khảo.Trong một mô hình hồi quy Cox, đo lường ảnh hưởng là hazard rate (tỷ suất mối nguy) (HR), là nguy cơ xảy ra sự kiện (hay là nguy cơ tử vong trong ví dụ này), của người tham gia sống sót đến một thời điểm cụ thể. Thông thường, chúng ta quan tâm đến việc sánh giữa các nhóm độc lập gvề nguy cơ của nó, và sử dụng tỷ số nguy cơ mà tương tự như tỷ số chênh khi thực hiện hồi quy logistic đa biến. Hàm cox.ph() từ package survival được sử dụng để fit mô hình. Hàm cox.zph() từ package survival có thể được sử dụng để kiểm tra tính phù hợp của giả định nguy cơ theo tỷ lệ với mô hình hồi quy Cox.LƯU Ý: Xác suất phải nằm trong khoảng từ 0 đến 1. Tuy nhiên, nguy cơ đại điện cho số sự kiện dự đoán trên một đơn vị thời gian.Nếu tỷ số nguy cơ cho một yếu tố dự đoán gần bằng 1, thì yếu tố dự đoán đó không ảnh hưởng đến sự sống sót,Nếu HR nhỏ hơn 1, thì yếu tố dự đoán là yếu tố bảo vệ (tức là yếu tố liên quan đến cải thiện khả năng sống sót),Và nếu HR lớn hơn 1, thì yếu tố dự đoán kết hợp với tăng nguy cơ (hay là giảm khả năng sống sót).","code":""},{"path":"survival-analysis.html","id":"fitting-một-mô-hình-cox","chapter":"27 Phân tích sống còn","heading":"Fitting một mô hình Cox","text":"Đầu tiên, chúng ta có thể fit một mô hình để đánh giá ảnh hưởng của tuổi và giới lên sự sống sót. Chỉ cần xuất mô hình, chúng ta có những thông tin sau:các ước lượng hệ số hồi quy coef để xác định mối liên hệ giữa các biến dự đoán và biến kết cục,lũy thừa của các ước số (exp(coef)) để tính tỷ số nguy cơ,các sai số chuẩn se(coef),chỉ số z-score: bao nhiêu sai số chuẩn là hệ số ước tính khác biệt từ giá trị 0,và p-value: xác suất mà ước số có thể là 0.Áp dụng hàm summary() cho các đối tượng của mô hình Cox cho biết thêm thông tin như là khoảng tin cậy của HR và các chỉ số kiểm định khác.Kết quả của hiệp biến đầu tiên gender được trình bày ở hàng đầu tiên. genderm (nam) được ra có ngụ ý rằng vị trí tầng đầu tiên (“f”), tức là nhóm nữ, là nhóm tham chiếu cho biến số giới tính. Vì thế, giải thích các thông số kiểm định là của nam với nữ. Giá trị p chỉ ra rằng không có đủ bằng chứng về ảnh hưởng của giới tính lên mối nguy hay là không có đủ bằng chứng về mối liên quan giữa giới và tử vong (tất cả các nguyên nhân).Cũng thiếu bằng chứng như vậy đối với biến số nhóm tuổi.Thật rất thú vị để thực hiện mô hình và xem kết quả, nhưng quan sát đầu tiên để xác minh xem có thỏa các giả định về nguy cơ theo tỷ lệ hay không mà có thể giúp tiết kiệm thời gian.LƯU Ý: đối số thứ hai được gọi là method có thể được định rõ khi tính toán mô hình Cox để xác định cách ràng buộc được vận dụng. Phương pháp mặc định là “efron”, và các tùy chọn khác là “breslow” và “exact”.Trong một mô hình khác, chúng tôi thêm nhiều yếu tố nguy cơ hơn như nguồn lây và số ngày giữa ngày khởi phát và ngày nhập viện. Điều trước tiên vào lúc này là xác minh các giả định nguy cơ theo tỷ lệ trước khi thực hiện các bước tiếp theo.Trong mô hình này, chúng ta bao gồm một biến dự báo liên tục (days_onset_hosp). Trong trường hợp này, chúng ta giải thích các ước tính của thông số như là sự gia tăng theo lôgarít kỳ vọng của nguy cơ tương đối cho mỗi mức tăng của một đơn vị trong biến dự đoán, bằng cách giữ các yếu tố dự đoán khác cố định. Đầu tiên chúng ta xác minh giả định nguy cơ theo tỷ lệ.Việc xác minh bằng đồ thị của giả định này có thể được thực hiện bằng hàm ggcoxzph() của package survminer.Kết quả mô hình chỉ ra rằng có mối liên quan nghịch giữa khoảng thời gian từ khởi phát bệnh đến nhân viện và tử vong tất cả các nguyên nhân. Nguy cơ dự đoán là bằng 0.9 lần ở một người nhập viện trễ hơn một ngày với người khác, khi giữ biến giới tính cố định. Hay giải thích một cách dễ hiểu hơn, tăng một đơn vị thời gian từ lúc khởi phát đến nhập viện thì có liên quan đến giảm 10.7% (coef *100) nguy cơ tử vong.Kết quả cũng cho thấy một mối liên quan thuận giữa nguồn lây và tử vong. Điều này có nghĩa là nguy cơ tử vong của bệnh nhân có nguồn lây bằng 1.21 lần với bệnh nhân có nguồn lây là đám tang.Chúng ta có thể xác minh mối quan hệ này bằng một bảng:Chúng ta cần phải xem xét và điều tra tại sao sự kết hợp này tồn tại trong số liệu. Một giải thích có thể chấp nhận được là bệnh nhân nhập viện trễ hơn vì có bệnh lúc đầu ít nghiêm trọng hơn. Một giải thích khác có lẽ dễ chấp nhận hơn là vì chúng ta sử dụng một bộ số liệu mô phỏng, mẫu này không phản ánh đúng thực tế!","code":"\n#fitting the cox model\nlinelistsurv_cox_sexage <-  survival::coxph(\n              Surv(futime, event) ~ gender + age_cat_small, \n              data = linelist_surv\n              )\n\n\n#printing the model fitted\nlinelistsurv_cox_sexage## Call:\n## survival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n##     data = linelist_surv)\n## \n##                       coef exp(coef) se(coef)      z     p\n## genderm           -0.03149   0.96900  0.04767 -0.661 0.509\n## age_cat_small5-19  0.09400   1.09856  0.06454  1.456 0.145\n## age_cat_small20+   0.05032   1.05161  0.06953  0.724 0.469\n## \n## Likelihood ratio test=2.8  on 3 df, p=0.4243\n## n= 4321, number of events= 1853 \n##    (218 observations deleted due to missingness)\n#summary of the model\nsummary(linelistsurv_cox_sexage)## Call:\n## survival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n##     data = linelist_surv)\n## \n##   n= 4321, number of events= 1853 \n##    (218 observations deleted due to missingness)\n## \n##                       coef exp(coef) se(coef)      z Pr(>|z|)\n## genderm           -0.03149   0.96900  0.04767 -0.661    0.509\n## age_cat_small5-19  0.09400   1.09856  0.06454  1.456    0.145\n## age_cat_small20+   0.05032   1.05161  0.06953  0.724    0.469\n## \n##                   exp(coef) exp(-coef) lower .95 upper .95\n## genderm               0.969     1.0320    0.8826     1.064\n## age_cat_small5-19     1.099     0.9103    0.9680     1.247\n## age_cat_small20+      1.052     0.9509    0.9176     1.205\n## \n## Concordance= 0.514  (se = 0.007 )\n## Likelihood ratio test= 2.8  on 3 df,   p=0.4\n## Wald test            = 2.78  on 3 df,   p=0.4\n## Score (logrank) test = 2.78  on 3 df,   p=0.4\ntest_ph_sexage <- survival::cox.zph(linelistsurv_cox_sexage)\ntest_ph_sexage##               chisq df    p\n## gender        0.454  1 0.50\n## age_cat_small 0.838  2 0.66\n## GLOBAL        1.399  3 0.71\n#fit the model\nlinelistsurv_cox <-  coxph(\n                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,\n                        data = linelist_surv\n                        )\n\n\n#test the proportional hazard model\nlinelistsurv_ph_test <- cox.zph(linelistsurv_cox)\nlinelistsurv_ph_test##                    chisq df       p\n## gender           0.45062  1    0.50\n## age_years        0.00199  1    0.96\n## source           1.79622  1    0.18\n## days_onset_hosp 31.66167  1 1.8e-08\n## GLOBAL          34.08502  4 7.2e-07\nsurvminer::ggcoxzph(linelistsurv_ph_test)\n#print the summary of the model\nsummary(linelistsurv_cox)## Call:\n## coxph(formula = Surv(futime, event) ~ gender + age_years + source + \n##     days_onset_hosp, data = linelist_surv)\n## \n##   n= 2772, number of events= 1180 \n##    (1767 observations deleted due to missingness)\n## \n##                      coef exp(coef)  se(coef)      z Pr(>|z|)    \n## genderm          0.004710  1.004721  0.060827  0.077   0.9383    \n## age_years       -0.002249  0.997753  0.002421 -0.929   0.3528    \n## sourceother      0.178393  1.195295  0.084291  2.116   0.0343 *  \n## days_onset_hosp -0.104063  0.901169  0.014245 -7.305 2.77e-13 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n##                 exp(coef) exp(-coef) lower .95 upper .95\n## genderm            1.0047     0.9953    0.8918    1.1319\n## age_years          0.9978     1.0023    0.9930    1.0025\n## sourceother        1.1953     0.8366    1.0133    1.4100\n## days_onset_hosp    0.9012     1.1097    0.8764    0.9267\n## \n## Concordance= 0.566  (se = 0.009 )\n## Likelihood ratio test= 71.31  on 4 df,   p=1e-14\n## Wald test            = 59.22  on 4 df,   p=4e-12\n## Score (logrank) test = 59.54  on 4 df,   p=4e-12\nlinelist_case_data %>% \n  tabyl(days_onset_hosp, outcome) %>% \n  adorn_percentages() %>%  \n  adorn_pct_formatting()##  days_onset_hosp Death Recover   NA_\n##                0 44.3%   31.4% 24.3%\n##                1 46.6%   32.2% 21.2%\n##                2 43.0%   32.8% 24.2%\n##                3 45.0%   32.3% 22.7%\n##                4 41.5%   38.3% 20.2%\n##                5 40.0%   36.2% 23.8%\n##                6 32.2%   48.7% 19.1%\n##                7 31.8%   38.6% 29.5%\n##                8 29.8%   38.6% 31.6%\n##                9 30.3%   51.5% 18.2%\n##               10 16.7%   58.3% 25.0%\n##               11 36.4%   45.5% 18.2%\n##               12 18.8%   62.5% 18.8%\n##               13 10.0%   60.0% 30.0%\n##               14 10.0%   50.0% 40.0%\n##               15 28.6%   42.9% 28.6%\n##               16 20.0%   80.0%  0.0%\n##               17  0.0%  100.0%  0.0%\n##               18  0.0%  100.0%  0.0%\n##               22  0.0%  100.0%  0.0%\n##               NA 52.7%   31.2% 16.0%"},{"path":"survival-analysis.html","id":"biểu-đồ-forest-plot-1","chapter":"27 Phân tích sống còn","heading":"Biểu đồ Forest plot","text":"Chúng ta có thể vẽ kết quả của mô hình Cox bằng cách sử dụng hàm ggforest() trong package survminer để vẽ biểu đồ Forest plot.","code":"\nggforest(linelistsurv_cox, data = linelist_surv)"},{"path":"survival-analysis.html","id":"các-hiệp-biến-phụ-thuộc-vào-thời-gian-trong-mô-hình-sống-còn","chapter":"27 Phân tích sống còn","heading":"27.6 Các hiệp biến phụ thuộc vào thời gian trong mô hình sống còn","text":"Một số nội dung dưới đây được adapt từ tài liệu Giới thiệu về phân tích sống còn với R với sự cho phép của TS. Emily ZaborTrong phần trước, chúng ta đã đề cập đến việc sử dụng hồi quy Cox để kiểm tra mối liên quan giữa hiệp biến và biến kết cục sống còn. Nhưng những phân tích này dựa trên hiệp biến được đo lường ở thời điểm ban đầu, tức là trước thời gian theo dõi sự kiện bắt đầu.Điều gì sẽ xảy ra nếu chúng ta quan tâm đến một hiệp biến được đo sau khi thời gian theo dõi bắt đầu? Hoặc điều gì sẽ xảy ra nếu chúng ta có một hiệp biến có thể thay đổi theo thời gianVí dụ: có thể chúng ta đang làm việc với các số liệu lâm sàng mà chúng lặp lại đo lường các giá trị xét nghiệm mà có thể thay đổi theo thời gian. Đây là một ví dụ về hiệp biến phụ thuộc vào thời gian. Để nhấn mạnh vào vấn đề này, chúng ta cần một thiết lập đặc biệt, nhưng may là mô hình Cox rất linh động và loại số liệu này cũng có thể được mô hình hóa bằng các công cụ từ package survival.","code":""},{"path":"survival-analysis.html","id":"thiết-lập-hiệp-biến-phụ-thuộc-vào-thời-gian","chapter":"27 Phân tích sống còn","heading":"Thiết lập hiệp biến phụ thuộc vào thời gian","text":"Phân tích các hiệp biến phụ thuộc vào thời gian trong R đòi hỏi thiết lập một bộ dữ liệu đặc biệt. Nếu quan tâm, hãy xem chi tiết hơn về vấn đề này được viết bởi tác giả của package survival Sử Dụng Hiệp Biến Phụ Thuộc Vào Thời Gian và Hệ Số Phụ Thuộc Vào Thời Gian trong Mô Hình Cox.Đối với vấn đề này, chúng ta sử dụng một bộ số liệu mới từ package SemiCompRisks có tên là BMT, bộ số liệu này bao gồm 137 bệnh nhân cấy ghép tủy xương. Các biến chúng ta sẽ tập trung vào là:T1 - thời gian (tính bằng ngày) đến khi tử vong hoặc đến lần theo dõi cuối cùngdelta1 - chỉ số tử vong; 1-Tử vong, 0-Còn sốngTA - thời gian (tính theo ngày) đến khi phát bệnh GVHD cấp tính (bệnh tế bào ghép tấn công vật chủ)deltaA - chỉ số của bệnh GVHD cấp tính;\n1 - Đã tiến triển bệnh GVHD cấp tính\n0 - Không tiến triển bệnh GVHD cấp tính\n1 - Đã tiến triển bệnh GVHD cấp tính0 - Không tiến triển bệnh GVHD cấp tínhChúng ta sẽ gọi bộ số liệu này từ package survival bằng cách sử dụng lệnh data() từ base R, giúp tải số liệu được chứa ở trong một package đã được cài đặt. Một data frame có tên BMT sẽ hiện thị trong môi trường R.","code":"\ndata(BMT, package = \"SemiCompRisks\")"},{"path":"survival-analysis.html","id":"thêm-mã-nhận-dạng-bệnh-nhân","chapter":"27 Phân tích sống còn","heading":"Thêm mã nhận dạng bệnh nhân","text":"Không có cột ID trong bộ số liệu BMT, cột này cần thiết để tạo ra bộ số liệu mà chúng ta muốn. Vì vậy, chúng ta sử dụng hàm rowid_to_column() từ package tibble thuộc hệ sinh thái tidyverse để tạo một biến id mới gọi là my_id (thêm cột ở vị trí đầu tiên của bộ số liệu với việc đánh số hàng tuần tự theo số nhận dạng bắt đầu từ số 1). Chúng ta đặt tên bộ số liệu này là bmt.Bộ số liệu mới bây giờ trông sẽ như thế này:","code":"\nbmt <- rowid_to_column(BMT, \"my_id\")"},{"path":"survival-analysis.html","id":"mở-rộng-hàng-của-các-bệnh-nhân","chapter":"27 Phân tích sống còn","heading":"Mở rộng hàng của các bệnh nhân","text":"Tiếp theo, chúng ta sử dụng hàm tmerge() với các hàm hỗ trợ event() và tdc() để tái cấu trúc bộ số liệu. Mục tiêu của chúng ta là tái cấu trúc bộ số liệu để tạo một hàng riêng biệt cho từng bệnh nhân trong mỗi khoảng thời gian mà họ có giá trị deltaA khác nhau. Trong bộ số liệu này, mỗi bệnh nhân có thể có nhiều nhất là hai hàng tùy thuộc vào việc họ có phát bệnh GVHD hay không trong giai đoạn thu thập số liệu. Chúng ta sẽ gọi chỉ số mới cho việc phát bệnh GVHD là agvhd.tmerge() tạo một bộ số liệu dài với nhiều khoảng thời gian cho các giá trị hiệp biến khác nhau cho từng bệnh nhânevent() tạo chỉ số cho sự kiện mới để đi cùng với khoảng thời gian mới được tạo ratdc() tạo cột hiệp biến phụ thuộc vào thời gian agvhd để đi cùng với các khoảng thời gian mới được tạo raĐể xem điều này thực hiện thế nào, hãy xem số liệu của 5 bệnh nhân đầu tiên.Các biến quan tâm trong bộ số liệu gốc trông như sau:Bộ số liệu mới cho cùng các bệnh nhân này trông như sau:Bây giờ, một số bệnh nhân có hai hàng trong bộ số liệu tương ứng với khoảng thời gian mà họ có giá trị khác của biến mới agvhd. Ví dụ như Bệnh nhân số 1 hiện có hai hàng có giá trị của biến agvhd bằng 0 từ thời điểm 0 đến 67 và giá trị bằng 1 từ thời điểm 67 đến 2081.","code":"\ntd_dat <- \n  tmerge(\n    data1 = bmt %>% select(my_id, T1, delta1), \n    data2 = bmt %>% select(my_id, T1, delta1, TA, deltaA), \n    id = my_id, \n    death = event(T1, delta1),\n    agvhd = tdc(TA)\n    )\nbmt %>% \n  select(my_id, T1, delta1, TA, deltaA) %>% \n  filter(my_id %in% seq(1, 5))##   my_id   T1 delta1   TA deltaA\n## 1     1 2081      0   67      1\n## 2     2 1602      0 1602      0\n## 3     3 1496      0 1496      0\n## 4     4 1462      0   70      1\n## 5     5 1433      0 1433      0\ntd_dat %>% \n  filter(my_id %in% seq(1, 5))##   my_id   T1 delta1 id tstart tstop death agvhd\n## 1     1 2081      0  1      0    67     0     0\n## 2     1 2081      0  1     67  2081     0     1\n## 3     2 1602      0  2      0  1602     0     0\n## 4     3 1496      0  3      0  1496     0     0\n## 5     4 1462      0  4      0    70     0     0\n## 6     4 1462      0  4     70  1462     0     1\n## 7     5 1433      0  5      0  1433     0     0"},{"path":"survival-analysis.html","id":"hồi-quy-cox-với-hiệp-biến-phụ-thuộc-vào-thời-gian","chapter":"27 Phân tích sống còn","heading":"Hồi quy Cox với hiệp biến phụ thuộc vào thời gian","text":"Bây giờ, chúng ta đã định hình lại số liệu và thêm biến mới aghvd phụ thuộc vào thời gian, hãy fit mô hình cox đơn biến. Chúng ta có thể sử dụng cùng hàm coxph() như trước, chỉ cần thay đổi trong hàm Surv() để chỉ rõ thời gian bắt đầu và thời gian kết thúc cho mỗi khoảng thời gian bằng cách sử dụng các đối số cho time1 = và time2 =.Một lần nữa, chúng ta trực quan hóa kết quả mô hình Cox bằng cách sử dụng hàm ggforest() từ survminer package.:Như bạn thấy từ biểu đồ forest plot, khoảng tin cậy và giá trị p cho thấy rằng không có mối liên hệ chặt chẽ giữa tử vong và bệnh GVHD cấp tính trong mô hình hồi quy đơn giản này.","code":"\nbmt_td_model = coxph(\n  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, \n  data = td_dat\n  )\n\nsummary(bmt_td_model)## Call:\n## coxph(formula = Surv(time = tstart, time2 = tstop, event = death) ~ \n##     agvhd, data = td_dat)\n## \n##   n= 163, number of events= 80 \n## \n##         coef exp(coef) se(coef)    z Pr(>|z|)\n## agvhd 0.3351    1.3980   0.2815 1.19    0.234\n## \n##       exp(coef) exp(-coef) lower .95 upper .95\n## agvhd     1.398     0.7153    0.8052     2.427\n## \n## Concordance= 0.535  (se = 0.024 )\n## Likelihood ratio test= 1.33  on 1 df,   p=0.2\n## Wald test            = 1.42  on 1 df,   p=0.2\n## Score (logrank) test = 1.43  on 1 df,   p=0.2\nggforest(bmt_td_model, data = td_dat)"},{"path":"survival-analysis.html","id":"tài-nguyên-học-liệu-10","chapter":"27 Phân tích sống còn","heading":"27.7 Tài nguyên học liệu","text":"Survival Analysis Part : Basic concepts first analysesSurvival Analysis RSurvival analysis infectious disease research: Describing events timeChapter advanced survival models PrincetonUsing Time Dependent Covariates Time Dependent Coefficients Cox ModelSurvival analysis cheatsheet RSurvminer cheatsheetPaper different survival measures cancer registry data Rcode provided supplementary materials","code":""},{"path":"gis.html","id":"gis","chapter":"28 GIS cơ bản","heading":"28 GIS cơ bản","text":"","code":""},{"path":"gis.html","id":"tổng-quan-6","chapter":"28 GIS cơ bản","heading":"28.1 Tổng quan","text":"Các khía cạnh không gian trong dữ liệu của bạn có thể cung cấp nhiều thông tin chi tiết về tình hình đợt bùng phát dịch và để trả lời các câu hỏi như:Các điểm nóng về dịch bệnh hiện nay ở đâu?Các điểm nóng đã thay đổi như thế nào theo thời gian?Việc tiếp cận các cơ sở y tế như thế nào? Có cần thêm sự tăng cường nào không?Trọng tâm hiện tại trong chương GIS này nhằm giải quyết nhu cầu của các nhà dịch tễ học ứng dụng trong ứng phó với các đợt bùng phát dịch. Chúng ta sẽ khám phá các phương pháp trực quan hóa dữ liệu không gian cơ bản bằng cách sử dụng package tmap và ggplot2. Chúng ta cũng sẽ đi qua một số phương pháp quản lý và truy vấn dữ liệu không gian cơ bản với package sf. Cuối cùng, chúng ta sẽ đề cập ngắn gọn đến các khái niệm về thống kê không gian (spatial statistics) như mối quan hệ không gian, tự tương quan không gian và hồi quy không gian bằng cách sử dụng package spdep.","code":""},{"path":"gis.html","id":"các-thuật-ngữ-chính-1","chapter":"28 GIS cơ bản","heading":"28.2 Các thuật ngữ chính","text":"Dưới đây chúng tôi giới thiệu một số thuật ngữ chính. Để được giới thiệu kỹ lưỡng về GIS và phân tích không gian, chúng tôi khuyên bạn nên xem lại một trong các hướng dẫn hoặc khóa học dài hơn được liệt kê trong phần Tài nguyên học liệu.Hệ thống thông tin địa lý (Geographic Information System - GIS) - GIS là một framework hoặc môi trường để thu thập, quản lý, phân tích và trực quan hóa dữ liệu không gian.","code":""},{"path":"gis.html","id":"phần-mềm-gis","chapter":"28 GIS cơ bản","heading":"Phần mềm GIS","text":"Một số phần mềm GIS phổ biến cho phép tương tác bằng các thao tác chuột để phát triển bản đồ và phân tích không gian. Những công cụ này đi kèm với những lợi thế như không cần phải học code và dễ dàng lựa chọn và đặt các biểu tượng và tính năng trên bản đồ theo cách thủ công. Dưới đây là hai phần mềm phổ biến:ArcGIS - Một phần mềm GIS thương mại công ty ESRI phát triển, rất phổ biến nhưng khá đắtQGIS - Một phần mềm GIS mã nguồn mở nhưng làm được hầu hết mọi thứ mà ArcGIS có thể làm được. Bạn có thể tải QGIS tại đâySử dụng R để thao tác GIS thoạt đầu có vẻ đáng sợ hơn bởi vì thay bằng các “thao tác chuột”, nó có “giao diện dòng lệnh” (bạn phải viết code để có được kết quả mong muốn). Tuy nhiên, đây là một lợi thế lớn nếu bạn cần tạo bản đồ lặp đi lặp lại hoặc tạo các phân tích có thể tái lập được.","code":""},{"path":"gis.html","id":"dữ-liệu-không-gian","chapter":"28 GIS cơ bản","heading":"Dữ liệu không gian","text":"Hai dạng dữ liệu không gian chính được sử dụng trong GIS là dữ liệu vectơ và raster:Vector Data - Định dạng phổ biến nhất của dữ liệu không gian được sử dụng trong GIS, dữ liệu vectơ bao gồm các đặc điểm hình học của vertices paths. Dữ liệu không gian dạng vectơ có thể được chia thành ba loại nhỏ được sử dụng rộng rãi:Điểm (Points) - Một điểm bao gồm một cặp tọa độ (x, y) đại diện cho một vị trí cụ thể trong một hệ tọa độ. Điểm là dạng dữ liệu không gian cơ bản nhất và có thể được sử dụng để biểu thị một trường hợp (vd: nhà bệnh nhân) hoặc một vị trí (vd: bệnh viện) trên bản đồ.Điểm (Points) - Một điểm bao gồm một cặp tọa độ (x, y) đại diện cho một vị trí cụ thể trong một hệ tọa độ. Điểm là dạng dữ liệu không gian cơ bản nhất và có thể được sử dụng để biểu thị một trường hợp (vd: nhà bệnh nhân) hoặc một vị trí (vd: bệnh viện) trên bản đồ.Đường (Lines) - Một đường bao gồm hai điểm kết nối với nhau. Đường có độ dài và có thể được sử dụng để biểu thị những thứ như con đường hoặc sông.Đường (Lines) - Một đường bao gồm hai điểm kết nối với nhau. Đường có độ dài và có thể được sử dụng để biểu thị những thứ như con đường hoặc sông.Đa giác (Polygons) - polygon composed least three line segments connected points. Polygon features length (.e. perimeter area) well area measurement. Polygons may used note area (.e. village) structure (.e. actual area hospital).Đa giác (Polygons) - polygon composed least three line segments connected points. Polygon features length (.e. perimeter area) well area measurement. Polygons may used note area (.e. village) structure (.e. actual area hospital).Raster Data - Một đa giác bao gồm ít nhất ba đoạn thẳng được nối với nhau bằng các điểm. Các đối tượng đa giác có chiều dài (vd: chu vi của khu vực) cũng như số đo diện tích. Đa giác có thể được sử dụng để biểu diễn một khu vực (vd: một ngôi làng) hoặc một cấu trúc (vd: diện tích thực tế của một bệnh viện).","code":""},{"path":"gis.html","id":"trực-quan-hóa-dữ-liệu-không-gian","chapter":"28 GIS cơ bản","heading":"Trực quan hóa dữ liệu không gian","text":"Để thể hiện trực quan dữ liệu không gian trên bản đồ, phần mềm GIS yêu cầu bạn cung cấp đầy đủ thông tin về vị trí của các đối tượng địa lý khác nhau, trong mối quan hệ của chúng với nhau. Nếu bạn đang sử dụng dữ liệu vectơ, điều này sẽ đúng cho hầu hết các trường hợp sử dụng, thông tin này thường sẽ được lưu trữ trong một shapefile:Shapefiles - Shapefile là một định dạng dữ liệu phổ biến để lưu trữ dữ liệu không gian “vectơ” bao gồm hoặc đường, điểm hoặc đa giác. Một shapefile thực chất là một tập hợp của ít nhất ba tệp - .shp, .shx và .dbf. Tất cả các tệp thành phần phụ này phải nằm trong cùng một thư mục để chúng có thể đọc được. Các tệp liên quan này có thể được nén vào một thư mục ZIP để gửi qua email hoặc tải xuống từ một trang web.Shapefile sẽ chứa thông tin về bản thân các đối tượng địa lý cũng như vị trí định vị chúng trên bề mặt Trái đất. Điều này rất quan trọng bởi vì trong khi Trái đất là một quả địa cầu, các bản đồ thường là hai chiều; các lựa chọn về cách “làm phẳng” dữ liệu không gian có thể có tác động lớn đến giao diện và cách giải thích các kết quả..Hệ trục tọa độ tham chiếu (Coordinate Reference Systems - CRS) - CRS là một hệ thống dựa trên tọa độ được sử dụng để xác định vị trí các đối tượng địa lý trên bề mặt Trái đất. Nó có một số thành phần chính:Hệ tọa độ - Có nhiều hệ tọa độ khác nhau, vì vậy hãy đảm bảo rằng bạn biết hệ tọa độ của mình là từ hệ nào. Các kinh độ/vĩ độ là phổ biến nhẩt, nhưng bạn cũng có thể gặp hệ tọa độ UTM.Hệ tọa độ - Có nhiều hệ tọa độ khác nhau, vì vậy hãy đảm bảo rằng bạn biết hệ tọa độ của mình là từ hệ nào. Các kinh độ/vĩ độ là phổ biến nhẩt, nhưng bạn cũng có thể gặp hệ tọa độ UTM.Đơn vị - Các đơn vị dành cho hệ tọa độ của bạn (ví dụ: độ thập phân, mét)Đơn vị - Các đơn vị dành cho hệ tọa độ của bạn (ví dụ: độ thập phân, mét)Dữ liệu - Một phiên bản được mô hình hóa cụ thể của Trái đất. Chúng đã được sửa đổi trong nhiều năm, vì vậy hãy đảm bảo rằng các lớp bản đồ của bạn đang sử dụng cùng một dữ liệu..Dữ liệu - Một phiên bản được mô hình hóa cụ thể của Trái đất. Chúng đã được sửa đổi trong nhiều năm, vì vậy hãy đảm bảo rằng các lớp bản đồ của bạn đang sử dụng cùng một dữ liệu..Phép chiếu - Tham chiếu đến phương trình toán học được sử dụng để chiếu trái đất hình tròn lên một bề mặt phẳng (bản đồ).Phép chiếu - Tham chiếu đến phương trình toán học được sử dụng để chiếu trái đất hình tròn lên một bề mặt phẳng (bản đồ).Hãy nhớ rằng bạn có thể tóm tắt dữ liệu không gian mà không cần sử dụng các công cụ lập bản đồ được hiển thị bên dưới. Đôi khi một bảng đơn giản phân chia theo địa lý (ví dụ: huyện, quốc gia, v.v.) là tất cả những gì cần thiết!","code":""},{"path":"gis.html","id":"bắt-đầu-với-gis","chapter":"28 GIS cơ bản","heading":"28.3 Bắt đầu với GIS","text":"Có một số thứ quan trọng bạn sẽ cần phải có và suy nghĩ tới khi tạo bản đồ. Bao gồm:Một tập dữ liệu – tập dữ liệu này có thể ở định dạng dữ liệu không gian (chẳng hạn như shapefiles, như đã lưu ý ở trên) hoặc nó có thể không ở định dạng không gian (chẳng hạn như csv).Một tập dữ liệu – tập dữ liệu này có thể ở định dạng dữ liệu không gian (chẳng hạn như shapefiles, như đã lưu ý ở trên) hoặc nó có thể không ở định dạng không gian (chẳng hạn như csv).Nếu tập dữ liệu của bạn không ở định dạng không gian, bạn cũng sẽ cần một tập dữ liệu tham chiếu. Dữ liệu tham chiếu bao gồm biểu diễn không gian của dữ liệu và các thuộc tính liên quan, sẽ bao gồm tài liệu chứa thông tin vị trí và địa chỉ của các đối tượng địa lý cụ thể.\nNếu bạn đang làm việc với các ranh giới địa lý được xác định trước (ví dụ: khu vực hành chính), các shapefiles tham chiếu thường có sẵn miễn phí để tải xuống từ cơ quan chính phủ hoặc tổ chức chia sẻ dữ liệu. Khi nghi ngờ, bạn có thể tìm kiếm trên Google cụm từ “[tên vùng] shapefile”\nNếu bạn có thông tin địa chỉ, nhưng không có vĩ độ và kinh độ, bạn có thể cần sử dụng một công cụ mã hóa địa lý để lấy dữ liệu không gian tham chiếu cho bản ghi của mình.\nNếu tập dữ liệu của bạn không ở định dạng không gian, bạn cũng sẽ cần một tập dữ liệu tham chiếu. Dữ liệu tham chiếu bao gồm biểu diễn không gian của dữ liệu và các thuộc tính liên quan, sẽ bao gồm tài liệu chứa thông tin vị trí và địa chỉ của các đối tượng địa lý cụ thể.Nếu bạn đang làm việc với các ranh giới địa lý được xác định trước (ví dụ: khu vực hành chính), các shapefiles tham chiếu thường có sẵn miễn phí để tải xuống từ cơ quan chính phủ hoặc tổ chức chia sẻ dữ liệu. Khi nghi ngờ, bạn có thể tìm kiếm trên Google cụm từ “[tên vùng] shapefile”Nếu bạn đang làm việc với các ranh giới địa lý được xác định trước (ví dụ: khu vực hành chính), các shapefiles tham chiếu thường có sẵn miễn phí để tải xuống từ cơ quan chính phủ hoặc tổ chức chia sẻ dữ liệu. Khi nghi ngờ, bạn có thể tìm kiếm trên Google cụm từ “[tên vùng] shapefile”Nếu bạn có thông tin địa chỉ, nhưng không có vĩ độ và kinh độ, bạn có thể cần sử dụng một công cụ mã hóa địa lý để lấy dữ liệu không gian tham chiếu cho bản ghi của mình.Nếu bạn có thông tin địa chỉ, nhưng không có vĩ độ và kinh độ, bạn có thể cần sử dụng một công cụ mã hóa địa lý để lấy dữ liệu không gian tham chiếu cho bản ghi của mình.Ý tưởng về cách bạn muốn trình bày thông tin trong bộ dữ liệu của mình cho đối tượng mục tiêu. Có nhiều loại bản đồ khác nhau, và điều quan trọng là phải suy nghĩ xem loại bản đồ nào phù hợp nhất với nhu cầu của bạn.Ý tưởng về cách bạn muốn trình bày thông tin trong bộ dữ liệu của mình cho đối tượng mục tiêu. Có nhiều loại bản đồ khác nhau, và điều quan trọng là phải suy nghĩ xem loại bản đồ nào phù hợp nhất với nhu cầu của bạn.","code":""},{"path":"gis.html","id":"các-loại-bản-đồ-để-trực-quan-hóa-dữ-liệu","chapter":"28 GIS cơ bản","heading":"Các loại bản đồ để trực quan hóa dữ liệu","text":"Bản đồ Choropleth - một loại bản đồ trong đó màu sắc, sự đổ bóng, hoặc các họa tiết được sử dụng để thể hiện các vùng địa lý liên quan đến giá trị của một thuộc tính. Ví dụ: giá trị lớn hơn có thể được biểu thị bằng màu tối hơn giá trị nhỏ hơn. Loại bản đồ này đặc biệt hữu ích khi trực quan hóa một biến số và xem cách nó thay đổi trên các vùng hoặc khu vực địa chính trị xác định.Bản đồ nhiệt mật độ trường hợp - một loại bản đồ trong đó màu sắc được sử dụng để thể hiện cường độ của một giá trị, tuy nhiên, nó không sử dụng các vùng hoặc ranh giới địa chính trị xác định để nhóm dữ liệu. Loại bản đồ này thường được sử dụng để hiển thị ‘điểm nóng’ hoặc các khu vực có mật độ hoặc tập trung điểm cao.Bản đồ mật độ điểm - một loại bản đồ sử dụng các điểm để biểu thị các giá trị thuộc tính trong dữ liệu của bạn. Loại bản đồ này được sử dụng tốt nhất để trực quan hóa phân tán dữ liệu của bạn và scan một cách trực quan các cụm.Bản đồ ký hiệu tỷ lệ (bản đồ ký hiệu chia độ) - một loại bản đồ tương tự như bản đồ choropleth, nhưng thay vì sử dụng màu sắc để biểu thị giá trị của một thuộc tính, nó sử dụng một ký hiệu (thường là một vòng tròn) liên quan đến giá trị. Ví dụ, một giá trị lớn hơn có thể được biểu thị bằng một ký hiệu lớn hơn một giá trị nhỏ hơn. Loại bản đồ này được sử dụng tốt nhất khi bạn muốn trực quan hóa kích thước hoặc số lượng dữ liệu của mình trên các vùng địa lý.Bạn cũng có thể kết hợp một số loại trực quan hóa khác nhau để hiển thị các trường hợp địa lý phức tạp. Ví dụ, các trường hợp (điểm) trong bản đồ dưới đây được tô màu theo cơ sở y tế gần nhất của họ (xem phần chú thích). Các vòng tròn lớn hiển thị cơ sở y tế gần nhất trong khu vực ở một bán kính xác định, và các điểm màu đỏ tươi là những cơ sở y tế không nằm trong bất kỳ bán kính nào:Lưu ý: Trọng tâm chính trong chương GIS này được dựa trên tình huống đáp ứng các vụ dịch tại thực địa. đó, nội dung của chương sẽ bao gồm các thao tác, hình ảnh hóa và phân tích dữ liệu không gian cơ bản.","code":""},{"path":"gis.html","id":"chuẩn-bị-18","chapter":"28 GIS cơ bản","heading":"28.4 Chuẩn bị","text":"","code":""},{"path":"gis.html","id":"gọi-package-8","chapter":"28 GIS cơ bản","heading":"Gọi package","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.Bạn có thể xem tổng quan về tất cả các package trong R xử lý dữ liệu không gian tại CRAN “Spatial Task View”.","code":"\npacman::p_load(\n  rio,           # to import data\n  here,          # to locate files\n  tidyverse,     # to clean, handle, and plot the data (includes ggplot2 package)\n  sf,            # to manage spatial data using a Simple Feature format\n  tmap,          # to produce simple maps, works for both interactive and static maps\n  janitor,       # to clean column names\n  OpenStreetMap, # to add OSM basemap in ggplot map\n  spdep          # spatial statistics\n  ) "},{"path":"gis.html","id":"dữ-liệu-trường-hợp-mẫu","chapter":"28 GIS cơ bản","heading":"Dữ liệu trường hợp mẫu","text":"Với mục đích minh họa, chúng ta sẽ làm việc với một mẫu ngẫu nhiên gồm 1000 trường hợp từ bộ dữ liệu một vụ dịch Ebola mô phỏng có tên linelist (về mặt tính toán, việc làm việc với ít trường hợp hơn sẽ dễ hiển thị hơn trong sổ tay này). Để tiện dõi, bấm để tải dữ liệu linelist “đã được làm sạch” (dưới dạng tệp .rds).Vì chúng ta đang lấy một mẫu ngẫu nhiên của các trường hợp, nên kết quả của bạn có thể hơi khác với những gì được minh họa ở đây khi bạn tự chạy code của mình.Nhập dữ liệu vào bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).Tiếp theo, chúng ta chọn một mẫu ngẫu nhiên gồm 1000 hàng bằng hàm sample() từ base R.Bây giờ chúng ta muốn chuyển đổi bộ dữ liệu linelist đang là một dataframe, thành một đối tượng “sf” (spatial features - các đặc tính không gian). bộ dữ liệu linelist có hai cột “lon” và “lat” đại diện cho kinh độ và vĩ độ của nơi cư trú của từng trường hợp, nên việc chuyển đổi này khá dễ dàng.Chúng ta sử dụng package sf (spatial features - các đặc tính không gian) và hàm st_as_sf() của nó để tạo đối tượng mới có tên linelist_sf. Đối tượng mới này về cơ bản giống với linelist, nhưng các cột lon và lat đã được chỉ định là cột tọa độ, và một hệ thống tham chiếu tọa độ (CRS) đã được gán khi các điểm được hiển thị. 4326 xác định tọa độ của chúng ta dựa trên Hệ thống trắc địa thế giới 1984 (WGS84) - là tiêu chuẩn cho tọa độ GPS.Dưới đây là cách bộ dữ liệu linelist gốc được hiển thị. Trong phần minh họa này, chúng ta sẽ chỉ sử dụng cột date_onset và geometry (được xây dựng từ các trường kinh độ và vĩ độ ở trên và là cột cuối cùng trong khung dữ liệu).","code":"\n# import clean case linelist\nlinelist <- import(\"linelist_cleaned.rds\")  \n# generate 1000 random row numbers, from the number of rows in linelist\nsample_rows <- sample(nrow(linelist), 1000)\n\n# subset linelist to keep only the sample rows, and all columns\nlinelist <- linelist[sample_rows,]\n# Create sf object\nlinelist_sf <- linelist %>%\n     sf::st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\nDT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )"},{"path":"gis.html","id":"shapefiles-phân-cấp-hành-chính","chapter":"28 GIS cơ bản","heading":"Shapefiles phân cấp hành chính","text":"Sierra Leone: shapefiles phân cấp hành chínhTrước đó, chúng tôi đã tải xuống tất cả các phân cấp hành chính của Sierra Leone từ website của Humanitarian Data Exchange (HDX). Ngoài ra, bạn có thể tải xuống các dữ liệu này và tất cả các dữ liệu mẫu khác cho sổ tay này qua gói R của chúng tôi, như được giải thích trong trang Tải sách và dữ liệu.Bây giờ chúng ta sẽ thực hiện những bước sau để lưu shapefile hành chính cấp 3 vào R:Nhập shapefileLàm sạch tên cộtLọc các hàng để chỉ giữ lại các khu vực quan tâmĐể nhập một shapefile, chúng ta sử dụng hàm read_sf() từ package sf. Nó được cung cấp đường dẫn tệp thông qua hàm (). - trong trường hợp này tệp nằm bên trong Dự án R của bạn tại thư mục “data”, rồi tới “gis”, và thư mục con “shp”, với tệp có tên “sle_adm3.shp” (xem chương Nhập xuất dữ liệu và Dự án R để biết thêm chi tiết). Bạn sẽ cần cung cấp đường dẫn tệp của riêng mình.Tiếp theo, chúng ta sử dụng hàm clean_names() từ package janitor để chuẩn hóa tên các cột của shapefile. Chúng ta cũng sử dụng hàm filter() để chỉ giữ lại các hàng có tên admin2 là “Western Area Urban” hoặc “Western Area Rural”.Dưới đây, bạn có thể thấy shapefile trông như thế nào sau khi nhập và làm sạch. Cuộn sang phải see columns hành chính cấp 0 (quốc gia), hành chính cấp 1, hành chính cấp 2, và cuối cùng là hành chính cấp 3. Mỗi cấp độ có một tên và một mã định danh duy nhất “pcode”. Pcode mở rộng với mỗi sự tăng lên của cấp hành chính, vd. SL (Sierra Leone) -> SL04 (Western) -> SL0410 (Western Area Rural) -> SL040101 (Koya Rural).","code":"\n# ADM3 level clean\nsle_adm3 <- sle_adm3_raw %>% \n  janitor::clean_names() %>% # standardize column names\n  filter(admin2name %in% c(\"Western Area Urban\", \"Western Area Rural\")) # filter to keep certain areas"},{"path":"gis.html","id":"dữ-liệu-dân-số","chapter":"28 GIS cơ bản","heading":"Dữ liệu dân số","text":"Sierra Leone: Dân số theo ADM3Những dữ liệu này có thể tải xuống từ HDX (link tại đây) hoặc thông qua R package epirhandbook như đã được giải thích trong chương này. Chúng ta cũng sử dụng hàm import() để nạp tệp .csv. Chúng tôi cũng chuyển file được nhập tới hàm clean_names() để chuẩn hóa cú pháp tên cột.Bộ dữ liệu dân số trông sẽ như bên dưới. Cuộn sang bên phải để xem các cột: dân số nam (male population), dân số nữ (female populaton), tổng dân số (total population), và dân số theo từng nhóm tuổi.","code":"\n# Population by ADM3\nsle_adm3_pop <- import(here(\"data\", \"gis\", \"population\", \"sle_admpop_adm3_2020.csv\")) %>%\n  janitor::clean_names()"},{"path":"gis.html","id":"các-cơ-sở-y-tế","chapter":"28 GIS cơ bản","heading":"Các cơ sở y tế","text":"Sierra Leone: Dữ liệu cơ sở y tế từ OpenStreetMapMột lần nữa, bạn có thể tải xuống thông tin vị trí của các cơ sở y tế từ HDX tại đây hoặc thông qua hướng dẫn trong chương Tải sách và dữ liệu.Chúng ta nhập shapefile tọa độ điểm các cơ sở với hàm read_sf(), làm sạch lại tên cột, sau đó lọc để chỉ giữ lại các điểm được gắn thẻ là “hospital”, “clinic”, hoặc “doctors”.Dưới đây là dataframe kết quả - Cuộn phải để xem tên cơ sở và tọa độ geometry.","code":"\n# OSM health facility shapefile\nsle_hf <- sf::read_sf(here(\"data\", \"gis\", \"shp\", \"sle_hf.shp\")) %>% \n  janitor::clean_names() %>%\n  filter(amenity %in% c(\"hospital\", \"clinic\", \"doctors\"))"},{"path":"gis.html","id":"vẽ-đồ-thị-tọa-độ","chapter":"28 GIS cơ bản","heading":"28.5 Vẽ đồ thị tọa độ","text":"Cách dễ nhất để vẽ đồ thị tọa độ X-Y (kinh độ / vĩ độ, điểm), trong trường hợp này, là vẽ chúng dưới dạng điểm trực tiếp từ đối tượng linelist_sf mà chúng ta đã tạo trong phần chuẩn bị.Package tmap cung cấp khả năng lập bản đồ đơn giản ở cả dạng tĩnh (“plot” mode) và tương tác (“view” mode) chỉ với một vài dòng code. Cú pháp của tmap tương tự như cú pháp của ggplot2, chẳng hạn như các lệnh được thêm vào nhau bằng dấu +. Đọc thêm chi tiết trong hướng dẫn này.Thiết lập tmap mode. Trong trường hợp này chúng ta sẽ sử dụng “plot” mode để tạo ra các biểu đồ tĩnh.Dưới đây, các điểm được vẽ độc lập. Hàm tm_shape() được cung cấp bởi đối tượng linelist_sf. Chúng ta sau đó thêm các điểm thông qua hàm tm_dots(), và cụ thể kích thước và màu sắc. linelist_sf là một đối tượng sf đã được chúng ta chỉ định hai cột chứa tọa độ vĩ độ/kinh độ và hệ quy chiếu tọa độ (CRS):Khi đứng một mình, các điểm không cho biết nhiều thông tin. Vì vậy, chúng ta nên lập bản đồ địa giới hành chính:Một lần nữa chúng ta sử dụng hàm tm_shape() (xem tài liệu này) nhưng thay vì cung cấp shapefile tọa độ điểm các trường hợp, chúng ta cung cấp shapefile địa giới hành chính (đa giác).Với đối số bbox = (bbox là viết tắt của “bounding box”), chúng ta có thể chỉ định các ranh giới tọa độ. Đầu tiên, chúng ta hiển thị bản đồ mà không có bbox, và sau đó thêm nó vào.Và bây giờ hiển thị các điểm và đa giác cùng nhau:Để đọc một bài sánh hay về các tùy chọn vẽ bản đồ trong R, hãy xem bài đăng blog này.","code":"\ntmap_mode(\"plot\") # choose either \"view\" or \"plot\"\n# Just the cases (points)\ntm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')\n# Just the administrative boundaries (polygons)\ntm_shape(sle_adm3) +               # admin boundaries shapefile\n  tm_polygons(col = \"#F7F7F7\")+    # show polygons in light grey\n  tm_borders(col = \"#000000\",      # show borders with color and line weight\n             lwd = 2) +\n  tm_text(\"admin3name\")            # column text to display for each polygon\n\n\n# Same as above, but with zoom from bounding box\ntm_shape(sle_adm3,\n         bbox = c(-13.3, 8.43,    # corner\n                  -13.2, 8.5)) +  # corner\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")\n# All together\ntm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")+\ntm_shape(linelist_sf) +\n  tm_dots(size=0.08, col='blue', alpha = 0.5) +\n  tm_layout(title = \"Distribution of Ebola cases\")   # give title to map"},{"path":"gis.html","id":"phép-nối-theo-không-gian","chapter":"28 GIS cơ bản","heading":"28.6 Phép nối theo không gian","text":"Bạn có thể đã quen với việc nối dữ liệu từ một tập dữ liệu này sang một tập dữ liệu khác. Một số phương pháp được thảo luận trong chương Nối dữ liệu của cuốn sổ tay này. Một phép nối theo không gian phục vụ một mục đích tương tự nhưng tận dụng các mối quan hệ không gian. Thay vì dựa vào các giá trị chung trong các cột để khớp chính xác các quan sát, bạn có thể sử dụng các mối quan hệ không gian của chúng, chẳng hạn như một đối tượng địa lý nằm trong đối tượng khác, hoặc hàng xóm gần nhất với đối tượng khác, hoặc ở trong vùng đệm của một bán kính nhất định từ đối tượng khác, v.v.Package sf cung cấp nhiều phương thức khác nhau để nối theo không gian. Xem thêm tài liệu về phương pháp st_join và các kiểu nối theo không gian trong tài liệu tham khảo này.","code":""},{"path":"gis.html","id":"điểm-trong-đa-giác","chapter":"28 GIS cơ bản","heading":"Điểm trong đa giác","text":"Gán đơn vị hành chính cho các trường hợp theo không gianSau đây là một câu hỏi hóc búa thú vị: linelist không chứa bất kỳ thông tin nào về các đơn vị hành chính của các trường hợp. Mặc dù lý tưởng nhất là thu thập thông tin như vậy trong giai đoạn thu thập dữ liệu ban đầu, chúng ta cũng có thể gán các đơn vị hành chính cho các trường hợp riêng lẻ dựa trên mối quan hệ không gian của chúng (tức là điểm giao với một đa giác)..Dưới đây, chúng ta sẽ giao các vị trí (điểm) theo không gian với địa giới hành chính cấp 3 (đa giác):Bắt đầu với linelist (các điểm)Nối theo không gian tới các địa giới, thiết lập kiểu nối là “st_intersects”Sử dụng hàm select() để chỉ giữ lại một số cột địa giới hành chính mớiTất cả các cột từ sle_adms đã được thêm vào linelist! Mỗi trường hợp bây giờ có các cột thể hiện chi tiết cấp hành chính mà nó nằm trong đó. Trong ví dụ này, chúng ta chỉ muốn giữ lại hai trong số các cột mới (địa giới hành chính cấp 3), vì vậy chúng dùng hàm select() để chọn tên các cột cũ và chỉ hai cột bổ sung quan tâm:Dưới đây, chỉ với mục đích hiển thị, bạn có thể thấy mười trường hợp đầu tiên và địa giới hành chính cấp 3 của chúng đã được gắn với nhau, dựa trên vị trí giao nhau trong không gian giữa các điểm với đa giác.Bây giờ chúng ta có thể mô tả các trường hợp theo đơn vị hành chính - điều mà chúng ta đã không thể làm trước khi nối theo không gian!Chúng ta cũng có thể tạo một biểu đồ cột về số lượng trường hợp theo đơn vị hành chính.Trong ví dụ này, chúng ta bắt đầu hàm ggplot() với bộ dữ liệu linelist_adm, trong đó chúng ta có thể áp dụng các hàm làm việc với factor như fct_infreq() để sắp xếp các cột theo tần suất (xem chương Factors để biết thêm các mẹo).","code":"\nlinelist_adm <- linelist_sf %>%\n  \n  # join the administrative boundary file to the linelist, based on spatial intersection\n  sf::st_join(sle_adm3, join = st_intersects)\nlinelist_adm <- linelist_sf %>%\n  \n  # join the administrative boundary file to the linelist, based on spatial intersection\n  sf::st_join(sle_adm3, join = st_intersects) %>% \n  \n  # Keep the old column names and two new admin ones of interest\n  select(names(linelist_sf), admin3name, admin3pcod)\n# Now you will see the ADM3 names attached to each case\nlinelist_adm %>% select(case_id, admin3name, admin3pcod)## Simple feature collection with 1000 features and 3 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: -13.27276 ymin: 8.448085 xmax: -13.20613 ymax: 8.490662\n## Geodetic CRS:  WGS 84\n## First 10 features:\n##      case_id     admin3name admin3pcod                   geometry\n## 1643  d7a110        West II   SL040207 POINT (-13.23329 8.467614)\n## 2490  beb534       West III   SL040208 POINT (-13.26787 8.454635)\n## 4773  60158e Mountain Rural   SL040102 POINT (-13.21581 8.461583)\n## 2063  47243a       West III   SL040208 POINT (-13.26943 8.461046)\n## 5628  7351ef Mountain Rural   SL040102 POINT (-13.21969 8.450125)\n## 4926  c1eb6f       West III   SL040208 POINT (-13.26134 8.463143)\n## 5444  928277       West III   SL040208 POINT (-13.26669 8.453813)\n## 1489  1e061f Mountain Rural   SL040102 POINT (-13.21972 8.451865)\n## 3789  ae97e8     Central II   SL040202 POINT (-13.23792 8.486407)\n## 3197  ce6cb9        West II   SL040207 POINT (-13.24835 8.463565)\n# Make new dataframe containing counts of cases by administrative unit\ncase_adm3 <- linelist_adm %>%          # begin with linelist with new admin cols\n  as_tibble() %>%                      # convert to tibble for better display\n  group_by(admin3pcod, admin3name) %>% # group by admin unit, both by name and pcode \n  summarise(cases = n()) %>%           # summarize and count rows\n  arrange(desc(cases))                     # arrange in descending order\n\ncase_adm3## # A tibble: 10 x 3\n## # Groups:   admin3pcod [10]\n##    admin3pcod admin3name     cases\n##    <chr>      <chr>          <int>\n##  1 SL040102   Mountain Rural   262\n##  2 SL040208   West III         223\n##  3 SL040207   West II          180\n##  4 SL040204   East II          128\n##  5 SL040201   Central I         56\n##  6 SL040203   East I            53\n##  7 SL040206   West I            47\n##  8 SL040202   Central II        26\n##  9 SL040205   East III          23\n## 10 <NA>       <NA>               2\nggplot(\n    data = linelist_adm,                       # begin with linelist containing admin unit info\n    mapping = aes(\n      x = fct_rev(fct_infreq(admin3name))))+ # x-axis is admin units, ordered by frequency (reversed)\n  geom_bar()+                                # create bars, height is number of rows\n  coord_flip()+                              # flip X and Y axes for easier reading of adm units\n  theme_classic()+                           # simplify background\n  labs(                                      # titles and labels\n    x = \"Admin level 3\",\n    y = \"Number of cases\",\n    title = \"Number of cases, by adminstative unit\",\n    caption = \"As determined by a spatial join, from 1000 randomly sampled cases from linelist\"\n  )"},{"path":"gis.html","id":"hàng-xóm-gần-nhất","chapter":"28 GIS cơ bản","heading":"Hàng xóm gần nhất","text":"Tìm cơ sở y tế gần nhất / khu vực cung cấp dịch vụ y tếCó thể sẽ hữu ích nếu biết các cơ sở y tế nằm ở đâu trong mối liên quan đến các điểm nóng về dịch bệnh.Chúng ta có thể sử dụng phương pháp nối st_nearest_feature trong hàm st_join() (sf package) để trực quan hóa cơ sở y tế gần nhất với các trường hợp bệnh nhân.Chúng ta bắt đầu với shapefile linelist có tên linelist_sfChúng ta nối theo không gian với đối tượng sle_hf, chứa thông tin về vị trí của các cơ sở y tế và phòng khám (các điểm)Chúng ta có thể thấy bên dưới (50 hàng đầu tiên) rằng mỗi trường hợp hiện đã có dữ liệu về phòng khám/bệnh viện gần nhấtChúng ta có thể thấy rằng “Den Clinic” là cơ sở y tế gần nhất với khoảng ~30% các trường hợp.Để trực quan hóa kết quả, chúng ta có thể sử dụng tmap - lúc này interactive mode sẽ xem dễ dàng hơn","code":"\n# Closest health facility to each case\nlinelist_sf_hf <- linelist_sf %>%                  # begin with linelist shapefile  \n  st_join(sle_hf, join = st_nearest_feature) %>%   # data from nearest clinic joined to case data \n  select(case_id, osm_id, name, amenity) %>%       # keep columns of interest, including id, name, type, and geometry of healthcare facility\n  rename(\"nearest_clinic\" = \"name\")                # re-name for clarity\n# Count cases by health facility\nhf_catchment <- linelist_sf_hf %>%   # begin with linelist including nearest clinic data\n  as.data.frame() %>%                # convert from shapefile to dataframe\n  count(nearest_clinic,              # count rows by \"name\" (of clinic)\n        name = \"case_n\") %>%         # assign new counts column as \"case_n\"\n  arrange(desc(case_n))              # arrange in descending order\n\nhf_catchment                         # print to console##                          nearest_clinic case_n\n## 1                            Den Clinic    361\n## 2       Shriners Hospitals for Children    312\n## 3         GINER HALL COMMUNITY HOSPITAL    175\n## 4                             panasonic     72\n## 5 Princess Christian Maternity Hospital     33\n## 6                     ARAB EGYPT CLINIC     21\n## 7                  MABELL HEALTH CENTER     16\n## 8                                  <NA>     10\ntmap_mode(\"view\")   # set tmap mode to interactive  \n\n# plot the cases and clinic points \ntm_shape(linelist_sf_hf) +            # plot cases\n  tm_dots(size=0.08,                  # cases colored by nearest clinic\n          col='nearest_clinic') +    \ntm_shape(sle_hf) +                    # plot clinic facilities in large black dots\n  tm_dots(size=0.3, col='black', alpha = 0.4) +      \n  tm_text(\"name\") +                   # overlay with name of facility\ntm_view(set.view = c(-13.2284, 8.4699, 13), # adjust zoom (center coords, zoom)\n        set.zoom.limits = c(13,14))+\ntm_layout(title = \"Cases, colored by nearest clinic\")"},{"path":"gis.html","id":"vùng-đệm","chapter":"28 GIS cơ bản","heading":"Vùng đệm","text":"Chúng ta cũng có thể tìm hiểu xem có bao nhiêu trường hợp nằm trong khoảng cách đi bộ 2,5 km (~30 phút) từ cơ sở y tế gần nhất.Chú ý: Để tính toán khoảng cách chính xác hơn, tốt hơn nên chiếu lại đối tượng sf của bạn lên hệ thống chiếu bản đồ địa phương tương ứng chẳng hạn như UTM (Trái đất được chiếu lên bề mặt phẳng). Trong ví dụ này, để đơn giản hơn, chúng ta sẽ dựa vào Hệ tọa độ địa lý của Hệ thống trắc địa thế giới (WGS84) (Trái đất được biểu diễn trong một bề mặt hình cầu/tròn, đó các đơn vị được tính bằng độ thập phân). Chúng ta sẽ sử dụng quy đổi chung là: 1 độ thập phân = ~111km.Xem thêm thông tin về phép chiếu bản đồ và hệ tọa độ tại bài viết này esri article. Blog này nói về các loại phép chiếu bản đồ khác nhau và cách người ta có thể chọn phép chiếu phù hợp tùy thuộc vào khu vực quan tâm và bối cảnh của bản đồ/phân tích của bạn.Đầu tiên, tạo một vùng đệm hình tròn với bán kính ~2.5km xung quanh mỗi cơ sở y tế. Điều này được thực hiện với hàm st_buffer() trong package tmap. Bởi vì đơn vị của bản đồ là kinh/vĩ độ thập phân, đó là cách “0.02” được diễn giải. Nếu hệ tọa độ bản đồ của bạn tính bằng mét, thì số đó phải được cung cấp bằng mét.Sau đây chúng ta vẽ biểu đồ của chính các vùng đệm, với:Thứ hai, chúng ta giao các vùng đệm này với các trường hợp (điểm) bằng cách sử dụng hàm st_join() và kiểu nối là st_intersects. Tức là, dữ liệu từ vùng đệm được nối với các điểm mà chúng giao với nhau.Bây giờ chúng ta có thể đếm kết quả: có nrow(linelist_sf_hf_2k[.na(linelist_sf_hf_2k$osm_id.y),]) trường hợp trong số 1000 trường hợp không giao nhau với bất kỳ vùng đệm nào (giá trị đó bị thiếu), và đó họ sống ở nơi cách nhiều hơn 30 phút đi bộ tới cơ sở y tế gần nhất.Chúng ta có thể trực quan hóa kết quả sao cho các trường hợp không giao nhau với bất kỳ vùng đệm nào sẽ xuất hiện với màu đỏ.","code":"\nsle_hf_2k <- sle_hf %>%\n  st_buffer(dist=0.02)       # decimal degrees translating to approximately 2.5km \ntmap_mode(\"plot\")\n# Create circular buffers\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2)+\ntm_shape(sle_hf) +                    # plot clinic facilities in large red dots\n  tm_dots(size=0.3, col='black')      \n# Intersect the cases with the buffers\nlinelist_sf_hf_2k <- linelist_sf_hf %>%\n  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%\n  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%\n  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)\n# Cases which did not get intersected with any of the health facility buffers\nlinelist_sf_hf_2k %>% \n  filter(is.na(osm_id.y)) %>%\n  nrow()## [1] 209\ntmap_mode(\"view\")\n\n# First display the cases in points\ntm_shape(linelist_sf_hf) +\n  tm_dots(size=0.08, col='nearest_clinic') +\n\n# plot clinic facilities in large black dots\ntm_shape(sle_hf) +                    \n  tm_dots(size=0.3, col='black')+   \n\n# Then overlay the health facility buffers in polylines\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2) +\n\n# Highlight cases that are not part of any health facility buffers\n# in red dots  \ntm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +\n  tm_dots(size=0.1, col='red') +\ntm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+\n\n# add title  \ntm_layout(title = \"Cases by clinic catchment area\")"},{"path":"gis.html","id":"các-hàm-nối-theo-không-gian-khác","chapter":"28 GIS cơ bản","heading":"Các hàm nối theo không gian khác","text":"Các giá trị tùy chọn cho đối số join bao gồm (lấy từ tài liệu này)st_contains_properlyst_containsst_covered_byst_coversst_crossesst_disjointst_equals_exactst_equalsst_is_within_distancest_nearest_featurest_overlapsst_touchesst_within","code":""},{"path":"gis.html","id":"bản-đồ-choropleth","chapter":"28 GIS cơ bản","heading":"28.7 Bản đồ Choropleth","text":"Bản đồ Choropleth có thể hữu ích để trực quan hóa dữ liệu của bạn theo khu vực được xác định trước, thường là đơn vị hành chính hoặc khu vực y tế. Ví dụ, trong ứng phó với ổ dịch, điều này có thể giúp xác định mục tiêu phân bổ nguồn lực cho các khu vực cụ thể có tỷ lệ mắc bệnh cao.Bây giờ chúng ta đã gán tên đơn vị hành chính cho tất cả các trường hợp (xem phần về phép nối không gian, ở trên), chúng ta có thể bắt đầu lập bản đồ số lượng trường hợp theo khu vực (bản đồ choropleth).Vì chúng ta cũng có dữ liệu dân số theo cấp hành chính cấp 3 (ADM3), chúng ta có thể thêm thông tin này vào bảng case_adm3 đã được tạo trước đó.Chúng ta bắt đầu với dataframe case_adm3 được tạo trong bước trước đó, là bảng tóm tắt của từng đơn vị hành chính và số lượng các trường hợp của nó.Dữ liệu dân số sle_adm3_pop được nối sử dụng hàm left_join() từ dplyr trên cơ sở các giá trị chung trên cột admin3pcod trong bộ dữ liệu case_adm3, và cột adm_pcode trong bộ dữ liệu sle_adm3_pop. Xem chương Nối dữ liệu).select() được áp dụng trên dataframe mới, để chỉ giữ những cột cần thiệt - total nghĩa là tổng dân sốCác trường hợp trên 10,000 dân được tính toán bằng cách tạo cột mới với hàm mutate()Nối bảng này với đa giác shapfile ADM3 để vẽ bản đồVẽ bản đồ kết quảChúng ta cũng có thể lập bản đồ tỷ suất mới mắc","code":"\n# Add population data and calculate cases per 10K population\ncase_adm3 <- case_adm3 %>% \n     left_join(sle_adm3_pop,                             # add columns from pop dataset\n               by = c(\"admin3pcod\" = \"adm3_pcode\")) %>%  # join based on common values across these two columns\n     select(names(case_adm3), total) %>%                 # keep only important columns, including total population\n     mutate(case_10kpop = round(cases/total * 10000, 3)) # make new column with case rate per 10000, rounded to 3 decimals\n\ncase_adm3                                                # print to console for viewing## # A tibble: 10 x 5\n## # Groups:   admin3pcod [10]\n##    admin3pcod admin3name     cases  total case_10kpop\n##    <chr>      <chr>          <int>  <int>       <dbl>\n##  1 SL040102   Mountain Rural   262  33993       77.1 \n##  2 SL040208   West III         223 210252       10.6 \n##  3 SL040207   West II          180 145109       12.4 \n##  4 SL040204   East II          128  99821       12.8 \n##  5 SL040201   Central I         56  69683        8.04\n##  6 SL040203   East I            53  68284        7.76\n##  7 SL040206   West I            47  60186        7.81\n##  8 SL040202   Central II        26  23874       10.9 \n##  9 SL040205   East III          23 500134        0.46\n## 10 <NA>       <NA>               2     NA       NA\ncase_adm3_sf <- case_adm3 %>%                 # begin with cases & rate by admin unit\n  left_join(sle_adm3, by=\"admin3pcod\") %>%    # join to shapefile data by common column\n  select(objectid, admin3pcod,                # keep only certain columns of interest\n         admin3name = admin3name.x,           # clean name of one column\n         admin2name, admin1name,\n         cases, total, case_10kpop,\n         geometry) %>%                        # keep geometry so polygons can be plotted\n  st_as_sf()                                  # convert to shapefile\n# tmap mode\ntmap_mode(\"plot\")               # view static map\n\n# plot polygons\ntm_shape(case_adm3_sf) + \n        tm_polygons(\"cases\") +  # color by number of cases column\n        tm_text(\"admin3name\")   # name display\n# Cases per 10K population\ntmap_mode(\"plot\")             # static viewing mode\n\n# plot\ntm_shape(case_adm3_sf) +                # plot polygons\n  tm_polygons(\"case_10kpop\",            # color by column containing case rate\n              breaks=c(0, 10, 50, 100), # define break points for colors\n              palette = \"Purples\"       # use a purple color palette\n              ) +\n  tm_text(\"admin3name\")                 # display text"},{"path":"gis.html","id":"vẽ-bản-đồ-với-ggplot2","chapter":"28 GIS cơ bản","heading":"28.8 Vẽ bản đồ với ggplot2","text":"Nếu bạn đã quen với việc sử dụng ggplot2, bạn có thể sử dụng package này để vẽ bản đồ tĩnh cho dữ liệu của bạn. Hàm geom_sf() sẽ vẽ các đối tượng khác nhau dựa trên các đối tượng địa lý (điểm, đường thẳng hoặc đa giác) có trong dữ liệu của bạn. Ví dụ: bạn có thể sử dụng hàm geom_sf() trong ggplot() bằng cách sử dụng dữ liệu sf với dạng hình học đa giác để tạo bản đồ choropleth.Để minh họa cách thức hoạt động của nó, Chúng ta có thể bắt đầu với shapefile đa giác ADM3 mà chúng ta đã sử dụng lúc trước. Xin nhớ lại rằng đây là các khu vực hành chính cấp 3 ở Sierra Leone:Chúng ta có thể sử dụng hàm left_join() từ dplyr để thêm dữ liệu mà chúng ta muốn vẽ tới đối tượng shapefile. Trong trường hợp này, chúng ta sẽ sử dụng bộ dữ liệu case_adm3 mà chúng ta đã tạo trước đó để tóm tắt số lượng trường hợp theo khu vực hành chính; tuy nhiên, chúng ta có thể sử dụng phương pháp tương tự này để vẽ bất kỳ dữ liệu nào được lưu trữ trong data frame.Để tạo biểu đồ cột về số lượng trường hợp theo khu vực, sử dụng ggplot2, sau đó chúng ta có thể gọi geom_col() như sau:Nếu chúng ta muốn sử dụng ggplot2 để tạo bản đồ choropleth về số lượng trường hợp, chúng ta có thể sử dụng cú pháp tương tự để gọi hàm geom_sf():Sau đó, chúng ta có thể tùy chỉnh hình thức bản đồ bằng cách sử dụng ngữ pháp nhất quán trên ggplot2, ví dụ:Đối với người dùng R cảm thấy thoải mái khi làm việc với ggplot2, geom_sf() cung cấp một cách làm đơn giản và trực tiếp, phù hợp với việc trực quan hóa bản đồ cơ bản. Để tìm hiểu thêm, hãy đọc hướng dẫn geom_sf() này hoặc sách về ggplot2.","code":"\nsle_adm3## Simple feature collection with 12 features and 19 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.094272 xmax: -12.91333 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 12 x 20\n##    objectid admin3name   admin3pcod admin3ref_n  admin2name   admin2pcod admin1name admin1pcod admin0name admin0pcod date       valid_on   valid_to   shape_leng shape_area\n##  *    <dbl> <chr>        <chr>      <chr>        <chr>        <chr>      <chr>      <chr>      <chr>      <chr>      <date>     <date>     <date>          <dbl>      <dbl>\n##  1      155 Koya Rural   SL040101   Koya Rural   Western Are~ SL0401     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.638   0.0137   \n##  2      156 Mountain Ru~ SL040102   Mountain Ru~ Western Are~ SL0401     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.293   0.00318  \n##  3      157 Waterloo Ru~ SL040103   Waterloo Ru~ Western Are~ SL0401     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.723   0.0136   \n##  4      158 York Rural   SL040104   York Rural   Western Are~ SL0401     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             1.24    0.0198   \n##  5      159 Central I    SL040201   Central I    Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.0688  0.000188 \n##  6      160 East I       SL040203   East I       Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.0575  0.000143 \n##  7      161 East II      SL040204   East II      Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.0840  0.000149 \n##  8      162 Central II   SL040202   Central II   Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.0488  0.0000651\n##  9      163 West III     SL040208   West III     Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.302   0.00170  \n## 10      164 West I       SL040206   West I       Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.0695  0.000182 \n## 11      165 West II      SL040207   West II      Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.149   0.000547 \n## 12      167 East III     SL040205   East III     Western Are~ SL0402     Western    SL04       Sierra Le~ SL         2016-08-01 2016-10-17 NA             0.327   0.00310  \n## # ... with 5 more variables: rowcacode0 <chr>, rowcacode1 <chr>, rowcacode2 <chr>, rowcacode3 <chr>, geometry <MULTIPOLYGON [°]>\nsle_adm3_dat <- sle_adm3 %>% \n  inner_join(case_adm3, by = \"admin3pcod\") # inner join = retain only if in both data objects\n\nselect(sle_adm3_dat, admin3name.x, cases) # print selected variables to console## Simple feature collection with 9 features and 2 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -13.29894 ymin: 8.384533 xmax: -13.12612 ymax: 8.499809\n## Geodetic CRS:  WGS 84\n## # A tibble: 9 x 3\n##   admin3name.x   cases                                                                                geometry\n##   <chr>          <int>                                                                      <MULTIPOLYGON [°]>\n## 1 Mountain Rural   262 (((-13.21496 8.474341, -13.21479 8.474289, -13.21465 8.474296, -13.21455 8.474298, -...\n## 2 Central I         56 (((-13.22646 8.489716, -13.22648 8.48955, -13.22644 8.489513, -13.22663 8.489229, -1...\n## 3 East I            53 (((-13.2129 8.494033, -13.21076 8.494026, -13.21013 8.494041, -13.2096 8.494025, -13...\n## 4 East II          128 (((-13.22653 8.491883, -13.22647 8.491853, -13.22642 8.49186, -13.22633 8.491814, -1...\n## 5 Central II        26 (((-13.23154 8.491768, -13.23141 8.491566, -13.23144 8.49146, -13.23131 8.491294, -1...\n## 6 West III         223 (((-13.28529 8.497354, -13.28456 8.496497, -13.28403 8.49621, -13.28338 8.496086, -1...\n## 7 West I            47 (((-13.24677 8.493453, -13.24669 8.493285, -13.2464 8.493132, -13.24627 8.493131, -1...\n## 8 West II          180 (((-13.25698 8.485518, -13.25685 8.485501, -13.25668 8.485505, -13.25657 8.485504, -...\n## 9 East III          23 (((-13.20465 8.485758, -13.20461 8.485698, -13.20449 8.485757, -13.20431 8.485577, -...\nggplot(data=sle_adm3_dat) +\n  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # reorder x axis by descending 'cases'\n               y=cases)) +                                  # y axis is number of cases by region\n  theme_bw() +\n  labs(                                                     # set figure text\n    title=\"Number of cases, by administrative unit\",\n    x=\"Admin level 3\",\n    y=\"Number of cases\"\n  ) + \n  guides(x=guide_axis(angle=45))                            # angle x-axis labels 45 degrees to fit better\nggplot(data=sle_adm3_dat) + \n  geom_sf(aes(fill=cases))    # set fill to vary by case count variable\nggplot(data=sle_adm3_dat) +                           \n  geom_sf(aes(fill=cases)) +                        \n  scale_fill_continuous(high=\"#54278f\", low=\"#f2f0f7\") +    # change color gradient\n  theme_bw() +\n  labs(title = \"Number of cases, by administrative unit\",   # set figure text\n       subtitle = \"Admin level 3\"\n  )"},{"path":"gis.html","id":"bản-đồ-cơ-sở","chapter":"28 GIS cơ bản","heading":"28.9 Bản đồ cơ sở","text":"","code":""},{"path":"gis.html","id":"openstreetmap","chapter":"28 GIS cơ bản","heading":"OpenStreetMap","text":"Dưới đây, chúng tôi mô tả cách lấy được bản đồ cơ sở cho bản đồ ggplot2 bằng cách sử dụng các tính năng của OpenStreetMap. Các phương pháp thay thế bao gồm sử dụng ggmap, yêu cầu bạn đăng ký miễn phí với Google (chi tiết).OpenStreetMap là một dự án hợp tác nhằm tạo ra một bản đồ thế giới có thể chỉnh sửa miễn phí. Dữ liệu vị trí địa lý nền tảng ví dụ: vị trí của các thành phố, đường xá, đặc điểm tự nhiên, sân bay, trường học, bệnh viện, đường xá, v.v.) được coi là đầu ra chính của dự án.Đầu tiên, chúng ta gọi package OpenStreetMap để lấy bản đồ cơ sở.Sau đó chúng ta tạo đối tượng map, được xác định bằng cách sử dụng hàm openmap() từ package OpenStreetMap (tài liệu). Chúng ta cung cấp những thông tin sau:upperLeft và lowerRight Hai cặp tọa độ xác định giới hạn của ô bản đồ cơ sở\nTrong trường hợp này, chúng tôi đã đưa giá trị tối đa và tối thiểu từ các hàng trong linelist, vì vậy bản đồ sẽ tương tác động với dữ liệu\nupperLeft và lowerRight Hai cặp tọa độ xác định giới hạn của ô bản đồ cơ sởTrong trường hợp này, chúng tôi đã đưa giá trị tối đa và tối thiểu từ các hàng trong linelist, vì vậy bản đồ sẽ tương tác động với dữ liệuzoom = (nếu null nó sẽ được xác định tự động)zoom = (nếu null nó sẽ được xác định tự động)type = loại bản đồ cơ sở nào - chúng tôi đã liệt kê một số khả năng ở đây và code hiện đang sử dụng cái đầu tiên ([1]) “osm”type = loại bản đồ cơ sở nào - chúng tôi đã liệt kê một số khả năng ở đây và code hiện đang sử dụng cái đầu tiên ([1]) “osm”mergeTiles = chúng tôi đã chọn TRUE để tất cả các lớp nền được hợp nhất thành mộtmergeTiles = chúng tôi đã chọn TRUE để tất cả các lớp nền được hợp nhất thành mộtNếu chúng ta vẽ bản đồ cơ sở này ngay bây giờ, sử dụng hàm autoplot.OpenStreetMap() từ package OpenStreetMap, bạn sẽ thấy rằng các đơn vị trên các trục không phải là kinh/vĩ độ. Nó đang sử dụng một hệ tọa độ khác. Để hiển thị chính xác nơi cứ trú các trường hợp (được lưu trữ theo vĩ độ/kinh độ), điều này phải được thay đổi.Vì vậy, chúng ta muốn chuyển đổi bản đồ thành vĩ độ/kinh độ với hàm openproj() từ package OpenStreetMap. Chúng ta cung cấp bản đồ cơ sở map và cũng cung cấp Hệ thống tham chiếu tọa độ (CRS) mà chúng ta muốn. Chúng ta thực hiện điều này bằng cách cung cấp chuỗi ký tự “proj.4” cho phép chiếu WGS 1984, nhưng bạn cũng có thể cung cấp CRS theo những cách khác. (xem trang này để hiểu rõ hơn chuỗi proj.4 là gì)Bây giờ khi chúng ta tạo biểu đồ, chúng ta thấy rằng dọc theo các trục là tọa độ vĩ độ và kinh độ. Hệ tọa độ đã được chuyển đổi. Bây giờ các trường hợp của chúng ta sẽ được biểu diễn chính xác nếu được phủ lên!Xem các hướng dẫn tại đây và tại đây để biết thêm chi tiết.","code":"\n# load package\npacman::p_load(OpenStreetMap)\n\n# Fit basemap by range of lat/long coordinates. Choose tile type\nmap <- openmap(\n  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # limits of basemap tile\n  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),\n  zoom = NULL,\n  type = c(\"osm\", \"stamen-toner\", \"stamen-terrain\", \"stamen-watercolor\", \"esri\",\"esri-topo\")[1])\nautoplot.OpenStreetMap(map)\n# Projection WGS84\nmap_latlon <- openproj(map, projection = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\")\n# Plot map. Must use \"autoplot\" in order to work with ggplot\nautoplot.OpenStreetMap(map_latlon)"},{"path":"gis.html","id":"bản-đồ-nhiệt-mật-độ-đường-viền","chapter":"28 GIS cơ bản","heading":"28.10 Bản đồ nhiệt mật độ đường viền","text":"Dưới đây, chúng tôi mô tả cách đạt được bản đồ nhiệt mật độ đường viền của các trường hợp, trên một bản đồ cơ sở, bắt đầu với một danh sách dòng (một dòng cho mỗi trường hợp).Tạo ô bản đồ cơ sở từ OpenStreetMap, như được mô tả ở trênVẽ biểu đồ các trường hợp từ linelist bằng cách sử dụng cột vĩ độ và kinh độChuyển đổi các điểm thành bản đồ nhiệt mật độ với hàm stat_density_2d() trong ggplot2,Khi chúng ta có một bản đồ cơ sở với tọa độ vĩ độ/kinh độ, chúng ta có thể vẽ các trường hợp của mình lên trên bằng cách sử dụng tọa độ vĩ độ/kinh độ của nơi cư trú của chúng.Xây dựng dựa trên hàm autoplot.OpenStreetMap() để tạo bản đồ cơ sở, các hàm ggplot2 sẽ dễ dàng thêm vào trên cùng, như được hiển thị với hàm geom_point() bên dưới:Bản đồ trên có thể khó giải thích, đặc biệt là với các điểm trùng lặp. Vì vậy, thay vào đó bạn có thể vẽ một bản đồ mật độ 2d bằng cách sử dụng hàm stat_density_2d() trong ggplot2. Bạn vẫn đang sử dụng tọa độ vĩ độ/kinh độ của linelist, nhưng ước tính mật độ lõi 2D được thực hiện và kết quả được hiển thị với các đường đồng mức - giống như bản đồ địa hình. Đọc bản đầy đủ tài liệu tại đây.","code":"\n# Plot map. Must be autoplotted to work with ggplot\nautoplot.OpenStreetMap(map_latlon)+                 # begin with the basemap\n  geom_point(                                       # add xy points from linelist lon and lat columns \n    data = linelist,                                \n    aes(x = lon, y = lat),\n    size = 1, \n    alpha = 0.5,\n    show.legend = FALSE) +                          # drop legend entirely\n  labs(x = \"Longitude\",                             # titles & labels\n       y = \"Latitude\",\n       title = \"Cumulative cases\")\n# begin with the basemap\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # add the density plot\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # specify color scale\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # labels \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases\")"},{"path":"gis.html","id":"bản-đồ-nhiệt-chuỗi-thời-gian","chapter":"28 GIS cơ bản","heading":"Bản đồ nhiệt chuỗi thời gian","text":"Bản đồ nhiệt mật độ ở trên cho thấy các trường hợp tích lũy. Chúng ta có thể khảo sát các vụ dịch theo thời gian và không gian bằng cách faceting bản đồ nhiệt dựa trên tháng khởi phát triệu chứng, như được rút ra từ linelist.Chúng ta bắt đầu với linelist, tạo một cột mới với Năm và Tháng khởi phát. Hàm format() trong base R thay đổi cách hiển thị ngày. Trong trường hợp này, chúng ta muốn “YYYY-MM”..Bây giờ, chúng ta chỉ cần đơn giản facet thông qua ggplot2 vào bản đồ nhiệt mật độ. facet_wrap() được áp dụng, sử dụng cột mới làm hàng. Chúng ta thiết lập số lượng cột được facet là 4 cho rõ ràng.","code":"\n# Extract month of onset\nlinelist <- linelist %>% \n  mutate(date_onset_ym = format(date_onset, \"%Y-%m\"))\n\n# Examine the values \ntable(linelist$date_onset_ym, useNA = \"always\")## \n## 2014-04 2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 2015-01 2015-02 2015-03 2015-04    <NA> \n##       1       6      13      39     103     190     181     124      93      77      58      43      27      45\n# packages\npacman::p_load(OpenStreetMap, tidyverse)\n\n# begin with the basemap\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # add the density plot\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # specify color scale\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # labels \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases over time\")+\n  \n  # facet the plot by month-year of onset\n  facet_wrap(~ date_onset_ym, ncol = 4)               "},{"path":"gis.html","id":"thống-kê-không-gian","chapter":"28 GIS cơ bản","heading":"28.11 Thống kê không gian","text":"Hầu hết các cuộc thảo luận của chúng ta cho đến nay đều tập trung vào việc trực quan hóa dữ liệu không gian. Trong một số trường hợp, bạn cũng có thể quan tâm đến việc sử dụng thống kê không gian để định lượng mối quan hệ không gian của các thuộc tính trong dữ liệu của mình. Phần này sẽ cung cấp một cái nhìn tổng quan ngắn gọn về một số khái niệm chính trong thống kê không gian và đề xuất một số tài liệu sẽ hữu ích để khám phá nếu bạn muốn thực hiện các phân tích không gian toàn diện hơn.","code":""},{"path":"gis.html","id":"mối-quan-hệ-không-gian","chapter":"28 GIS cơ bản","heading":"Mối quan hệ không gian","text":"Trước khi có thể tính toán bất kỳ số liệu thống kê không gian nào, chúng ta cần xác định mối quan hệ giữa các đối tượng địa lý trong dữ liệu của mình. Có nhiều cách để khái niệm hóa các mối quan hệ không gian, nhưng một mô hình đơn giản và thường được áp dụng để sử dụng là mô hình adjancy - liền kề - cụ thể là chúng ta mong đợi mối quan hệ địa lý giữa các khu vực có chung biên giới hoặc “láng giềng” với nhau..Chúng ta có thể định lượng các mối quan hệ liền kề giữa các vùng địa giới hành chính trong dữ liệu sle_adm3 mà chúng ta đang sử dụng với package spdep. Chúng ta sẽ cụ thể sự tiếp giáp queen, có nghĩa là các khu vực sẽ là hàng xóm của nhau nếu chúng có chung ít nhất một điểm dọc theo biên giới của chúng. Phương pháp thay thế có thể là sự tiếp giáp rook, đòi hỏi các khu vực phải chia sẻ một cạnh - trong trường hợp của chúng ta, với các đa giác không đều, sự phân biệt là không đáng kể, nhưng trong một số trường hợp, sự lựa chọn giữa queen và rook có thể có ảnh hưởng.Ma trận được ở trên hiển thị mối quan hệ giữa 9 vùng trong dữ liệu sle_adm3 của chúng ta. Điểm 0 cho biết hai vùng không phải là láng giềng, trong khi bất kỳ giá trị nào khác 0 cho biết mối quan hệ láng giềng. Các giá trị trong ma trận được chia tỷ lệ để mỗi vùng có tổng trọng số hàng là 1.Một cách tốt hơn để trực quan hóa những mối quan hệ láng giềng này là vẽ biểu đồ chúng:Chúng ta đã sử dụng phương pháp tiếp cận adjacency để xác định các đa giác hàng xóm; những người hàng xóm mà chúng ta đã xác định đôi khi cũng được gọi là những người hàng xóm dựa trên sự tiếp giáp. Nhưng đây chỉ là một cách để lựa chọn các khu vực dự kiến có mối quan hệ địa lý. Các cách tiếp cận thay thế phổ biến nhất để xác định các mối quan hệ địa lý tạo ra những người hàng xóm dựa trên khoảng cách; ngắn gọn thì chúng là:K-nearest neighbors - Dựa trên khoảng cách giữa các tâm (trung tâm có trọng số địa lý của mỗi vùng đa giác), hãy chọn n vùng gần nhất làm vùng lân cận. Ngưỡng khoảng cách tối đa cũng có thể được chỉ định. Trong spdep, bạn có thể sử dụng hàm knearneigh() (xem tài liệu).K-nearest neighbors - Dựa trên khoảng cách giữa các tâm (trung tâm có trọng số địa lý của mỗi vùng đa giác), hãy chọn n vùng gần nhất làm vùng lân cận. Ngưỡng khoảng cách tối đa cũng có thể được chỉ định. Trong spdep, bạn có thể sử dụng hàm knearneigh() (xem tài liệu).Distance threshold neighbors - Chọn tất cả hàng xóm trong một ngưỡng khoảng cách. Trong spdep, các mối quan hệ láng giềng này có thể được xác định bằng cách sử dụng hàm dnearneigh() (xem tài liệu).Distance threshold neighbors - Chọn tất cả hàng xóm trong một ngưỡng khoảng cách. Trong spdep, các mối quan hệ láng giềng này có thể được xác định bằng cách sử dụng hàm dnearneigh() (xem tài liệu).","code":"\nsle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # create neighbors \nsle_adjmat <- spdep::nb2mat(sle_nb)    # create matrix summarizing neighbor relationships\nsle_listw <- spdep::nb2listw(sle_nb)   # create listw (list of weights) object -- we will need this later\n\nsle_nb## Neighbour list object:\n## Number of regions: 9 \n## Number of nonzero links: 30 \n## Percentage nonzero weights: 37.03704 \n## Average number of links: 3.333333\nround(sle_adjmat, digits = 2)##   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n## 1 0.00 0.20 0.00 0.20 0.00  0.2 0.00 0.20 0.20\n## 2 0.25 0.00 0.00 0.25 0.25  0.0 0.00 0.25 0.00\n## 3 0.00 0.00 0.00 0.50 0.00  0.0 0.00 0.00 0.50\n## 4 0.25 0.25 0.25 0.00 0.00  0.0 0.00 0.00 0.25\n## 5 0.00 0.33 0.00 0.00 0.00  0.0 0.33 0.33 0.00\n## 6 0.50 0.00 0.00 0.00 0.00  0.0 0.00 0.50 0.00\n## 7 0.00 0.00 0.00 0.00 0.50  0.0 0.00 0.50 0.00\n## 8 0.20 0.20 0.00 0.00 0.20  0.2 0.20 0.00 0.00\n## 9 0.33 0.00 0.33 0.33 0.00  0.0 0.00 0.00 0.00\n## attr(,\"call\")\n## spdep::nb2mat(neighbours = sle_nb)\nplot(sle_adm3_dat$geometry) +                                           # plot region boundaries\n  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # add neighbor relationships"},{"path":"gis.html","id":"tự-tương-quan-không-gian","chapter":"28 GIS cơ bản","heading":"Tự tương quan không gian","text":"Định luật địa lý đầu tiên được trích dẫn của Tobler tuyên bố rằng “mọi thứ đều liên quan đến mọi thứ khác, nhưng những thứ ở gần có liên quan hơn những thứ ở xa”. Trong dịch tễ học, điều này thường có nghĩa là nguy cơ về một kết quả sức khỏe cụ thể ở một vùng nhất định tương tự với các vùng lân cận hơn là những vùng xa. Khái niệm này đã được chính thức hóa dưới dạng tự tương quan không gian - thuộc tính thống kê mà các đối tượng địa lý có giá trị tương tự được nhóm lại với nhau trong không gian. Các phép đo thống kê về tự tương quan không gian có thể được sử dụng để định lượng mức độ phân cụm không gian trong dữ liệu của bạn, xác định vị trí xảy ra phân cụm, và xác định các xu hướng chung về tự tương quan không gian giữa các biến khác nhau trong dữ liệu của bạn. Phần này giới thiệu tổng quan về một số thước đo phổ biến của tự tương quan không gian và cách tính chúng trong R.Moran’s - Đây là thống kê tóm tắt mang tính toàn cục (global) về mối tương quan giữa giá trị của một biến trong một vùng và giá trị của cùng một biến ở các vùng lân cận. Thống kê Moran’s thường dao động từ -1 tới 1. Giá trị 0 cho thấy không có tương quan không gian, trong khi các giá trị gần 1 hoặc -1 cho thấy tự tương quan không gian (các giá trị tương tự gần nhau) hoặc phân tán không gian (các giá trị không tương tự ở gần nhau) mạnh hơn.Ví dụ: chúng ta sẽ tính toán thống kê Moran’s để định lượng tự tương quan theo không gian trong các trường hợp Ebola mà chúng ta đã mapping trước đó (hãy nhớ rằng đây là một tập con các trường hợp từ một vụ dịch mô phỏng trong dataframe linelist). Package spdep có hàm moran.test có thể giúp chúng ta thực hiện phép tính toán này:Đầu ra từ hàm moran.test() cho chúng ta thấy kết quả thống kê Moran statistic từ hàm round(moran_i$estimate[1],2). Điều này cho thấy sự hiện diện của tự tương quan không gian trong dữ liệu của chúng ta - cụ thể là những khu vực có số ca mắc Ebola tương tự nhau thì có khả năng ở gần nhau. Giá trị p cung cấp bởi kiểm định moran.test() được tạo ra bằng cách sánh với kỳ vọng trong giả thuyết không là không có tự tương quan không gian, và có thể được sử dụng nếu bạn cần báo cáo kết quả của một kiểm định giả thuyết chính thức.Local Moran’s - Chúng ta có thể phân tách thống kê Moran’s (toàn cục - global) được tính toán ở trên để xác định tự tương quan cục bộ (local); nghĩa là, để xác định các cụm cụ thể trong dữ liệu của chúng ta. Thống kê này, đôi khi còn được gọi là Local Indicator Spatial Association (LISA), tóm tắt mức độ tự tương quan không gian xung quanh mỗi vùng riêng lẻ. Nó có thể hữu ích để tìm các điểm “nóng - hot” và “lạnh - cold” trên bản đồ.Để hiển thị một ví dụ, chúng ta có thể tính toán và lập bản đồ Local Moran’s cho các trường hợp Ebola ở trên với hàm local_moran() từ package spdep:Getis-Ord Gi* - Đây là một thống kê khác thường được sử dụng để phân tích điểm nóng - hotspot analysis; mức độ phổ biến của thống kê này liên quan đến ứng dụng của nó trong công cụ Phân tích điểm nóng của ArcGIS. Nó dựa trên giả định rằng thông thường, sự khác biệt về giá trị của một biến giữa các vùng lân cận phải tuân theo phân phối chuẩn. Nó sử dụng cách tiếp cận z-score để xác định các vùng có giá trị cao hơn đáng kể (điểm nóng) hoặc thấp hơn đáng kể (điểm lạnh) của một biến cụ thể, với các vùng lân cận của chúng..Chúng ta có thể tính toán và lập bản đồ chỉ số Gi* sử dụng hàm localG() từ package spdep:Như bạn có thể thấy, bản đồ được tạo ra bởi Getis-Ord Gi* trông hơi khác với bản đồ của Local Moran’s được tạo ra trước đó. Điều này phản ánh rằng phương pháp được sử dụng để tính toán hai số liệu thống kê này hơi khác nhau; bạn nên sử dụng cái nào tùy thuộc vào trường hợp sử dụng cụ thể của bạn và câu hỏi nghiên cứu quan tâm.Lee’s L test - Đây là một kiểm định thống kê về mối tương quan không gian giữa hai biến. Nó cho phép bạn kiểm định xem xu hướng không gian của một biến x có tương tự với xu hướng không gian của một biến y khác hay không, với giả định là chúng có mối tương quan không gian với nhauĐể đưa ra một ví dụ, hãy kiểm định liệu rằng xu hướng không gian các trường hợp Ebola từ một vụ dịch mô phỏng có tương quan với xu hướng không gian của dân số hay không. Để bắt đầu, chúng ta cần có một biến population trong bộ dữ liệu sle_adm3 của mình. Chúng ta có thể sử dụng biến total từ bộ dữ liệu sle_adm3_pop mà chúng ta đã tải trước đó.Chúng ta có thể trực quan hóa nhanh xu hướng không gian của hai biến cạnh nhau, để xem liệu chúng có tương tự nhau hay không:Một cách trực quan, các xu hướng có vẻ không giống nhau. Chúng ta có thể sử dụng hàm lee.test() trong package spdep để kiểm định liệu xu hướng tự tương quan không gian giữa hai biến số có liên quan có ý nghĩa thống kê với nhau hay không. Thống kê L sẽ gần tới 0 nếu không có mối tương quan giữa các xu hướng, gần bằng 1 nếu có mối tương quan dương mạnh (tức là các xu hướng tương tự nhau) và gần bằng -1 nếu có mối tương quan âm mạnh (tức là các xu hướng là ngược nhau).Kết quả từ thống kê Lee’s L cho hai biến là round(lee_test$estimate[1],2), chỉ ra rằng chúng có mối tương quan âm yếu. Điều này khẳng định đánh giá trực quan của chúng ta rằng xu hướng các trường hợp bệnh và dân số không liên quan đến nhau cũng như cung cấp bằng chứng rằng xu hướng không gian của các trường hợp không hoàn toàn là kết quả của mật độ dân số ở các khu vực có nguy cơ cao.Thống kê Lee L có thể hữu ích để đưa ra các suy luận về mối quan hệ phân bố theo không gian giữa các biến; tuy nhiên, để mô tả bản chất của mối quan hệ giữa hai biến một cách chi tiết hơn, hoặc điều chỉnh cho nhiễu, sẽ cần đến các kỹ thuật hồi quy không gian. Chúng sẽ được mô tả ngắn gọn trong phần sau.","code":"\nmoran_i <-spdep::moran.test(sle_adm3_dat$cases,    # numeric vector with variable of interest\n                            listw=sle_listw)       # listw object summarizing neighbor relationships\n\nmoran_i                                            # print results of Moran's I test## \n##  Moran I test under randomisation\n## \n## data:  sle_adm3_dat$cases  \n## weights: sle_listw    \n## \n## Moran I statistic standard deviate = 1.5288, p-value = 0.06315\n## alternative hypothesis: greater\n## sample estimates:\n## Moran I statistic       Expectation          Variance \n##         0.2015019        -0.1250000         0.0456085\n# calculate local Moran's I\nlocal_moran <- spdep::localmoran(                  \n  sle_adm3_dat$cases,                              # variable of interest\n  listw=sle_listw                                  # listw object with neighbor weights\n)\n\n# join results to sf data\nsle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    \n\n# plot map\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=Ii)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Local Moran's I\") +\n  labs(title=\"Local Moran's I statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n# Perform local G analysis\ngetis_ord <- spdep::localG(\n  sle_adm3_dat$cases,\n  sle_listw\n)\n\n# join results to sf data\nsle_adm3_dat$getis_ord <- getis_ord\n\n# plot map\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=getis_ord)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Gi*\") +\n  labs(title=\"Getis-Ord Gi* statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\nsle_adm3_dat <- sle_adm3_dat %>% \n  rename(population = total)                          # rename 'total' to 'population'\ntmap_mode(\"plot\")\n\ncases_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"cases\") + tm_layout(main.title=\"Cases\")\npop_map <- tm_shape(sle_adm3_dat) + tm_polygons(\"population\") + tm_layout(main.title=\"Population\")\n\ntmap_arrange(cases_map, pop_map, ncol=2)   # arrange into 2x1 facets\nlee_test <- spdep::lee.test(\n  x=sle_adm3_dat$cases,          # variable 1 to compare\n  y=sle_adm3_dat$population,     # variable 2 to compare\n  listw=sle_listw                # listw object with neighbor weights\n)\n\nlee_test## \n##  Lee's L statistic randomisation\n## \n## data:  sle_adm3_dat$cases ,  sle_adm3_dat$population \n## weights: sle_listw  \n## \n## Lee's L statistic standard deviate = -0.85616, p-value = 0.804\n## alternative hypothesis: greater\n## sample estimates:\n## Lee's L statistic       Expectation          Variance \n##       -0.13618400       -0.04104157        0.01234912"},{"path":"gis.html","id":"hồi-quy-không-gian","chapter":"28 GIS cơ bản","heading":"Hồi quy không gian","text":"Bạn có thể muốn đưa ra các suy luận thống kê về mối quan hệ giữa các biến trong dữ liệu không gian của mình. Trong những trường hợp này, sẽ hữu ích khi xem xét các kỹ thuật hồi quy không gian - nghĩa là, các cách tiếp cận hồi quy xem xét rõ ràng tổ chức không gian của các đơn vị trong dữ liệu của bạn. Một số lý mà bạn có thể cần xem xét các mô hình hồi quy không gian, thay vì các mô hình hồi quy tiêu chuẩn như GLM, bao gồm:Các mô hình hồi quy tiêu chuẩn giả định rằng các phần dư là độc lập với nhau. Khi có hiện tượng tự tương quan không gian mạnh, các phần dư của mô hình hồi quy chuẩn cũng có khả năng tự tương quan không gian, đó vi phạm giả định này. Điều này có thể dẫn đến các vấn đề trong việc giải thích kết quả mô hình, trong trường hợp đó, một mô hình không gian sẽ được ưu tiên hơn.Các mô hình hồi quy tiêu chuẩn giả định rằng các phần dư là độc lập với nhau. Khi có hiện tượng tự tương quan không gian mạnh, các phần dư của mô hình hồi quy chuẩn cũng có khả năng tự tương quan không gian, đó vi phạm giả định này. Điều này có thể dẫn đến các vấn đề trong việc giải thích kết quả mô hình, trong trường hợp đó, một mô hình không gian sẽ được ưu tiên hơn.Các mô hình hồi quy cũng thường giả định rằng tác động của một biến x là không đổi đối với tất cả các quan sát. Trong trường hợp không đồng nhất về không gian - spatial heterogenity, các tác động mà chúng ta muốn ước tính có thể thay đổi theo không gian và chúng ta có thể quan tâm đến việc định lượng những khác biệt đó. Trong trường hợp này, các mô hình hồi quy không gian mang lại sự linh hoạt hơn cho việc ước lượng và giải thích các tác động.Các mô hình hồi quy cũng thường giả định rằng tác động của một biến x là không đổi đối với tất cả các quan sát. Trong trường hợp không đồng nhất về không gian - spatial heterogenity, các tác động mà chúng ta muốn ước tính có thể thay đổi theo không gian và chúng ta có thể quan tâm đến việc định lượng những khác biệt đó. Trong trường hợp này, các mô hình hồi quy không gian mang lại sự linh hoạt hơn cho việc ước lượng và giải thích các tác động.Các chi tiết về phương pháp tiếp cận hồi quy không gian nằm ngoài phạm vi của sổ tay này. Thay vào đó, phần này sẽ cung cấp tổng quan về các mô hình hồi quy không gian phổ biến nhất và cách sử dụng của chúng, đồng thời giới thiệu cho bạn tài liệu tham khảo có thể sử dụng nếu bạn muốn khám phá thêm lĩnh vực này.Các mô hình sai số không gian - Spatial error models - Các mô hình này giả định rằng sai số trên các đơn vị không gian có tương quan với nhau, trong trường hợp đó, dữ liệu sẽ vi phạm các giả định của mô hình OLS tiêu chuẩn. Các mô hình này đôi khi còn được biết đến với tên Các mô hình tự hồi quy đồng thời - simultaneous autoregressive (SAR) models. Mô hình được fit bằng cách sử dụng hàm errorsarlm() trong package spatialreg (các hàm hồi quy không gian là một phần của package spdep).Các mô hình độ trễ không gian - Spatial lag models - Các mô hình này giả định rằng biến phụ thuộc của một vùng không chỉ bị ảnh hưởng bởi giá trị của các biến độc lập trong , mà còn bởi giá trị của các biến đó ở các vùng lân cận . Tương tự như các mô hình sai số không gian, các mô hình độ trễ không gian cũng thường được biết đến với tên gọi Các mô hình tự hồi quy đồng thời. Mô hình được fit bằng cách sử dụng hàm lagsarlm() trong package spatialreg.Package spdep chứa một số kiểm định hữu ích để quyết định lựa chọn giữa các mô hình OLS chuẩn, độ trễ không gian và sai số không gian. Các kiểm định này được gọi là chẩn đoán Lagrange Multiplier, có thể được sử dụng để xác định loại phụ thuộc không gian trong dữ liệu của bạn và chọn mô hình nào phù hợp nhất. Hàm lm.LMtests() có thể được sử dụng để tính toán tất cả các kiểm định Lagrange Multiplier. Anselin (1988) cũng cung cấp một sơ đồ khối hữu ích để quyết định sử dụng mô hình hồi quy không gian nào dựa trên kết quả của các kiểm định Lagrange Multiplier:Các mô hình Bayesian phân tầng - Bayesian hierarchical models - Phương pháp tiếp cận Bayes thường được sử dụng cho một số ứng dụng trong phân tích không gian, phổ biến nhất là lập bản đồ dịch bệnh. Chúng được ưu tiên sử dụng trong các trường hợp dữ liệu trường hợp được phân phối thưa thớt (ví dụ trong trường hợp các outcome là hiếm gặp) hoặc “nhiễu” về mặt thống kê, vì chúng có thể được sử dụng để tạo ra các ước tính “mượt mà” về nguy cơ bệnh tật bằng cách tính đến quy trình không gian tiềm ẩn cơ bản. Điều này có thể giúp cải thiện chất lượng của các ước tính. Chúng cũng cho phép người điều tra cụ thể trước (thông qua việc lựa chọn prior) các xu hướng tương quan không gian phức tạp có thể tồn tại trong dữ liệu, mà có thể giải thích cho các sự biến động phụ thuộc hoặc không phụ thuộc không gian trong cả biến độc lập và phụ thuộc. Trong R, các mô hình Bayesian phân tầng có thể sử dụng thông qua package CARbayes (xem hưỡng dẫn) hoặc R-INLA (xem trang web và sách giáo khoa). R cũng có thể được sử dụng để gọi phần mềm bên ngoài thực hiện ước lượng Bayes, chẳng hạn như JAGS hoặc WinBUGS.","code":""},{"path":"gis.html","id":"tài-nguyên-học-liệu-11","chapter":"28 GIS cơ bản","heading":"28.12 Tài nguyên học liệu","text":"R Các tính năng cơ bản và package sf vignetteR Các tính năng cơ bản và package sf vignetteR tmap package vignetteR tmap package vignetteggmap: Trực quan hóa không gian với ggplot2ggmap: Trực quan hóa không gian với ggplot2Giới thiệu về cách tạo bản đồ với R, tổng quan về các package khác nhauGiới thiệu về cách tạo bản đồ với R, tổng quan về các package khác nhauDữ liệu không gian trong R (khóa học EarthLab)Dữ liệu không gian trong R (khóa học EarthLab)Phân tích dữ liệu không gian ứng dụng trong R sách giáo khoaPhân tích dữ liệu không gian ứng dụng trong R sách giáo khoaSpatialEpiApp - một ứng dụng Shiny có thể tải xuống dưới dạng một package trong R, cho phép bạn cung cấp dữ liệu của riêng mình và tiến hành lập bản đồ, phân tích cụm và thống kê không gian.SpatialEpiApp - một ứng dụng Shiny có thể tải xuống dưới dạng một package trong R, cho phép bạn cung cấp dữ liệu của riêng mình và tiến hành lập bản đồ, phân tích cụm và thống kê không gian.Giới thiệu về kinh tế lượng không gian với R hội thảoGiới thiệu về kinh tế lượng không gian với R hội thảo","code":""},{"path":"tables-presentation.html","id":"tables-presentation","chapter":"29 Trình bày bảng","heading":"29 Trình bày bảng","text":"HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Chương này sẽ trình bày cách chuyển đổi một bảng tóm tắt dữ liệu thành các bảng sẵn sàng cho mục đích trình bày với package flextable. Các bảng này có thể được chèn vào slide powerpoint, trang HTML, tài liệu PDF hoặc Word, v.v.Hãy hiểu rằng trước khi sử dụng flextable, bạn phải tạo bảng tóm tắt dữ liệu dưới dạng một data frame. Sử dụng các phương pháp trong các chương Bảng mô tả và Xoay trục dữ liệu như tạo bảng đơn, tạo bảng chéo, xoay trục, và tính toán các thống kê mô tả. Kết quả là một data frame sau đó có thể được chuyển đến flextable để định dạng hiển thị.Có nhiều các R packages khác có thể được sử dụng để tạo bảng cho mục đích trình bày - trong chương này chúng tôi nhấm mạnh vào package flextable. Một ví dụ sử dụng knitr package và hàm của nó kable() có thể được tìm thấy trong chương Truy vết tiếp xúc. Tương tự như vậy, package DT cũng được nhấn mạnh trong chương Dashboards với Shiny. Các package khác như GT và huxtable được đề cập trong chương Package đề xuất.","code":""},{"path":"tables-presentation.html","id":"chuẩn-bị-19","chapter":"29 Trình bày bảng","heading":"29.1 Chuẩn bị","text":"","code":""},{"path":"tables-presentation.html","id":"gọi-packages-8","chapter":"29 Trình bày bảng","heading":"Gọi packages","text":"Hãy cài đặt và gọi package flextable. Trong sổ tay này chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt package nếu cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi package bằng lệnh library() từ base R. Xem thêm chương R cơ bản để biết thêm các thông tin về các package trong R.","code":"\npacman::p_load(\n  rio,            # import/export\n  here,           # file pathways\n  flextable,      # make HTML tables \n  officer,        # helper functions for tables\n  tidyverse)      # data management, summary, and visualization"},{"path":"tables-presentation.html","id":"nhập-dữ-liệu-14","chapter":"29 Trình bày bảng","heading":"Nhập dữ liệu","text":"Để bắt đầu, chúng ta nhập bộ dữ liệu linelist đã được làm sạch về các ca bệnh Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã làm sạch” (.rds file). Nhập dữ liệu bằng hàm import() từ package rio (chấp nhận nhiều loại tập tin như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị như dưới đây.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"tables-presentation.html","id":"chuẩn-bị-bảng","chapter":"29 Trình bày bảng","heading":"Chuẩn bị bảng","text":"Trước khi bắt đầu sử dụng flextable bạn cần phải tạo bảng của bạn dưới một data frame. Xem chương Bảng mô tả và Xoay trục dữ liệu để biết cách tạo một data frame sử dụng các packages như janitor và dplyr. Đầu tiên, bạn phải sắp xếp nội dung theo hàng và cột như cách bạn muốn nội dung hiển thị. Sau đó, data frame sẽ được chuyển đến flextable để hiển thị nó với màu sắc, tiêu đề, phông chữ, v.v.Dưới đây là một ví dụ trong chương Bảng mô tả về cách biến đổi các trường hợp bệnh trong linelist thành một data frame để tóm tắt các outcomes của bệnh nhân và giá trị CT theo bệnh viện, với hàng Tổng ở cuối bảng. Đầu ra được lưu dưới dạng table.","code":"\ntable <- linelist %>% \n  \n  # Get summary values per hospital-outcome group\n  ###############################################\n  group_by(hospital, outcome) %>%                      # Group data\n  summarise(                                           # Create new summary columns of indicators of interest\n    N = n(),                                            # Number of rows per hospital-outcome group     \n    ct_value = median(ct_blood, na.rm=T)) %>%           # median CT value per group\n  \n  # add totals\n  ############\n  bind_rows(                                           # Bind the previous table with this mini-table of totals\n    linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    \n      summarise(\n        N = n(),                                       # Number of rows for whole dataset     \n        ct_value = median(ct_blood, na.rm=T))) %>%     # Median CT for whole dataset\n  \n  # Pivot wider and format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # Pivot from long to wide\n    values_from = c(ct_value, N),                       # new values are from ct and count columns\n    names_from = outcome) %>%                           # new column names are from outcomes\n  mutate(                                              # Add new columns\n    N_Known = N_Death + N_Recover,                               # number with known outcome\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)\n  select(                                              # Re-order columns\n    hospital, N_Known,                                   # Intro columns\n    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns\n  arrange(N_Known)                                    # Arrange rows from lowest to highest (Total row at bottom)\n\ntable  # print## # A tibble: 7 x 8\n## # Groups:   hospital [7]\n##   hospital                             N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death ct_value_Death\n##   <chr>                                  <int>     <int> <chr>                  <dbl>   <int> <chr>              <dbl>\n## 1 St. Mark's Maternity Hospital (SMMH)     325       126 38.8%                     22     199 61.2%                 22\n## 2 Central Hospital                         358       165 46.1%                     22     193 53.9%                 22\n## 3 Other                                    685       290 42.3%                     21     395 57.7%                 22\n## 4 Military Hospital                        708       309 43.6%                     22     399 56.4%                 21\n## 5 Missing                                 1125       514 45.7%                     21     611 54.3%                 21\n## 6 Port Hospital                           1364       579 42.4%                     21     785 57.6%                 22\n## 7 Total                                   3440      1469 42.7%                     22    1971 57.3%                 22"},{"path":"tables-presentation.html","id":"cơ-bản-về-flextable","chapter":"29 Trình bày bảng","heading":"29.2 Cơ bản về flextable","text":"","code":""},{"path":"tables-presentation.html","id":"tạo-một-flextable","chapter":"29 Trình bày bảng","heading":"Tạo một flextable","text":"Để tạo và quản lý các đối tượng của flextable, đầu tiên chúng ta đẩy data frame vào hàm flextable(), sau đó lưu kết quả là my_table.hospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Sau khi thực hiện việc này, chúng ta có thể pipe dần đối tượng my_table thông qua các hàm định dạng flextable khác.Trong trang này để rõ ràng, chúng tôi sẽ lưu bảng ở các bước trung gian vào đối tượng my_table, thêm các hàm flextable theo từng bước. Nếu bạn muốn xem tất cả code từ đầu đến cuối được viết trong một đoạn, hãy xem mục Kết hợp tất cả các code phía dưới đây.Cú pháp chung của mỗi dòng code flextable như sau:function(table, = X, j = X, part = \"X\"), :\n‘function’ có thể là một trong số rất nhiều hàm khác nhau, ví dụ như width() để xác định độ rộng cột, bg() để thiết lập màu nền, align() để điều chỉnh văn bản căn giữa / phải / trái, v.v.\ntable = tên của data frame, có thể bỏ qua nếu như data frame được piping vào trong hàm.\npart = đề cập đến phần nào của bảng mà hàm đang được áp dụng. Ví dụ. “tiêu đề”, “nội dung” hoặc “tất cả”.\n= chỉ định hàng mà hàm sẽ được áp dụng, trong đó ‘X’ là số thứ tự hàng. Nếu nhiều hàng được chọn, ví dụ: từ hàng đầu tiên đến hàng thứ ba, ta có thể viết: = c (1: 3). Lưu ý nếu chọn ‘body’, hàng đầu tiên bắt đầu từ bên dưới phần tiêu đề.\nj = chỉ định cột mà hàm sẽ được áp dụng, trong đó ‘X’ là số thứ tự cột hoặc tên cột. Nếu nhiều cột được chọn, ví dụ: từ hàng thứ năm đến hàng thứ sáu, ta có thể viết: j = c(5,6).\n‘function’ có thể là một trong số rất nhiều hàm khác nhau, ví dụ như width() để xác định độ rộng cột, bg() để thiết lập màu nền, align() để điều chỉnh văn bản căn giữa / phải / trái, v.v.table = tên của data frame, có thể bỏ qua nếu như data frame được piping vào trong hàm.part = đề cập đến phần nào của bảng mà hàm đang được áp dụng. Ví dụ. “tiêu đề”, “nội dung” hoặc “tất cả”.= chỉ định hàng mà hàm sẽ được áp dụng, trong đó ‘X’ là số thứ tự hàng. Nếu nhiều hàng được chọn, ví dụ: từ hàng đầu tiên đến hàng thứ ba, ta có thể viết: = c (1: 3). Lưu ý nếu chọn ‘body’, hàng đầu tiên bắt đầu từ bên dưới phần tiêu đề.j = chỉ định cột mà hàm sẽ được áp dụng, trong đó ‘X’ là số thứ tự cột hoặc tên cột. Nếu nhiều cột được chọn, ví dụ: từ hàng thứ năm đến hàng thứ sáu, ta có thể viết: j = c(5,6).Bạn có thể tìm thấy danh sách đầy đủ các hàm định dạng trong package flextable tại đây hoặc xem tài liệu hướng dẫn bằng cách gõ ?flextable.","code":"\nmy_table <- flextable(table) \nmy_table"},{"path":"tables-presentation.html","id":"độ-rộng-cột","chapter":"29 Trình bày bảng","heading":"Độ rộng cột","text":"Chúng ta có thể sử dụng hàm autofit() để điều chỉnh bảng sao cho mỗi ô chỉ có một hàng văn bản. Hàm qflextable() là một cách viết tắt thuận tiện cho flextable() và autofit().hospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Tuy nhiên, điều này có thể không phải lúc nào cũng phù hợp, đặc biệt nếu có các giá trị rất dài trong các ô, nghĩa là bảng có thể không vừa trong độ rộng của trang.Thay vào đó, chúng ta có thể điều chỉnh độ rộng cột bằng hàm width(). Điều này có thể tốn một chút thời gian để tìm giá trị chiều rộng phù hợp cho các cột. Trong ví dụ dưới đây, chúng ta chỉ định các độ rộng khác nhau cho cột 1, cột 2 và cột 4 đến 8.hospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table %>% autofit()\nmy_table <- my_table %>% \n  width(j=1, width = 2.7) %>% \n  width(j=2, width = 1.5) %>% \n  width(j=c(4,5,7,8), width = 1)\n\nmy_table"},{"path":"tables-presentation.html","id":"tiêu-đề-cột","chapter":"29 Trình bày bảng","heading":"Tiêu đề cột","text":"Một bảng có nhiều tiêu đề cột sẽ giúp giải thích nội dung bảng một cách dễ dàng hơn.Đối với bảng này, chúng ta cần thêm một lớp tiêu đề thứ hai để các cột bao gồm các nhóm con giống nhau có thể được nhóm lại với nhau. Chúng ta thực hiện điều này bằng hàm add_header_row() với top = TRUE. Chúng ta cung cấp tên mới của mỗi cột bằng values =, bỏ trống \"\" đối với các cột chúng ta dự định sẽ ghép lại với nhau sau này.Chúng ta cũng đổi tên các tên tiêu đề phụ ở hàng thứ hai bằng lệnh set_header_labels().Cuối cùng, chúng ta sử dụng hàm merge_at () để hợp nhất các tiêu đề cột trong hàng tiêu đề trên cùng.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table <- my_table %>% \n  \n  add_header_row(\n    top = TRUE,                # New header goes on top of existing header row\n    values = c(\"Hospital\",     # Header values for each column below\n               \"Total cases with known outcome\", \n               \"Recovered\",    # This will be the top-level header for this and two next columns\n               \"\",\n               \"\",\n               \"Died\",         # This will be the top-level header for this and two next columns\n               \"\",             # Leave blank, as it will be merged with \"Died\"\n               \"\")) %>% \n    \n  set_header_labels(         # Rename the columns in original header row\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %>% \n  \n  merge_at(i = 1, j = 3:5, part = \"header\") %>% # Horizontally merge columns 3 to 5 in new header row\n  merge_at(i = 1, j = 6:8, part = \"header\")     # Horizontally merge columns 6 to 8 in new header row\n\nmy_table  # print"},{"path":"tables-presentation.html","id":"đường-viền-và-nền","chapter":"29 Trình bày bảng","heading":"Đường viền và nền","text":"Bạn có thể điều chỉnh đường viền, đường bên trong, v.v. bằng các hàm khác nhau trong flextable. Để dễ dàng, thông thường đầu tiên bạn cần loại bỏ hết các đường viền trong bảng bằng hàm border_remove().Sau đó, bạn có thể áp dụng các theme đường viền mặc định bằng cách đưa bảng tới hàm theme_box(), theme_booktabs(), hoặc theme_alafoli().Bạn có thể thêm các đường dọc và ngang bằng nhiều hàm khác nhau. hline() và vline() sẽ thêm các dòng vào một hàng hoặc cột cụ thể. Bên trong hàm, bạn cần chỉ định phần mà bảng sẽ áp dụng qua đối số part = với các tùy chọn “”, “body”, hoặc “header”. Đối với các đường dọc, ghi rõ cột được áp dụng với j =, đối với các đường ngang, ghi rõ hàng được áp dụng với =. Các hàm khác như vline_right(), vline_left(), hline_top(), và hline_bottom() chỉ thêm các đường viền ở bên ngoài.Bên trong tất cả các hàm này, kiểu đường phải được định nghĩa thông qua đối số border = và phải là đầu ra của một lệnh riêng biệt bằng cách sử dụng hàm fp_border() từ package officer. Hàm này giúp bạn xác định độ rộng và màu sắc của đường. Bạn có thể định nghĩa các thông tin này phía trên trước khi thực hiện các lệnh liên quan tới bảng, như được trình bày dưới đây:HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\n# define style for border line\nborder_style = officer::fp_border(color=\"black\", width=1)\n\n# add border lines to table\nmy_table <- my_table %>% \n\n  # Remove all existing borders\n  border_remove() %>%  \n  \n  # add horizontal lines via a pre-determined theme setting\n  theme_booktabs() %>% \n  \n  # add vertical lines to separate Recovered and Died sections\n  vline(part = \"all\", j = 2, border = border_style) %>%   # at column 2 \n  vline(part = \"all\", j = 5, border = border_style)       # at column 5\n\nmy_table"},{"path":"tables-presentation.html","id":"phông-chữ-và-căn-chỉnh","chapter":"29 Trình bày bảng","heading":"Phông chữ và căn chỉnh","text":"Chúng ta căn giữa tất cả các cột ngoại trừ cột ngoài cùng bên trái với tên các bệnh viện, bằng cách sử dụng hàm align() từ flextable.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Ngoài ra, chúng ta có thể tăng kích thước phông chữ tiêu đề và sau đó thay đổi thành đậm. Chúng ta cũng có thể thay đổi hàng “Total” thành đậm.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Chúng ta cũng có thể thiết lập để các cột tỷ lệ chỉ hiển thị một chữ số thập phân bằng cách sử dụng hàm colformat_num(). Lưu ý rằng điều này cũng có thể được thực hiện ở giai đoạn quản lý dữ liệu với hàm round().HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table <- my_table %>% \n   flextable::align(align = \"center\", j = c(2:8), part = \"all\") \nmy_table\nmy_table <-  my_table %>%  \n  fontsize(i = 1, size = 12, part = \"header\") %>%   # adjust font size of header\n  bold(i = 1, bold = TRUE, part = \"header\") %>%     # adjust bold face of header\n  bold(i = 7, bold = TRUE, part = \"body\")           # adjust bold face of total row (row 7 of body)\n\nmy_table\nmy_table <- colformat_num(my_table, j = c(4,7), digits = 1)\nmy_table"},{"path":"tables-presentation.html","id":"hợp-nhất-ô","chapter":"29 Trình bày bảng","heading":"Hợp nhất ô","text":"Cũng giống như khi chúng ta hợp nhất các ô theo chiều ngang trong hàng tiêu đề, chúng ta cũng có thể hợp nhất các ô theo chiều dọc bằng cách sử dụng merge_at() và chỉ rõ các hàng () và cột (j). Ở đây chúng ta hợp nhất ô “Hospital” và “Total cases known outcome” theo chiều dọc để cung cấp thêm không gian cho chúng.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table <- my_table %>% \n  merge_at(i = 1:2, j = 1, part = \"header\") %>% \n  merge_at(i = 1:2, j = 2, part = \"header\")\n\nmy_table"},{"path":"tables-presentation.html","id":"màu-nền","chapter":"29 Trình bày bảng","heading":"Màu nền","text":"Để phân biệt nội dung của bảng với các tiêu đề, chúng ta có thể muốn thêm định dạng bổ sung, ví dụ như thay đổi màu nền. Trong ví dụ này, chúng ta sẽ thay đổi nội dung bảng thành màu xám.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table <- my_table %>% \n    bg(part = \"body\", bg = \"gray95\")  \n\nmy_table "},{"path":"tables-presentation.html","id":"định-dạng-có-điều-kiện","chapter":"29 Trình bày bảng","heading":"29.3 Định dạng có điều kiện","text":"Chúng ta có thể highlight tất cả các giá trị trong một cột đáp ứng một quy tắc nhất định, ví dụ các ô có hơn 55% trường hợp tử vong. Đơn giản chỉ cần đặt điều kiện sánh vào trong đối số = hoặc j =, phía sau dấu ~. Bạn cần tham chiếu tới thứ tự cột cần highlight trong trong data frame, không phải tiêu đề cột.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22Hoặc, chúng ta có thể highlight toàn bộ hàng đáp ứng một tiêu chí nhất định, chẳng hạn như tên một bệnh viện. Để làm điều này đơn giản chỉ cần không định danh thông số ở đối số (j), để các tiêu chí được áp dụng cho tất cả các cột.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nmy_table %>% \n  bg(j = 7, i = ~ Pct_Death >= 55, part = \"body\", bg = \"red\") \nmy_table %>% \n  bg(., i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") "},{"path":"tables-presentation.html","id":"tbl_pres_all","chapter":"29 Trình bày bảng","heading":"29.4 Kết hợp tất cả các code","text":"Dưới đây, chúng tôi ghép tất cả code từ các phần trên lại với nhau.HospitalTotal cases known outcomeRecoveredDiedTotal% casesMedian CT valuesTotal% casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22","code":"\nborder_style = officer::fp_border(color=\"black\", width=1)\n\npacman::p_load(\n  rio,            # import/export\n  here,           # file pathways\n  flextable,      # make HTML tables \n  officer,        # helper functions for tables\n  tidyverse)      # data management, summary, and visualization\n\ntable <- linelist %>% \n\n  # Get summary values per hospital-outcome group\n  ###############################################\n  group_by(hospital, outcome) %>%                      # Group data\n  summarise(                                           # Create new summary columns of indicators of interest\n    N = n(),                                            # Number of rows per hospital-outcome group     \n    ct_value = median(ct_blood, na.rm=T)) %>%           # median CT value per group\n  \n  # add totals\n  ############\n  bind_rows(                                           # Bind the previous table with this mini-table of totals\n    linelist %>% \n      filter(!is.na(outcome) & hospital != \"Missing\") %>%\n      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    \n      summarise(\n        N = n(),                                       # Number of rows for whole dataset     \n        ct_value = median(ct_blood, na.rm=T))) %>%     # Median CT for whole dataset\n  \n  # Pivot wider and format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %>% \n  pivot_wider(                                         # Pivot from long to wide\n    values_from = c(ct_value, N),                       # new values are from ct and count columns\n    names_from = outcome) %>%                           # new column names are from outcomes\n  mutate(                                              # Add new columns\n    N_Known = N_Death + N_Recover,                               # number with known outcome\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)\n  select(                                              # Re-order columns\n    hospital, N_Known,                                   # Intro columns\n    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns\n    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns\n  arrange(N_Known) %>%                                 # Arrange rows from lowest to highest (Total row at bottom)\n\n  # formatting\n  ############\n  flextable() %>%              # table is piped in from above\n  add_header_row(\n    top = TRUE,                # New header goes on top of existing header row\n    values = c(\"Hospital\",     # Header values for each column below\n               \"Total cases with known outcome\", \n               \"Recovered\",    # This will be the top-level header for this and two next columns\n               \"\",\n               \"\",\n               \"Died\",         # This will be the top-level header for this and two next columns\n               \"\",             # Leave blank, as it will be merged with \"Died\"\n               \"\")) %>% \n    set_header_labels(         # Rename the columns in original header row\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %>% \n  merge_at(i = 1, j = 3:5, part = \"header\") %>% # Horizontally merge columns 3 to 5 in new header row\n  merge_at(i = 1, j = 6:8, part = \"header\") %>%  \n  border_remove() %>%  \n  theme_booktabs() %>% \n  vline(part = \"all\", j = 2, border = border_style) %>%   # at column 2 \n  vline(part = \"all\", j = 5, border = border_style) %>%   # at column 5\n  merge_at(i = 1:2, j = 1, part = \"header\") %>% \n  merge_at(i = 1:2, j = 2, part = \"header\") %>% \n  width(j=1, width = 2.7) %>% \n  width(j=2, width = 1.5) %>% \n  width(j=c(4,5,7,8), width = 1) %>% \n  flextable::align(., align = \"center\", j = c(2:8), part = \"all\") %>% \n  bg(., part = \"body\", bg = \"gray95\")  %>% \n  bg(., j=c(1:8), i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") %>% \n  colformat_num(., j = c(4,7), digits = 1) %>%\n  bold(i = 1, bold = TRUE, part = \"header\") %>% \n  bold(i = 7, bold = TRUE, part = \"body\")## `summarise()` has grouped output by 'hospital'. You can override using the `.groups` argument.\ntable"},{"path":"tables-presentation.html","id":"lưu-bảng-của-bạn","chapter":"29 Trình bày bảng","heading":"29.5 Lưu bảng của bạn","text":"Có nhiều cách khác nhau mà bảng có thể được tích hợp vào kết quả đầu ra của bạn.","code":""},{"path":"tables-presentation.html","id":"lưu-bảng-đơn","chapter":"29 Trình bày bảng","heading":"Lưu bảng đơn","text":"Bạn có thể xuất các bảng ra file Word, PowerPoint hoặc HTML hoặc dưới tệp tin ảnh (PNG). Để thực hiện điều này, hãy sử dụng một trong các hàm sau:save_as_docx()save_as_pptx()save_as_image()save_as_html()Ví dụ dưới đây, chúng ta sẽ lưu bảng dưới dạng tài liệu word. Lưu ý cú pháp của đối số đầu tiên - bạn chỉ có thể cung cấp tên của đối tượng flextable, ví dụ: my_table, hoặc bạn có thể gán một “tên” cho bảng (ví dụ đặt tên là “table”). Nếu đặt tên thì tên này sẽ xuất hiện dưới dạng tiêu đề của bảng trong Word. Code để lưu bảng dưới dạng ảnh PNG cũng được minh họa như dưới đây.Lưu ý là bạn cần cài đặt package webshot hoặc webshot2 để lưu bảng từ flextable dưới dạng ảnh. Hình ảnh xuất ra sẽ có nền trong suốt.Nếu bạn muốn xem thử kết quả đầu ra của bảng flextable , sử dụng lệnh print() và chỉ định định dạng muốn xem trước với preview =. Tài liệu sẽ được “mở lên” trên máy tính của bạn bằng phần mềm đã chỉ định, nhưng sẽ không được lưu. Điều này có thể hữu ích để kiểm tra xem bảng có vừa với một trang/slide hay không hoặc bạn có thể nhanh chóng copy kết quả sang một tài liệu khác. Bạn có thể sử dụng phương pháp này với đối số preview đặt là “pptx” hoặc “docx”.","code":"\n# Edit the 'my table' as needed for the title of table.  \nsave_as_docx(\"my table\" = my_table, path = \"file.docx\")\n\nsave_as_image(my_table, path = \"file.png\")\nprint(my_table, preview = \"docx\") # Word document example\nprint(my_table, preview = \"pptx\") # Powerpoint example"},{"path":"tables-presentation.html","id":"in-bảng-trong-r-markdown","chapter":"29 Trình bày bảng","heading":"In bảng trong R markdown","text":"Bảng này có thể được tích hợp vào R markdown, một dạng báo cáo tự động của bạn, nếu đối tượng bảng được gọi trong phần code chunk của R markdown. Điều này có nghĩa là bảng có thể được cập nhật như một phần của báo cáo trong đó dữ liệu có thể thay đổi, đó, các con số có thể được làm mới.Xem thêm chi tiết trong chương Báo cáo với R Markdown của cuốn sổ tay này.","code":""},{"path":"tables-presentation.html","id":"nguồn-6","chapter":"29 Trình bày bảng","heading":"29.6 Nguồn","text":"Sách đầy đủ về flextable có thể xem ở đây: https://ardata-fr.github.io/flextable-book/\nTrang Github xem ở đây\nCó thể tìm thấy sách hướng dẫn về tất cả các hàm flextable ở đâyThư viên các ví dụ về mẫu bảng flextable cùng code có thể truy cập tại đây","code":""},{"path":"ggplot-basics.html","id":"ggplot-basics","chapter":"30 ggplot cơ bản","heading":"30 ggplot cơ bản","text":"ggplot2 là một package dùng để trực quan hóa dữ liệu phổ biến nhất trong R. Các hàm ggplot() là nền tảng của package này, và toàn bộ cách tiếp cận này thường được gọi là “ggplot” với các số liệu kết quả đôi khi được gọi trìu mến là “ggplots”. Chữ “gg” bắt nguồn từ chữ “grammar graphics” (ngữ pháp đồ thị) dùng để xây dựng các biểu đồ. ggplot2 được hưởng lợi từ nhiều package R bổ sung giúp nâng cao hơn nữa chức năng của nó.Cú pháp của nó khác biệt đáng kể với vẽ biểu đồ bằng base R, cũng như có một đường cong học tập gắn với nó. Sử dụng ggplot2 thông thường yêu cầu người sử dụng phải định dạng lại dữ liệu của họ để tương thích với tidyverse, giúp cho việc sử dụng các packages này cùng nhau một cách có hiệu quả.Trong chương này, chúng tôi sẽ trình bày các nguyên tắc cơ bản về vẽ biểu đồ bằng ggplot2. Xem chương Các tips với ggplot để biết các gợi ý và các kỹ thuật nâng cao giúp cho biểu đồ của bạn thực sự trông đẹp mắt.Có một số hướng dẫn ggplot2 mở rộng được liên kết trong phần tài nguyên học liệu. Bạn cũng có thể tải xuống trực quan hóa dữ liệu với ggplot cheatsheet từ trang web của RStudio. Nếu bạn muốn có cảm hứng cho các cách trực quan hóa dữ liệu của mình một cách sáng tạo, chúng tôi khuyên bạn nên ghé thăm các trang web như R graph gallery và Data--viz.","code":""},{"path":"ggplot-basics.html","id":"chuẩn-bị-20","chapter":"30 ggplot cơ bản","heading":"30.1 Chuẩn bị","text":"","code":""},{"path":"ggplot-basics.html","id":"gọi-packages-9","chapter":"30 ggplot cơ bản","heading":"Gọi packages","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.","code":"\npacman::p_load(\n  tidyverse,      # includes ggplot2 and other data management tools\n  rio,            # import/export\n  here,           # file locator\n  stringr         # working with characters   \n)"},{"path":"ggplot-basics.html","id":"nhập-dữ-liệu-15","chapter":"30 ggplot cơ bản","heading":"Nhập dữ liệu","text":"Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới. Chúng ta sẽ tập trung và hai biến liên tục là age, wt_kg (cân nặng được tính bằng kilogram), ct_blood (giá trị CT), vàdays_onset_hosp (sự khác biệt giữa ngày khởi phát và nhập viện).","code":"\nlinelist <- rio::import(\"linelist_cleaned.rds\")"},{"path":"ggplot-basics.html","id":"làm-sạch-chung","chapter":"30 ggplot cơ bản","heading":"Làm sạch chung","text":"Khi chuẩn bị dữ liệu để vẽ biểu đồ, tốt nhất là làm cho dữ liệu tuân thủ tiêu chuẩn dữ liệu “gọn gàng” nhất có thể. Để đạt được điều này, bạn có thể tham khảo chương Làm sạch số liệu và các hàm quan trọng trong cuốn sổ tay này.Một số cách đơn giản mà chúng ta có thể chuẩn bị dữ liệu của mình để tốt hơn cho việc vẽ biểu đồ, có thể bao gồm việc làm cho nội dung của dữ liệu hiển thị tốt hơn - điều này không nhất thiết phải tương đương với việc bạn chuẩn bị dữ liệu tốt hơn để thao tác với dữ liệu. Ví dụ:Thay thế giá trị NA trong cột kiểu ký tự thành “Unknown”Cân nhắc chuyển đổi cột thành dạng factor để các giá trị của chúng được quy định một có thứ tựLàm sạch một số cột để các giá trị “thân thiện với dữ liệu” của chúng với dấu gạch dưới, v.v. được thay đổi thành văn bản bình thường hoặc chữ hoa tiêu đề (xem chương Ký tự và chuỗi)Sau đây là một số ví dụ:","code":"\n# make display version of columns with more friendly names\nlinelist <- linelist %>%\n  mutate(\n    gender_disp = case_when(gender == \"m\" ~ \"Male\",        # m to Male \n                            gender == \"f\" ~ \"Female\",      # f to Female,\n                            is.na(gender) ~ \"Unknown\"),    # NA to Unknown\n    \n    outcome_disp = replace_na(outcome, \"Unknown\")          # replace NA outcome with \"unknown\"\n  )"},{"path":"ggplot-basics.html","id":"xoay-trục-dài-hơn","chapter":"30 ggplot cơ bản","heading":"Xoay trục dài hơn","text":"Về cấu trúc dữ liệu, đối với ggplot2 chúng ta thường muốn xoay trục dữ liệu sang định dạng dài hơn. Xem thêm ở chương Xoay trục dữ liệu.Ví dụ, chúng ta muốn vẽ biểu đồ dữ liệu đang ở định dạng “ngang”, chẳng hạn từng trường hợp trong bộ dữ liệu linelist và các triệu chứng của chúng. Dưới đây chúng ta sẽ tạo một bộ dữ liệu nhỏ từ linelist gọi là symptoms_data chỉ chứa case_id và các cột triệu chứng.Đây là 50 dòng đầu tiên của bộ dữ liệu mới được tạo ra - hãy xem cách chúng được định dạng lại với mỗi triệu chứng là một cột:Nếu chúng ta muốn lập biểu đồ số trường hợp có các triệu chứng cụ thể, chúng ta bị giới hạn bởi thực tế là mỗi triệu chứng là một cột khác nhau. Tuy nhiên, chúng ta có thể xoay các cột triệu chứng sang một định dạng dài hơn như sau:Dưới đây là danh sách 50 dòng đầu tiên. Lưu ý rằng với mỗi trường hợp sẽ có 5 dòng - mỗi dòng tương ứng với một triệu chứng có thể xảy ra. Các cột mới có tên symptom_name và symptom_is_present là kết quả của việc xoay trục dữ liệu. Lưu ý rằng định dạng này có thể không hữu ích cho các hoạt động khác, nhưng rất hữu ích cho việc vẽ biểu đồ.","code":"\nsymptoms_data <- linelist %>% \n  select(c(case_id, fever, chills, cough, aches, vomit))\nsymptoms_data_long <- symptoms_data %>%    # begin with \"mini\" linelist called symptoms_data\n  \n  pivot_longer(\n    cols = -case_id,                       # pivot all columns except case_id (all the symptoms columns)\n    names_to = \"symptom_name\",             # assign name for new column that holds the symptoms\n    values_to = \"symptom_is_present\") %>%  # assign name for new column that holds the values (yes/no)\n  \n  mutate(symptom_is_present = replace_na(symptom_is_present, \"unknown\")) # convert NA to \"unknown\""},{"path":"ggplot-basics.html","id":"các-khái-niệm-cơ-bản-của-ggplot","chapter":"30 ggplot cơ bản","heading":"30.2 Các khái niệm cơ bản của ggplot","text":"“Ngữ pháp đồ thị” - ggplot2Vẽ đồ thị với ggplot2 dựa trên việc “thêm” các lớp đồ thị và các phần tử thiết kế chồng lên nhau, với mỗi lệnh được thêm vào các lệnh trước bằng một dấu cộng (+). Kết quả là một đối tượng biểu đồ nhiều lớp có thể được lưu, sửa đổi, , xuất ra, v.v.Các đối tượng ggplot có thể rất phức tạp, nhưng thứ tự cơ bản của các lớp thường sẽ giống như sau:Bắt đầu với lớp nền bằng lệnh ggplot() - lệnh này “mở” ggplot và cho phép các hàm tiếp theo được thêm vào với dấu +. Thông thường, tập dữ liệu cũng được chỉ định trong lệnh nàyThêm các lớp “geom” - các hàm này trực quan hóa dữ liệu dưới dạng geometries - hình học (shapes - hình dạng), ví dụ: biểu đồ cột, biểu đồ đường, biểu đồ phân tán, histogram (hoặc là sự kết hợp giữa chúng!). Tất cả các hàm này đều bắt đầu với tiền tố geom_.Thêm các yếu tố thiết kế vào đồ thị, chẳng hạn như nhãn trục, tiêu đề, phông chữ, kích thước, phối màu, chú giải hoặc xoay trụcMột ví dụ đơn giản về bộ khung code như dưới đây. Chúng tôi sẽ giải thích từng cấu phần trong các phần bên dưới.","code":"\n# plot data from my_data columns as red points\nggplot(data = my_data)+                   # use the dataset \"my_data\"\n  geom_point(                             # add a layer of points (dots)\n    mapping = aes(x = col1, y = col2),    # \"map\" data column to axes\n    color = \"red\")+                       # other specification for the geom\n  labs()+                                 # here you add titles, axes labels, etc.\n  theme()                                 # here you adjust color, font, size etc of non-data plot elements (axes, title, etc.) "},{"path":"ggplot-basics.html","id":"ggplot","chapter":"30 ggplot cơ bản","heading":"30.3 ggplot()","text":"Lệnh mở đầu của bất kỳ biểu đồ ggplot2 nào cũng là ggplot(). Lệnh này chỉ đơn giản là tạo ra một khung trống để thêm các lớp. Nó “mở ra” con đường cho các lớp tiếp theo được thêm vào với dấu +.Thông thường, lệnh ggplot() bao gồm đối số data = cho biểu đồ. Việc này giúp thiết lập bộ dữ liệu mặc định được sử dụng cho các lớp tiếp theo của biểu đồ.Lệnh này sẽ kết thúc bằng một dấu + sau dấu ngoặc đơn đóng cuối cùng của hàm. Điều này giúp lệnh “mở” trở lại. ggplot sẽ chỉ thực thi/xuất hiện khi lệnh đầy đủ bao gồm một lớp cuối cùng mà không có dấu + ở cuối.","code":"\n# This will create plot that is a blank canvas\nggplot(data = linelist)"},{"path":"ggplot-basics.html","id":"geoms","chapter":"30 ggplot cơ bản","heading":"30.4 Geoms","text":"Một khung trống chắc chắn là không đủ - chúng ta cần tạo thêm các hình học (dạng) từ dữ liệu (vd: biểu đồ cột, histograms, biểu đồ phân tán, box plots).Điều này được thực hiện bằng cách thêm các lớp “geoms” vào lệnh ggplot() ban đầu. Có rất nhiều hàm ggplot2 có thể tạo ra các “geoms”. Mỗi hàm này bắt đầu bằng “geom_”, vì vậy chúng tôi sẽ gọi chúng một cách chung chung là geom_XXXX(). Có hơn 40 loại geoms trong ggplot2 và rất nhiều cái khác được tạo ra bởi cộng đồng. Xem chúng tại thư viện ggplot2. Một số geom phổ biến được liệt kê dưới đây:Histograms - geom_histogram()Biểu đồ cột - geom_bar() hoặc geom_col() (xem mục “Biểu đồ cột”)Box plots - geom_boxplot()Điểm (vd: biểu đồ phân tán) - geom_point()Biểu đồ đường - geom_line() hoặc geom_path()Đường xu hướng - geom_smooth()Trong một biểu đồ, bạn có thể hiển thị một hoặc nhiều geoms. Chúng sẽ được thêm vào các lệnh ggplot2 trước đó bằng dấu +, và chúng được vẽ theo thứ tự sao cho các geoms sau được vẽ lên phía trên của geoms trước đó.","code":""},{"path":"ggplot-basics.html","id":"ggplot_basics_mapping","chapter":"30 ggplot cơ bản","heading":"30.5 Chọn dữ liệu cho biểu đồ","text":"Hầu hết các hàm geom phải được cho biết cái gì được sử dụng để vẽ biểu đồ - vì vậy bạn phải cung cấp cách map (gán) các biến số trong dữ liệu của bạn tới các thành phần của biểu đồ như là các trục, màu đối tượng, kích thước đối tượng, v.v. Đối với hầu hết các geoms, các thành phần thiết yếu phải được gán tới các cột trong dữ liệu là trục x, và (nếu cần) là trục y.Việc “mapping” được thực hiện bằng đối số mapping = của hàm. Giá trị bạn cung cấp tới mapping phải được gói trong hàm aes(), vì vậy bạn sẽ viết một cái gì đó kiểu như mapping = aes(x = col1, y = col2), như được trình bày bên dưới.Dưới đây, trong lệnh ggplot(), dữ liệu được thiết lập là các trường hợp trong bộ linelist. Trong đối số mapping = aes(), cột age được gán cho trục x, và cột wt_kg được gán cho trục y.Sau dấu +, các lệnh vẽ biểu đồ được tiếp tục. Một đối tượng được tạo bằng hàm “geom” thông qua geom_point(). Geom này kế thừa các thông số được gán từ lệnh ggplot() bên trên - nó biết các trục được gán và tiếp tục trực quan hóa mối quan hệ giữa chúng dưới dạng các điểm trên khung vẽ.Một ví dụ khác, lệnh sau sử dụng bộ số liệu tương tự, chỉ có một sự khác biệt nhỏ về cách mapping và hàm geom. Hàm geom_histogram() chỉ yêu cầu gán cột cho trục x, bởi vì trục số lượng y được tạo ra một cách tự động.","code":"\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+\n  geom_point()\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()"},{"path":"ggplot-basics.html","id":"thẩm-mỹ-đồ-thị","chapter":"30 ggplot cơ bản","heading":"Thẩm mỹ đồ thị","text":"Trong ggplot, thuật ngữ “thẩm mỹ đồ thị” có một ý nghĩa đặc biệt. Nó đề cập đến một thuộc tính trực quan của dữ liệu được vẽ. Lưu ý rằng “thẩm mỹ” ở đây đề cập đến dữ liệu đưuợc vẽ bằng các geoms/shapes - không phải các thành phần hiển thị xung quanh như là tiêu đề, nhãn của trục, màu nền, mà bạn có thể liên kết với từ “thẩm mỹ” trong tiếng Anh thông dụng. Trong ggplot, những chi tiết đó được gọi là “chủ đề” và được điều chỉnh trong lệnh theme()(xem phần này).đó, thẩm mỹ của đối tượng biểu đồ có thể là màu sắc, kích thước, độ trong suốt, vị trí, v.v. của dữ liệu được vẽ. Không phải tất cả các geoms sẽ có các tùy chọn thẩm mỹ giống nhau, nhưng một số tùy chọn được áp dụng với phần lớn các geoms. Dưới đây là một số ví dụ:shape = Hiển thị một điểm với hàm geom_point() dưới dạng dấu chấm, ngôi sao, hình tam giác hoặc hình vuông…fill = Màu sắc bên trong (vd: của cột hoặc boxplot)color = Đường bên ngoài của cột, boxplot, v.v., hoặc màu của điểm nếu sử dụng hàm geom_point()size = Kích thước (vd: độ dày của đường, kích thước của điểm)alpha = Độ trong suốt (1 = bình thường, 0 = vô hình)binwidth = Độ rộng các bins trong biểu đồ histogramwidth = Độ rộng của các cột trong “biểu đồ cột”linetype = Kiểu của đường (vd: liền, nét đứt, chấm chấm)Thẩm mỹ của đối tượng biểu đồ có thể được gán giá trị theo hai cách:Gán một giá trị tĩnh (vd: color = \"blue\") để áp dụng cho tất cả các quan sát được vẽ biểu đồGán cho một cột của dữ liệu (vd: color = hospital) để hiển thị từng quan sát phụ thuộc vào giá trị của nó trong cột đó","code":""},{"path":"ggplot-basics.html","id":"gán-một-giá-trị-tĩnh","chapter":"30 ggplot cơ bản","heading":"Gán một giá trị tĩnh","text":"Nếu bạn muốn yếu tố thẩm mỹ cho đối tượng biểu đồ là tĩnh, nghĩa là - giống nhau đối với mọi quan sát trong dữ liệu, bạn viết phép gán của nó bên trong geom nhưng ở bên ngoài của bất cứ đối số mapping = aes() nào. Các phép gán này có thể trông như này size = 1 hoặc color = \"blue\". Sau đây là hai ví dụ:Trong ví dụ đầu tiên, đối số mapping = aes() ở bên trong hàm ggplot() và các trục được gán tới cột age và weight trong bộ dữ liệu. Các yếu tố thẩm mỹ như là color =, size =, và alpha = (độ trong suốt) được gán các giá trị tĩnh. Để rõ ràng, điều này được thực hiện trong hàm geom_point(), vì bạn có thể thêm các geom khác sau đó mà sẽ nhận các giá trị khác nhau cho các yếu tố thẩm mỹ của biểu đồ.Trong ví dụ thứ hai, biểu đồ histogram chỉ yêu cầu trục x được gán với một cột. Các thông số của biểu đồ histogram như binwidth =, color =, fill = (màu sắc bên trong), và alpha = một lần nữa được đặt trong geom thành các giá trị tĩnh.","code":"\n# scatterplot\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # set data and axes mapping\n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)         # set static point aesthetics\n\n# histogram\nggplot(data = linelist, mapping = aes(x = age))+       # set data and axes\n  geom_histogram(              # display histogram\n    binwidth = 7,                # width of bins\n    color = \"red\",               # bin line color\n    fill = \"blue\",               # bin interior color\n    alpha = 0.1)                 # bin transparency"},{"path":"ggplot-basics.html","id":"vẽ-theo-tỷ-lệ-giá-trị-của-cột","chapter":"30 ggplot cơ bản","heading":"Vẽ theo tỷ lệ giá trị của cột","text":"Một cách khác đó là vẽ theo tỷ lệ giá trị của cột các đối tượng thẩm mỹ của biểu đồ. Theo cách tiếp cận này, việc hiển thị các đối tượng thẩm mỹ sẽ phụ thuộc vào giá trị của quan sát trong cột dữ liệu đó. Nếu các giá trị cột là liên tục, thang đo hiển thị (chú giải) cho thẩm mỹ đó sẽ là liên tục. Nếu các giá trị cột là rời rạc, chú giải sẽ hiển thị từng giá trị và dữ liệu được vẽ biểu đồ sẽ xuất hiện dưới dạng “được nhóm” (đọc thêm ở mục Nhóm trong chương này).Để đạt được điều này, bạn gán yếu tố thẩm mỹ của biểu đồ với một tên cột (không trong dấu ngoặc kép). Điều này phải được thực hiện bên trong một hàm mapping = aes() (lưu ý: có một số vị trí trong code mà bạn có thể thực hiện các phép gán, như được thảo luận bên dưới).Hai ví dụ như sau.Ở ví dụ đầu tiên, yếu tố thẩm mỹ color = (của mỗi điểm) được gán cho cột age - và thang đo liên tục được xuất hiện dưới dạng chú thích! Hiện tại bạn chỉ cần quan tâm tới sự xuất hiện của thanh này - chúng ta sẽ học cách chỉnh sửa nó trong các phần sau.Trong ví dụ thứ hai, hai yếu tố thẩm mỹ được gán cho hai cột tương ứng (color = và size =), trong khi shape = và alpha = được gán cho các giá trị tĩnh bên ngoài đối số mapping = aes().Lưu ý: Các phép gán trục luôn được gán cho các cột trong dữ liệu (không phải cho các giá trị tĩnh) và điều này luôn được thực hiện với mapping = aes().Điều quan trọng là phải theo dõi các lớp của biểu đồ và các đối tượng thẩm mỹ khi vẽ các biểu đồ phức tạp - ví dụ biểu đồ được cấu thành từ nhiều geoms. ITrong ví dụ dưới đây, size = được gán hai lần - một lần cho geom_point() và một lần cho geom_smooth() - cả hai lần đều là giá trị tĩnh.","code":"\n# scatterplot\nggplot(data = linelist,   # set data\n       mapping = aes(     # map aesthetics to column values\n         x = age,           # map x-axis to age            \n         y = wt_kg,         # map y-axis to weight\n         color = age)\n       )+     # map color to age\n  geom_point()         # display data as points \n\n# scatterplot\nggplot(data = linelist,   # set data\n       mapping = aes(     # map aesthetics to column values\n         x = age,           # map x-axis to age            \n         y = wt_kg,         # map y-axis to weight\n         color = age,       # map color to age\n         size = age))+      # map size to age\n  geom_point(             # display data as points\n    shape = \"diamond\",      # points display as diamonds\n    alpha = 0.3)            # point transparency at 30%\nggplot(data = linelist,\n       mapping = aes(           # map aesthetics to columns\n         x = age,\n         y = wt_kg,\n         color = age_years)\n       ) + \n  geom_point(                   # add points for each row of data\n    size = 1,\n    alpha = 0.5) +  \n  geom_smooth(                  # add a trend line \n    method = \"lm\",              # with linear method\n    size = 2)                   # size (width of line) of 2"},{"path":"ggplot-basics.html","id":"ggplot_basics_map_loc","chapter":"30 ggplot cơ bản","heading":"Thực hiện phép gán ở đâu","text":"Việc gán các yếu tố thẩm mỹ bên trong đối số mapping = aes() có thể được viết ở một số chỗ trong các lệnh vẽ biểu đồ và thậm chí có thể được viết nhiều lần. Nó có thể được viết trong lệnh ggplot() trên cùng, và/hoặc cho từng geom riêng lẻ bên dưới. Các kiểu viết bao gồm:Các phép gán được thực hiện ở lệnh ggplot() trên cùng sẽ được mặc định kế thừa ở bất kỳ các geom bên dưới, giống như cách mà x = và y = được kế thừaCác phép gán được thực hiện trong một geom chỉ áp dụng cho geom đóTương tự, data = được chỉ định cho lệnh ggplot() ở trên đầu sẽ áp dụng mặc định cho tất cả các geom bên dưới, nhưng bạn vẫn có thể chỉ định data riêng cho từng geom (nhưng sẽ khó hơn).đó, mỗi lệnh sau sẽ tạo ra cùng một biểu đồ giống nhau:","code":"\n# These commands will produce the exact same plot\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\nggplot(data = linelist)+\n  geom_histogram(mapping = aes(x = age))\n\nggplot()+\n  geom_histogram(data = linelist, mapping = aes(x = age))"},{"path":"ggplot-basics.html","id":"ggplotgroups","chapter":"30 ggplot cơ bản","heading":"Nhóm","text":"Bạn có thể dễ dàng nhóm dữ liệu và “vẽ biểu đồ theo nhóm”. Trên thực tế, bạn đã làm điều này rồi!Gán cột “phân nhóm” với yếu tố thẩm mỹ biều đồ phù hợp, bên trong đối số mapping = aes(). Ở bên trên, chúng ta đã minh họa nó bằng cách sử dụng các giá trị liên tục khi gán điểm size = tới cột age. Tuy nhiên, cách này cũng hoạt động theo cùng một cơ chế đối với các cột rời rạc/phân loại.Ví dụ, nếu bạn muốn các điểm được hiển thị theo giới, bạn sẽ đặt mapping = aes(color = gender). Một chú giải tự động hiện lên. Phép gán này có thể được thực hiện bên trong mapping = aes() ở lệnh ggplot() đầu tiên (và được thừa kế bởi các geom), hoặc nó thể được đặt trong một mapping = aes() riêng biệt bên trong geom. Cả hai cách tiếp cận được trình bày dưới đây:Lưu ý rằng tùy thuộc vào loại geom bạn sử dụng, bạn sẽ cần sử dụng các đối số khác nhau để nhóm dữ liệu. Đối với geom_point(), bạn sẽ thường sử dụng nhất các tham số như color =, shape = hoặc size =. Trong khi đó đối với geom_bar(), bạn thường sử dụng nhất tham số fill =. Điều này chỉ phụ thuộc vào loại geom và yếu tố trang trí nào bạn muốn thể hiện sự phân nhóm.Cách cơ bản nhất để nhóm dữ liệu là chỉ sử dụng đối số group = bên trong mapping = aes(). Tuy nhiên, cách này tự nó sẽ không làm thay đổi màu sắc, hình dạng hoặc tạo ra chú thích. Tuy nhiên dữ liệu được nhóm lại, đó hiển thị thống kê có thể bị ảnh hưởng.Để thay đổi thứ tự của các nhóm trong biểu đồ, xem chương Các tips với ggplot hoặc chương Factors. Ngoài ra cũng có rất nhiều ví dụ về các biểu đồ được nhóm trong các phần bên dưới đối với dữ liệu dạng liên tục và danh mục.","code":"\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg, color = gender))+\n  geom_point(alpha = 0.5)\n# This alternative code produces the same plot\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg))+\n  geom_point(\n    mapping = aes(color = gender),\n    alpha = 0.5)"},{"path":"ggplot-basics.html","id":"ggplot_basics_facet","chapter":"30 ggplot cơ bản","heading":"30.6 Facets / Chia nhỏ biểu đồ","text":"Facets, hay “chia nhỏ biểu đồ”, được sử dụng để chia một biểu đồ thành nhiều phần nhỏ, với mỗi phần (“facet”) đại diện cho một nhóm của dữ liệu. Các biểu đồ giống nhau được tạo nhiều lần, mỗi cái sử dụng một phân nhóm của cùng một bộ dữ liệu.Faceting là một chức năng đi kèm với ggplot2, vì vậy các chú giải và trục của các biểu đồ nhỏ được căn chỉnh tự động. Có các package khác được thảo luận trong chương Các tips với ggplot được sử dụng để kết hợp các biểu đồ hoàn toàn khác nhau (cowplot và patchwork) thành một biểu đồ.Faceting được thực hiện bằng các hàm ggplot2 sau đây:facet_wrap() Để hiện thị các biểu đồ khác nhau cho từng thứ bậc của một biến số đơn lẻ. Một ví dụ như thể hiện các đường cong dịch bệnh khác nhau cho từng bệnh viện trong khu vực. Các facets được sắp xếp theo thứ tự bảng chữ cái, trừ khi biến có kiểu factor với các thứ bậc đã được xác định.Bạn có thể sử dụng một số tùy chọn nhất định để xác định bố cục của các facets, vd: nrow = 1 hoặc ncol = 1 để kiểm soát số hàng hoặc cột mà chúng được sắp xếp.facet_grid() Áp dụng khi bạn muốn đưa một biến thứ hai vào sắp xếp các biểu đồ con. Ở đây mỗi ô thể hiện sự giao nhau của các giá trị giữa hai cột. Ví dụ, các đường cong dịch bệnh cho từng sự kết hợp của bệnh viện-nhóm tuổi với các bệnh viện dọc theo phía đỉnh (các cột) và các nhóm tuổi dọc theo hai bên (các hàng).nrow và ncol không được áp dụng, bởi vì các phân nhóm được trình bày dưới dạng lướiMỗi hàm này chấp nhận một cú pháp công thức để chỉ định cột được faceting. Cả hai đều chấp nhận tối đa hai cột, mỗi cột ở một bên dấu ngã ~.Đối với facet_wrap(), bạn sẽ thường chỉ viết một cột trước dấu ngã ~ chẳng hạn như facet_wrap(~hospital). Tuy nhiên, bạn vẫn có thể viết hai cột, ví dụ facet_wrap(outcome ~ hospital) - mỗi kết hợp duy nhất sẽ hiển thị trong một ô riêng biệt, nhưng chúng sẽ không được sắp xếp trong một lưới. Các tiêu đề sẽ hiển thị các thuật ngữ kết hợp và chúng sẽ không phải là logic cụ thể cho các cột với các hàng. Nếu bạn đang chỉ cung cấp một biến số để faceting, dấu chấm . được sử dụng như để giữ chỗ cho phía bên kia của công thức - hãy xem các ví dụ về code.Đối với facet_wrap(), bạn sẽ thường chỉ viết một cột trước dấu ngã ~ chẳng hạn như facet_wrap(~hospital). Tuy nhiên, bạn vẫn có thể viết hai cột, ví dụ facet_wrap(outcome ~ hospital) - mỗi kết hợp duy nhất sẽ hiển thị trong một ô riêng biệt, nhưng chúng sẽ không được sắp xếp trong một lưới. Các tiêu đề sẽ hiển thị các thuật ngữ kết hợp và chúng sẽ không phải là logic cụ thể cho các cột với các hàng. Nếu bạn đang chỉ cung cấp một biến số để faceting, dấu chấm . được sử dụng như để giữ chỗ cho phía bên kia của công thức - hãy xem các ví dụ về code.Đối với facet_grid() bạn cũng có thể chỉ định một hoặc hai cột tới công thức (grid rows ~ columns). Nếu bạn chỉ muốn chỉ định một cột, hãy đặt một dấu chấm . ở một phía của dấu ngã chẳng hạn như facet_grid(. ~ hospital) hoặc facet_grid(hospital ~ .).Đối với facet_grid() bạn cũng có thể chỉ định một hoặc hai cột tới công thức (grid rows ~ columns). Nếu bạn chỉ muốn chỉ định một cột, hãy đặt một dấu chấm . ở một phía của dấu ngã chẳng hạn như facet_grid(. ~ hospital) hoặc facet_grid(hospital ~ .).Facets có thể chứa một lượng lớn thông tin - vì vậy bạn nên đảm bảo những biến số được lựa chọn để facets không có quá nhiều thứ bậc. Dưới đây là một số ví dụ nhanh với tập dữ liệu sốt rét (xem chương Tải sách và dữ liệu) bao gồm số lượng trường hợp sốt rét hàng ngày của các cơ sở theo nhóm tuổi..Sau đây chúng ta nhập số liệu vào và thực hiện một số biến đổi để đơn giản hóa:50 hàng đầu tiên của dữ liệu sốt rét được trình bày như bên dưới. Lưu ý rằng có một cột tên là malaria_tot, ngoài ra còn có các cột khác chứa thông tin về số lượng trường hợp theo nhóm tuổi (chúng sẽ được sử dụng trong ví dụ thứ hai với facet_grid()).","code":"\n# These data are daily counts of malaria cases, by facility-day\nmalaria_data <- import(here(\"data\", \"malaria_facility_count_data.rds\")) %>%  # import\n  select(-submitted_date, -Province, -newid)                                 # remove unneeded columns"},{"path":"ggplot-basics.html","id":"facet_wrap","chapter":"30 ggplot cơ bản","heading":"facet_wrap()","text":"Tại thời điểm này, hãy chỉ tập trung vào các cột malaria_tot và District, tạm thời bỏ qua cột số lượng ca bệnh theo tuổi. Chúng ta sẽ vẽ các đường cong dịch bệnh với hàm geom_col(), giúp tạo ra một cột cho từng ngày với độ cao được xác định từ giá trị của cột malaria_tot (dữ liệu đã là số lượng hàng ngày, vì vậy chúng tôi sử dụng hàm geom_col() - xem mục “Biểu đồ cột” bên dưới).Khi chúng ta thêm lệnh facet_wrap(), hãy thêm dấu ngã kèm với cột dùng để facet bên trong lệnh (trong trường hợp này là District). Bạn có thể đặt một cột khác ở bên trái của dấu ngã, - điều này sẽ tạo ra một facet cho từng sự kết hợp - nhưng chúng tôi khuyên bạn nên làm điều đó bằng hàm facet_grid(). Trong ví dụ này, chỉ một facet được tạo ra cho giá trị duy nhất của cột District.","code":"\n# A plot with facets by district\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plot the count data as columns\n  theme_minimal()+                              # simplify the background panels\n  labs(                                         # add plot labels, title, etc.\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district\") +\n  facet_wrap(~District)                       # the facets are created"},{"path":"ggplot-basics.html","id":"facet_grid","chapter":"30 ggplot cơ bản","heading":"facet_grid()","text":"Chúng ta có thể sử dụng cách tiếp cận facet_grid() đối với hai biến. Giả sử chúng ta muốn thêm District age vào biểu đồ của mình. Trước hết, chúng ta cần thực hiện một số biến đổi dữ liệu trên các cột tuổi để đưa những dữ liệu này sang định dạng “dài” được ggplot ưu tiên. Tất cả các nhóm tuổi đều có các cột riêng - chúng ta cần chúng nhập vào một cột duy nhất có tên age_group và một cột khasc có tên num_cases. Xem chương Xoay trục dữ liệu để hiểu thêm về quy trình này.50 hàng đầu tiên của dữ liệu trông giống như sau:Khi bạn chuyển hai biến số tới facet_grid(), cách đơn giản nhất là sử dụng ký hiệu công thức (vd: x ~ y), trong đó x là hàng và y là cột. Dưới đây là biểu đồ, sử dụng facet_grid() để hiển thị các biểu đồ cho mỗi kết hợp của các cột age_group và District.","code":"\nmalaria_age <- malaria_data %>%\n  select(-malaria_tot) %>% \n  pivot_longer(\n    cols = c(starts_with(\"malaria_rdt_\")),  # choose columns to pivot longer\n    names_to = \"age_group\",      # column names become age group\n    values_to = \"num_cases\"      # values to a single column (num_cases)\n  ) %>%\n  mutate(\n    age_group = str_replace(age_group, \"malaria_rdt_\", \"\"),\n    age_group = forcats::fct_relevel(age_group, \"5-14\", after = 1))\nggplot(malaria_age, aes(x = data_date, y = num_cases)) +\n  geom_col(fill = \"darkred\", width = 1) +\n  theme_minimal()+\n  labs(\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district and age group\"\n  ) +\n  facet_grid(District ~ age_group)"},{"path":"ggplot-basics.html","id":"giới-hạn-trục-tự-do-hoặc-cố-định","chapter":"30 ggplot cơ bản","heading":"Giới hạn trục tự do hoặc cố định","text":"Theo mặc định, các tỷ lệ trục được hiển thị khi faceting là giống nhau (cố định) trên tất cả các facets. Điều này rất hữu ích cho việc sánh chéo, nhưng không phải lúc nào cũng thích hợp.Khi sử dụng facet_wrap() hoặc facet_grid(), chúng ta có thể thêm scales = \"free_y\" để “free” hoặc giải phóng trục y của các biểu đồ nhỏ chia tỷ lệ thích hợp với tập con dữ liệu của chúng. Điều này đặc biệt hữu ích nếu số lượng thực tế là nhỏ đối với một trong các danh mục phụ và khó có thể nhìn thấy xu hướng. Thay vì “free_y”, chúng ta cũng có thể viết “free_x” để làm tương tự đối với trục x (vd: biến ngày thág) hoặc “free” đối với cả hai trục. Lưu ý rằng trong facet_grid, tỷ lệ y sẽ giống nhau đối với các facets trong cùng một hàng và tỷ lệ x sẽ giống nhau đối với các facets trong cùng một cột.Khi chỉ sử dụng facet_grid, chúng ta có thể thêm space = \"free_y\" hoặc space = \"free_x\" để chiều cao hoặc chiều rộng thực tế của facet được tính theo giá trị của biều đồ bên trong. Điều này chỉ hoạt động nếu scales = \"free\" (y hoặc x) đã được áp dụng.","code":"\n# Free y-axis\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plot the count data as columns\n  theme_minimal()+                              # simplify the background panels\n  labs(                                         # add plot labels, title, etc.\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district - 'free' x and y axes\") +\n  facet_wrap(~District, scales = \"free\")        # the facets are created"},{"path":"ggplot-basics.html","id":"trật-tự-thức-bậc-của-factor-trong-facets","chapter":"30 ggplot cơ bản","heading":"Trật tự thức bậc của Factor trong facets","text":"Xem bài viết này về cách làm thế nào để sắp xếp lại thức bậc của biến factor bên trong facets.","code":""},{"path":"ggplot-basics.html","id":"lưu-trữ-biểu-đồ","chapter":"30 ggplot cơ bản","heading":"30.7 Lưu trữ biểu đồ","text":"","code":""},{"path":"ggplot-basics.html","id":"lưu-biểu-đồ-1","chapter":"30 ggplot cơ bản","heading":"Lưu biểu đồ","text":"Mặc định khi bạn chạy lệnh ggplot(), biểu đồ sẽ được ở cửa số Plots của RStudio. Tuy nhiên, bạn cũng có thể lưu biểu đồ dưới dạng một đối tượng bằng cách sử dụng toán tử gán <- và đặt tên cho nó. Biểu đồ sẽ không được ra trừ khi bạn gọi tên của đối tượng. Bạn cũng có thể nó bằng cách đưa tên biểu đồ vào hàm print(), nhưng điều này chỉ cần thiết trong một số trường hợp nhất định chẳng hạn như khi biểu đồ được tạo bên trong một vòng lặp để nhiều biểu đồ cùng một lúc (xem chương Lặp, vòng lặp, và danh sách).","code":"\n# define plot\nage_by_wt <- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+\n  geom_point(alpha = 0.1)\n\n# print\nage_by_wt    "},{"path":"ggplot-basics.html","id":"chỉnh-sửa-biều-đồ-đã-lưu","chapter":"30 ggplot cơ bản","heading":"Chỉnh sửa biều đồ đã lưu","text":"Một điểm hay của ggplot2 là bạn có thể gán tên cho một biểu đồ (như bên trên), và sau đó thêm các lớp mới bắt đầu bằng tên của nó. Bạn không cần phải lặp lại tất cả các lệnh đã tạo ra biểu đồ ban đầu!Ví dụ: để sửa đổi biểu đồ age_by_wt đã được định nghĩa ở bên trên, thêm một trục dọc tại tuổi bằng 50, chúng ta chỉ cần thêm dấu + và bắt đầu thêm các lớp bổ sung vào biểu đồ.","code":"\nage_by_wt+\n  geom_vline(xintercept = 50)"},{"path":"ggplot-basics.html","id":"xuất-biểu-đồ","chapter":"30 ggplot cơ bản","heading":"Xuất biểu đồ","text":"Việc xuất biểu đồ được thực hiện dễ dàng với hàm ggsave() của package ggplot2. Nó có thể hoạt động theo hai cách:Chỉ định tên của đối tượng biểu đồ, sau đó là đường dẫn tệp và tên có phần mở rộng\nVí dụ: ggsave(my_plot, (\"plots\", \"my_plot.png\"))\nChỉ định tên của đối tượng biểu đồ, sau đó là đường dẫn tệp và tên có phần mở rộngVí dụ: ggsave(my_plot, (\"plots\", \"my_plot.png\"))Chạy lệnh chỉ với một đường dẫn tệp, để lưu biểu đồ gần nhất được ra\nVí dụ: ggsave((\"plots\", \"my_plot.png\"))\nChạy lệnh chỉ với một đường dẫn tệp, để lưu biểu đồ gần nhất được raVí dụ: ggsave((\"plots\", \"my_plot.png\"))Bạn có thể xuất dưới dạng tệp png, pdf, jpeg, tiff, bmp, svg, hoặc một số định dạng khác, bằng cách chỉ định phần mở rộng tệp trong đường dẫn tệp.Bạn cũng có thể chỉ định các đối số width =, height =, và units = (“”, “cm”, hoặc “mm”). Bạn cũng có thể chỉ định dpi = để điều chỉnh độ phân giâỉ của biểu đồ (vd: dpi = 300). Xem hướng dẫn chi tiết về hàm bằng cách gõ ?ggsave hoặc đọc tài liệu online này.Hãy nhớ rằng bạn có thể sử dụng cú pháp () để cung cấp đường dẫn tệp mong muốn. Xem chương Nhập xuất dữ liệu để biết thêm thông tin.","code":""},{"path":"ggplot-basics.html","id":"nhãn","chapter":"30 ggplot cơ bản","heading":"30.8 Nhãn","text":"Chắc chắn là bạn sẽ muốn thêm hoặc điều chỉnh nhãn của biểu đồ. Việc này được thực hiện dễ dàng nhất với hàm labs() bằng cách thêm dấu + như cách bạn thêm các geoms.Bên trong hàm labs(), bạn có thể cung cấp các chuỗi ký tự cho các đối số sau:x = và y = Tiêu đề trục x và trục y (nhãn)title = Tiêu đề chính của biểu đồsubtitle = Tiêu đề phụ của biểu đồ, nhỏ hơn và đặt bên dưới tiêu đề chínhcaption = Caption của biểu đồ, mặc định ở góc phải dướiDưới đây là biểu đồ chúng ta đã tạo lúc trước, nhưng có thêm các nhãn:Hãy để ý chúng ta đã sử dụng hàm str_glue() từ package stringr để tạo một code R động bên trong văn bản khi gán giá trị cho caption. Caption sẽ hiển thị “Dữ liệu kể từ:” phản ánh ngày nhập viện gần nhất trong bộ dữ liệu linelist. Đọc thêm ở chương Ký tự và chuỗi.Một chú ý khi bạn muốn thêm tiêu đề cho chú giải: Đó là không có đối số “legend title”, vì bạn có thể có nhiều thang đo trong chú giải của mình. Bên trong lệnh labs(), bạn có thể viết đối số cho yếu tố thẩm mỹ được sử dụng để tạo chú giải, và cung cấp tiêu đề cho nó theo cách này. Trong ví dụ bên trên, chúng ta đã gán color = age để tạo chú giải. đó, chúng ta cũng cung cấp đối số color = ttrong hàm labs() và gán tiêu đề chú giải mong muốn (“Age” với chữ được viết hoa). Nếu bạn tạo chú thích bằng đối số aes(fill = COLUMN), thì trong lệnh labs() bạn nên viết fill = để điều chỉnh tiêu đề cho chú thích. Xem thêm mục thang đo màu sắc trong chương Các tips với ggplot để biết thêm chi tiết về cách chỉnh sửa chú giải và cách tiếp cận thay thế bằng cách sử dụng các hàm scales_().","code":"\nage_by_wt <- ggplot(\n  data = linelist,   # set data\n  mapping = aes(     # map aesthetics to column values\n         x = age,           # map x-axis to age            \n         y = wt_kg,         # map y-axis to weight\n         color = age))+     # map color to age\n  geom_point()+           # display data as points\n  labs(\n    title = \"Age and weight distribution\",\n    subtitle = \"Fictional Ebola outbreak, 2014\",\n    x = \"Age in years\",\n    y = \"Weight in kilos\",\n    color = \"Age\",\n    caption = stringr::str_glue(\"Data as of {max(linelist$date_hospitalisation, na.rm=T)}\"))\n\nage_by_wt"},{"path":"ggplot-basics.html","id":"ggplot_basics_themes","chapter":"30 ggplot cơ bản","heading":"30.9 Chủ đề","text":"Một trong những phần hay nhất của ggplot2 là mức độ kiểm soát của bạn đối với biểu đồ - bạn có thể định nghĩa bất kỳ điều gì! Như đã đề cập ở trên, thiết kế của biểu đồ không liên quan tới dạng biểu đồ mà được điều chỉnh bên trong hàm theme(). Ví dụ, màu nền của biểu đồ, sự xuất hiện/biến mất của đường lưới, cũng như phông chữ/cỡ chữ/màu sắc/căn lề của văn bản (tiêu đề chính, tiêu đề phụ, captions, chữ trên các trục…). Những điều chỉnh này có thể được thực hiện theo hai cách:Thêm một chủ đề hoàn chỉnh bằng hàm theme_() để điều chỉnh toàn bộ các thành phần biểu đồ - các chủ đề hoàn chỉnh này bao gồm theme_classic(), theme_minimal(), theme_dark(), theme_light() theme_grey(), theme_bw()Điều chỉnh từng khía cạnh đơn lẻ của biểu đồ với hàm theme()","code":""},{"path":"ggplot-basics.html","id":"chủ-đề-hoàn-chỉnh","chapter":"30 ggplot cơ bản","heading":"Chủ đề hoàn chỉnh","text":"Vì chúng khá đơn giản, chúng tôi sẽ trình bày các hàm chủ đề hoàn chỉnh bên dưới và sẽ không mô tả thêm ở đây. Lưu ý rằng bất kỳ điều chỉnh nhỏ nào bằng hàm theme() nên được thực hiện sau khi áp dụng một chủ đề hoàn chỉnh.Viết chúng với dấu ngoặc đơn trống.","code":"\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme classic\")+\n  theme_classic()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme bw\")+\n  theme_bw()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme minimal\")+\n  theme_minimal()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme gray\")+\n  theme_gray()"},{"path":"ggplot-basics.html","id":"tùy-chỉnh-chủ-đề","chapter":"30 ggplot cơ bản","heading":"Tùy chỉnh chủ đề","text":"Hàm theme() có thể nhận một số lượng lớn các đối số, mỗi đối số sẽ chỉnh sửa một khía cạnh rất cụ thể của biểu đồ. Chúng tôi sẽ không trình bày tất cả các đối số, nhưng sẽ tập trung mô tả công thức chung cho chúng và chỉ cho bạn cách tìm tên đối số mà bạn cần. Cú pháp cơ bản là:Bên trong hàm theme(), hãy viết tên đối số cho phần tử biểu đồ mà bạn muốn chỉnh sửa, chẳng hạn như plot.title =Cung cấp một hàm element_() tới đối sốThường sử dụng nhất là element_text(), một số khác bao gồm element_rect() chọn màu nền cho canvas, hoặc element_blank() để xóa các phần tử biểu đồBên trong hàm element_(), xác định giá trị đối số cần gán để điều chỉnh theo ý bạn mong muốnVì trình bày bên trên vẫn khá trừu tượng, nên đây là một số ví dụ.Lưu ý là biểu đồ dưới đây trông không thật sự đẹp, nhưng nó giúp bạn thấy nhiều cách khác nhau để bạn có thể điều chỉnh biểu đồ của mình.Chúng ta bắt đầu với biểu đồ có tên age_by_wt đã được tạo ra bên trên và thêm hàm theme_classic()Để điều chỉnh đẹp hơn, chúng ta thêm hàm theme() và bao gồm một đối số cho từng phần tử biểu đồ muốn điều chỉnhSẽ rất tốt nếu bạn sắp xếp các đối số theo một trật tự logic. Hãy xem ví dụ sau:legend.position = là đặc biệt nhất vì nó chỉ chấp nhận các giá trị đơn giản như “bottom”, “top”, “left”, và “right”. các đối số liên quan đến văn bản yêu cầu bạn đặt các chi tiết bên trong hàm element_text().Cỡ chư tiêu đề với element_text(size = 30)Căn lề caption với element_text(hjust = 0) (từ trái qua phải)Tiêu đề phụ được nghiêng với element_text(face = \"italic\")Sau đây là một số đối số phổ biến của hàm theme(). Bạn sẽ nhận ra một số xu hướng chung, chẳng hạn như thêm .x hoặc .y để chỉ áp dụng thay đổi cho một trục.Nhưng còn rất nhiều các đối số khác! Làm thế nào tôi có thể nhớ tất cả chúng? Đừng lo lắng - bạn không thể nhớ hết chúng được đâu. May mắn thay, có một vài công cụ có thể thể giúp bạn:Tài liệu hướng dẫn của tidyverse phần tùy chỉnh chủ đề, có chứa một danh sách đầy đủ các đối số.MẸO: Chạy lệnh theme_get() từ ggplot2 để tất cả hơn 90 đối số của hàm theme() ra console.MẸO: Nếu bạn muốn xóa một phần tử của biểu đồ, bạn cũng có thể làm điều đó bằng hàm theme(). Chỉ cần đặt element_blank() tới đối số để nó biến mất hoàn toàn. Đối với chú thích, thiết lập legend.position = \"none\".","code":"\nage_by_wt + \n  theme_classic()+                                 # pre-defined theme adjustments\n  theme(\n    legend.position = \"bottom\",                    # move legend to bottom\n    \n    plot.title = element_text(size = 30),          # size of title to 30\n    plot.caption = element_text(hjust = 0),        # left-align caption\n    plot.subtitle = element_text(face = \"italic\"), # italicize subtitle\n    \n    axis.text.x = element_text(color = \"red\", size = 15, angle = 90), # adjusts only x-axis text\n    axis.text.y = element_text(size = 15),         # adjusts only y-axis text\n    \n    axis.title = element_text(size = 20)           # adjusts both axes titles\n    )     "},{"path":"ggplot-basics.html","id":"màu-sắc","chapter":"30 ggplot cơ bản","heading":"30.10 Màu sắc","text":"Xem mục thang đo cho màu sắc trong chương Các tips với ggplot.","code":""},{"path":"ggplot-basics.html","id":"piping-tới-ggplot2","chapter":"30 ggplot cơ bản","heading":"30.11 Piping tới ggplot2","text":"Khi sử dụng pipes để làm sạch và chuyển đổi dữ liệu của bạn, bạn có thể dễ dàng chuyển dữ liệu đã chuyển đổi tới ggplot().Các pipes sẽ chuyển dữ liệu từ hàm-tới-hàm và sẽ chuyển tới dấu + một khi hàm ggplot() được gọi. Lưu ý rằng trong trường hợp này, không cần chỉ định đối số data =, bởi vì nó đã được tự động xác định khi bạn piping dữ liệu.Dưới đây là cách mà nó hoạt động:","code":"\nlinelist %>%                                                     # begin with linelist\n  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # select columns\n  pivot_longer(                                                  # pivot longer\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %>%\n  mutate(                                                        # replace missing values\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %>% \n  \n  ggplot(                                                        # begin ggplot!\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )"},{"path":"ggplot-basics.html","id":"vẽ-biểu-đồ-dữ-liệu-liên-tục","chapter":"30 ggplot cơ bản","heading":"30.12 Vẽ biểu đồ dữ liệu liên tục","text":"Xuyên xuốt chương này, bạn đã gặp rất nhiều ví dụ về cách vẽ biểu đồ dữ liệu liên tục. Ở đây chúng tôi tổng hợp ngắn gọn chúng và trình bày một vài biến thể.\nCác ví dụ bao gồm:Vẽ biểu đồ cho một biến liên tục:\nHistogram, một biểu đồ thường dùng để trình bày sự phân bố của một biến số liên tục.\nBox plot (còn được gọi là box và whisker), để hiện thị khoảng phân vị 25%, 50%, và 75%, phần cuối của phân phối, và các giá trị ngoại lai (outliers) (những hạn chế quan trọng).\nJitter plot, để hiển thị tất cả các giá trị dưới dạng các điểm ‘lộn xộn’ để chúng có thể (hầu hết) được nhìn thấy, ngay cả khi hai điểm có cùng giá trị.\nViolin plot, hiển thị sự phân bố của một biến liên tục dựa trên chiều rộng đối xứng của đàn ‘violin’.\nSina plot, là sự kết hợp của jitter và violin plots, trong đó các điểm riêng lẻ được hiển thị nhưng ở hình dạng đối xứng của sự phân bố (thông qua package ggforce).\nVẽ biểu đồ cho một biến liên tục:Histogram, một biểu đồ thường dùng để trình bày sự phân bố của một biến số liên tục.Box plot (còn được gọi là box và whisker), để hiện thị khoảng phân vị 25%, 50%, và 75%, phần cuối của phân phối, và các giá trị ngoại lai (outliers) (những hạn chế quan trọng).Jitter plot, để hiển thị tất cả các giá trị dưới dạng các điểm ‘lộn xộn’ để chúng có thể (hầu hết) được nhìn thấy, ngay cả khi hai điểm có cùng giá trị.Violin plot, hiển thị sự phân bố của một biến liên tục dựa trên chiều rộng đối xứng của đàn ‘violin’.Sina plot, là sự kết hợp của jitter và violin plots, trong đó các điểm riêng lẻ được hiển thị nhưng ở hình dạng đối xứng của sự phân bố (thông qua package ggforce).Biểu đồ phân tán (Scatter plot) cho hai biến liên tục.Biểu đồ phân tán (Scatter plot) cho hai biến liên tục.Biểu đồ nhiệt dành cho ba biến liên tục (xem chương Biểu đồ nhiệt )Biểu đồ nhiệt dành cho ba biến liên tục (xem chương Biểu đồ nhiệt )","code":""},{"path":"ggplot-basics.html","id":"histograms","chapter":"30 ggplot cơ bản","heading":"Histograms","text":"Histograms có thể trông giống như biểu đồ cột, nhưng sự khác biệt là nó đo lường sự phân phối của một biến liên tục. Không có khoảng cách giữa các “thanh” và chỉ có một biến số được cung cấp cho hàm geom_histogram().Dưới đây là code để tạo một histograms, mà sẽ nhóm dữ liệu liên tục thành các dải và hiển thị trong các thanh liền kề có độ cao khác nhau. Việc này được thực hiện bằng hàm geom_histogram(). Xem mục “Biểu đồ cột” trong chương này để hiểu sự khác biệt giữa các hàm geom_histogram(), geom_bar(), và geom_col().Chúng ta sẽ hiển thị sự phân bố độ tuổi của các trường hợp. Bên trong đối số mapping = aes(), chỉ định cột bạn muốn xem phân phối. Bạn có thể gán cột này cho trục x hoặc trục y.Các hàng sẽ được chỉ định tới các “bins” dựa trên số tuổi của chúng, và các bins này sẽ được đồ thị hóa bằng các cột. Nếu bạn chỉ định số lượng bins bnằg đối số bins =, các điểm ngắt được cách đều giữa các giá trị tối thiểu và tối đa của biểu đồ. Nếu bins = không được chỉ định, một số lượng bins thích hợp sẽ được chọn và một thông báo sẽ hiện ra ngay sau biểu đồ:Nếu bạn không muốn chỉ định số lượng bins tới bins =, bạn có thể chỉ định binwidth = theo đơn vị của trục. Chúng tôi đưa ra một vài ví dụ trình bày sự khác biệt giữa bins và bin widths:Để vẽ đường mật độ phân bố, bạn có thể sử dụng hàm geom_density():Để vẽ một biểu đồ histogram “chồng” (của một biến liên tục trong dữ liệu),bạn có thể làm như sau:Dùng hàm geom_histogram() với đối số fill = bên trong aes() và gán tới cột được dùng để nhóm, hoặcDùng hàm geom_freqpoly(), có thể sẽ dễ đọc hơn (bạn vẫn có thể đặt binwidth =)Để xem tỷ lệ của tất cả các giá trị, hãy thiết lập y = after_stat(density) (sử dụng chính xác cú pháp này - không thay đổi đối với dữ liệu của bạn). Lưu ý: các tỷ lệ này sẽ hiển thị theo từng nhóm.Các kết quả được trình bày bên dưới (*lưu ý cách sử dụng của color = và. fill =):Nếu bạn muốn nghịch vui một chút, hãy thử hàm geom_density_ridges từ package ggridges (vignette tại đây.Đọc thêm về histograms tại tài liệu về tidyverse chương về geom_histogram().","code":"## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n# A) Regular histogram\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram()+\n  labs(title = \"A) Default histogram (30 bins)\")\n\n# B) More bins\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram(bins = 50)+\n  labs(title = \"B) Set to 50 bins\")\n\n# C) Fewer bins\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram(bins = 5)+\n  labs(title = \"C) Set to 5 bins\")\n\n\n# D) More bins\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram(binwidth = 1)+\n  labs(title = \"D) binwidth of 1\")\n# Frequency with proportion axis, smoothed\nggplot(data = linelist, mapping = aes(x = age)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional density\")\n\n# Stacked frequency with proportion axis, smoothed\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_density(size = 2, alpha = 0.2, position = \"stack\")+\n  labs(title = \"'Stacked' proportional densities\")\n# \"Stacked\" histogram\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_histogram(binwidth = 2)+\n  labs(title = \"'Stacked' histogram\")\n\n# Frequency \nggplot(data = linelist, mapping = aes(x = age, color = gender)) +\n  geom_freqpoly(binwidth = 2, size = 2)+\n  labs(title = \"Freqpoly\")\n\n# Frequency with proportion axis\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +\n  geom_freqpoly(binwidth = 5, size = 2)+\n  labs(title = \"Proportional freqpoly\")\n\n# Frequency with proportion axis, smoothed\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional, smoothed with geom_density()\")"},{"path":"ggplot-basics.html","id":"box-plots","chapter":"30 ggplot cơ bản","heading":"Box plots","text":"Box plots rất phổ biến, nhưng có những hạn chế quan trọng. Chúng có thể che khuất phân phối thực tế - vd: phân phối hai mode (bimodal distribution). Xem trang R graph gallery và trang data--viz article để biết thêm chi tiết. Tuy nhiên, chúng hiển thị tốt các khoảng tứ phân vị và các giá trị ngoại lai - vì vậy chúng có thể được phủ lên trên các loại biểu đồ khác thể hiện sự phân bố chi tiết hơn.Dưới đây, chúng ta ôn lại về các thành phần khác nhau của boxplot:Khi sử dụng geom_boxplot() để tạo biểu đồ box plot, bạn thường chỉ map duy nhất một trục (x hoặc y) bên trong aes(). Trục được chỉ định sẽ xác định xem các ô nằm ngang hay dọc.Trong hầu hết các geoms, bạn tạo ra một biểu đồ theo từng nhóm bằng cách mapping các thuộc tính thẩm mỹ như color = hoặc fill = tới cột bên trong aes(). Tuy nhiên, biểu đồ box plots làm điều này bằng cách gán cột phân nhóm cho trục chưa được gán (x hoặc y). Dưới đây là code cho một boxplot của tất cả các giá trị tuổi trong bộ dữ liệu, và code còn lại là để hiển thị từng box plot cho từng nhóm giới tính (không-missing) trong dữ liệu. Lưu ý là giá trị missing NA sẽ xuất hiện dưới dạng một box plot riêng rẽ trừ khi nó được loại bỏ. Ở ví dụ này chúng tôi cũng thiết lập fill tới cột outcome, đó mà mỗi biểu đồ sẽ có màu khác nhau- nhưng điều này không quan trọng.Code để thêm một box plot vào các cạnh của biểu đồ phân tán (còn gọi là “marginal” plots), vui lòng xem chương Các tips với ggplot.","code":"\n# A) Overall boxplot\nggplot(data = linelist)+  \n  geom_boxplot(mapping = aes(y = age))+   # only y axis mapped (not x)\n  labs(title = \"A) Overall boxplot\")\n\n# B) Box plot by group\nggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + \n  geom_boxplot()+                     \n  theme(legend.position = \"none\")+   # remove legend (redundant)\n  labs(title = \"B) Boxplot by gender\")      "},{"path":"ggplot-basics.html","id":"violin-jitter-và-sina-plots","chapter":"30 ggplot cơ bản","heading":"Violin, jitter, và sina plots","text":"Dưới đây là code để tạo violin plots (geom_violin) và jitter plots (geom_jitter) để hiển thị phân bố của biến. Bạn có thể chỉ định các màu sắc được xác định từ dữ liệu bằng cách chèn các tùy chọn này vào bên trong aes().Bạn cũng có thể kết hợp hai biểu đồ này làm một nhờ hàm geom_sina() từ package ggforce. Biểu đồ sina vẽ các điểm phân bố trên hình dạng của biểu đồ violin. Khi được phủ lên biểu đồ violin (bằng cách điều chỉnh độ trong suốt), nó giúp việc diễn giải một cách trực quan hơn.","code":"\n# A) Jitter plot by group\nggplot(data = linelist %>% drop_na(outcome),      # remove missing values\n       mapping = aes(y = age,                     # Continuous variable\n           x = outcome,                           # Grouping variable\n           color = outcome))+                     # Color variable\n  geom_jitter()+                                  # Create the violin plot\n  labs(title = \"A) jitter plot by gender\")     \n\n\n\n# B) Violin plot by group\nggplot(data = linelist %>% drop_na(outcome),       # remove missing values\n       mapping = aes(y = age,                      # Continuous variable\n           x = outcome,                            # Grouping variable\n           fill = outcome))+                       # fill variable (color)\n  geom_violin()+                                   # create the violin plot\n  labs(title = \"B) violin plot by gender\")    \n# A) Sina plot by group\nggplot(\n  data = linelist %>% drop_na(outcome), \n  aes(y = age,           # numeric variable\n      x = outcome)) +    # group variable\n  geom_violin(\n    aes(fill = outcome), # fill (color of violin background)\n    color = \"white\",     # white outline\n    alpha = 0.2)+        # transparency\n  geom_sina(\n    size=1,                # Change the size of the jitter\n    aes(color = outcome))+ # color (color of dots)\n  scale_fill_manual(       # Define fill for violin background by death/recover\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  scale_color_manual(      # Define colours for points by death/recover\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  theme_minimal() +                                # Remove the gray background\n  theme(legend.position = \"none\") +                # Remove unnecessary legend\n  labs(title = \"B) violin and sina plot by gender, with extra formatting\")      "},{"path":"ggplot-basics.html","id":"hai-biến-liên-tục","chapter":"30 ggplot cơ bản","heading":"Hai biến liên tục","text":"Theo cú pháp tương tự, geom_point() sẽ cho phép bạn vẽ biểu đồ hai biến liên tục dưới dạng một biểu đồ phân tán. Điều này hữu ích để hiển thị các giá trị thực tế hơn là phân phối của chúng. Một biểu đồ phân tán cơ bản của tuổi với cân nặng được trình bày ở hình (). Ở hình (B), chúng ta lại sử dụng facet_grid() để hiển thị mối quan hệ giữa hai biến liên tục trong bộ dữ liệu linelist.","code":"\n# Basic scatter plot of weight and age\nggplot(data = linelist, \n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"A) Scatter plot of weight and age\")\n\n# Scatter plot of weight and age by gender and Ebola outcome\nggplot(data = linelist %>% drop_na(gender, outcome), # filter retains non-missing gender/outcome\n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"B) Scatter plot of weight and age faceted by gender and outcome\")+\n  facet_grid(gender ~ outcome) "},{"path":"ggplot-basics.html","id":"ba-biến-liên-tục","chapter":"30 ggplot cơ bản","heading":"Ba biến liên tục","text":"Bạn có thể hiển thị ba biến liên tục bằng cách sử dụng đối số fill = để tạo một biểu đồ nhiệt. Màu của mỗi “ô” sẽ phản ánh giá trị của biên liên tục thứ ba trong bộ dữ liệu. Xem chương Các tips với ggplot để biết thêm chi tiết và một số ví dụ.Có nhiều cách để tạo biểu đồ 3D trong R, nhưng đối với dịch tễ học ứng dụng, chúng thường khó giải thích và đó ít hữu ích hơn trong việc ra quyết định.","code":""},{"path":"ggplot-basics.html","id":"vẽ-biểu-đồ-cho-biến-danh-mục","chapter":"30 ggplot cơ bản","heading":"30.13 Vẽ biểu đồ cho biến danh mục","text":"Dữ liệu dạng danh mục có thể là các giá trị ký tự, có thể là logic (TRUE/FALSE), hoặc factors (Xem chương Factors).","code":""},{"path":"ggplot-basics.html","id":"chuẩn-bị-21","chapter":"30 ggplot cơ bản","heading":"Chuẩn bị","text":"","code":""},{"path":"ggplot-basics.html","id":"cấu-trúc-dữ-liệu","chapter":"30 ggplot cơ bản","heading":"Cấu trúc dữ liệu","text":"Điều đầu tiên cần hiểu về dữ liệu dạng danh mục đó là kiểm tra xem nó đang tồn tại ở dạng dữ liệu thô như các trường hợp trong bộ dữ liệu linelist, hay dưới dạng dữ liệu tóm tắt hoặc tổng hợp chứa các số lượng hoặc tỷ lệ. Trạng thái dữ liệu của bạn sẽ quyết định hàm vẽ biểu đồ nào được sử dụng:Nếu dữ liệu của bạn là các quan sát thô với một hàng cho mỗi quan sát, bạn có thể sử dụng hàm geom_bar()Nếu dữ liệu của bạn đã được tổng hợp thành số lượng hoặc tỷ lệ, bạn có thể sử dụng hàm geom_col()","code":""},{"path":"ggplot-basics.html","id":"kiểu-của-cột-và-thứ-tự-các-giá-trị","chapter":"30 ggplot cơ bản","heading":"Kiểu của cột và thứ tự các giá trị","text":"Sau đó, kiểm tra kiểu dữ liệu của cột mà bạn muốn vẽ. Chúng ta xem xét cột hospital, đầu tiên bằng hàm class() từ base R, sau đó là với hàm tabyl() từ package janitor.Chúng ta có thể thấy các giá trị bên trong là các ký tự, vì chúng là tên bệnh viện và theo mặc định, chúng được sắp xếp theo thứ tự bảng chữ cái. Ngoài ra còn có các giá trị ‘’ và ‘missing’, thứ mà chúng ta muốn nó sẽ là danh mục cuối cùng khi trình bày. Vì thế chúng ta cần chuyển cột này sang dạng factor và sắp xếp lại chúng. Xem chương Factors để biết chi tiết cách thực hiện.","code":"\n# View class of hospital column - we can see it is a character\nclass(linelist$hospital)## [1] \"character\"\n# Look at values and proportions within hospital column\nlinelist %>% \n  tabyl(hospital)##                              hospital    n    percent\n##                      Central Hospital  454 0.07710598\n##                     Military Hospital  896 0.15217391\n##                               Missing 1469 0.24949049\n##                                 Other  885 0.15030571\n##                         Port Hospital 1762 0.29925272\n##  St. Mark's Maternity Hospital (SMMH)  422 0.07167120\n# Convert to factor and define level order so \"Other\" and \"Missing\" are last\nlinelist <- linelist %>% \n  mutate(\n    hospital = fct_relevel(hospital, \n      \"St. Mark's Maternity Hospital (SMMH)\",\n      \"Port Hospital\", \n      \"Central Hospital\",\n      \"Military Hospital\",\n      \"Other\",\n      \"Missing\"))\nlevels(linelist$hospital)## [1] \"St. Mark's Maternity Hospital (SMMH)\" \"Port Hospital\"                        \"Central Hospital\"                     \"Military Hospital\"                   \n## [5] \"Other\"                                \"Missing\""},{"path":"ggplot-basics.html","id":"ggplot_basics_bars","chapter":"30 ggplot cơ bản","heading":"geom_bar()","text":"Sử dụng geom_bar() nếu bạn muốn chiều cao cột (hoặc chiều cao của các cột trong biểu đồ cột chồng) phản ánh số lượng hàng có liên quan trong dữ liệu. Các thanh này sẽ có khoảng trống giữa chúng, trừ khi width = được điều chỉnh.Chỉ cung cấp phép gán cột trên một trục (thường là trục x). Nếu bạn cung cấp cả trục x và y, bạn sẽ nhận được thông báo Error: stat_count() can x y aesthetic.Bạn có thể tạo biểu đồ cột chồng bằng cách thêm fill = cột được chỉ định bên trong mapping = aes()Trục đối diện sẽ có tiêu đề là “số lượng” theo mặc định, bởi vì nó đại diện cho số hàngDưới đây, chúng ta đã chỉ định cột outcome tới trục y, nhưng nó cũng có thể dễ dàng thực hiện trên trục x. Nếu bạn có các giá trị ký tự dài hơn, đôi khi sẽ dễ nhìn hơn nếu bạn lật các thanh sang một bên và đặt chú giải ở dưới cùng. Điều này có thể ảnh hưởng đến cách sắp xếp các thứ bậc trong biến factor - trong trường hợp này, chúng tôi đảo ngược chúng với hàm fct_rev() để đặt giá trị missing và ở dưới cùng.","code":"\n# A) Outcomes in all cases\nggplot(linelist %>% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +\n  theme_minimal()+\n  labs(title = \"A) Number of cases by hospital\",\n       y = \"Hospital\")\n\n\n# B) Outcomes in all cases by hosptial\nggplot(linelist %>% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +\n  theme_minimal()+\n  theme(legend.position = \"bottom\") +\n  labs(title = \"B) Number of recovered and dead Ebola cases, by hospital\",\n       y = \"Hospital\")"},{"path":"ggplot-basics.html","id":"geom_col","chapter":"30 ggplot cơ bản","heading":"geom_col()","text":"Sử dụng geom_col() nếu bạn muốn chiều cao cột (hoặc chiều cao của các cột trong biểu đồ cột chồng) các giá trị được tính toán trước tồn tại trong dữ liệu. Thông thường, đây là các số lượng hoặc tỷ lệ đã được tóm tắt hoặc “tổng hợp”.Cung cấp phép gán cột cho cả hai trục tới hàm geom_col(). Thông thường, cột trục x của bạn là biến rời rạc và cột trục y của bạn là biến dạng số.Giả sử chúng ta có một bộ dữ liệu có tên outcomes:Dưới đây là code sử dụng hàm geom_col để tạo biểu đồ cột đơn giản trình bày phân bố các outcome của bệnh nhân Ebola. Với geom_col, cả x và y đều cần được chỉ định. Ở đây x là biến phân loại dọc theo trục x và y là cột chứa tỷ lệ proportion.Để trình bày kết quả tách theo từng bệnh viện, chúng ta cần bảng phải chứa nhiều thông tin hơn, và ở định dạng “dài”. Chúng ta tạo bảng này với các tần số là sự kết hợp của các danh mục của biến outcome và hospital (xem chương Nhóm dữ liệu để biết thêm các mẹo).Sau đó, chúng ta vẽ biểu đồ ggplot với một số định dạng được bổ sung:Lật trục: Hoán đổi vị trị trục với coord_flip() để chúng ta có thể đọc tên các bệnh viện.Columns side--side: Added position = \"dodge\" argument bars death recover presented side side rather stacked. Lưu ý mặc định là các cột xếp chồng lên nhau.Độ rộng cột: Chỉ định ‘chiều rộng’, đó các cột mỏng bằng một nửa chiều rộng đầy đủ có thể.Thứ tự cột: Đảo lại các danh mục trên trục y để ‘’ và ‘Missing’ ở dưới cùng, với hàm scale_x_discrete(limits=rev). Lưu ý rằng chúng ta sử dụng cách này thay vì scale_y_discrete bởi vì hospital được nhắc tới trong đối số x của aes(), ngay cả khi một cách trực quan nó nằm trên trục y. Chúng ta làm vậy bởi vì ggplot dường như trình bày các danh mục từ sau lên trước trừ khi chúng ta yêu cầu nó không làm vậy.Các chi tiết khác: Nhãn/tiêu đề và màu sắc được thêm tương ứng vào bên trong lệnh labs và scale_fill_color.Lưu ý rằng tỷ lệ là nhị phân, đó chúng ta có thể loại bỏ các giá trị ‘recover’ và chỉ hiện thị tỷ lệ những người tử vong. Việc này chỉ nhằm cho mục đích minh họa.Nếu sử dụng geom_col() cho dữ liệu ngày tháng (vd: đường cong dịch bệnh từ dữ liệu tổng hợp) - bạn sẽ muốn điều chỉnh đối số width = để loại bỏ “khoảng trống” giữa các cột. nếu sử dụng số liệu cập nhật hàng ngày, hãy thiết lập width = 1. Nếu là hàng tuần, width = 7. Không thể thiết lập cho tháng vì mỗi tháng có số ngày khác nhau.","code":"## # A tibble: 2 x 3\n##   outcome     n proportion\n##   <chr>   <int>      <dbl>\n## 1 Death    1022       56.2\n## 2 Recover   796       43.8\n# Outcomes in all cases\nggplot(outcomes) + \n  geom_col(aes(x=outcome, y = proportion)) +\n  labs(subtitle = \"Number of recovered and dead Ebola cases\")\noutcomes2 <- linelist %>% \n  drop_na(outcome) %>% \n  count(hospital, outcome) %>%  # get counts by hospital and outcome\n  group_by(hospital) %>%        # Group so proportions are out of hospital total\n  mutate(proportion = n/sum(n)*100) # calculate proportions of hospital total\n\nhead(outcomes2) # Preview data## # A tibble: 6 x 4\n## # Groups:   hospital [3]\n##   hospital                             outcome     n proportion\n##   <fct>                                <chr>   <int>      <dbl>\n## 1 St. Mark's Maternity Hospital (SMMH) Death     199       61.2\n## 2 St. Mark's Maternity Hospital (SMMH) Recover   126       38.8\n## 3 Port Hospital                        Death     785       57.6\n## 4 Port Hospital                        Recover   579       42.4\n## 5 Central Hospital                     Death     193       53.9\n## 6 Central Hospital                     Recover   165       46.1\n# Outcomes in all cases by hospital\nggplot(outcomes2) +  \n  geom_col(\n    mapping = aes(\n      x = proportion,                 # show pre-calculated proportion values\n      y = fct_rev(hospital),          # reverse level order so missing/other at bottom\n      fill = outcome),                # stacked by outcome\n    width = 0.5)+                    # thinner bars (out of 1)\n  theme_minimal() +                  # Minimal theme \n  theme(legend.position = \"bottom\")+\n  labs(subtitle = \"Number of recovered and dead Ebola cases, by hospital\",\n       fill = \"Outcome\",             # legend title\n       y = \"Count\",                  # y axis title\n       x = \"Hospital of admission\")+ # x axis title\n  scale_fill_manual(                 # adding colors manually\n    values = c(\"Death\"= \"#3B1c8C\",\n               \"Recover\" = \"#21908D\" )) "},{"path":"ggplot-basics.html","id":"geom_histogram","chapter":"30 ggplot cơ bản","heading":"geom_histogram()","text":"Histograms có thể trông giống biểu đồ cột, nhưng khác biệt vì nó đo lường sự phân bố của một biến liên tục. Không có khoảng cách giữa các “cột”, và chỉ có một cột được cung cấp cho hàm geom_histogram(). Có các đối số cụ thể cho biểu đồ chẳng hạn như bin_width = và breaks = ể chỉ định cách dữ liệu nên được xếp. Phần bên trên về dữ liệu liên tục và chương Đường cong dịch bệnh sẽ cung cấp thêm các hi tiết.","code":""},{"path":"ggplot-basics.html","id":"tài-nguyên-học-liệu-12","chapter":"30 ggplot cơ bản","heading":"30.14 Tài nguyên học liệu","text":"Có rất nhiều trợ giúp trực tuyến, đặc biệt là với ggplot. Xem:ggplot2 cheat sheetanother cheat sheettidyverse ggplot basics pageplotting continuous variablesR Data Science trang về data visualizationgraphics communicaton","code":""},{"path":"ggplot-tips.html","id":"ggplot-tips","chapter":"31 Các tips với ggplot","heading":"31 Các tips với ggplot","text":"Trong trang này, chúng tôi sẽ đề cập đến các mẹo và thủ thuật để làm cho biểu đồ ggplots của bạn đẹp và bóng bẩy hơn. Xem thêm chương ggplot cơ bản để có các kiến thức nền tảng.Có một số hướng dẫn ggplot2 mở rộng được liên kết trong phần Nguồn. Bạn cũng có thể tải xuống cheatsheet trực quan hóa số liệu với ggplot từ trang web của RStudio. Chúng tôi thực sự khuyên bạn nên tìm thêm cảm hứng tại các trang web sau: R graph gallery và Data--viz.","code":""},{"path":"ggplot-tips.html","id":"chuẩn-bị-22","chapter":"31 Các tips với ggplot","heading":"31.1 Chuẩn bị","text":"","code":""},{"path":"ggplot-tips.html","id":"gọi-packages-10","chapter":"31 Các tips với ggplot","heading":"Gọi packages","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.","code":"\npacman::p_load(\n  tidyverse,      # includes ggplot2 and other\n  rio,            # import/export\n  here,           # file locator\n  stringr,        # working with characters   \n  scales,         # transform numbers\n  ggrepel,        # smartly-placed labels\n  gghighlight,    # highlight one part of plot\n  RColorBrewer    # color scales\n)"},{"path":"ggplot-tips.html","id":"nhập-dữ-liệu-16","chapter":"31 Các tips với ggplot","heading":"Nhập dữ liệu","text":"Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết.50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới.","code":"\nlinelist <- rio::import(\"linelist_cleaned.rds\")"},{"path":"ggplot-tips.html","id":"ggplot_tips_colors","chapter":"31 Các tips với ggplot","heading":"31.2 Thang đo đối với màu sắc, tô màu, trục, v.v.","text":"Trong ggplot2, khi yếu tố thẩm mỹ của dữ liệu được vẽ (vd: kích thước, màu sắc, hình dạng, tô màu, trục biểu đồ) được gắn với các cột trong bộ dữ liệu, thì hiển thị chính xác có thể được điều chỉnh với lệnh “scale” tương ứng. Trong phần này, chúng tôi giải thích một số điều chỉnh thang đo phổ biến.","code":""},{"path":"ggplot-tips.html","id":"phối-màu","chapter":"31 Các tips với ggplot","heading":"31.2.1 Phối màu","text":"Một điều ban đầu có thể khó hiểu khi dùng ggplot2 là kiểm soát các phối màu. Lưu ý rằng phần này thảo luận về màu sắc của các đối tượng biểu đồ (geoms/shapes) ví dụ như điểm, cột, đường, ô, v.v. Để điều chỉnh màu của các văn bản, tiêu đề hoặc màu nền, hãy xem phần Chủ đề trong chương ggplot cơ bản.Để kiểm soát “màu sắc” của các đối tượng biểu đồ, bạn sẽ điều chỉnh hoặc là color = (màu bên ngoài) hoặc fill = (màu bên trong). Một ngoại lệ đối với mẫu này là geom_point(), nơi bạn thực sự chỉ có thể điều khiển color =, để xác định màu của điểm (bên trong và bên ngoài).Khi thiết lập màu hoặc tô màu, bạn có thể sử dụng tên màu được R nhận dạng như \"red\" (xem danh sách đầy đủ hoặc gõ ?colors), hoặc cụ thể một mã màu hex như \"#ff0505\".Như đã được giải thích trong chương ggplot cơ bản phần chọn dữ liệu cho biểu đồ, các yếu tố thẩm mỹ như fill = và color = có thể được định nghĩa ở bên ngoài của biểu thức mapping = aes() hoặc bên trong câu lệnh. Nếu đặt bên ngoài hàm aes(), giá trị được gán nên là giá trị tĩnh (vd: color = \"blue\") và sẽ áp dụng cho toàn bộ dữ liệu được vẽ bởi geom. Nếu đặt bên trong, các aesthetic nên được gán tới cột, ví dụ như color = hospital, và sự biểu diễn sẽ thay đổi theo giá trị của hàng đó trong dữ liệu. Một vài ví dụ:","code":"\n# histogram - \nggplot(data = linelist, mapping = aes(x = age))+       # set data and axes\n  geom_histogram(              # display histogram\n    binwidth = 7,                # width of bins\n    color = \"red\",               # bin line color\n    fill = \"lightblue\")          # bin interior color (fill) \n# Static color for points and for line\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(color = \"purple\")+\n  geom_vline(xintercept = 50, color = \"orange\")+\n  labs(title = \"Static color for points and line\")\n\n# Color mapped to continuous column\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = temp))+         \n  labs(title = \"Color mapped to continuous column\")\n\n# Color mapped to discrete column\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = gender))+         \n  labs(title = \"Color mapped to discrete column\")\n\n# bar plot, fill to discrete column, color to static value\nggplot(data = linelist, mapping = aes(x = hospital))+     \n  geom_bar(mapping = aes(fill = gender), color = \"yellow\")+         \n  labs(title = \"Fill mapped to discrete column, static color\")"},{"path":"ggplot-tips.html","id":"ggplot_tips_scales","chapter":"31 Các tips với ggplot","heading":"Thang đo","text":"Một khi bạn gán cột tới một yếu tố thẩm mỹ của biểu đồ (vd: x =, y =, fill =, color =…), biểu đồ của bạn sẽ hiển thị một thang đo/chú giải. Xem ở trên cách thang đo có thể là các giá trị liên tục, rời rạc, ngày tháng, v.v. tùy thuộc vào kiểu dữ liệu của cột được chỉ định. Nếu bạn có nhiều yếu tố thẩm mỹ được gán tới cột, biểu đồ của bạn sẽ có nhiều thang đo.Bạn có thể kiểm soát các thang đo bằng hàm scales_() thích hợp. Các hàm scale của ggplot() có 3 phần được viết như sau: scale_AESTHETIC_METHOD().Phần đầu tiên, scale_(), là cố định.Phần thứ hai, AESTHETIC, là tên yếu tố thẩm mỹ bạn muốn điều chỉnh thang đó (_fill_, _shape_, _color_, _size_, _alpha_…) - các tùy chọn ở đây cũng bao gồm _x_ và _y_.Phần thứ ba, METHOD, sẽ là một trong số các tùy chọn sau _discrete(), continuous(), _date(), _gradient(), hoặc _manual(), tùy thuộc vào kiểu dữ liệu của cột và cách bạn muốn kiểm soát nó. Có những tùy chọn khác, tuy nhiên những lựa chọn trên thường được sử dụng nhất.Hãy chắc chắn rằng bạn sử dụng đúng hàm scale! Nếu không, lệnh scale của bạn sẽ không xuất hiện để thay đổi bất cứ điều gì. Nếu bạn có nhiều thang đo, bạn có thể sử dụng nhiều hàm scale để điều chỉnh chúng! Ví dụ:","code":""},{"path":"ggplot-tips.html","id":"các-đối-số-của-hàm-scale","chapter":"31 Các tips với ggplot","heading":"Các đối số của hàm Scale","text":"Mỗi loại thang đo có những đối số riêng của chúng, mặc dù cũng có những sự trùng nhau. Truy vấn hàm chẳng hạn như ?scale_color_discrete trong cửa sổ R console để xem tài liệu về các đối số của hàm.Với thang đo liên tục, sử dụng breaks = để cung cấp một chuỗi giá trị tới seq() (đặt =, =, và = như được minh họa trong ví dụ bên dưới. Thiết lập expand = c(0,0) để loại bỏ không gian đệm xung quanh các trục (điều này có thể được sử dụng trên bất kỳ thang đo của trục _x_ hoặc _y_ nào)Với thang đo rời rạc, bạn có thể điều chỉnh thứ tự của các giá trị với breaks =, và cách các giá trị hiển thị với đối số labels =. Cung cấp một vectơ ký tự cho mỗi cái đó (xem ví dụ bên dưới). Bạn cũng có thể loại bỏ NA dễ dàng bằng cách đặt na.translate = FALSE.Các điều chỉnh với thang đo ngày tháng được trình bãy rõ hơn trong chương Đường cong dịch bệnh.","code":""},{"path":"ggplot-tips.html","id":"điều-chỉnh-thủ-công","chapter":"31 Các tips với ggplot","heading":"Điều chỉnh thủ công","text":"Một trong những thủ thuật hữu ích nhất là sử dụng các hàm scaling “một cách thủ công” để gán màu sắc như bạn mong muốn. Có những hàm với cú pháp scale_xxx_manual() (vd: scale_colour_manual() hoặc scale_fill_manual()). Mỗi đối số dưới đây được minh họa trong các code ví dụ bên dưới.Gán màu cho các giá trị dữ liệu với đối số values =Cụ thể màu sắc cho giá trị NA với na.value =Thay đổi cách các giá trị được viết trong chú giải với đối số labels =Thay đổi tiêu đề chú giải bằng name =Dưới đây, chúng ta tạo một biểu đồ cột và hiển thị cách nó xuất hiện theo mặc định, sau đó với ba thang đo được điều chỉnh - thang đo trục y liên tục, thang đo trục x rời rạc, và điều chỉnh thủ công cách tô màu (màu bên trong cột).","code":"\n# BASELINE - no scale adjustment\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n# SCALES ADJUSTED\nggplot(data = linelist)+\n  \n  geom_bar(mapping = aes(x = outcome, fill = gender), color = \"black\")+\n  \n  theme_minimal()+                   # simplify background\n  \n  scale_y_continuous(                # continuous scale for y-axis (counts)\n    expand = c(0,0),                 # no padding\n    breaks = seq(from = 0,\n                 to = 3000,\n                 by = 500))+\n  \n  scale_x_discrete(                   # discrete scale for x-axis (gender)\n    expand = c(0,0),                  # no padding\n    drop = FALSE,                     # show all factor levels (even if not in data)\n    na.translate = FALSE,             # remove NA outcomes from plot\n    labels = c(\"Died\", \"Recovered\"))+ # Change display of values\n    \n  \n  scale_fill_manual(                  # Manually specify fill (bar interior color)\n    values = c(\"m\" = \"violetred\",     # reference values in data to assign colors\n               \"f\" = \"aquamarine\"),\n    labels = c(\"m\" = \"Male\",          # re-label the legend (use \"=\" assignment to avoid mistakes)\n              \"f\" = \"Female\",\n              \"Missing\"),\n    name = \"Gender\",                  # title of legend\n    na.value = \"grey\"                 # assign a color for missing values\n  )+\n  labs(title = \"Adjustment of scales\") # Adjust the title of the fill legend"},{"path":"ggplot-tips.html","id":"thang-đo-liên-tục-trên-trục","chapter":"31 Các tips với ggplot","heading":"Thang đo liên tục trên trục","text":"Khi dữ liệu được ánh xạ tới các trục của biểu đồ, chúng cũng có thể được điều chỉnh bằng các lệnh scales. Một ví dụ phổ biến là điều chỉnh hiển thị của một trục (ví dụ: trục y) được ánh xạ tới một cột có dữ liệu liên tục.Chúng ta có thể muốn điều chỉnh độ chia hoặc hiển thị của giá trị trong ggplot bằng cách sử dụng scale_y_continuous(). Như đã lưu ý ở trên, sử dụng đối số breaks = để cung cấp một chuỗi các giá trị sẽ đóng vai trò là “ngắt các khoảng giá trị” dọc theo thang đo. Đây là những giá trị mà các số sẽ hiển thị. Đối với đối số này, bạn có thể cung cấp một vectơ c() chứa các giá trị để chia thang đo theo mong muốn hoặc bạn có thể cung cấp một chuỗi số thông thường bằng cách sử dụng hàm seq() từ base R. Hàm seq() này chấp nhận =, =, và =.","code":"\n# BASELINE - no scale adjustment\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n\n# \nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  scale_y_continuous(\n    breaks = seq(\n      from = 0,\n      to = 3000,\n      by = 100)\n  )+\n  labs(title = \"Adjusted y-axis breaks\")"},{"path":"ggplot-tips.html","id":"hiển-thị-phần-trăm","chapter":"31 Các tips với ggplot","heading":"Hiển thị phần trăm","text":"Nếu giá trị dữ liệu ban đầu của bạn là tỷ lệ, bạn có thể dễ dàng hiển thị chúng dưới dạng phần trăm với “%” bằng cách cung cấp labels = scales::percent trong lệnh scales command, như được trình bày dưới đây.Mặc dù có một giải pháp thay thế là chuyển đổi các giá trị thành ký tự và thêm ký tự “%” vào cuối, cách tiếp cận này sẽ gây ra phức tạp vì dữ liệu của bạn sẽ không còn là các giá trị số liên tục.","code":"\n# Original y-axis proportions\n#############################\nlinelist %>%                                   # start with linelist\n  group_by(hospital) %>%                       # group data by hospital\n  summarise(                                   # create summary columns\n    n = n(),                                     # total number of rows in group\n    deaths = sum(outcome == \"Death\", na.rm=T),   # number of deaths in group\n    prop_death = deaths/n) %>%                   # proportion deaths in group\n  ggplot(                                      # begin plotting\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+ \n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis original proportions\")\n\n\n\n# Display y-axis proportions as percents\n########################################\nlinelist %>%         \n  group_by(hospital) %>% \n  summarise(\n    n = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T),\n    prop_death = deaths/n) %>% \n  ggplot(\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+\n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis as percents (%)\")+\n  scale_y_continuous(\n    labels = scales::percent                    # display proportions as percents\n  )"},{"path":"ggplot-tips.html","id":"thang-đo-log","chapter":"31 Các tips với ggplot","heading":"Thang đo Log","text":"Để biến đổi một trục liên tục sang thang đo log, hãy thêm trans = \"log2\" vào lệnh scale. Ví dụ: chúng ta tạo một data frame của các vùng với các giá trị preparedness_index và số trường hợp tích lũy tương ứng.Các trường hợp tích lũy ở vùng “” lớn hơn đáng kể với tất cả các vùng khác. Trong những trường hợp như thế này, bạn có thể chọn hiển thị trục y bằng thang đo log để người đọc có thể thấy sự khác biệt giữa các vùng với ít trường hợp tích lũy hơn.","code":"\nplot_data <- data.frame(\n  region = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"),\n  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),\n  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)\n)\n\nplot_data##   region preparedness_index cases_cumulative\n## 1      A                8.8               15\n## 2      B                7.5               45\n## 3      C                3.4               80\n## 4      D                3.6               20\n## 5      E                2.1               21\n## 6      F                7.9                7\n## 7      G                7.0               51\n## 8      H                5.6               30\n## 9      I                1.0             1442\n# Original y-axis\npreparedness_plot <- ggplot(data = plot_data,  \n       mapping = aes(\n         x = preparedness_index,\n         y = cases_cumulative))+\n  geom_point(size = 2)+            # points for each region \n  geom_text(\n    mapping = aes(label = region),\n    vjust = 1.5)+                  # add text labels\n  theme_minimal()\n\npreparedness_plot                  # print original plot\n\n\n# print with y-axis transformed\npreparedness_plot+                   # begin with plot saved above\n  scale_y_continuous(trans = \"log2\") # add transformation for y-axis"},{"path":"ggplot-tips.html","id":"thang-đo-gradient","chapter":"31 Các tips với ggplot","heading":"Thang đo Gradient","text":"Tô màu thang đo gradient có thể liên quan đến sắc thái bổ sung. Các giá trị mặc định thường khá dễ chịu, nhưng bạn có thể muốn điều chỉnh các giá trị, điểm cắt, v.v.Để trình bày cách điều chỉnh thang màu liên tục, chúng tôi sẽ sử dụng bộ dữ liệu từ chương Truy vết tiếp xúc chứa độ tuổi của các trường hợp và các trường hợp tiếp xúc gốc của chúng.Dưới đây, chúng ta sẽ tạo ra một “raster” biểu đồ mật độ nhiệt. Chúng ta sẽ không đề cập chi tiết đến cách thức (xem link ở đoạn trên), nhưng chúng ta sẽ tập trung vào cách chúng ta có thể điều chỉnh thang màu. Đọc thêm về hàm stat_density2d() của package ggplot2 tại đây. Lưu ý cách mà thang đo fill là liên tục.Bây giờ chúng ta hiển thị một số biến đổi trên fill scale:Bây giờ chúng ta sẽ xem xét một số ví dụ về việc thực sự điều chỉnh các điểm ngắt của thang đo:scale_fill_gradient() chấp nhận hai màu (cao/thấp)scale_fill_gradientn() chấp nhận một vectơ có độ dài màu bất kỳ tới values = (các giá trị trung gian sẽ được nội suy)Sử dụng scales::rescale() để điều chỉnh cách định vị màu sắc dọc theo gradient; nó sẽ cân chỉnh lại vectơ vị trí của bạn nằm giữa 0 và 1.","code":"\ncase_source_relationships <- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %>% \n  select(source_age, target_age) \ntrans_matrix <- ggplot(\n    data = case_source_relationships,\n    mapping = aes(x = source_age, y = target_age))+\n  stat_density2d(\n    geom = \"raster\",\n    mapping = aes(fill = after_stat(density)),\n    contour = FALSE)+\n  theme_minimal()\ntrans_matrix\ntrans_matrix + scale_fill_viridis_c(option = \"plasma\")\ntrans_matrix + \n  scale_fill_gradient(     # 2-sided gradient scale\n    low = \"aquamarine\",    # low value\n    high = \"purple\",       # high value\n    na.value = \"grey\",     # value for NA\n    name = \"Density\")+     # Legend title\n  labs(title = \"Manually specify high/low colors\")\n\n# 3+ colors to scale\ntrans_matrix + \n  scale_fill_gradientn(    # 3-color scale (low/mid/high)\n    colors = c(\"blue\", \"yellow\",\"red\") # provide colors in vector\n  )+\n  labs(title = \"3-color scale\")\n\n# Use of rescale() to adjust placement of colors along scale\ntrans_matrix + \n  scale_fill_gradientn(    # provide any number of colors\n    colors = c(\"blue\", \"yellow\",\"red\", \"black\"),\n    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # positions for colors are rescaled between 0 and 1\n    )+\n  labs(title = \"Colors not evenly positioned\")\n\n# use of limits to cut-off values that get fill color\ntrans_matrix + \n  scale_fill_gradientn(    \n    colors = c(\"blue\", \"yellow\",\"red\"),\n    limits = c(0, 0.0002))+\n  labs(title = \"Restrict value limits, resulting in grey space\")"},{"path":"ggplot-tips.html","id":"bảng-màu","chapter":"31 Các tips với ggplot","heading":"Bảng màu","text":"","code":""},{"path":"ggplot-tips.html","id":"colorbrewer-và-viridis","chapter":"31 Các tips với ggplot","heading":"Colorbrewer và Viridis","text":"Nhìn chung, nếu bạn muốn sử dụng các bảng màu có sẵn, bạn có thể sử dụng các hàm scale_xxx_brewer hoặc scale_xxx_viridis_y.Càm hàm ‘brewer’ có thể rút ra từ bảng màu colorbrewer.org.Các hàm ‘viridis’ lấy từ các bảng màu viridis (thân thiện với người mù màu!), giúp “cung cấp các bản đồ màu sắc đồng nhất về mặt tri giác ở cả hai màu đen và trắng. Chúng cũng được thiết kế để người xem cảm nhận được các dạng mù màu phổ biến.” (đọc thêm tại đây và tại đây). Xác định xem bảng màu là rời rạc, liên tục hay xếp chồng bằng cách cụ thể điều này ở cuối hàm (vd: nếu rời rạc sẽ là scale_xxx_viridis_d).Bạn nên kiểm tra biểu đồ của mình trong trình mô phỏng mù màu này. Nếu bạn có phối màu đỏ/xanh lá cây, hãy thử phối “nóng-lạnh” (đỏ-xanh lam) như được môt tả ở đâySau đây là một ví dụ từ chương ggplot cơ bản, sử dụng các phối màu khác nhau.","code":"\nsymp_plot <- linelist %>%                                         # begin with linelist\n  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # select columns\n  pivot_longer(                                                  # pivot longer\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %>%\n  mutate(                                                        # replace missing values\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %>% \n  ggplot(                                                        # begin ggplot!\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  theme(legend.position = \"bottom\")+\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )\n\nsymp_plot  # print with default colors\n\n#################################\n# print with manually-specified colors\nsymp_plot +\n  scale_fill_manual(\n    values = c(\"yes\" = \"black\",         # explicitly define colours\n               \"no\" = \"white\",\n               \"unknown\" = \"grey\"),\n    breaks = c(\"yes\", \"no\", \"unknown\"), # order the factors correctly\n    name = \"\"                           # set legend to no title\n\n  ) \n\n#################################\n# print with viridis discrete colors\nsymp_plot +\n  scale_fill_viridis_d(\n    breaks = c(\"yes\", \"no\", \"unknown\"),\n    name = \"\"\n  )"},{"path":"ggplot-tips.html","id":"thay-đổi-thứ-tự-của-biến-rời-rạc","chapter":"31 Các tips với ggplot","heading":"31.3 Thay đổi thứ tự của biến rời rạc","text":"Việc thay đổi thứ tự các biến rời rạc thường khó hiểu đối với những người mới làm quen với vẽ biểu đồ bằng ggplot2. Tuy nhiên, thật dễ hiểu cách thực hiện việc này khi bạn hiểu cách ggplot2 xử lý các biến rời rạc. Nói chung, nếu một biến số rời rạc được sử dụng, nó sẽ tự động được chuyển đổi thành một biến dạng factor - theo mặc định sắp xếp các giá trị theo thứ tự bảng chữ cái. Để xử lý điều này, bạn chỉ cần sắp xếp lại các levels của biến factor để phản ánh thứ tự bạn muốn chúng xuất hiện trong biểu đồ. Để biết thêm thông tin chi tiết về cách sắp xếp lại các đối tượng factor, hãy xem chương factor trong cuốn sách này.Chúng ta có thể xem xét một ví dụ phổ biến bằng cách sử dụng các nhóm tuổi - theo mặc định, nhóm 5-9 tuổi sẽ được đặt ở giữa các nhóm tuổi (thứ tự chữ và số đã cho), nhưng chúng ta có thể di chuyển nó phía sau nhóm tuổi 0-4 của biểu đồ bằng cách sắp xếp lại thứ bậc của biến factor này.","code":"\nggplot(\n  data = linelist %>% drop_na(age_cat5),                         # remove rows where age_cat5 is missing\n  mapping = aes(x = fct_relevel(age_cat5, \"5-9\", after = 1))) +  # relevel factor\n\n  geom_bar() +\n  \n  labs(x = \"Age group\", y = \"Number of hospitalisations\",\n       title = \"Total hospitalisations by age group\") +\n  \n  theme_minimal()"},{"path":"ggplot-tips.html","id":"ggthemr","chapter":"31 Các tips với ggplot","heading":"31.3.0.1 ggthemr","text":"Bạn cũng có thể xem xét sử dụng package ggthemr. Bạn có thể tải xuống package này từ Github theo hướng dẫn này. INó cung cấp các bảng màu rất đẹp về mặt thẩm mỹ, nhưng hãy lưu ý rằng chúng thường có số lượng giá trị tối đa có thể bị giới hạn nếu bạn muốn nhiều hơn 7 hoặc 8 màu.","code":""},{"path":"ggplot-tips.html","id":"đường-đồng-mức","chapter":"31 Các tips với ggplot","heading":"31.4 Đường đồng mức","text":"Contour plots rất hữu ích khi bạn có nhiều điểm cần biểu diễn có thể che lấp nhau (“overplotting”). Dữ liệu case-source bên trên một lần nữa được dùng để vẽ, nhưng đơn giản hơn bằng cách sử dụng hàm stat_density2d() và stat_density2d_filled() để tạo ra các mức đường đồng mức rời rạc - giống như một bản đồ địa hình. Đọc thêm về các số liệu thống kê ở đây.","code":"\ncase_source_relationships %>% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d()+\n  geom_point()+\n  theme_minimal()+\n  labs(title = \"stat_density2d() + geom_point()\")\n\n\ncase_source_relationships %>% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d_filled()+\n  theme_minimal()+\n  labs(title = \"stat_density2d_filled()\")"},{"path":"ggplot-tips.html","id":"phân-phối-biên","chapter":"31 Các tips với ggplot","heading":"31.5 Phân phối biên","text":"Để hiển thị các phân phối trên các cạnh của biểu đồ tán xạ với hàm geom_point(), bạn có thể sử dụng package ggExtra với hàm ggMarginal(). Lưu biểu đồ ggplot nguyên gốc của bạn dưới dạng một đối tượng, sau đó chuyển nó tới hàm ggMarginal() như được trình bày dưới đây. Sau đây là những đối số chính:Bạn phải cụ thể kiểu type = theo một số lựa chọn sau: “histogram”, “density” “boxplot”, “violin”, hoặc “densigram”.Theo mặc định, các đồ thị biên sẽ xuất hiện ở cả hai trục. Bạn có thể thiết lập margins = thành “x” hoặc “y” nếu bạn chỉ muốn hiện thị ở một trong số chúng.Các đối số tùy chọn khác bao gồm fill = (màu cột), color = (màu đường), size = (kích thương biểu đồ với kích thước biên, đó số lớn hơn làm biểu đồ biên nhỏ hơn).Bạn có thể cung cấp các đối số theo trục khác với xparams = và yparams =. Ví dụ, để có các kích thước bin khác nhau trong biểu đồ histogram, như được minh họa dưới đây.Bạn có thể có các nhóm biểu đồ biên phản ánh (các cột đã được gán tới color = trong đối số thẩm mỹ của ggplot()). Nếu đúng như vậy, hãy thiết lập các đối số của hàm ggMarginal() như groupColour = hoặc groupFill = thành TRUE, như được trình bày dưới đây.Đọc thêm ở vignette này, ở trang web R Graph Gallery hoặc tài liệu trợ giúp hàm ?ggMarginal.Để thêm biểu đồ biên, hãy sử dụng type = \"histogram\". Bạn có thể tùy chọn thiết lập groupFill = TRUE để có biểu đồ histograms trầm.Biểu đồ mật độ biên với các giá trị được nhóm/tô màu:Đặt kích thước size = để điều chỉnh kích thước tương đối của ô biên. Số nhỏ hơn tạo ra biểu đồ cận biên lớn hơn. Bạn cũng có thể đặt color =. Dưới đây một biểu đồ boxplot cận biên, với sự minh họa của đối số margins = để nó chỉ hiện thị trên một trục:","code":"\n# Install/load ggExtra\npacman::p_load(ggExtra)\n\n# Basic scatter plot of weight and age\nscatter_plot <- ggplot(data = linelist)+\n  geom_point(mapping = aes(y = wt_kg, x = age)) +\n  labs(title = \"Scatter plot of weight and age\")\n# with histograms\nggMarginal(\n  scatter_plot,                     # add marginal histograms\n  type = \"histogram\",               # specify histograms\n  fill = \"lightblue\",               # bar fill\n  xparams = list(binwidth = 10),    # other parameters for x-axis marginal\n  yparams = list(binwidth = 5))     # other parameters for y-axis marginal\n# Scatter plot, colored by outcome\n# Outcome column is assigned as color in ggplot. groupFill in ggMarginal set to TRUE\nscatter_plot_color <- ggplot(data = linelist %>% drop_na(gender))+\n  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +\n  labs(title = \"Scatter plot of weight and age\")+\n  theme(legend.position = \"bottom\")\n\nggMarginal(scatter_plot_color, type = \"density\", groupFill = TRUE)\n# with boxplot \nggMarginal(\n  scatter_plot,\n  margins = \"x\",      # only show x-axis marginal plot\n  type = \"boxplot\")   "},{"path":"ggplot-tips.html","id":"dán-nhãn-thông-minh","chapter":"31 Các tips với ggplot","heading":"31.6 Dán nhãn thông minh","text":"Trong ggplot2, bạn có thể thêm văn bản vào biểu đồ. Tuy nhiên, điều này đi kèm với hạn chế đáng chú ý là các nhãn văn bản thường xung đột với các điểm dữ liệu trong một biểu đồ, khiến chúng trông lộn xộn hoặc khó đọc. Không có cách nào để giải quyết triệt để vấn đề này với các package trong base R, nhưng có một tiện ích bổ sung của ggplot2 đó là ggrepel giúp xử lý vấn đề này rất đơn giản!Package ggrepel cung cấp hai hàm mới, geom_label_repel() và geom_text_repel(), thay thế cho geom_label() và geom_text(). Đơn giản chỉ cần sử dụng các hàm này thay vì các hàm cơ bản để tạo các nhãn. Bên trong hàm, hãy cụ thể các thông số cho hàm aes() như thường lệ, nhưng bao gồm thêm đối số label = trong đó bạn cung cấp tên cột có chứa giá trị bạn muốn hiển thị (vd: id bệnh nhân, hoặc tên, v.v.). Bạn có thể tạo các nhãn phức tạp hơn bằng cách kết hợp các cột và dòng mới (\\n) bên trong hàm str_glue() như được trình bày bên dưới.Một vào mẹo:Sử dụng min.segment.length = 0 để luôn vẽ các đoạn thẳng hoặc min.segment.length = Inf để không bao giờ vẽ chúngSử dụng size = bên ngoài hàm aes() để thiết lập cỡ chữSử dụng force = để thay đổi khoảng cách giữa các nhãn và các điểm tương ứng của chúng (mặc định là 1)Thêm đối số fill = bên trong hàm aes() để có nhãn được tô màu theo giá trị\nKý tự “” có thể xuất hiện trong chú giải - hãy thêm guides(fill = guide_legend(override.aes = aes(color = NA)))+ để xóa nó\nKý tự “” có thể xuất hiện trong chú giải - hãy thêm guides(fill = guide_legend(override.aes = aes(color = NA)))+ để xóa nóHãy xem hướng dẫn chuyên sâu này để biết thêm.Bạn chỉ có thể gắn nhãn một tập hợp con của các điểm dữ liệu - bằng cách sử dụng cú pháp ggplot() tiêu chuẩn để cung cấp các dữ liệu data = khác nhau cho từng lớp geom của biểu đồ. Dưới đây, tất cả các trường hợp đều được vẽ biểu đồ, nhưng chỉ một số ít được gắn nhãn.","code":"\npacman::p_load(ggrepel)\n\nlinelist %>%                                               # start with linelist\n  group_by(hospital) %>%                                   # group by hospital\n  summarise(                                               # create new dataset with summary values per hospital\n    n_cases = n(),                                           # number of cases per hospital\n    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # mean delay per hospital\n  ) %>% \n  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # send data frame to ggplot\n  geom_point(size = 2)+                                    # add points\n  geom_label_repel(                                        # add point labels\n    mapping = aes(\n      label = stringr::str_glue(\n        \"{hospital}\\n{n_cases} cases, {delay_mean} days\")  # how label displays\n      ), \n    size = 3,                                              # text size in labels\n    min.segment.length = 0)+                               # show all line segments                \n  labs(                                                    # add axes labels\n    title = \"Mean delay to admission, by hospital\",\n    x = \"Number of cases\",\n    y = \"Mean delay (days)\")\nggplot()+\n  # All points in grey\n  geom_point(\n    data = linelist,                                   # all data provided to this layer\n    mapping = aes(x = ht_cm, y = wt_kg),\n    color = \"grey\",\n    alpha = 0.5)+                                              # grey and semi-transparent\n  \n  # Few points in black\n  geom_point(\n    data = linelist %>% filter(days_onset_hosp > 15),  # filtered data provided to this layer\n    mapping = aes(x = ht_cm, y = wt_kg),\n    alpha = 1)+                                                # default black and not transparent\n  \n  # point labels for few points\n  geom_label_repel(\n    data = linelist %>% filter(days_onset_hosp > 15),  # filter the data for the labels\n    mapping = aes(\n      x = ht_cm,\n      y = wt_kg,\n      fill = outcome,                                          # label color by outcome\n      label = stringr::str_glue(\"Delay: {days_onset_hosp}d\")), # label created with str_glue()\n    min.segment.length = 0) +                                  # show line segments for all\n  \n  # remove letter \"a\" from inside legend boxes\n  guides(fill = guide_legend(override.aes = aes(color = NA)))+\n  \n  # axis labels\n  labs(\n    title = \"Cases with long delay to admission\",\n    y = \"weight (kg)\",\n    x = \"height(cm)\")"},{"path":"ggplot-tips.html","id":"trục-thời-gian","chapter":"31 Các tips với ggplot","heading":"31.7 Trục thời gian","text":"Làm việc với các trục thời gian trong ggplot có vẻ khó khăn, nhưng được thực hiện rất dễ dàng với một vài hàm chính. Hãy nhớ rằng khi làm việc với thời gian hoặc ngày tháng, bạn phải đảm bảo rằng các biến cần được định dạng chính xác dưới kiểu date hoặc datetime - hãy xem chương Làm việc với ngày tháng để biết thêm chi tiết, hoặc chương [Đường con dịch bệnh] mục ggplot để xem các ví dụ.Nhóm các hàm hữu dụng nhất khi làm việc với ngày tháng trong ggplot2 là các hàm scale (scale_x_date(), scale_x_datetime(), và tương tự với các hàm trục y). Các hàm này cho phép bạn xác định tần suất bạn có nhãn trục và cách định dạng nhãn trục. Để tìm hiểu cách định dạng ngày tháng, hãy xem lại mục làm việc với ngày tháng một lần nữa! Bạn có thể sử dụng các đối số date_breaks và date_labels để cụ thể ngày sẽ trông như thế nào:date_breaks cho phép bạn cụ thể khoảng cách ngắt trục bằng cách truyền một chuỗi tới đối số (vd: \"3 months\", hoặc “2 days\")date_breaks cho phép bạn cụ thể khoảng cách ngắt trục bằng cách truyền một chuỗi tới đối số (vd: \"3 months\", hoặc “2 days\")date_labels cho phép bạn định nghĩa định dạng ngày tháng hiển thị. Bạn có thể truyền một chuỗi định dạng ngày tháng tới đối số (vd: \"%b-%d-%Y\"):date_labels cho phép bạn định nghĩa định dạng ngày tháng hiển thị. Bạn có thể truyền một chuỗi định dạng ngày tháng tới đối số (vd: \"%b-%d-%Y\"):","code":"\n# make epi curve by date of onset when available\nggplot(linelist, aes(x = date_onset)) +\n  geom_histogram(binwidth = 7) +\n  scale_x_date(\n    # 1 break every 1 month\n    date_breaks = \"1 months\",\n    # labels should show month then date\n    date_labels = \"%b %d\"\n  ) +\n  theme_classic()"},{"path":"ggplot-tips.html","id":"làm-nổi-bật","chapter":"31 Các tips với ggplot","heading":"31.8 Làm nổi bật","text":"Làm nổi bật các phần tử cụ thể trong biểu đồ là một cách hữu ích để thu hút sự chú ý đến một trường hợp cụ thể của một biến đồng thời cung cấp thông tin về sự phân tán của tập dữ liệu đầy đủ. Mặc dù điều này không dễ dàng thực hiện với ggplot2, tuy nhiên có một package bên ngoài giúp bạn làm điều đó có tên gghighlight. Nó rất dễ sử dụng cùng với cú pháp của ggplot.Package gghighlight sử dụng hàm gghighlight() để thực hiện. Để sử dụng hàm này, hãy cung cấp một biểu thức logic tới hàm - điều này có thể có các kết quả khá linh hoạt, nhưng ở đây chúng ta sẽ trình bày một ví dụ về phân bổ độ tuổi của các trường hợp trong bộ dữ liệu linelist, làm nổi bật chúng theo outcome.Nó cũng hoạt động tốt khi faceting - cho phép người dùng tạo ra các biểu đồ con và làm nổi bật một nhóm dữ liệu mà không áp dụng cho toàn bộ biểu đồ con ! Dưới đây, chúng tôi đếm các ca bệnh theo tuần và vẽ đồ thị đường cong dịch bệnh theo bệnh viện (color = và facet_wrap() được gán cho cột hospital).","code":"\n# load gghighlight\nlibrary(gghighlight)\n\n# replace NA values with unknown in the outcome variable\nlinelist <- linelist %>%\n  mutate(outcome = replace_na(outcome, \"Unknown\"))\n\n# produce a histogram of all cases by age\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, fill = outcome)) +\n  geom_histogram() + \n  gghighlight::gghighlight(outcome == \"Death\")     # highlight instances where the patient has died.\n# produce a histogram of all cases by age\nlinelist %>% \n  count(week = lubridate::floor_date(date_hospitalisation, \"week\"),\n        hospital) %>% \n  ggplot()+\n  geom_line(aes(x = week, y = n, color = hospital))+\n  theme_minimal()+\n  gghighlight::gghighlight() +                      # highlight instances where the patient has died\n  facet_wrap(~hospital)                              # make facets by outcome"},{"path":"ggplot-tips.html","id":"vẽ-nhiều-tập-dữ-liệu","chapter":"31 Các tips với ggplot","heading":"31.9 Vẽ nhiều tập dữ liệu","text":"Lưu ý rằng việc căn chỉnh các trục một cách chính xác để vẽ biểu đồ từ nhiều tập dữ liệu trong cùng một biểu đồ có thể khó khăn. Hãy xem xét một trong các chiến lược sau:Hợp nhất dữ liệu trước khi vẽ biểu đồ và chuyển đổi sang định dạng “dài” với một cột biểu diễn tập dữ liệuSử dụng package cowplot hoặc các package tương tự để ghép hai biểu đồ (xem bên dưới)","code":""},{"path":"ggplot-tips.html","id":"ghép-các-biểu-đồ","chapter":"31 Các tips với ggplot","heading":"31.10 Ghép các biểu đồ","text":"Hai packages phổ biến dùng để ghép các biểu đồ là cowplot và patchwork. Trong chương này chúng ta sẽ tập trung chủ yếu vào package cowplot, và một vài lần sử dụng package patchwork.Đây là tài liệu trực tuyến giới thiệu về cowplot. Bạn có thể đọc thêm các tài liệu trực tuyến mở rộng hơn cho từng hàm tại đây. Chúng tôi sẽ đề cập đến một vài trường hợp sử dụng và hàm phổ biến nhất bên dưới.Package cowplot hoạt động song song với ggplot2 - về cơ bản, bạn sử dụng nó để sắp xếp và kết hợp các ggplots và chú giải của chúng thành một biểu đồ ghép. Package này cũng chấp nhận các biểu đồ vẽ bởi base R.Trong khi faceting (được mô tả trong chương ggplot cơ bản) là cách tiếp cận thuận tiện để vẽ biểu đồ, nhưng đôi khi không thể đạt được kết quả bạn muốn từ cách tiếp cận tương đối hạn chế của nó. Tại đây, bạn có thể chọn kết hợp các biểu đồ bằng cách dán chúng lại với nhau thành một biểu đồ lớn hơn. Có ba packages tuyệt vời được sử dụng cho mục đích này - cowplot, gridExtra, và patchwork. Tuy nhiên, các package này phần lớn tương tự nhau, đó chúng ta sẽ tập trung vào package cowplot trong phần này.","code":"\npacman::p_load(\n  tidyverse,      # data manipulation and visualisation\n  cowplot,        # combine plots\n  patchwork       # combine plots\n)"},{"path":"ggplot-tips.html","id":"plot_grid","chapter":"31 Các tips với ggplot","heading":"plot_grid()","text":"Package cowplot có một số lượng lớn hàm, nhưng việc sử dụng nó dễ dàng nhất có thể đạt được thông qua việc sử dụng hàm plot_grid(). Đây là một cách hiệu quả để sắp xếp các biểu đồ được xác định trước theo dạng lưới. Chúng ta có thể làm việc thông qua một ví dụ khác với bộ dữ liệu sốt rét - ở đây chúng ta có thể vẽ biểu đồ tổng số ca bệnh theo huyện và cũng hiển thị đường cong dịch bệnh theo thời gian.","code":"\nmalaria_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) \n\n# bar chart of total cases by district\np1 <- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"District\",\n    y = \"Total number of cases\",\n    title = \"Total malaria cases by district\"\n  ) +\n  theme_minimal()\n\n# epidemic curve over time\np2 <- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1) +\n  labs(\n    x = \"Date of data submission\",\n    y =  \"number of cases\"\n  ) +\n  theme_minimal()\n\ncowplot::plot_grid(p1, p2,\n                  # 1 column and two rows - stacked on top of each other\n                   ncol = 1,\n                   nrow = 2,\n                   # top plot is 2/3 as tall as second\n                   rel_heights = c(2, 3))"},{"path":"ggplot-tips.html","id":"ghép-các-chú-giải","chapter":"31 Các tips với ggplot","heading":"Ghép các chú giải","text":"Nếu các biểu đồ của bạn có cùng chú giải, việc kết hợp chúng là tương đối dễ dàng. Đơn giản, hãy sử dụng phương pháp cowplot ở trên để kết hợp các biểu đồ, sau đó xóa chú giải khỏi một trong số chúng (loại bỏ trùng lặp).Nếu các biểu đồ có các chú giải khác nhau, bạn phải sử dụng cách khác:Tạo và lưu các biểu đồ không có chú giải bằng cách sử dụng theme(legend.position = \"none\")Trích xuất các chú giải từ từng biểu đồ sử dụng hàm get_legend() như được trình bày bên dưới - nhưng trích xuất các chú giải từ các biểu đồ đã sửa đổi để thực sự hiển thị chú giảiKết hợp các chú giải vào bảng chú giảiKết hợp các biểu đồ và bảng chú giảiVới mục đích minh họa, chúng ta hiển thị hai biểu đồ một cách riêng biệt, sau đó sắp xếp trong một lưới với các chú giải của riêng chúng (xấu xí và không sử dụng hiệu quả không gian):Đây là khi hai biểu đồ được kết hợp sử dụng hàm plot_grid() mà không kết hợp các chú giải:Và bây giờ chúng ta sẽ kế hợp các chú giải. Về cơ bản chúng ta cần xác định từng biểu đồ mà không bao gồm chú giải của nó (theme(legend.position = \"none\"), sau đó chúng ta xác định từng chú giải của biểu đồ một cách riêng biệt, sử dụng hàm get_legend() từ package cowplot. Khi chúng ta trích xuất chú giải từ các biểu đồ đã lưu, chúng ta cần thêm + chú thích vào lại, bao gồm việc cụ thể vị trí (“bên phải”) và các điều chỉnh nhỏ hơn để căn chỉnh các chú giải và tiêu đề của chúng. Sau đó, chúng ta kết hợp các chú giải lại với nhau theo chiều dọc, và rồi kết hợp hai biểu đồ lại với bảng chú giải mới.Giải pháp này đã được học hỏi từ bài đăng này với một thay đổi nhỏ để sắp xếp các chú giải từ bài đăng này.MẸO: Lưu ý vui - từ “cow” trong cowplot bằt nguồn từ tên của người sáng tạo ra nó - Claus O. Wilke.","code":"\np1 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, outcome) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  labs(title = \"Cases by outcome\")\n\n\np2 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, age_cat) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(axis.text.y = element_blank())+\n  labs(title = \"Cases by age\")\ncowplot::plot_grid(p1, p2, rel_widths = c(0.3))\n# Define plot 1 without legend\np1 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, outcome) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(legend.position = \"none\")+\n  labs(title = \"Cases by outcome\")\n\n\n# Define plot 2 without legend\np2 <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, age_cat) %>% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(\n    legend.position = \"none\",\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank()\n  )+\n  labs(title = \"Cases by age\")\n\n\n# extract legend from p1 (from p1 + legend)\nleg_p1 <- cowplot::get_legend(p1 +\n                                theme(legend.position = \"right\",        # extract vertical legend\n                                      legend.justification = c(0,0.5))+ # so legends  align\n                                labs(fill = \"Outcome\"))                 # title of legend\n# extract legend from p2 (from p2 + legend)\nleg_p2 <- cowplot::get_legend(p2 + \n                                theme(legend.position = \"right\",         # extract vertical legend   \n                                      legend.justification = c(0,0.5))+  # so legends align\n                                labs(fill = \"Age Category\"))             # title of legend\n\n# create a blank plot for legend alignment\n#blank_p <- patchwork::plot_spacer() + theme_void()\n\n# create legends panel, can be one on top of the other (or use spacer commented above)\nlegends <- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))\n\n# combine two plots and the combined legends panel\ncombined <- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))\n\ncombined  # print"},{"path":"ggplot-tips.html","id":"thêm-biểu-đồ-phụ","chapter":"31 Các tips với ggplot","heading":"Thêm biểu đồ phụ","text":"Bạn cũng có thể thêm một biểu đồ nhỏ vào một biểu đồ khác sử dụng package cowplot. Dưới đây là những điều cần lưu ý:f:Xác định biểu đồ chính với hàm theme_half_open() trong package cowplot; tốt nhất có thể có chú giải ở trên cùng hoặc dưới cùngXác định biểu đồ phụ. Tốt nhất là biểu đồ đó bạn không cần chú giải. Bạn có thể xóa các phần tử chủ đề của biểu đồ đó bằng hàm element_blank() như được trình bày bên dưới.Kết hợp chúng bằng cách áp dụng hàm ggdraw() tới biểu đồ chính, rồi sau đó thêm hàm draw_plot() chỉ định biểu đồ phụ và cụ thể hệ trục tọa độ (x và y của góc dưới bên trái), chiều cao và chiều rộng theo tỷ lệ của toàn bộ biểu đồ chính)Kỹ thuật này được giải thích chi tiết hơn trong hai hướng dẫn sau:Wilke labdraw_plot() documentation","code":"\n# Define main plot\nmain_plot <- ggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset, fill = hospital))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+ \n  theme_half_open()+\n  theme(legend.position = \"bottom\")+\n  labs(title = \"Epidemic curve and outcomes by hospital\")\n\n\n# Define inset plot\ninset_plot <- linelist %>% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %>% \n  count(hospital, outcome) %>% \n  ggplot()+\n    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n    scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n    coord_flip()+\n    theme_minimal()+\n    theme(legend.position = \"none\",\n          axis.title.y = element_blank())+\n    labs(title = \"Cases by outcome\") \n\n\n# Combine main with inset\ncowplot::ggdraw(main_plot)+\n     draw_plot(inset_plot,\n               x = .6, y = .55,    #x = .07, y = .65,\n               width = .4, height = .4)"},{"path":"ggplot-tips.html","id":"trục-kép","chapter":"31 Các tips với ggplot","heading":"31.11 Trục kép","text":"Trục y thứ hai thường là phần bổ sung được yêu cầu cho đồ thị ggplot2. Mặc dù có một cuộc tranh luận gay gắt về tính hợp lệ của các biểu đồ như vậy trong cộng đồng trực quan hóa dữ liệu và chúng thường không được khuyến nghị, nhưng người quản lý của bạn có thể vẫn muốn điều này. Dưới đây, chúng tôi trình bày một phương pháp để vẽ các biểu đồ như vậy: sử dụng package cowplot để kết hợp hai biểu đồ riêng biệt.Cách tiếp cận này bao gồm việc tạo hai biểu đồ riêng biệt - một biểu đồ có trục y ở bên trái và biểu đồ còn lại có trục y ở bên phải. Cả hai sẽ cùng sử dụng một theme_cowplot() và phải có cùng trục x. Sau đó, trong lệnh thứ ba, hai biểu đồ được căn chỉnh và chồng lên nhau. Các hàm chức năng của cowplot, được mô tả chi tiết tại trang web này.Để chứng minh kỹ thuật này, chúng ta sẽ phủ đường cong dịch bệnh bằng một đường biểu diễn phần trăm bệnh nhân tử vong hàng tuần. Chúng tôi sử dụng ví dụ này vì việc căn chỉnh ngày tháng trên trục x phức tạp hơn là căn chỉnh biểu đồ cột với một biểu đồ khác. Một số điều cần lưu ý:Đường cong dịch bệnh và đường biểu diễn được tổng hợp thành nhiều tuần trước khi vẽ biểu đồ và date_breaks và date_labels giống hệt nhau - chúng ta làm điều này để trục x của hai biểu đồ giống nhau khi chúng được phủ lên nhau.Trục y được chuyển sang phía bên phải cho biểu đồ 2 với đối số position = của hàm scale_y_continuous().Cả hai biểu đồ cùng sử dụng theme_cowplot()Lưu ý rằng có một ví dụ khác về kỹ thuật này trong chương Đường cong dịch bệnh - phủ tỷ lệ mới mắc tích lũy lên trên đỉnh đường cong dịch bệnh.Tạo biểu đồ 1\nĐâu là biểu đồ đương cong dịch bệnh cơ bản. Chúng ta sử dụng hàm geom_area() chỉ để minh họa cách sử dụng của nó (mặc dịch là vùng dưới một đường)Tạo biểu đồ 2\nTạo biểu đồ thứ hai hiển thị một đường về tỷ lệ phần trăm trường hợp tử vong hàng tuần..Bây giờ chúng ta căn chỉnh biểu đồ bằng cách sử dụng hàm align_plots(), cụ thể căn chỉnh theo chiều ngang và dọc (“hv”, cũng có thể hoặc là “h”, “v”, “none”). Chúng ta cũng chỉ định căn chỉnh tất cả các trục (trên, dưới, trái, và phải) với “tblr”. Đầu ra là một class list (2 phần tử).Sau đó, chúng tôi vẽ hai biểu đồ lại với nhau bằng cách sử dụng hàm ggdraw() (từ pakcage cowplot) à tham chiếu đến hai phần của đối tượng aligned_plots.","code":"\npacman::p_load(cowplot)            # load/install cowplot\n\np1 <- linelist %>%                 # save plot as object\n     count(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %>% \n     ggplot()+\n          geom_area(aes(x = epiweek, y = n), fill = \"grey\")+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n     theme_cowplot()+\n     labs(\n       y = \"Weekly cases\"\n     )\n\np1                                      # view plot \np2 <- linelist %>%         # save plot as object\n     group_by(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %>% \n     summarise(\n       n = n(),\n       pct_death = 100*sum(outcome == \"Death\", na.rm=T) / n) %>% \n     ggplot(aes(x = epiweek, y = pct_death))+\n          geom_line()+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n          scale_y_continuous(\n               position = \"right\")+\n          theme_cowplot()+\n          labs(\n            x = \"Epiweek of symptom onset\",\n            y = \"Weekly percent of deaths\",\n            title = \"Weekly case incidence and percent deaths\"\n          )\n\np2     # view plot\naligned_plots <- cowplot::align_plots(p1, p2, align=\"hv\", axis=\"tblr\")         # align the two plots and save them as list\naligned_plotted <- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # overlay them and save the visual plot\naligned_plotted                                                                # print the overlayed plots"},{"path":"ggplot-tips.html","id":"packages-giúp-đỡ-bạn","chapter":"31 Các tips với ggplot","heading":"31.12 Packages giúp đỡ bạn","text":"Có một số package R thực sự gọn gàng được thiết kế đặc biệt để giúp bạn điều hướng ggplot2:","code":""},{"path":"ggplot-tips.html","id":"giao-diện-kéo-thả-ggplot2-với-package-equisse","chapter":"31 Các tips với ggplot","heading":"Giao diện kéo thả ggplot2 với package equisse","text":"“Addin này cho phép bạn khám phá dữ liệu của mình một cách tương tác bằng cách trực quan hóa nó với package ggplot2. Nó cho phép bạn vẽ biểu đồ cột, đường cong, biểu đồ tán xạ, histograms, boxplot và các đối tượng sf, sau đó xuất biểu đồ hoặc truy xuất code để tái tạo biểu đồ.”Cài đặt và sau đó khởi chạy addin thông qua menu của RStudio hoặc gõ esquisse::esquisser().Xem thêm Github pageDocumentation","code":""},{"path":"ggplot-tips.html","id":"tổng-hợp","chapter":"31 Các tips với ggplot","heading":"31.13 Tổng hợp","text":"","code":""},{"path":"ggplot-tips.html","id":"hiển-thị-số","chapter":"31 Các tips với ggplot","heading":"Hiển thị số","text":"Bạn có thể tắt ký hiệu khoa học bằng cách chạy lệnh này trước khi vẽ biểu đồ.Hoặc áp dụng hàm number_format() từ package scales cho một giá trị cụ thể hoặc cột, như được trình bày bên dưới.Sử dụng các hàm từ package scales easily adjust numbers displayed. để dễ dàng điều chỉnh cách hiển thị số. Chúng có thể được áp dụng cho các cột trong data frame của bạn, nhưng được hiển thị trên các số riêng lẻ cho mục đích ví dụ.","code":"\noptions(scipen=999)\nscales::number(6.2e5)## [1] \"620 000\"\nscales::number(1506800.62,  accuracy = 0.1,)## [1] \"1 506 800.6\"\nscales::comma(1506800.62, accuracy = 0.01)## [1] \"1,506,800.62\"\nscales::comma(1506800.62, accuracy = 0.01,  big.mark = \".\" , decimal.mark = \",\")## [1] \"1.506.800,62\"\nscales::percent(0.1)## [1] \"10%\"\nscales::dollar(56)## [1] \"$56\"\nscales::scientific(100000)## [1] \"1e+05\""},{"path":"ggplot-tips.html","id":"nguồn-7","chapter":"31 Các tips với ggplot","heading":"31.14 Nguồn","text":"Cảm hứng\nggplot graph galleryTrình bày dữ liệu của Trung tâm Phòng ngừa và Kiểm soát Dịch bệnh Châu Âu Guidelines presentation surveillance dataFacets và dán nhãn\nUsing labellers facet strips\nLabellersĐiều chỉnh thức bậc biến factors\nfct_reorderfct_inorderHow reorder boxplotReorder variable ggplot2R Data Science - FactorsChú giảiAdjust legend orderChú thích\nCaption alignmentNhãn\nggrepelCheatsheetsBeautiful plotting ggplot2","code":""},{"path":"epicurves.html","id":"epicurves","chapter":"32 Đường cong dịch bệnh","heading":"32 Đường cong dịch bệnh","text":"Đường cong dịch bệnh (còn được gọi là “đường cong epi”) là một biểu đồ dịch tễ học cốt lõi thường được sử dụng để trực quan xu hướng khởi phát bệnh theo thời gian trong một cụm hoặc nhóm ca bệnh.Phân tích đường cong dịch bệnh có thể cho biết xu hướng theo thời gian, giá trị ngoại lai, mức độ bùng phát dịch, khoảng thời gian có khả năng bị phơi nhiễm cao nhất, khoảng thời gian giữa các thế hệ ca bệnh và thậm chí có thể giúp xác định phương thức lây truyền của một căn bệnh không xác định (ví dụ: điểm bắt nguồn, nguồn tiếp diễn phổ biến, lây truyền từ người sang người). Bạn có thể tìm thấy một bài học trực tuyến về giải thích các đường cong dịch bệnh tại trang web của CDC Hoa Kỳ.Trong chương này, chúng tôi trình bày hai cách tiếp cận để tạo ra đường cong dịch bệnh trong R:Package incidence2, có thể tạo ra đường cong dịch bệnh với các lệnh đơn giảnPackage ggplot2, cho phép khả năng tùy chỉnh nâng cao thông qua các lệnh phức tạp hơnChúng tôi cũng sẽ giải quyết các trường hợp cụ thể như:Lập biểu đồ dữ liệu đếm tổng hợpFaceting hoặc tạo nhiều cấu phần nhỏÁp dụng đường trung bình độngHiển thị dữ liệu “dự kiến” hoặc có thể bị chậm trễ trong báo cáoThêm tỷ lệ ca nhiễm mới tích lũy bằng cách sử dụng trục thứ hai","code":""},{"path":"epicurves.html","id":"chuẩn-bị-23","chapter":"32 Đường cong dịch bệnh","heading":"32.1 Chuẩn bị","text":"","code":""},{"path":"epicurves.html","id":"packages-3","chapter":"32 Đường cong dịch bệnh","heading":"Packages","text":"Đoạn code này hiển thị cách gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, sẽ cài đặt package nếu cần và gọi package để sử dụng. Bạn cũng có thể cài đặt package với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.","code":"\npacman::p_load(\n  rio,          # file import/export\n  here,         # relative filepaths \n  lubridate,    # working with dates/epiweeks\n  aweek,        # alternative package for working with dates/epiweeks\n  incidence2,   # epicurves of linelist data\n  i2extras,     # supplement to incidence2\n  stringr,      # search and manipulate character strings\n  forcats,      # working with factors\n  RColorBrewer, # Color palettes from colorbrewer2.org\n  tidyverse     # data management + ggplot2 graphics\n) "},{"path":"epicurves.html","id":"nhập-dữ-liệu-17","chapter":"32 Đường cong dịch bệnh","heading":"Nhập dữ liệu","text":"Hai bộ dữ liệu mẫu được sử dụng trong chương này:Bộ số liệu linelist về các ca bệnh từ một vụ dịch mô phỏngSố lượng tổng hợp theo bệnh viện từ cùng một dịch bệnh mô phỏng bên trênCác bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau.Bộ số liệu linelistChúng ta nhập bộ dữ liệu về các ca bệnh mô phỏng từ một vụ dịch Ebola. Nếu bạn muốn tải xuống dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương Tải sách và dữ liệu. Chúng tôi giả sử các tệp tin nằm trong thư mục làm việc nên không có thư mục con nào được chỉ định trong đường dẫn này.50 dòng đầu tiên được hiển thị như bên dưới:Số lượng ca bệnh bệnh viện tổng hợpTheo mục tiêu của cuốn sách này, bộ dữ liệu về số lượng tổng hợp hàng tuần theo bệnh viện được tạo từ linelist với đoạn code sau.50 dòng đầu tiên được hiển thị như bên dưới:","code":"\nlinelist <- import(\"linelist_cleaned.xlsx\")\n# import the counts data into R\ncount_data <- linelist %>% \n  group_by(hospital, date_hospitalisation) %>% \n  summarize(n_cases = dplyr::n()) %>% \n  filter(date_hospitalisation > as.Date(\"2013-06-01\")) %>% \n  ungroup()"},{"path":"epicurves.html","id":"thiết-lập-các-tham-số","chapter":"32 Đường cong dịch bệnh","heading":"Thiết lập các tham số","text":"Để tạo báo cáo, bạn có thể muốn thiết lập các thông số có thể chỉnh sửa, chẳng hạn như ngày dữ liệu hiện tại (“ngày dữ liệu”). Sau đó, bạn có thể tham chiếu đối tượng data_date trong code khi áp dụng bộ lọc hoặc trong chú thích động.","code":"\n## set the report date for the report\n## note: can be set to Sys.Date() for the current date\ndata_date <- as.Date(\"2015-05-15\")"},{"path":"epicurves.html","id":"xác-minh-ngày","chapter":"32 Đường cong dịch bệnh","heading":"Xác minh ngày","text":"Xác minh rằng mỗi cột ngày có liên quan là phân lớp Ngày và có phạm vi giá trị thích hợp. Bạn có thể thực hiện việc này đơn giản bằng cách sử dụng hàm hist() cho histogram hoặc hàm range() với na.rm=TRUE, hoặc với hàm ggplot() như bên dưới.","code":"\n# check range of onset dates\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))"},{"path":"epicurves.html","id":"đường-cong-dịch-bệnh-với-package-incidence2","chapter":"32 Đường cong dịch bệnh","heading":"32.2 Đường cong dịch bệnh với package incidence2","text":"Dưới đây, chúng tôi trình bày cách tạo các đường cong dịch bệnh bằng cách sử dụng package precision2. Các tác giả của package này đã cố gắng cho phép người dùng tạo và sửa đổi các đường cong dịch bệnh mà không cần biết cú pháp ggplot2. Phần lớn nội dung của chương này được điều chỉnh từ minh họa của package, bạn có thể tìm thấy tại trang github của package incidence2.","code":""},{"path":"epicurves.html","id":"ví-dụ-đơn-giản","chapter":"32 Đường cong dịch bệnh","heading":"Ví dụ đơn giản","text":"Cần có 2 bước để vẽ đường cong dịch bệnh với package incidence2:Tạo một incidence object (sử dụng hàm incidence())\nCung cấp dữ liệu\nXác định cột ngày tại date_index =\nXác định khoảng thời gian interval = các ca nên được tổng hợp (hàng ngày, tuần, tháng..)\nXác định bất kỳ cột dùng để nhóm nào (ví dụ như giới tính, bệnh viện, kết quả)\nTạo một incidence object (sử dụng hàm incidence())Cung cấp dữ liệuXác định cột ngày tại date_index =Xác định khoảng thời gian interval = các ca nên được tổng hợp (hàng ngày, tuần, tháng..)Xác định bất kỳ cột dùng để nhóm nào (ví dụ như giới tính, bệnh viện, kết quả)Vẽ biểu đồ incidence object\nXác định nhãn, màu, tiêu đề, …\nVẽ biểu đồ incidence objectXác định nhãn, màu, tiêu đề, …Dưới đây, chúng tôi gọi package incidence2, tạo incidence object từ dữ liệu linelist trên cột date_onset và tổng hợp các trường hợp theo ngày. Sau đó, chúng tôi ra tóm tắt về đối tượng incidence object.Đối tượng incidence2 trông giống như một tibble (một kiểu data frame) và có thể được hiển thị hoặc thao tác thêm như một bộ dữ liệu.Đây là thông tin khi được hiển thị. Nó có một cột date_index và một cột count .Bạn cũng có thể tổng hợp thông tin của đối tượng:Để vẽ biểu đồ incidence object, hãy sử dụng hàm plot() với tên của incidence object. Trong nền, hàm plot.incidence2() đã được gọi, vì vậy để đọc tài liệu cụ thể về incidence2, bạn cần chạy lệnh ?plot.incidence2.Nếu bạn nhận thấy nhiều đường dọc nhỏ màu trắng, hãy cố gắng điều chỉnh kích thước hình ảnh của bạn. Ví dụ: nếu bạn xuất biểu đồ bằng ggsave(), bạn có thể cung cấp giá trị số cho width = và height =. Nếu bạn mở rộng biểu đồ, những đường đó có thể biến mất.","code":"\n# load incidence2 package\npacman::p_load(incidence2)\n\n# create the incidence object, aggregating cases by day\nepi_day <- incidence(       # create incidence object\n  x = linelist,             # dataset\n  date_index = date_onset,  # date column\n  interval = \"day\"          # date grouping interval\n  )\nclass(epi_day)## [1] \"incidence2\" \"tbl_df\"     \"tbl\"        \"data.frame\"\nepi_day## An incidence2 object: 367 x 2\n## 5632 cases from 2014-04-07 to 2015-04-30\n## interval: 1 day\n## cumulative: FALSE\n## \n##    date_index count\n##    <date>     <int>\n##  1 2014-04-07     1\n##  2 2014-04-15     1\n##  3 2014-04-21     2\n##  4 2014-04-25     1\n##  5 2014-04-26     1\n##  6 2014-04-27     1\n##  7 2014-05-01     2\n##  8 2014-05-03     1\n##  9 2014-05-04     1\n## 10 2014-05-05     1\n## # ... with 357 more rows\n# print summary of the incidence object\nsummary(epi_day)## An incidence2 object: 367 x 2\n## 5632 cases from 2014-04-07 to 2015-04-30\n## interval: 1 day\n## cumulative: FALSE\n## timespan: 389 days\n# plot the incidence object\nplot(epi_day)"},{"path":"epicurves.html","id":"thay-đổi-khoảng-thời-gian-tổng-hợp-ca-bệnh","chapter":"32 Đường cong dịch bệnh","heading":"Thay đổi khoảng thời gian tổng hợp ca bệnh","text":"Đối số interval = của hàm incidence() xác định cách các quan sát được nhóm thành các cột dọc trong biểu đồ.Xác định khoảng thời gianincidence2 đem lại sự linh hoạt và cú pháp dễ hiểu để bạn có thể dễ dàng tổng hợp số ca bệnh thành các biểu đồ cột-đường cong dịch bệnh. Cung cấp một giá trị như những giá trị bên dưới cho đối số interval =. Bạn có thể viết bất kỳ thông tin nào bên dưới dưới dạng số nhiều (ví dụ: “weeks”) và bạn có thể thêm số phía trước (ví dụ: “3 months”).Dưới đây là ví dụ về các khoảng thời gian khác nhau trông như thế nào khi áp dụng vào bộ số liệu linelist. Lưu ý cách mà định dạng mặc định và tần suất của các nhãn thời gian trên trục x thay đổi khi khoảng thời gian thay đổi.Ngày đầu tiênBạn có thể tùy chọn chỉ định một giá trị thuộc phân lớp Ngày (ví dụ: .Date(\"2016-05-01\")) tới đối số firstdate = trong lệnh incidence(). Nếu được cung cấp, dữ liệu sẽ được cắt bớt theo phạm vi này và khoảng thời gian sẽ bắt đầu từ ngày này.","code":"\n# Create the incidence objects (with different intervals)\n##############################\n# Weekly (Monday week by default)\nepi_wk      <- incidence(linelist, date_onset, interval = \"Monday week\")\n\n# Sunday week\nepi_Sun_wk  <- incidence(linelist, date_onset, interval = \"Sunday week\")\n\n# Three weeks (Monday weeks by default)\nepi_2wk     <- incidence(linelist, date_onset, interval = \"2 weeks\")\n\n# Monthly\nepi_month   <- incidence(linelist, date_onset, interval = \"month\")\n\n# Quarterly\nepi_quarter   <- incidence(linelist, date_onset, interval = \"quarter\")\n\n# Years\nepi_year   <- incidence(linelist, date_onset, interval = \"year\")\n\n\n# Plot the incidence objects (+ titles for clarity)\n############################\nplot(epi_wk)+      labs(title = \"Monday weeks\")\nplot(epi_Sun_wk)+  labs(title = \"Sunday weeks\")\nplot(epi_2wk)+     labs(title = \"2 (Monday) weeks\")\nplot(epi_month)+   labs(title = \"Months\")\nplot(epi_quarter)+ labs(title = \"Quarters\")\nplot(epi_year)+    labs(title = \"Years\")"},{"path":"epicurves.html","id":"nhóm-1","chapter":"32 Đường cong dịch bệnh","heading":"Nhóm","text":"Các nhóm được chỉ định trong lệnh incidence() và có thể được sử dụng để tô màu cho các cột hoặc facet dữ liệu. Để chỉ định các nhóm trong dữ liệu của bạn, hãy cung cấp tên cột tới đối số groups = trong hàm incidence() (không có dấu ngoặc kép xung quanh tên cột). Nếu chỉ định nhiều cột, hãy để tên các cột bên trong hàm c().Bạn có thể chỉ định rằng các trường hợp có giá trị bị thiếu trong các cột được nhóm được liệt kê như một nhóm NA riêng biệt bằng cách thiết lập na_as_group = TRUE. Nếu không, chúng sẽ bị loại khỏi biểu đồ.Để tô màu các cột theo cột nhóm, bạn cần cung cấp lại tên cột tới đối số fill = trong lệnh plot().Để tô màu các cột theo cột nhóm, bạn cần cung cấp lại tên cột tới đối số fill = trong lệnh plot().Để facet dựa trên cột nhóm, hãy xem phần bên dưới về facet với incidence2.Để facet dựa trên cột nhóm, hãy xem phần bên dưới về facet với incidence2.Trong ví dụ dưới đây, các trường hợp trong toàn bộ đợt bùng phát được nhóm theo phân loại tuổi của họ. Các giá trị thiếu được đưa vào một nhóm. Khoảng thời gian của đường cong bệnh dịch là tuần.MẸO: Thay đổi tiêu đề của chú giải bằng cách thêm + lệnh ggplot2 labs(fill = \"title\") vào biểu đồ incidence2.Bạn cũng có thể để các cột được nhóm hiển thị cạnh nhau bằng cách đặt stack = FALSE trong plot(), như được hiển thị bên dưới:Bạn có thể đặt đối số na_as_group = thành FALSE trong lệnh incidence() để loại bỏ các hàng có giá trị bị thiếu khỏi biểu đồ.","code":"\n# Create incidence object, with data grouped by age category\nage_outbreak <- incidence(\n  linelist,                # dataset\n  date_index = date_onset, # date column\n  interval = \"week\",       # Monday weekly aggregation of cases\n  groups = age_cat,        # age_cat is set as a group\n  na_as_group = TRUE)      # missing values assigned their own group\n\n# plot the grouped incidence object\nplot(\n  age_outbreak,             # incidence object with age_cat as group\n  fill = age_cat)+          # age_cat is used for bar fill color (must have been set as a groups column above)\nlabs(fill = \"Age Category\") # change legend title from default \"age_cat\" (this is a ggplot2 modification)\n# Make incidence object of monthly counts. \nmonthly_gender <- incidence(\n linelist,\n date_index = date_onset,\n interval = \"month\",\n groups = gender            # set gender as grouping column\n)\n\nplot(\n  monthly_gender,   # incidence object\n  fill = gender,    # display bars colored by gender\n  stack = FALSE)    # side-by-side (not stacked)"},{"path":"epicurves.html","id":"lọc-dữ-liệu","chapter":"32 Đường cong dịch bệnh","heading":"Lọc dữ liệu","text":"Để vẽ biểu đồ đường cong dịch bệnh của một bộ dữ liệu con:Lọc bộ số liệu linelistCung cấp dữ liệu đã lọc vào lệnh incidence()Vẽ biểu đồ incidence objectVí dụ dưới đây sử dụng dữ liệu được lọc để chỉ hiển thị các trường hợp tại Central Hospital.","code":"\n# filter the linelist\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n\n# create incidence object using filtered data\ncentral_outbreak <- incidence(central_data, date_index = date_onset, interval = \"week\")\n\n# plot the incidence object\nplot(central_outbreak, title = \"Weekly case incidence at Central Hospital\")"},{"path":"epicurves.html","id":"số-lượng-tổng-hợp","chapter":"32 Đường cong dịch bệnh","heading":"Số lượng tổng hợp","text":"Nếu dữ liệu ban đầu của bạn được tổng hợp (số lượng), hãy cung cấp tên của cột chứa thông tin về số lượng ca tới đối số count = khi tạo incidence object với hàm incidence().Ví dụ, data frame count_data này được tổng hợp từ linelist theo số lượng hàng ngày theo bệnh viện. 50 hàng đầu tiên hiển thị như sau:Nếu bạn đang bắt đầu phân tích với dữ liệu đếm hàng ngày như bộ dữ liệu ở trên, thì lệnh incidence() để chuyển đổi dữ liệu này thành đường cong dịch bệnh hàng tuần theo bệnh viện sẽ trông như sau:","code":"\nepi_counts <- incidence(              # create weekly incidence object\n  count_data,                         # dataset with counts aggregated by day\n  date_index = date_hospitalisation,  # column with dates\n  count = n_cases,                    # column with counts\n  interval = \"week\",                  # aggregate daily counts up to weeks\n  groups = hospital                   # group by hospital\n  )\n\n# plot the weekly incidence epi curve, with stacked bars by hospital\nplot(epi_counts,                      # incidence object\n     fill = hospital)                 # color the bars by hospital"},{"path":"epicurves.html","id":"facetscác-biểu-đồ-nhỏ","chapter":"32 Đường cong dịch bệnh","heading":"Facets/Các biểu đồ nhỏ","text":"Để facet dữ liệu theo nhóm (ví dụ tạo “các biểu đồ nhỏ”):Xác định các cột dùng để facet tới đối số groups = khi bạn tạo incidence objectSử dụng lệnh facet_plot() thay cho plot()Xác định cột nhóm nào được sử dụng cho fill = và cho facets =Dưới đây, chúng ta thiết lập cả hai cột hospital và outcome làm cột chia nhóm trong lệnh incidence(). Sau đó, trong lệnh facet_plot(), chúng ta vẽ biểu đồ đường cong dịch bệnh, chỉ rõ rằng chúng ta muốn có các đường cong dịch bệnh khác nhau cho mỗi bệnh viện và trong mỗi đường cong dịch bệnh, các cột được xếp chồng lên nhau và được tô màu theo outcome.Lưu ý rằng package ggtree (được sử dụng để trực quan cây phả hệ) cũng có một hàm là facet_plot() - đây là lý tại sao chúng ta phải cụ thể incidence2::facet_plot() như ở trên.","code":"\nepi_wks_hosp_out <- incidence(\n  linelist,                      # dataset\n  date_index = date_onset,       # date column\n  interval = \"month\",            # monthly bars  \n  groups = c(outcome, hospital)  # both outcome and hospital are given as grouping columns\n  )\n\n# plot\nincidence2::facet_plot(\n  epi_wks_hosp_out,      # incidence object\n  facets = hospital,     # facet column\n  fill = outcome)        # fill column"},{"path":"epicurves.html","id":"hiệu-chỉnh-với-plot","chapter":"32 Đường cong dịch bệnh","heading":"Hiệu chỉnh với plot()","text":"Một đường cong dịch bệnh được tạo ra bởi incidence2 có thể được sửa đổi thông qua các đối số trong hàm plot().Dưới đây là các đối số của hàm plot() dùng để điều chỉnh hình thức cột:Dưới đây là các đối số của hàm plot() để sửa đổi trục ngày tháng:Lưu ý rằng đối số date_breaks = chỉ hoạt động nếu centre_dates = FALSE. Cung cấp giá trị ký tự trong dấu ngoặc kép bằng cú pháp strptime như bên dưới, như đã được trình bày chi tiết trong chương Làm việc với ngày tháng. Bạn có thể sử dụng \\n để tạo “dòng mới”.%d = Số ngày của tháng (5, 17, 28, …)\n%j = Số ngày của năm (ngày Julian 001-366)\n%= Ngày trong tuần viết tắt (Mon, Tue, Wed, …)\n%= Ngày trong tuần viết đầy đủ (Monday, Tuesday, …)\n%w = Số thứ tự ngày của tuần (0-6, Chủ nhật là 0)\n%u = Số thứ tự ngày của tuần (1-7, Thứ hai là 1)\n%W = Số thứ tự tuần (00-53, Thứ hai là ngày bắt đầu tuần mới)\n%U = Số thứ tự tuần (01-53, Chủ nhật là ngày bắt đầu tuần mới)\n%m = Số thứ tự tháng (Ví dụ 01, 02, 03, 04)\n%b = Tháng viết tắt (Jan, Feb, …)\n%B = Tháng viết đầy đủ (January, February, …)\n%y = Năm viết dạng 2 ký tự (Ví dụ 89)\n%Y = Năm viết dạng 2 ký tự (Ví dụ 1989)\n%H = giờ (khung 24 giờ)\n%M = phút\n%S = giây\n%z = bù từ múi giờ GMT\n%Z = Múi giờ (ký tự)Dưới đây là các đối số trong hàm plot() để hiệu chỉnh các nhãn trong biểu đồ:Một ví dụ sử dụng kết hợp các đối số ở trên:Để điều chỉnh thêm giao diện hiển thị của biểu đồ, hãy xem mục bên dưới về các hiệu chỉnh với hàm ggplot().","code":"\n# filter the linelist\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n\n# create incidence object using filtered data\ncentral_outbreak <- incidence(\n  central_data,\n  date_index = date_onset,\n  interval = \"week\",\n  groups = outcome)\n\n# plot incidence object\nplot(\n  central_outbreak,\n  fill = outcome,                       # box/bar color\n  legend = \"top\",                       # legend on top\n  title = \"Cases at Central Hospital\",  # title\n  xlab = \"Week of onset\",               # x-axis label\n  ylab = \"Week of onset\",               # y-axis label\n  show_cases = TRUE,                    # show each case as an individual box\n  alpha = 0.7,                          # transparency \n  border = \"grey\",                      # box border\n  angle = 30,                           # angle of date labels\n  centre_dates = FALSE,                 # date labels at edge of bar\n  date_format = \"%a %d %b %Y\\n(Week %W)\" # adjust how dates are displayed\n  )"},{"path":"epicurves.html","id":"hiệu-chỉnh-với-ggplot2","chapter":"32 Đường cong dịch bệnh","heading":"Hiệu chỉnh với ggplot2","text":"Bạn có thể hiệu chỉnh biểu đồ được tạo bởi incidence2 bằng cách thêm các hiệu chỉnh ggplot2 với dấu + sau khi đóng ngoặc hàm biểu diễn tỷ lệ mắc bệnh plot(), như được minh họa bên dưới.Dưới đây, biểu đồ incidence2 kết thúc và ngay sau đó các lệnh ggplot2 được sử dụng để sửa đổi các trục, thêm chú thích và điều chỉnh phông chữ đậm và kích thước chữ.Lưu ý rằng nếu bạn thêm scale_x_date(), hầu hết các định dạng ngày từ plot() sẽ bị ghi đè. Xem mục đường cong dịch bệnh với ggplot() và chương Các tips với ggplot để có thêm lựa chọn.","code":"\n# filter the linelist\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n\n# create incidence object using filtered data\ncentral_outbreak <- incidence(\n  central_data,\n  date_index = date_onset,\n  interval = \"week\",\n  groups = c(outcome))\n\n# plot incidence object\nplot(\n  central_outbreak,\n  fill = outcome,                       # box/bar color\n  legend = \"top\",                       # legend on top\n  title = \"Cases at Central Hospital\",  # title\n  xlab = \"Week of onset\",               # x-axis label\n  ylab = \"Week of onset\",               # y-axis label\n  show_cases = TRUE,                    # show each case as an individual box\n  alpha = 0.7,                          # transparency \n  border = \"grey\",                      # box border\n  centre_dates = FALSE,                   \n  date_format = \"%a %d %b\\n%Y (Week %W)\", \n  angle = 30                           # angle of date labels\n  )+\n  \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 30, by = 5),  # specify y-axis increments by 5\n    expand = c(0,0))+                         # remove excess space below 0 on y-axis\n  \n  # add dynamic caption\n  labs(\n    fill = \"Patient outcome\",                               # Legend title\n    caption = stringr::str_glue(                            # dynamic caption - see page on characters and strings for details\n      \"n = {central_cases} from Central Hospital\n      Case onsets range from {earliest_date} to {latest_date}. {missing_onset} cases are missing date of onset and not shown\",\n      central_cases = nrow(central_data),\n      earliest_date = format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),\n      latest_date = format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),      \n      missing_onset = nrow(central_data %>% filter(is.na(date_onset)))))+\n  \n  # adjust bold face, and caption position\n  theme(\n    axis.title = element_text(size = 12, face = \"bold\"),    # axis titles larger and bold\n    axis.text = element_text(size = 10, face = \"bold\"),     # axis text size and bold\n    plot.caption = element_text(hjust = 0, face = \"italic\") # move caption to left\n  )"},{"path":"epicurves.html","id":"đổi-màu","chapter":"32 Đường cong dịch bệnh","heading":"Đổi màu","text":"","code":""},{"path":"epicurves.html","id":"chỉ-định-bảng-màu","chapter":"32 Đường cong dịch bệnh","heading":"Chỉ định bảng màu","text":"Cung cấp tên của bảng màu đã được định danh trước tới tham số col_pal = trong hàm plot(). Package incidence2 đi kèm với 2 bảng màu được xác định trước: “vibrant” và “muted”. Trong “vibrant”, có 6 màu đầu tiên là riêng biệt và trong “muted” có 9 màu đầu tiên là khác biệt. Sau những con số này, các màu là sự thêm vào/trung gian của các màu khác. Bạn có thể tìm thấy những bảng màu được xác định trước này tại website này. Các bảng màu loại trừ màu xám, nó được dành riêng cho dữ liệu bị thiếu (sử dụng na_color = để thay đổi mặc định này).Bạn cũng có thể sử dụng một trong các bảng màu trong base R (đặt tên của bảng màu không có dấu ngoặc kép).Bạn cũng có thể thêm bảng màu từ package viridis hoặc package RColorBrewer. Đầu tiên các package đó cần được tải, sau đó thêm các hàm scale_fill_*() tương ứng của chúng bằng dấu +, như bên dưới đây.","code":"\n# Create incidence object, with data grouped by age category  \nage_outbreak <- incidence(\n  linelist,\n  date_index = date_onset,   # date of onset for x-axis\n  interval = \"week\",         # weekly aggregation of cases\n  groups = age_cat)\n\n# plot the epicurve with default palette\nplot(age_outbreak, fill = age_cat, title = \"'vibrant' default incidence2 palette\")\n\n# plot with different color palette\n#plot(age_outbreak, fill = age_cat, col_pal = muted, title = \"'muted' incidence2 palette\")\n# plot with base R palette\nplot(age_outbreak, fill = age_cat, col_pal = heat.colors, title = \"base R heat.colors palette\")\n\n# plot with base R palette\nplot(age_outbreak, fill = age_cat, col_pal = rainbow, title = \"base R rainbow palette\")\npacman::p_load(RColorBrewer, viridis)\n\n# plot with color palette\nplot(age_outbreak, fill = age_cat, title = \"Viridis palette\")+\n  scale_fill_viridis_d(\n    option = \"inferno\",     # color scheme, try also \"plasma\" or the default\n    name = \"Age Category\",  # legend name\n    na.value = \"grey\")      # for missing values\n\n# plot with color palette\nplot(age_outbreak, fill = age_cat, title = \"RColorBrewer palette\")+\n  scale_fill_brewer(\n    palette = \"Dark2\",      # color palette, try also Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3\n    name = \"Age Category\",  # legend name\n    na.value = \"grey\")      # for missing values"},{"path":"epicurves.html","id":"xác-định-thủ-công","chapter":"32 Đường cong dịch bệnh","heading":"Xác định thủ công","text":"Để chỉ định màu theo cách thủ công, hãy thêm hàm scale_fill_manual() trong ggplot2 sau hàm plot() bằng dấu + và cung cấp vectơ tên màu hoặc mã HEX tới đối số values =. Số lượng màu được liệt kê phải bằng số nhóm. Hãy lưu ý, các giá trị bị thiếu có phải là một nhóm hay không - chúng có thể được chuyển đổi thành giá trị dạng ký tự chẳng hạn như “Missing” trong quá trình chuẩn bị dữ liệu của bạn bằng hàm fct_explicit_na(), như đã được giải thích trong chương Factors.Như đã đề cập trong chương Các tips với ggplot, bạn có thể tạo bảng màu của riêng mình bằng cách sử dụng hàm colorRampPalette() trên một vectơ chứa tên các màu sắc và chỉ định số màu bạn muốn trả về. Đây là một cách tốt để có thể thu được nhiều màu trong một lần bằng cách chỉ định một vài màu.","code":"\n# manual colors\nplot(age_outbreak, fill = age_cat, title = \"Manually-specified colors\")+\n  scale_fill_manual(\n    values = c(\"darkgreen\", \"darkblue\", \"purple\", \"grey\", \"yellow\", \"orange\", \"red\", \"lightblue\"),  # colors\n    name = \"Age Category\")      # Name for legend\nmy_cols <- c(\"darkgreen\", \"darkblue\", \"purple\", \"grey\", \"yellow\", \"orange\")\nmy_palette <- colorRampPalette(my_cols)(12)  # expand the 6 colors above to 12 colors\nmy_palette##  [1] \"#006400\" \"#00363F\" \"#00097E\" \"#3A0BAF\" \"#821ADD\" \"#A84BE2\" \"#B592CB\" \"#C9C99B\" \"#E7E745\" \"#FFF600\" \"#FFCD00\" \"#FFA500\""},{"path":"epicurves.html","id":"điều-chỉnh-thứ-bậc","chapter":"32 Đường cong dịch bệnh","heading":"Điều chỉnh thứ bậc","text":"Để điều chỉnh thứ tự xuất hiện của nhóm (trên biểu đồ và trong chú giải), cột phân nhóm cần phải là kiểu Factor. Xem chương Factors để biết thêm thông tin.Đầu tiên, chúng ta hãy quan sát một đường cong dịch bệnh hàng tuần theo bệnh viện với thứ tự mặc định:Bây giờ, để điều chỉnh thứ tự sao cho nhóm phân loại “Missing” và “” ở trên cùng của đường cong dịch bệnh, chúng ta có thể làm như sau:Gọi package forcats, để làm việc với cột định dạng factorGọi package forcats, để làm việc với cột định dạng factorĐiều chỉnh bộ dữ liệu - trong trường hợp này, chúng tôi sẽ xác định một bộ dữ liệu mới (plot_data) trong đó:\nCột gender được xác định là một biến phân loại có thứ bậc được thiết lập bằng hàm fct_relevel() sao cho “” và “Missing” đứng đầu tiên, đó chúng xuất hiện ở trên đầu các cột\nĐiều chỉnh bộ dữ liệu - trong trường hợp này, chúng tôi sẽ xác định một bộ dữ liệu mới (plot_data) trong đó:Cột gender được xác định là một biến phân loại có thứ bậc được thiết lập bằng hàm fct_relevel() sao cho “” và “Missing” đứng đầu tiên, đó chúng xuất hiện ở trên đầu các cộtIncidence object được tạo và vẽ biểu đồ như trước đóIncidence object được tạo và vẽ biểu đồ như trước đóChúng ta thêm các điều chỉnh ggplot2\nscale_fill_manual() để gán màu theo cách thủ công sao cho “Missing” là màu xám và “” là màu \nChúng ta thêm các điều chỉnh ggplot2scale_fill_manual() để gán màu theo cách thủ công sao cho “Missing” là màu xám và “” là màu beMẸO: Nếu bạn chỉ muốn đảo ngược thứ tự của chú giải, hãy thêm lệnh ggplot2 này guides(fill = guide_legend(reverse = TRUE)).","code":"\n# ORIGINAL - hospital NOT as factor\n###################################\n\n# create weekly incidence object, rows grouped by hospital and week\nhospital_outbreak <- incidence(\n  linelist,\n  date_index = date_onset, \n  interval = \"week\", \n  groups = hospital)\n\n# plot incidence object\nplot(hospital_outbreak, fill = hospital, title = \"ORIGINAL - hospital not a factor\")\n# MODIFIED - hospital as factor\n###############################\n\n# load forcats package for working with factors\npacman::p_load(forcats)\n\n# Convert hospital column to factor and adjust levels\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Set \"Missing\" and \"Other\" as top levels\n\n\n# Create weekly incidence object, grouped by hospital and week\nhospital_outbreak_mod <- incidence(\n  plot_data,\n  date_index = date_onset, \n  interval = \"week\", \n  groups = hospital)\n\n# plot incidence object\nplot(hospital_outbreak_mod, fill = hospital)+\n  \n  # manual specify colors\n  scale_fill_manual(values = c(\"grey\", \"beige\", \"darkgreen\", \"green2\", \"orange\", \"red\", \"pink\"))+                      \n\n  # labels added via ggplot\n  labs(\n      title = \"MODIFIED - hospital as factor\",   # plot title\n      subtitle = \"Other & Missing at top of epicurve\",\n      y = \"Weekly case incidence\",               # y axis title  \n      x = \"Week of symptom onset\",               # x axis title\n      fill = \"Hospital\")                         # title of legend     "},{"path":"epicurves.html","id":"đường-lưới-dọc","chapter":"32 Đường cong dịch bệnh","heading":"Đường lưới dọc","text":"Nếu bạn vẽ biểu đồ với các thiết lập mặc định của incidence2, bạn có thể nhận thấy rằng các đường lưới dọc xuất hiện ở từng nhãn ngày và giữa mỗi nhãn ngày. Điều này có thể dẫn đến các đường lưới giao nhau với đỉnh của một số cột.Bạn có thể xóa tất cả các đường lưới bằng cách thêm lệnh ggplot2 theme_classic().Tuy nhiên, lưu ý rằng nếu sử dụng tuần, các đối số date_breaks và date_minor_breaks chỉ hoạt động cho các tuần được quy định bắt đầu vào Thứ Hai. Nếu các tuần của bạn bắt đầu vào một ngày khác trong tuần, thay vào đó, bạn sẽ cần cung cấp vectơ ngày cho các đối số breaks = và minor_breaks = theo cách thủ công. Xem mục ggplot2 để biết các ví dụ về điều này bằng cách sử dụng hàm seq.Date().","code":"\n# make incidence object\na <- incidence(\n  central_data,\n  date_index = date_onset,\n  interval = \"Monday weeks\"\n)\n\n# Default gridlines\nplot(a, title = \"Default lines\")\n\n# Specified gridline intervals\n# NOT WORKING WITH INCIDENCE2 1.0.0\n# plot(a, title = \"Weekly lines\")+\n#   scale_x_date(\n#     date_breaks = \"4 weeks\",      # major vertical lines align on weeks\n#     date_minor_breaks = \"weeks\",  # minor vertical lines every week\n#     date_labels = \"%a\\n%d\\n%b\")   # format of date labels\n\n# No gridlines\nplot(a, title = \"No lines\")+\n  theme_classic()                 # remove all gridlines"},{"path":"epicurves.html","id":"số-mới-mắc-tích-lũy","chapter":"32 Đường cong dịch bệnh","heading":"Số mới mắc tích lũy","text":"Bạn có thể dễ dàng tạo ra một biểu đồ số mới mắc tích lũy bằng cách chuyển incidence object đến lệnh incidence2 cumulate() và sau đó đến lệnh plot(). Điều này cũng tương tự với lệnh facet_plot().Xem phần sau để biết phương pháp thay thế để vẽ biểu đồ số mới mắc tích lũy với ggplot2 - ví dụ: để chồng một đường số mới mắc tích lũy lên trên đường cong dịch bệnh.","code":"\n# make weekly incidence object\nwkly_inci <- incidence(\n  linelist,\n  date_index = date_onset,\n  interval = \"week\"\n)## 256 missing observations were removed.\n# plot cumulative incidence\nwkly_inci %>% \n  cumulate() %>% \n  plot()"},{"path":"epicurves.html","id":"trung-bình-động","chapter":"32 Đường cong dịch bệnh","heading":"Trung bình động","text":"Bạn có thể thêm đường trung bình động vào biểu đồ tạo bởi incidence2 một cách dễ dàng với hàm add_rolling_average() từ package i2extras. Chuyển đối tượng incidence2 của bạn tới hàm này, và sau đó vẽ bằng hàm plot(). Thiết lập = là số ngày trước đó bạn muốn đưa vào đường trung bình động (mặc định là 2). Nếu dữ liệu của bạn được nhóm lại, trung bình động sẽ được tính cho mỗi nhóm.Để tìm hiểu cách áp dụng đường trung bình động một cách tổng quát hơn trên dữ liệu, hãy xem chương Đường trung bình động.","code":"\nrolling_avg <- incidence(                    # make incidence object\n  linelist,\n  date_index = date_onset,\n  interval = \"week\",\n  groups = gender) %>% \n  \n  i2extras::add_rolling_average(before = 6)  # add rolling averages (in this case, by gender)\n\n# plot\nplot(rolling_avg, n.breaks = 3) # faceted automatically because rolling average on groups"},{"path":"epicurves.html","id":"đường-cong-dịch-bệnh-với-ggplot2","chapter":"32 Đường cong dịch bệnh","heading":"32.3 Đường cong dịch bệnh với ggplot2","text":"Sử dụng ggplot() để xây dựng đường cong dịch bệnh cho phép sự linh hoạt và tùy chỉnh nhiều hơn, nhưng đòi hỏi nhiều nỗ lực và hiểu biết hơn về sử dụng ggplot().Không giống như sử dụng package incidence2, bạn phải kiểm soát thủ công việc tổng hợp các trường hợp theo thời gian (theo tuần, tháng, v.v.) và khoảng thời gian của các nhãn trên trục ngày thág. Việc này phải được quản lý rất cẩn thận.Các ví dụ này sử dụng một tập con của bộ dữ liệu linelist - chỉ các trường hợp từ Central Hospital.Để tạo ra một đường cong dịch bệnh với ggplot(), có ba yếu tố chính:Một histogram, với các ca bệnh linelist được tổng hợp thành các “bins” được phân biệt bằng các điểm “ngắt” cụ thểCân chỉnh các trục và nhãnChủ đề của biểu đồ, bao gồm tiêu đề, nhãn, chú thích, v.v.","code":"\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")"},{"path":"epicurves.html","id":"xác-định-bins-của-số-liệu","chapter":"32 Đường cong dịch bệnh","heading":"Xác định bins của số liệu","text":"Ở đây chúng ta trình bày cách xác định các ca bệnh sẽ được tổng hợp thành các bins của một histogram (“cột”). Điều quan trọng cần nhận ra là việc tổng hợp số ca bệnh thành các bins của một histogram không nhất thiết phải có cùng khoảng với thời gian xuất hiện trên trục x.Dưới đây có lẽ là đoạn code đơn giản nhất để tạo ra các đường cong dịch bệnh hàng ngày và hàng tuần.Trong lệnh ggplot() tổng quát, bộ dữ liệu được đưa vào data =. Trên nền tảng này, dạng hình học của histogram được thêm bằng một dấu +. Trong geom_histogram(), chúng ta ánh xạ các yếu tố thẩm mỹ sao cho cột date_onset được ánh xạ tới trục x. Cũng trong hàm geom_histogram() nhưng không phải trong đối số aes(), chúng ta đặt binwidth = bằng số bins của histogram, tính bằng ngày. Nếu cú pháp ggplot2 này khó hiểu, hãy xem lại chương ggplot cơ bản.THẬN TRỌNG: Lập biểu đồ các trường hợp hàng tuần bằng cách sử dụng binwidth = 7 bắt đầu cột 7 ngày đầu tiên ở ca bệnh đầu tiên, mà có thể là bất kỳ ngày nào trong tuần! Để tạo các tuần cụ thể, hãy xem phần bên dưới.Chúng tôi xin lưu ý rằng ca bệnh đầu tiên trong bộ dữ liệu của Central Hospital có triệu chứng khởi phát vào ngày:Để chỉ định thủ công chia biểu đồ cột, không sử dụng argument binwidth = và thay vào đó cung cấp vectơ ngày để breaks =.Tạo vectơ ngày tháng với hàm seq.Date() trong base R. Hàm này sử dụng các đối số =, =, và =. Ví dụ: lệnh bên dưới trả về ngày mỗi tháng bắt đầu từ ngày 15 Tháng 1 và kết thúc trước ngày 28 Tháng 6.Vectơ này có được cung cấp cho hàm geom_histogram() dưới dạng breaks =:Một chuỗi ngày hàng tuần đơn giản có thể được trả về bằng cách đặt = \"week\". Ví dụ:Một giải pháp thay thế cho việc xác định ngày bắt đầu và ngày kết thúc cụ thể là viết code động để các cột hàng tuần bắt đầu vào thứ Hai trước ca đầu tiên. Chúng tôi sẽ sử dụng các vectơ ngày này trong suốt các ví dụ dưới đây.Hãy giải mã đoạn code khá “khoai” ở trên:Giá trị “” (ngày sớm nhất của chuỗi) được tạo như sau: giá trị ngày nhỏ nhất (min() với na.rm=TRUE) trong cột date_onset được đưa vào hàm floor_date() thuộc package lubridate. floor_date() được đặt thành “tuần” trả về ngày bắt đầu của “tuần” của trường hợp đó, với điều kiện là ngày bắt đầu của mỗi tuần là Thứ Hai (week_start = 1).Tương tự như vậy, giá trị “” (ngày kết thúc của chuỗi) được tạo bằng cách sử dụng hàm ngược lại ceiling_date() để trả về thứ hai sau ca cuối cùng.Đối số “” của seq.Date() có thể được đặt thành bất kỳ số ngày, tuần hoặc tháng nào.Sử dụng week_start = 7 cho tuần bắt đầu vào Chủ nhậtVì chúng ta sẽ sử dụng các vectơ ngày dạng này trong toàn bộ chương này, chúng ta cũng xác định một vectơ cho toàn bộ đợt bùng phát (ở trên chỉ dành cho Central Hospital).Các kết quả trả về của seq.Date() có thể được sử dụng để tạo các khoảng chia bins trong histogram, cũng như khoảng chia cho các nhãn ngày mà có thể độc lập với các bins. Đọc thêm về nhãn ngày trong các phần sau.MẸO: Đối với lệnh ggplot() đơn giản hơn, hãy lưu các khoảng chia bins và khoảng chia nhãn ngày dưới dạng các vectơ đã đặt tên trước và gán tên này vào đối số breaks =.","code":"\n# daily \nggplot(data = central_data) +          # set data\n  geom_histogram(                      # add histogram\n    mapping = aes(x = date_onset),     # map date column to x-axis\n    binwidth = 1)+                     # cases binned by 1 day \n  labs(title = \"Central Hospital - Daily\")                # title\n\n# weekly\nggplot(data = central_data) +          # set data \n  geom_histogram(                      # add histogram\n      mapping = aes(x = date_onset),   # map date column to x-axis\n      binwidth = 7)+                   # cases binned every 7 days, starting from first case (!) \n  labs(title = \"Central Hospital - 7-day bins, starting at first case\") # title\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")## [1] \"Thursday 01 May, 2014\"\nmonthly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # print##  [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\" \"2014-07-01\" \"2014-08-01\" \"2014-09-01\" \"2014-10-01\" \"2014-11-01\" \"2014-12-01\" \"2015-01-01\"\n## [13] \"2015-02-01\" \"2015-03-01\" \"2015-04-01\" \"2015-05-01\" \"2015-06-01\" \"2015-07-01\"\n# monthly \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # provide the pre-defined vector of breaks                    \n  labs(title = \"Monthly case bins\")   # title\nweekly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n# Sequence of weekly Monday dates for CENTRAL HOSPITAL\nweekly_breaks_central <- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")\n# Sequence for the entire outbreak\nweekly_breaks_all <- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")"},{"path":"epicurves.html","id":"ví-dụ-về-đường-cong-dịch-bệnh-theo-tuần","chapter":"32 Đường cong dịch bệnh","heading":"Ví dụ về đường cong dịch bệnh theo tuần","text":"Dưới đây là code ví dụ chi tiết để tạo đường cong dịch bệnh hàng tuần cho các tuần bắt đầu vào Thứ Hai, với các cột, nhãn ngày và đường lưới dọc đã được căn chỉnh. Phần này dành cho người dùng có nhu cầu code nhanh. Để hiểu sâu từng khía cạnh (chủ đề, nhãn ngày, v.v.), hãy tiếp tục xem các phần tiếp theo. Chú ý:Các đoạn chia bins của histogram được xác định bằng hàm seq.Date() như được giải thích ở trên để bắt đầu vào thứ Hai trước ca sớm nhất và kết thúc vào thứ Hai sau ca cuối cùngKhoảng nhãn ngày được xác định bởi date_breaks = bên trong scale_x_date()Khoảng đường lưới dọc nhỏ giữa các nhãn ngày được xác định bởi date_minor_breaks =expand = c(0,0) trong trục x và y loại bỏ không gian thừa trên mỗi cạnh của trục, điều này cũng đảm bảo các nhãn ngày bắt đầu từ cột đầu tiên.","code":"\n# TOTAL MONDAY WEEK ALIGNMENT\n#############################\n# Define sequence of weekly breaks\nweekly_breaks_central <- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Monday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Monday after last case\n      by   = \"week\")    # bins are 7-days \n\n\nggplot(data = central_data) + \n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    \n    # mapping aesthetics\n    mapping = aes(x = date_onset),  # date column mapped to x-axis\n    \n    # histogram bin breaks\n    breaks = weekly_breaks_central, # histogram bin breaks defined previously\n    \n    # bars\n    color = \"darkblue\",     # color of lines around bars\n    fill = \"lightblue\"      # color of fill within bars\n  )+ \n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),           # remove excess x-axis space before and after case bars\n    date_breaks       = \"4 weeks\",        # date labels and major vertical gridlines appear every 3 Monday weeks\n    date_minor_breaks = \"week\",           # minor vertical lines appear every Monday week\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+             # remove excess y-axis space below 0 (align histogram flush with x-axis)\n  \n  # aesthetic themes\n  theme_minimal()+                # simplify plot background\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # caption on left side\n                                face = \"italic\"), # caption in italics\n    axis.title = element_text(face = \"bold\"))+    # axis titles in bold\n  \n  # labels including dynamic caption\n  labs(\n    title    = \"Weekly incidence of cases (Monday weeks)\",\n    subtitle = \"Note alignment of bars, vertical gridlines, and axis labels on Monday weeks\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"epicurves.html","id":"tuần-bắt-đầu-bằng-chủ-nhật","chapter":"32 Đường cong dịch bệnh","heading":"Tuần bắt đầu bằng Chủ nhật","text":"Để vẽ được biểu đồ cho các tuần bắt đầu bằng Chủ nhật, cần có một số sửa đổi, vì date_breaks = \"weeks\" chỉ hoạt động cho các tuần bắt đầu bằng thứ Hai.Các điểm ngắt của các histogram bins phải được đặt thành Chủ nhật (week_start = 7)Trong scale_x_date(), các đoạn ngắt ngày tương tự nên được gắn với breaks = và minor_breaks = để đảm bảo các nhãn ngày và đường lưới dọc căn chỉnh vào ngày Chủ nhật.Ví dụ: lệnh scale_x_date() cho các tuần bắt đầu vào Chủ nhật có thể trông như sau:","code":"scale_x_date(\n    expand = c(0,0),\n    \n    # specify interval of date labels and major vertical gridlines\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"4 weeks\"),\n    \n    # specify interval of minor vertical gridline \n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"week\"),\n   \n    # date label format\n    date_labels = \"%a\\n%d %b\\n%Y\")+         # day, above month abbrev., above 2-digit year"},{"path":"epicurves.html","id":"nhómtô-màu-theo-giá-trị","chapter":"32 Đường cong dịch bệnh","heading":"Nhóm/tô màu theo giá trị","text":"Các cột histogram có thể được tô màu theo nhóm và “xếp chồng lên nhau”. Để chỉ định cột nhóm, hãy thực hiện các thay đổi sau. Xem chương ggplot cơ bản để biết thêm chi tiết.Bên trong đối số aes() của hàm vẽ histogram, ánh xạ tên cột tới đối số group = và fill =Loại bỏ bất kỳ tham số fill = nào bên ngoài đối số aes(), vì nó sẽ ghi đè giá trị bên trongĐối số bên trong aes() sẽ áp dụng theo nhóm, trong khi bất kỳ đối số bên ngoài nào đều sẽ áp dụng cho tất cả các cột (ví dụ: bạn có thể vẫn muốn tô màu color = bên ngoài, vì vậy mỗi cột có cùng một đường viền)Đây là lệnh aes() hiển thị nhóm và tô màu các cột theo giới tính:Đây là kết quả khi áp dụng:","code":"\naes(x = date_onset, group = gender, fill = gender)\nggplot(data = linelist) +     # begin with linelist (many hospitals)\n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # set data to be grouped by hospital\n      fill = hospital),       # bar fill (inside color) by hospital\n    \n    # bin breaks are Monday weeks\n    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       \n    \n    # Color around bars\n    color = \"black\")"},{"path":"epicurves.html","id":"hiệu-chỉnh-màu","chapter":"32 Đường cong dịch bệnh","heading":"Hiệu chỉnh màu","text":"Để thiết lập thủ công tô màu cho từng nhóm, hãy sử dụng scale_fill_manual() (lưu ý: scale_color_manual() là một cái khác!)\nSử dụng đối số values = để áp dụng một vectơ màu\nSử dụng na.value = để xác định màu cho giá trị NA\nSử dụng đối số labels = để thay đổi văn bản trong mục chú thích. Để cho toàn, sử dụng một vectơ được đặt tên kiểu như c(\"old\" = \"new\", \"old\" = \"new\") hoặc điều chỉnh giá trị trong bộ dữ liệu\nSử dụng name = để đặt một tiêu đề thích hợp cho mục chú thích\nĐể thiết lập thủ công tô màu cho từng nhóm, hãy sử dụng scale_fill_manual() (lưu ý: scale_color_manual() là một cái khác!)Sử dụng đối số values = để áp dụng một vectơ màuSử dụng na.value = để xác định màu cho giá trị NASử dụng đối số labels = để thay đổi văn bản trong mục chú thích. Để cho toàn, sử dụng một vectơ được đặt tên kiểu như c(\"old\" = \"new\", \"old\" = \"new\") hoặc điều chỉnh giá trị trong bộ dữ liệuSử dụng name = để đặt một tiêu đề thích hợp cho mục chú thíchĐể biết thêm mẹo về thang màu và bảng màu, hãy xem chương ggplot cơ bản.Để biết thêm mẹo về thang màu và bảng màu, hãy xem chương ggplot cơ bản.","code":"\nggplot(data = linelist)+           # begin with linelist (many hospitals)\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # cases grouped by hospital\n        fill = hospital),          # bar fill by hospital\n    \n    # bin breaks\n    breaks = weekly_breaks_all,        # sequence of weekly Monday bin breaks, defined in previous code\n    \n    # Color around bars\n    color = \"black\")+              # border color of each bar\n  \n  # manual specification of colors\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # specify fill colors (\"values\") - attention to order!"},{"path":"epicurves.html","id":"hiệu-chỉnh-thứ-bậc","chapter":"32 Đường cong dịch bệnh","heading":"Hiệu chỉnh thứ bậc","text":"Thứ tự mà các cột được nhóm xếp chồng lên nhau được điều chỉnh tốt nhất bằng cách phân loại cột nhóm dưới dạng Factor. Sau đó, bạn có thể chỉ định thứ tự cấp độ phân loại (và nhãn hiển thị của chúng). Xem chương về Factors hoặc Các tips với ggplot để biết thêm chi tiết.Trước khi tạo biểu đồ, hãy sử dụng hàm fct_relevel() từ package forcats để chuyển đổi cột phân nhóm thành kiểu Factor và điều chỉnh thứ tự cấp độ theo cách thủ công, như được trình bày chi tiết trong chương về Factors.Trong biểu đồ dưới đây, điểm khác biệt duy nhất với trước đó là cột hospital đã được hợp nhất như trên và chúng ta sử dụng các guides() để đảo ngược thứ tự chú thích, đó “nhãn Missing” nằm ở cuối chú thích.MẸO: Để chỉ đảo ngược thứ tự của chú thích, hãy thêm lệnh ggplot2 này: guides(fill = guide_legend(reverse = TRUE)).","code":"\n# load forcats package for working with factors\npacman::p_load(forcats)\n\n# Define new dataset with hospital as factor\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Convert to factor and set \"Missing\" and \"Other\" as top levels to appear on epicurve top\n\nlevels(plot_data$hospital) # print levels in order## [1] \"Missing\"                              \"Other\"                                \"Central Hospital\"                     \"Military Hospital\"                   \n## [5] \"Port Hospital\"                        \"St. Mark's Maternity Hospital (SMMH)\"\nggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # cases grouped by hospital\n        fill = hospital),               # bar fill (color) by hospital\n    \n    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section\n    \n    color = \"black\")+                   # border color around each bar\n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space before and after case bars\n    date_breaks       = \"3 weeks\",      # labels appear every 3 Monday weeks\n    date_minor_breaks = \"week\",         # vertical lines appear every Monday week\n    date_labels       = \"%d\\n%b\\n'%y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+                   # remove excess y-axis space below 0\n  \n  # manual specification of colors, ! attention to order\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # aesthetic themes\n  theme_minimal()+                      # simplify plot background\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # caption on left side in italics\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # axis titles in bold\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases by hospital\",\n    subtitle = \"Hospital as re-ordered factor\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly cases\")"},{"path":"epicurves.html","id":"hiệu-chỉnh-chú-thích","chapter":"32 Đường cong dịch bệnh","heading":"Hiệu chỉnh chú thích","text":"Đọc thêm về chú thích và scale trong chương Các tips với ggplot. Dưới đây là một vài điểm nổi bật:Chỉnh sửa tiêu đề chú thích trong hàm scale hoặc với labs(fill = \"Legend title\") (nếu bạn đang sử dụng color =, thì hãy sử dụng labs(color = \"\"))Chỉnh sửa tiêu đề chú thích trong hàm scale hoặc với labs(fill = \"Legend title\") (nếu bạn đang sử dụng color =, thì hãy sử dụng labs(color = \"\"))theme(legend.title = element_blank()) để bỏ trống tiêu đề chú thíchtheme(legend.title = element_blank()) để bỏ trống tiêu đề chú thíchtheme(legend.position = \"top\") (“bottom”, “left”, “right”, hoặc “none” để bỏ chú thích)theme(legend.position = \"top\") (“bottom”, “left”, “right”, hoặc “none” để bỏ chú thích)theme(legend.direction = \"horizontal\") xoay ngang chú thíchtheme(legend.direction = \"horizontal\") xoay ngang chú thíchguides(fill = guide_legend(reverse = TRUE)) để đảo ngược thứ tự các mục chú thíchguides(fill = guide_legend(reverse = TRUE)) để đảo ngược thứ tự các mục chú thích","code":""},{"path":"epicurves.html","id":"cột-kề-cột","chapter":"32 Đường cong dịch bệnh","heading":"Cột kề cột","text":"Hiển thị song song các cột nhóm (trái ngược với xếp chồng lên nhau) được chỉ định trong geom_histogram() với position = \"dodge\" được đặt bên ngoài aes().Nếu có nhiều hơn hai nhóm giá trị, nó có thể gây khó đọc. Thay vào đó, hãy cân nhắc sử dụng một biểu đồ được chia nhỏ (gồm nhiều biểu đồ nhỏ). Để dễ xem trong ví dụ này, các giá trị giới tính bị thiếu sẽ bị xóa.","code":"\nggplot(central_data %>% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # cases grouped by gender\n          fill = gender),         # bars filled by gender\n        \n        # histogram bin breaks\n        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section\n        \n        color = \"black\",          # bar edge color\n        \n        position = \"dodge\")+      # SIDE-BY-SIDE bars\n                      \n  \n  # The labels on the x-axis\n  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars\n               date_breaks       = \"3 weeks\",      # labels appear every 3 Monday weeks\n               date_minor_breaks = \"week\",         # vertical lines appear every Monday week\n               date_labels       = \"%d\\n%b\\n'%y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels\n  \n  #scale of colors and legend labels\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # specify fill colors (\"values\") - attention to order!\n                    na.value = \"grey\" )+     \n\n  # aesthetic themes\n  theme_minimal()+                                               # a set of themes to simplify plot\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n        axis.title = element_text(face = \"bold\"))+               # axis titles in bold\n  \n  # labels\n  labs(title    = \"Weekly incidence of cases, by gender\",\n       subtitle = \"Subtitle\",\n       fill     = \"Gender\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\")"},{"path":"epicurves.html","id":"giới-hạn-trục","chapter":"32 Đường cong dịch bệnh","heading":"Giới hạn trục","text":"Có hai cách để giới hạn phạm vi các giá trị trên trục.Nói chung, cách khuyến khích sử dụng là lệnh coord_cartesian(), chấp nhận xlim = c(min, max) và ylim = c(min, max) (trong đó bạn cung cấp giá trị nhỏ nhất và lớn nhất). Cách này hoạt động như một “thu phóng kích thước” mà không thực sự loại bỏ bất kỳ dữ liệu nào, điều này rất quan trọng đối với các số liệu thống kê và các thang đo tổng hợp.Ngoài ra, bạn có thể thiết lập giá trị ngày tối đa và tối thiểu bằng cách sử dụng limits = c() bên trong hàm scale_x_date(). Ví dụ:Tương tự như vậy, nếu bạn muốn trục x kéo dài đến một ngày cụ thể (ví dụ: ngày hiện tại), ngay cả khi không có trường hợp mới nào được báo cáo, bạn có thể sử dụng:LƯU Ý: Hãy thận trọng khi đặt giới hạn hoặc chia tỷ lệ trục y (ví dụ: 0 đến 30 với khoảng là 5: seq(0, 30, 5)). Những con số tĩnh như vậy có thể cắt bớt biểu đồ quá ngắn nếu dữ liệu thay đổi vượt quá giới hạn!.","code":"\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # sets a minimum date but leaves the maximum open.  scale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  "},{"path":"epicurves.html","id":"nhãnđường-lưới-của-trục-ngày","chapter":"32 Đường cong dịch bệnh","heading":"Nhãn/đường lưới của trục ngày","text":"MẸO: Hãy nhớ rằng các nhãn trục ngày độc lập với việc tổng hợp dữ liệu thành các cột, nhưng về mặt trực quan, điều quan trọng là phải căn chỉnh các cột, nhãn ngày và các đường lưới dọc.Để sửa đổi nhãn ngày và đường lưới, hãy sử dụng scale_x_date() theo một trong những cách sau:Nếu histogram bins là ngày, tuần bắt đầu vào thứ hai, tháng hoặc năm:\nSử dụng date_breaks = để xác định khoảng thời gian của các nhãn và đường lưới chính (ví dụ: “day”, “week”, “3 weeks”, “month” hoặc “year”)\nSử dụng date_minor_breaks = để xác định khoảng của các đường lưới dọc nhỏ (giữa các nhãn ngày)\nThêm expand = c(0,0) để bắt đầu các nhãn ở cột đầu tiên\nSử dụng date_labels = để xác định định dạng của nhãn ngày - hãy xem chương Ngày để biết các mẹo (sử dụng \\n cho một dòng mới)\nNếu histogram bins là ngày, tuần bắt đầu vào thứ hai, tháng hoặc năm:Sử dụng date_breaks = để xác định khoảng thời gian của các nhãn và đường lưới chính (ví dụ: “day”, “week”, “3 weeks”, “month” hoặc “year”)Sử dụng date_minor_breaks = để xác định khoảng của các đường lưới dọc nhỏ (giữa các nhãn ngày)Thêm expand = c(0,0) để bắt đầu các nhãn ở cột đầu tiênSử dụng date_labels = để xác định định dạng của nhãn ngày - hãy xem chương Ngày để biết các mẹo (sử dụng \\n cho một dòng mới)Nếu histogram bins là các tuần bắt đầu vào Chủ nhật:\nSử dụng breaks = và minor_breaks = bằng cách cung cấp một chuỗi ngày cho mỗi khoảng chia\nVẫn có thể sử dụng date_labels = và expand = để định dạng như mô tả ở trên\nNếu histogram bins là các tuần bắt đầu vào Chủ nhật:Sử dụng breaks = và minor_breaks = bằng cách cung cấp một chuỗi ngày cho mỗi khoảng chiaVẫn có thể sử dụng date_labels = và expand = để định dạng như mô tả ở trênMột số ghi chú:Xem phần mở đầu của mục ggplot về hướng dẫn cách tạo chuỗi ngày bằng seq.Date().Xem trang này hoặc chương Làm việc với ngày tháng để biết thêm mẹo tạo nhãn ngày.","code":""},{"path":"epicurves.html","id":"minh-họa","chapter":"32 Đường cong dịch bệnh","heading":"Minh họa","text":"Dưới đây là minh họa biểu đồ trong đó các cột và nhãn biểu đồ/đường lưới được căn chỉnh thẳng hàng và không thẳng hàng:","code":"\n# 7-day bins + Monday labels\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # 7-day bins with start at first case\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),               # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",       # Monday every 3 weeks\n    date_minor_breaks = \"week\",    # Monday weeks\n    date_labels = \"%a\\n%d\\n%b\\n'%y\")+  # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # remove excess space under x-axis, make flush\n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays at first case\\nDate labels and gridlines on Mondays\\nNote how ticks don't align with bars\")\n\n\n\n# 7-day bins + Months\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                  # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",           # 1st of month\n    date_minor_breaks = \"week\",       # Monday weeks\n    date_labels = \"%a\\n%d %b\\n%Y\")+    # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays with first case\\nMajor gridlines and date labels at 1st of each month\\nMinor gridlines weekly on Mondays\\nNote uneven spacing of some gridlines and ticks unaligned with bars\")\n\n\n# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,    # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"4 weeks\",           # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    date_labels = \"%a\\n%d %b\\n%Y\")+      # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"ALIGNED Mondays\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels and gridlines on Mondays as well\")\n\n\n# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,            # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",            # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    date_labels = \"%b\\n%Y\")+          # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)\n          \n  labs(\n    title = \"ALIGNED Mondays with MONTHLY labels\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels on 1st of Month\\nMonthly major gridlines removed\")\n\n\n# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # minor gridlines set to weekly beginning Sunday before first case\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    date_labels = \"%a\\n%d\\n%b\\n'%y\")+  # label format\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(title = \"ALIGNED Sundays\",\n       subtitle = \"7-day bins manually set to begin Sunday before first case (27 Apr)\\nDate labels and gridlines manually set to Sundays as well\")"},{"path":"epicurves.html","id":"dữ-liệu-tổng-hợp","chapter":"32 Đường cong dịch bệnh","heading":"Dữ liệu tổng hợp","text":"Thông thường, thay vì bắt đầu với bộ số liệu linelist, bạn có thể bắt đầu với số lượng tổng hợp từ các cơ sở y tế, quận, huyện, v.v. Bạn có thể tạo đường cong dịch bệnh với ggplot() nhưng code sẽ hơi khác một chút. Phần này sẽ tận dụng bộ dữ liệu count_data đã được nạp trước đó trong mục chuẩn bị dữ liệu. Bộ dữ liệu này là linelist được tổng hợp thành số lượng bệnh viện theo ngày. 50 hàng đầu tiên được hiển thị dưới đây.","code":""},{"path":"epicurves.html","id":"vẽ-biểu-đồ-dữ-liệu-đếm-hàng-ngày","chapter":"32 Đường cong dịch bệnh","heading":"Vẽ biểu đồ dữ liệu đếm hàng ngày","text":"Chúng ta có thể vẽ biểu đồ đường cong dịch bệnh từ dữ liệu đếm hàng ngày. Dưới đây là sự khác biệt trong đoạn code:Khi ánh xạ các yếu tố trong hàm aes(), hãy cụ thể y = bằng một cột đếm (trong trường hợp này, tên cột là n_cases)Khi ánh xạ các yếu tố trong hàm aes(), hãy cụ thể y = bằng một cột đếm (trong trường hợp này, tên cột là n_cases)Thêm đối số stat = \"identity\" trong geom_histogram(), giúp xác định rằng chiều cao cột phải là giá trị y =, không phải số hàng như mặc địnhThêm đối số stat = \"identity\" trong geom_histogram(), giúp xác định rằng chiều cao cột phải là giá trị y =, không phải số hàng như mặc địnhThêm đối số width = để tránh các đường trắng dọc giữa các cột. Đối với dữ liệu hàng ngày được đặt thành 1. Đối với dữ liệu đếm hàng tuần được đặt thành 7. Đối với dữ liệu đếm hàng tháng, các đường màu trắng là một vấn đề (mỗi tháng có số ngày khác nhau) - hãy xem xét chuyển đổi trục x của bạn thành cột phân loại (factor) theo thứ tự (tháng) và sử dụng geom_col().Thêm đối số width = để tránh các đường trắng dọc giữa các cột. Đối với dữ liệu hàng ngày được đặt thành 1. Đối với dữ liệu đếm hàng tuần được đặt thành 7. Đối với dữ liệu đếm hàng tháng, các đường màu trắng là một vấn đề (mỗi tháng có số ngày khác nhau) - hãy xem xét chuyển đổi trục x của bạn thành cột phân loại (factor) theo thứ tự (tháng) và sử dụng geom_col().","code":"\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars\n  labs(\n    x = \"Date of report\", \n    y = \"Number of cases\",\n    title = \"Daily case incidence, from daily count data\")"},{"path":"epicurves.html","id":"vẽ-biểu-đồ-dữ-liệu-đếm-hàng-tuần","chapter":"32 Đường cong dịch bệnh","heading":"Vẽ biểu đồ dữ liệu đếm hàng tuần","text":"Nếu dữ liệu của bạn đã là số lượng ca bệnh đếm theo tuần, chúng có thể trông giống như bộ dữ liệu này (được gọi là count_data_weekly):50 hàng đầu tiên của count_data_weekly được hiển thị bên dưới. Bạn có thể thấy rằng số lượng đếm đã được tổng hợp thành các tuần. Mỗi tuần được hiển thị theo ngày đầu tiên của tuần (mặc định là Thứ Hai).Bây giờ vẽ biểu đồ sao cho x = cột epiweek. Hãy nhớ thêm y = cột đếm khi ánh xạ trục và thêm stat = \"identity\" như đã giải thích ở trên.","code":"\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # x-axis is epiweek (as class Date)\n      y = n_cases_weekly,    # y-axis height in the weekly case counts\n      group = hospital,      # we are grouping the bars and coloring by hospital\n      fill = hospital),\n    stat = \"identity\")+      # this is also required when plotting count data\n     \n  # labels for x-axis\n  scale_x_date(\n    date_breaks = \"2 months\",      # labels every 2 months \n    date_minor_breaks = \"1 month\", # gridlines every month\n    date_labels = '%b\\n%Y')+       #labeled by month with year below\n     \n  # Choose color palette (uses RColorBrewer package)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Week of onset\", \n    y = \"Weekly case incidence\",\n    fill = \"Hospital\",\n    title = \"Weekly case incidence, from aggregated count data by hospital\")"},{"path":"epicurves.html","id":"đường-trung-bình-động","chapter":"32 Đường cong dịch bệnh","heading":"Đường trung bình động","text":"Xem chương về Đường trung bình động để có mô tả chi tiết và một số tùy chọn. Dưới đây là một tùy chọn để tính toán đường trung bình động với package slider. Theo cách tiếp cận này, trung bình động được tính toán trong bộ dữ liệu trước khi vẽ biểu đồ:Tổng hợp dữ liệu thành số lượng nếu cần thiết (hàng ngày, hàng tuần, v.v.) (xem chương Nhóm dữ liệu)Tạo một cột mới để giữ đường trung bình động, được tạo bằng hàm slide_index() từ package sliderVẽ đường trung bình động dưới dạng một geom_line() ở trên đỉnh (phía sau) histogram đường cong dịch bệnhTham khảo thêm tại vignette của package slider","code":"\n# load package\npacman::p_load(slider)  # slider used to calculate rolling averages\n\n# make dataset of daily counts and 7-day moving average\n#######################################################\nll_counts_7day <- linelist %>%    # begin with linelist\n  \n  ## count cases by date\n  count(date_onset, name = \"new_cases\") %>%   # name new column with counts as \"new_cases\"\n  drop_na(date_onset) %>%                     # remove cases with missing date_onset\n  \n  ## calculate the average number of cases in 7-day window\n  mutate(\n    avg_7day = slider::slide_index(    # create new column\n      new_cases,                       # calculate based on value in new_cases column\n      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window \n      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed\n      .before = 6,                     # window is the day and 6-days before\n      .complete = FALSE),              # must be FALSE for unlist() to work in next step\n    avg_7day = unlist(avg_7day))       # convert class list to class numeric\n\n\n# plot\n######\nggplot(data = ll_counts_7day) +  # begin with new dataset defined above \n    geom_histogram(              # create epicurve histogram\n      mapping = aes(\n        x = date_onset,          # date column as x-axis\n        y = new_cases),          # height is number of daily new cases\n        stat = \"identity\",       # height is y value\n        fill=\"#92a8d1\",          # cool color for bars\n        colour = \"#92a8d1\",      # same color for bar border\n        )+ \n    geom_line(                   # make line for rolling average\n      mapping = aes(\n        x = date_onset,          # date column for x-axis\n        y = avg_7day,            # y-value set to rolling average column\n        lty = \"7-day \\nrolling avg\"), # name of line in legend\n      color=\"red\",               # color of line\n      size = 1) +                # width of line\n    scale_x_date(                # date scale\n      date_breaks = \"1 month\",\n      date_labels = '%d/%m',\n      expand = c(0,0)) +\n    scale_y_continuous(          # y-axis scale\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Number of confirmed cases\",\n      fill = \"Legend\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # removes title of legend"},{"path":"epicurves.html","id":"facetingchia-nhỏ-biểu-đồ","chapter":"32 Đường cong dịch bệnh","heading":"Faceting/chia nhỏ biểu đồ","text":"Như với các ggplots khác, bạn có thể tạo các biểu đồ được chia nhỏ (“nhiều biểu đồ con”). Như đã giải thích trong chương Các tips với ggplot trong cuốn sách này, bạn có thể sử dụng facet_wrap() hoặc facet_grid(). Ở đây chúng tôi sẽ minh họa bằng hàm facet_wrap(). Đối với đường cong dịch bệnh, sử dụng facet_wrap() thường dễ dàng hơn vì khả năng bạn thường chỉ cần chia nhỏ biểu đồ theo một biến.Cú pháp chung là facet_wrap(rows ~ cols), trong đó bên trái dấu ngã (~) là tên của biến sẽ được trải trên các “hàng” của biểu đồ chia nhỏ và ở bên phải dấu ngã là tên của biến sẽ được trải trên các “cột” của biểu đồ chia nhỏ. Đơn giản nhất, chỉ cần sử dụng một tên cột, ở bên phải dấu ngã: facet_wrap(~age_cat).Trục tự \nBạn sẽ cần phải quyết định xem tỷ lệ của các trục cho mỗi biểu đồ nhỏ là “cố định” với cùng một kích thước (mặc định) hay “tự ” (nghĩa là chúng sẽ thay đổi dựa trên dữ liệu của chúng). Thực hiện điều này với đối số scales = trong hàm facet_wrap() bằng cách chỉ định “free_x” hoặc “free_y” hoặc “free”.Số cột và hàng của các biểu đồ con\nĐiều này có thể xác định với ncol = và nrow = trong hàm facet_wrap().Thứ tự các biểu đồ con\nĐể thay đổi thứ tự xuất hiện, hãy thay đổi thứ tự cơ bản của các cấp của cột phân loại được sử dụng để tạo các biểu đồ con.Đinh dạng trục\nKích thước phông chữ và mặt biểu đồ, dải màu, v.v. có thể được sửa đổi thông qua theme() với các đối số như:strip.text = element_text() (kích thước, màu sắc, mặt, góc …)strip.text = element_text() (kích thước, màu sắc, mặt, góc …)strip.background = element_rect() (ví dụ: element_rect(fill = \"grey\"))strip.background = element_rect() (ví dụ: element_rect(fill = \"grey\"))strip.position = (vị trị “dưới”, “trên”, “trái”, hoặc “phải”)strip.position = (vị trị “dưới”, “trên”, “trái”, hoặc “phải”)Dải nhãn\nNhãn của các biểu đồ con có thể được sửa đổi thông qua “nhãn” của cột như một factor hoặc bằng cách sử dụng một “người dán nhãn - labeller”.Để tạo một labeller như thế, sử dụng hàm as_labeller() từ ggplot2. Sau đó, cung cấp labeller cho đối số labeller = của facet_wrap() như dưới đây.Một ví dụ về chia nhỏ biểu đồ - chia bằng cột age_cat.Xem link để biết thêm thông tin về labellers.","code":"\nmy_labels <- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n# make plot\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # arguments inside aes() apply by group\n      \n    color = \"black\",      # arguments outside aes() apply to all data\n        \n    # histogram breaks\n    breaks = weekly_breaks_central)+  # pre-defined date vector (see earlier in this page)\n                      \n  # The labels on the x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    date_labels       = \"%b\\n'%y\")+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"epicurves.html","id":"tổng-vụ-dịch-trong-nền-của-biểu-đồ-con","chapter":"32 Đường cong dịch bệnh","heading":"Tổng vụ dịch trong nền của biểu đồ con","text":"Để hiển thị tổng vụ dịch trong nền của mỗi biểu đồ con, hãy thêm hàm gghighlight() với dấu ngoặc đơn trống vào ggplot. Hàm này thuộc package gghighlight. Lưu ý rằng trục y tối đa trong tất cả các biểu đồ con hiện dựa vào đỉnh của toàn bộ vụ dịch. Có nhiều ví dụ hơn về package này trong chương Các tips với ggplot.","code":"\nggplot(central_data) + \n  \n  # epicurves by group\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # arguments inside aes() apply by group\n    \n    color = \"black\",    # arguments outside aes() apply to all data\n    \n    # histogram breaks\n    breaks = weekly_breaks_central)+     # pre-defined date vector (see top of ggplot section)                \n  \n  # add grey epidemic in background to each facet\n  gghighlight::gghighlight()+\n  \n  # labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    date_labels       = \"%b\\n'%y\")+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,                          # each plot is one value of age_cat\n    ncol = 4,                          # number of columns\n    strip.position = \"top\",            # position of the facet title/strip\n    labeller = my_labels)+             # labeller defines above\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"epicurves.html","id":"dữ-liệu-một-biểu-đồ-con","chapter":"32 Đường cong dịch bệnh","heading":"Dữ liệu một biểu đồ con","text":"Nếu bạn muốn có một hộp biểu đồ con chứa tất cả dữ liệu, hãy sao chép toàn bộ dữ liệu và coi các bản sao như một giá trị cho các biểu đồ con. Hàm “trợ giúp” CreateAllFacet() bên dưới có thể hỗ trợ việc này (nhờ bài đăng trên blog này). Khi nó được chạy, số hàng tăng gấp đôi và sẽ có một cột mới được gọi là facet, trong đó các hàng được sao chép sẽ có giá trị “tất cả” và các hàng ban đầu có giá trị ban đầu của cột phân chia. Bây giờ bạn chỉ cần phân chia cột facet .Dưới đây là hàm trợ giúp. Chạy code này và nó sẽ luôn sẵn sàng để bạn sử dụng.Bây giờ hãy áp dụng hàm trợ giúp cho bộ dữ liệu, trên cột age_cat:Những thay đổi đáng chú ý đối với lệnh ggplot() là:Dữ liệu được sử dụng bây giờ là central_data2 (nhân đôi các hàng, với cột mới là “facet”)Dữ liệu được sử dụng bây giờ là central_data2 (nhân đôi các hàng, với cột mới là “facet”)Labeller sẽ cần được cập nhật, nếu được sử dụngLabeller sẽ cần được cập nhật, nếu được sử dụngTùy chọn: để có các biểu đồ con xếp chồng lên nhau theo chiều dọc: cột chia được chuyển sang các hàng bên cạnh của phương trình và ở bên phải được thay thế bằng “.” (facet_wrap(facet~.)), và ncol = 1. Bạn cũng có thể cần điều chỉnh chiều rộng và chiều cao của ảnh biểu đồ đã lưu dưới dạng png (xem ggsave() trong chương Các tips với ggplot).Tùy chọn: để có các biểu đồ con xếp chồng lên nhau theo chiều dọc: cột chia được chuyển sang các hàng bên cạnh của phương trình và ở bên phải được thay thế bằng “.” (facet_wrap(facet~.)), và ncol = 1. Bạn cũng có thể cần điều chỉnh chiều rộng và chiều cao của ảnh biểu đồ đã lưu dưới dạng png (xem ggsave() trong chương Các tips với ggplot).","code":"\n# Define helper function\nCreateAllFacet <- function(df, col){\n     df$facet <- df[[col]]\n     temp <- df\n     temp$facet <- \"all\"\n     merged <-rbind(temp, df)\n     \n     # ensure the facet value is a factor\n     merged[[col]] <- as.factor(merged[[col]])\n     \n     return(merged)\n}\n# Create dataset that is duplicated and with new column \"facet\" to show \"all\" age categories as another facet level\ncentral_data2 <- CreateAllFacet(central_data, col = \"age_cat\") %>%\n  \n  # set factor levels\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))## Warning: Unknown levels in `f`: 70+\n# check levels\ntable(central_data2$facet, useNA = \"always\")## \n##   all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  <NA> \n##   454    84    84    82    58    73    57     7     9\nggplot(central_data2) + \n  \n  # actual epicurves by group\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # arguments inside aes() apply by group\n        color = \"black\",    # arguments outside aes() apply to all data\n        \n        # histogram breaks\n        breaks = weekly_breaks_central)+    # pre-defined date vector (see top of ggplot section)\n                     \n  # Labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    date_labels       = \"%b\\n'%y\")+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # create facets\n  facet_wrap(facet~. ,                            # each plot is one value of facet\n             ncol = 1)+            \n\n  # labels\n  labs(title    = \"Weekly incidence of cases, by age category\",\n       subtitle = \"Subtitle\",\n       fill     = \"Age category\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))"},{"path":"epicurves.html","id":"dữ-liệu-dự-kiến","chapter":"32 Đường cong dịch bệnh","heading":"32.4 Dữ liệu dự kiến","text":"Dữ liệu gần đây nhất được biểu thị trong đường cong dịch tễ nên được đánh dấu là dự kiến hoặc có thể báo cáo chậm trễ. Điều này có thể được thực hiện bằng cách thêm một đường thẳng đứng và/hoặc hình chữ nhật trong một số ngày cụ thể. Đây là hai tùy chọn:Sử dụng annotate():\nĐể sử dụng dạng đường annotate(geom = \"segment\"). Cung cấp x, xend, y, và yend. Hiệu chỉnh kích thước, kiểu dòng (lty), và màu.\nĐể sử dụng dạng hình chữ nhật annotate(geom = \"rect\"). Cung cấp xmin/xmax/ymin/ymax. Hiệu chỉnh màu và hệ số alpha.\nSử dụng annotate():Để sử dụng dạng đường annotate(geom = \"segment\"). Cung cấp x, xend, y, và yend. Hiệu chỉnh kích thước, kiểu dòng (lty), và màu.Để sử dụng dạng hình chữ nhật annotate(geom = \"rect\"). Cung cấp xmin/xmax/ymin/ymax. Hiệu chỉnh màu và hệ số alpha.Nhóm dữ liệu theo trạng thái tạm thời và tô màu các cột đó theo cách khác nhauNhóm dữ liệu theo trạng thái tạm thời và tô màu các cột đó theo cách khác nhauTHẬN TRỌNG: Bạn có thể thử hàm geom_rect() để vẽ hình chữ nhật, nhưng việc điều chỉnh độ trong suốt không khả thi trong bối cảnh cảnh bộ số liệu linelist. Hàm này sẽ phủ lên một hình chữ nhật cho mỗi hàng/quan sát!. Sử dụng hệ số alpha rất thấp (ví dụ: 0.01) hoặc một cách tiếp cận khác.","code":""},{"path":"epicurves.html","id":"sử-dụng-annotate","chapter":"32 Đường cong dịch bệnh","heading":"Sử dụng annotate()","text":"Trong annotate(geom = \"rect\"), đối số xmin và xmax cần được định dạng phân lớp ngàyLưu ý rằng vì những dữ liệu này được tổng hợp thành các cột hàng tuần và cột cuối cùng kéo dài đến Thứ Hai sau điểm dữ liệu cuối cùng, vùng được tô bóng có thể bao gồm 4 tuầnĐây là một ví dụ trực tuyến về annotate()Đường thẳng đứng màu đen có thể tạo ra với code bên dưới, nhưng sử dụng geom_vline(), bạn sẽ mất khả năng kiểm soát chiều cao:","code":"\nggplot(central_data) + \n  \n  # histogram\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"1 month\",           # 1st of month\n    date_minor_breaks = \"1 month\",     # 1st of month\n    date_labels = \"%b\\n'%y\")+          # label format\n  \n  # labels and theme\n  labs(\n    title = \"Using annotate()\\nRectangle and line showing that data from last 21-days are tentative\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()+\n  \n  # add semi-transparent red rectangle to tentative data\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()\n    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()\n    fill  = \"red\")+\n  \n  # add black vertical line on top of other layers\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # line begins at y = 0\n    yend  = Inf,       # line to top of plot\n    size  = 2,         # line size\n    color = \"black\",\n    lty   = \"solid\")+   # linetype e.g. \"solid\", \"dashed\"\n\n  # add text in rectangle\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Subject to reporting delays\",\n    angle = 90)\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")"},{"path":"epicurves.html","id":"màu-cột","chapter":"32 Đường cong dịch bệnh","heading":"Màu cột","text":"Một cách tiếp cận thay thế có thể là điều chỉnh màu sắc hoặc cách hiển thị của chính các cột dữ liệu dự kiến. Bạn có thể tạo một cột mới trong giai đoạn chuẩn bị dữ liệu và sử dụng cột đó để nhóm dữ liệu, sao cho aes(fill = ) của dữ liệu tạm thời có thể có màu hoặc hệ số alpha khác với các cột khác.","code":"\n# add column\n############\nplot_data <- central_data %>% \n  mutate(tentative = case_when(\n    date_onset >= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # tenative if in last 7 days\n    TRUE                                       ~ \"Reliable\")) # all else reliable\n\n# plot\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histogram\n  geom_histogram(\n    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page\n    color = \"black\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",           # Monday every 3 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    date_labels = \"%d\\n%b\\n'%y\")+      # label format\n  \n  # labels and theme\n  labs(title = \"Show days that are tentative reporting\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # remove title of legend"},{"path":"epicurves.html","id":"nhãn-ngày-nhiều-cấp-độ","chapter":"32 Đường cong dịch bệnh","heading":"32.5 Nhãn ngày nhiều cấp độ","text":"Nếu bạn muốn phân nhiều cấp nhãn ngày (ví dụ: tháng và năm) mà không sao chép các cấp nhãn cấp độ thấp hơn, hãy xem xét một trong các cách tiếp cận bên dưới:Hãy nhớ rằng - bạn có thể sử dụng các công cụ như \\n trong các đối số date_labels hoặc labels để đặt các phần của mỗi nhãn trên một dòng mới bên dưới. Tuy nhiên, đoạn code dưới đây giúp bạn thực hiện nhiều năm hoặc tháng (ví dụ) ở dòng thấp hơn và chỉ một lần. Một số lưu ý về code bên dưới:Số lượng ca bệnh được tổng hợp thành các tuần vì lý thẩm mỹ. Xem chương Đường cong dịch bệnh (tab dữ liệu tổng hợp) để biết chi tiết.Một miền geom_area() được sử dụng thay vì một histogram, vì phương pháp tiếp cận chia biểu đồ dưới đây không hoạt động tốt với histogram.Tổng hợp dữ đếm hàng tuầnVẽ biểu đồCác kỹ thuật trên được điều chỉnh từ đây và bài đăng này trên stackoverflow.com.","code":"\n# Create dataset of case counts by week\n#######################################\ncentral_weekly <- linelist %>%\n  filter(hospital == \"Central Hospital\") %>%   # filter linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %>%  \n  count(week) %>%                              # summarize weekly case counts\n  drop_na(week) %>%                            # remove cases with missing onset_date\n  complete(                                    # fill-in all weeks with no cases reported\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # convert new NA values to 0 counts\n# plot with box border on year\n##############################\nggplot(central_weekly) +\n  geom_area(aes(x = week, y = n),    # make line, specify x and y\n            stat = \"identity\") +             # because line height is count number\n  scale_x_date(date_labels=\"%b\",             # date label format show month \n               date_breaks=\"month\",          # date labels on 1st of each month\n               expand=c(0,0)) +              # remove excess space on each end\n  scale_y_continuous(\n    expand  = c(0,0))+                       # remove excess space below x-axis\n  facet_grid(~lubridate::year(week), # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",                # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                   # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",         # facet labels placement\n        strip.background = element_rect(fill = NA, # facet labels no fill grey border\n                                        colour = \"grey50\"),\n        panel.spacing = unit(0, \"cm\"))+      # no space between facet panels\n  labs(title = \"Nested year labels, grey label border\")\n# plot with no box border on year\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # establish x and y for entire plot\n  geom_line(stat = \"identity\",              # make line, line height is count number\n            color = \"#69b3a2\") +            # line color\n  geom_point(size=1, color=\"#69b3a2\") +     # make points at the weekly data points\n  geom_area(fill = \"#69b3a2\",               # fill area below line\n            alpha = 0.4)+                   # fill transparency\n  scale_x_date(date_labels=\"%b\",            # date label format show month \n               date_breaks=\"month\",         # date labels on 1st of each month\n               expand=c(0,0)) +             # remove excess space\n  scale_y_continuous(\n    expand  = c(0,0))+                      # remove excess space below x-axis\n  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",               # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                  # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",                     # facet label placement\n          strip.background = element_blank(),            # no facet lable background\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_rect(colour=\"grey40\"),  # grey border to facet PANEL\n          panel.spacing=unit(0,\"cm\"))+                   # No space between facet panels\n  labs(title = \"Nested year labels - points, shaded, no label border\")"},{"path":"epicurves.html","id":"trục-kép-1","chapter":"32 Đường cong dịch bệnh","heading":"32.6 Trục kép","text":"Mặc dù có những cuộc thảo luận gay gắt về tính hợp lệ của trục kép trong cộng đồng về trực quan hóa dữ liệu, nhiều chuyên gia dịch tễ vẫn muốn nhìn nhận biểu đồ đường cong dịch bệnh hoặc biểu đồ tương tự với phần trăm trên trục thứ hai. Điều này được thảo luận nhiều hơn trong chương Các tips với ggplot, nhưng một ví dụ sử dụng phương pháp cowplot được trình bày bên dưới:Hai biểu đồ riêng biệt được tạo, và sau đó được kết hợp với package cowplot.Các biểu đồ phải có chính xác cùng trục x (đã đặt giới hạn), nếu không dữ liệu và nhãn sẽ không được căn chỉnh phù hợpMỗi biểu đồ sử dụng theme_cowplot() và một biểu đồ có trục y được di chuyển sang phía bên phải của biểu đồBây giờ sử dụng cowplot để chồng lên hai biểu đồ. Sự chú ý đã được tập trung vào việc căn chỉnh trục x, cạnh của trục y và việc sử dụng theme_cowplot().","code":"\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\n#######################################\nplot_cases <- linelist %>% \n  \n  # plot cases per week\n  ggplot()+\n  \n  # create histogram  \n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # bin breaks every week beginning monday before first case, going to monday after last case\n    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)\n        \n  # specify beginning and end of date axis to align with other plot\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  # labels\n  labs(\n      y = \"Daily cases\",\n      x = \"Date of symptom onset\"\n    )+\n  theme_cowplot()\n\n\n# make second plot of percent died per week\n###########################################\nplot_deaths <- linelist %>%                        # begin with linelist\n  group_by(week = floor_date(date_onset, \"week\")) %>%  # create week column\n  \n  # summarise to get weekly percent of cases who died\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %>% \n  \n  # begin plot\n  ggplot()+\n  \n  # line of weekly percent who died\n  geom_line(                                # create line of percent died\n    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column\n    stat = \"identity\",                      # set line height to the value in pct_death column, not the number of rows (which is default)\n    size = 2,\n    color = \"black\")+\n  \n  # Same date-axis limits as the other plot - perfect alignment\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  \n  # y-axis adjustments\n  scale_y_continuous(                # adjust y-axis\n    breaks = seq(0,100, 10),         # set break intervals of percent axis\n    limits = c(0, 100),              # set extent of percent axis\n    position = \"right\")+             # move percent axis to the right\n  \n  # Y-axis label, no x-axis label\n  labs(x = \"\",\n       y = \"Percent deceased\")+      # percent axis label\n  \n  theme_cowplot()                   # add this to make the two plots merge together nicely\naligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"số-mới-mắc-tích-lũy-1","chapter":"32 Đường cong dịch bệnh","heading":"32.7 Số mới mắc tích lũy","text":"Lưu ý: Nếu sử dụng incidence2, hãy xem chương về cách bạn có thể tính số mới mắc tích lũy bằng một hàm đơn giản. Chương này sẽ đề cập đến cách tính số mới mắc tích lũy và vẽ biểu đồ bằng ggplot().Nếu bắt đầu bằng bộ số liệu linelist, hãy tạo một cột mới chứa số ca bệnh tích lũy mỗi ngày trong đợt bùng phát bằng cách sử dụng cumsum() từ base R:10 hàng đầu tiên được hiển thị bên dưới:Sau đó, cột tích lũy này có thể được vẽ dựa trên date_onset, sử dụng geom_line():Nó cũng có thể được phủ đè lên đường cong dịch bệnh, với trục kép bằng cách sử dụng phương pháp cowplot được mô tả ở trên và trong chương Các tips với ggplot:Bây giờ sử dụng cowplot để chồng lên hai biểu đồ. Sự chú ý đã được tập trung vào việc căn chỉnh trục x, cạnh của trục y và việc sử dụng theme_cowplot().","code":"\ncumulative_case_counts <- linelist %>% \n  count(date_onset) %>%                # count of rows per day (returned in column \"n\")   \n  mutate(                         \n    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date\n    )\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\nplot_cases <- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Daily cases\",\n    x = \"Date of symptom onset\"\n  )+\n  theme_cowplot()\n\n# make second plot of cumulative cases line\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Cumulative cases\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\naligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])"},{"path":"epicurves.html","id":"nguồn-tham-khảo-2","chapter":"32 Đường cong dịch bệnh","heading":"32.8 Nguồn tham khảo","text":"","code":""},{"path":"age-pyramid.html","id":"age-pyramid","chapter":"33 Tháp dân số và thang đo Likert","heading":"33 Tháp dân số và thang đo Likert","text":"Kim tự tháp nhân khẩu học rất hữu ích khi bạn muốn hiển thị sự phân bố về độ tuổi và giới tính. Code tương tự cũng có thể được sử dụng để trực quan hóa kết quả của các câu hỏi khảo sát kiểu Likert (ví dụ: “Hoàn toàn đồng ý”, “Đồng ý”, “Trung lập”, “Không đồng ý”, “Hoàn toàn không đồng ý”). Trong chương này, chúng tôi đề cập đến những điều sauTạo một tháp dân số nhanh & dễ dàng với package apyramidTùy biến tháp dân số với ggplot()Hiển thị dữ liệu nhân khẩu học “nền” trong tháp dân sốSử dụng các biểu đồ kiểu kim tự tháp để hiển thị các loại dữ liệu khác (ví dụ: câu trả lời cho các câu hỏi khảo sát kiểu Likert)","code":""},{"path":"age-pyramid.html","id":"chuẩn-bị-24","chapter":"33 Tháp dân số và thang đo Likert","heading":"33.1 Chuẩn bị","text":"","code":""},{"path":"age-pyramid.html","id":"gọi-package-9","chapter":"33 Tháp dân số và thang đo Likert","heading":"Gọi package","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.","code":"\npacman::p_load(rio,       # to import data\n               here,      # to locate files\n               tidyverse, # to clean, handle, and plot the data (includes ggplot2 package)\n               apyramid,  # a package dedicated to creating age pyramids\n               janitor,   # tables and cleaning data\n               stringr)   # working with strings for titles, captions, etc."},{"path":"age-pyramid.html","id":"nhập-dữ-liệu-18","chapter":"33 Tháp dân số và thang đo Likert","heading":"Nhập dữ liệu","text":"Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết.50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới.","code":"\n# import case linelist \nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"age-pyramid.html","id":"làm-sạch","chapter":"33 Tháp dân số và thang đo Likert","heading":"Làm sạch","text":"Để tạo tháp nhân khẩu học theo độ tuổi/giới tính truyền thống, trước tiên dữ liệu phải được làm sạch theo những cách sau:Cột gender phải được làm sạch.Tùy thuộc vào phương pháp của bạn, độ tuổi phải được lưu trữ dưới dạng số hoặc trong cột age category.Nếu sử dụng nhóm tuổi, các giá trị trong cột phải được sắp xếp thứ tự, hoặc là thứ tự chữ-số mặc định hoặc được đặt có chủ ý bằng cách chuyển đổi thành kiểu factor.Sau đây chúng ta sử dụng hàm tabyl() từ package janitor để khảo sát hai cột gender và age_cat5.Chúng ta có thể vẽ biểu đồ histogram đối với cột age để chắc chắn rằng nó đã được làm sạch và phân loại chính xác:","code":"\nlinelist %>% \n  tabyl(age_cat5, gender)##  age_cat5   f   m NA_\n##       0-4 640 416  39\n##       5-9 641 412  42\n##     10-14 518 383  40\n##     15-19 359 364  20\n##     20-24 305 316  17\n##     25-29 163 259  13\n##     30-34 104 213   9\n##     35-39  42 157   3\n##     40-44  25 107   1\n##     45-49   8  80   5\n##     50-54   2  37   1\n##     55-59   0  30   0\n##     60-64   0  12   0\n##     65-69   0  12   1\n##     70-74   0   4   0\n##     75-79   0   0   1\n##     80-84   0   1   0\n##       85+   0   0   0\n##      <NA>   0   0  86\nhist(linelist$age)"},{"path":"age-pyramid.html","id":"apyramid-package","chapter":"33 Tháp dân số và thang đo Likert","heading":"33.2 apyramid package","text":"Package apyramid là một sản phẩm của dự án R4Epis. Bạn có thể đọc thêm về package này tại đây. Nó cho phép bạn nhanh chóng tạo một tháp tuổi. Để tùy biến đẹp hơn, xem mục sử dụng ggplot(). Bạn có thể đọc thêm về package apyramid tại trang Help bằng cách nhập ?age_pyramid vào R console.","code":""},{"path":"age-pyramid.html","id":"dữ-liệu-linelist-1","chapter":"33 Tháp dân số và thang đo Likert","heading":"Dữ liệu Linelist","text":"Sử dụng dữ liệu linelist đã làm sạch, chúng ta có thể tạo một tháp tuổi chỉ với một lệnh age_pyramid() cơ bản. Trong lệnh này:Đối số data = sử dụng bộ dữ liệu linelistĐối số age_group = (trục y) lấy thông tin từ cột nhóm tuổi (trong ngoặc kép)Đối số split_by = (trục x) lấy thông tin từ cột giớiTháp có thể hiện thị phần trăm của tất cả các trường hợp trên trục x, thay vì chỉ số lượng, bằng cách thêm proportional = TRUE.Khi sử dụng package agepyramid, nếu cột được phân chia split_by là nhị phân (vd. nam/nữ, hoặc có/không), thì kết quả sẽ xuất hiện dưới dạng một kim tự tháp. Tuy nhiên nếu có nhiều hơn hai giá trị trong cột được phân chia split_by (không bao gồm NA), kim tự tháp sẽ xuất hiện dưới dạng nhiều biểu đồ cột ngang với các thanh màu xám trong “background” cho biết phạm vi của dữ liệu không có mặt cho nhóm tuổi đó. Trong trường hợp này, giá trị của split_by = sẽ xuất hiện dưới dạng nhãn ở đỉnh mỗi biểu đồ. Chẳng hạn, bên dưới là những gì xảy ra nếu split_by = được chỉ định tới cột hospital.","code":"\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\")\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      proportional = TRUE)\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"hospital\")  "},{"path":"age-pyramid.html","id":"giá-trị-missing-2","chapter":"33 Tháp dân số và thang đo Likert","heading":"Giá trị Missing","text":"Các hàng chứa giá trị missing NA của các cột split_by = hoặc age_group =, nếu được mã hóa là NA, sẽ không tự động kích hoạt việc phân chia biểu đồ như được hiển thị ở trên. Mặc định những hàng này không được hiển thị. Tuy nhiên, bạn có thể chỉ định các giá trị missing hiển thị, trong một biểu đồ liền kề và dưới dạng một nhóm tuổi riêng biệt, bằng cách chỉ định na.rm = FALSE.","code":"\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      na.rm = FALSE)         # show patients missing age or gender"},{"path":"age-pyramid.html","id":"tỷ-lệ-màu-sắc-thẩm-mỹ","chapter":"33 Tháp dân số và thang đo Likert","heading":"Tỷ lệ, màu sắc, & thẩm mỹ","text":"Theo mặc định, các cột hiển thị số lượng (không phải %), đường gạch ngang giữa cho mỗi nhóm được hiển thị và màu sắc là xanh lục/tím. Các thông số này có thể được điều chỉnh, như được trình bày dưới đây:Bạn cũng có thể thêm các lệnh ggplot() vào biểu đồ bằng cách sử dụng các cú pháp chuẩn của ggplot() “+” , chẳng hạn như chủ đề trang trí và điều chỉnh nhãn:","code":"\napyramid::age_pyramid(\n  data = linelist,\n  age_group = \"age_cat5\",\n  split_by = \"gender\",\n  proportional = TRUE,              # show percents, not counts\n  show_midpoint = FALSE,            # remove bar mid-point line\n  #pal = c(\"orange\", \"purple\")      # can specify alt. colors here (but not labels)\n  )+                 \n  \n  # additional ggplot commands\n  theme_minimal()+                               # simplfy background\n  scale_fill_manual(                             # specify colors AND labels\n    values = c(\"orange\", \"purple\"),              \n    labels = c(\"m\" = \"Male\", \"f\" = \"Female\"))+\n  labs(y = \"Percent of all cases\",              # note x and y labs are switched\n       x = \"Age categories\",                          \n       fill = \"Gender\", \n       caption = \"My data source and caption here\",\n       title = \"Title of my plot\",\n       subtitle = \"Subtitle with \\n a second line...\")+\n  theme(\n    legend.position = \"bottom\",                          # legend to bottom\n    axis.text = element_text(size = 10, face = \"bold\"),  # fonts/sizes\n    axis.title = element_text(size = 12, face = \"bold\"))"},{"path":"age-pyramid.html","id":"dữ-liệu-được-tổng-hợp","chapter":"33 Tháp dân số và thang đo Likert","heading":"Dữ liệu được tổng hợp","text":"Ví dụ bên trên giả định rằng dữ liệu của bạn có định dạng mỗi hàng cho một quan sát. Nếu dữ liệu của bạn đã được tổng hợp thành số lượng theo nhóm tuổi, bạn vẫn có thể sử dụng package apyramid, như được trình bày dưới đây.Để minh họa, chúng ta sẽ tổng hợp dữ liệu linelist theo số lượng đối với nhóm tuổi và giới, dưới định dạng “ngang”. Việc này sẽ mô phỏng như thể dữ liệu ban đầu của bạn đang được trình bày dưới dạng số lượng. Tìm hiểu thêm về Nhóm dữ liệu và Xoay trục dữ liệu ở các chương tương ứng.…lệnh trên sẽ khiến bộ dữ liệu trông như thế này: bao gồm các cột nhóm tuổi, số lượng nam, nữ, và missing.Để thiết lập chủ đề cho tháp tuổi, chúng ta sẽ xoay trục dữ liệu sang dạng “dọc” bằng hàm pivot_longer() trong package dplyr. Đó là bởi vì ggplot() thường thích dữ liệu được bố trí ở dạng “dọc”, và package apyramid đang sử dụng ggplot().Sau đó sử dụng các đối số split_by = và count = của hàm age_pyramid() để chỉ định các cột tương ứng trong bộ dữ liệu:Lưu ý rằng ở trên, thứ tự của “m” và “f” là khác nhau (tháp bị đảo ngược). Để điều chỉnh thự tự, bạn phải định nghĩa lại cột giới trong dữ liệu được tổng hợp thành kiểu Factor và sắp xếp thứ tự như mong muốn. Xem chương Factors.","code":"\ndemo_agg <- linelist %>% \n  count(age_cat5, gender, name = \"cases\") %>% \n  pivot_wider(\n    id_cols = age_cat5,\n    names_from = gender,\n    values_from = cases) %>% \n  rename(`missing_gender` = `NA`)\n# pivot the aggregated data into long format\ndemo_agg_long <- demo_agg %>% \n  pivot_longer(\n    col = c(f, m, missing_gender),            # cols to elongate\n    names_to = \"gender\",                # name for new col of categories\n    values_to = \"counts\") %>%           # name for new col of counts\n  mutate(\n    gender = na_if(gender, \"missing_gender\")) # convert \"missing_gender\" to NA\napyramid::age_pyramid(data = demo_agg_long,\n                      age_group = \"age_cat5\",# column name for age category\n                      split_by = \"gender\",   # column name for gender\n                      count = \"counts\")      # column name for case counts"},{"path":"age-pyramid.html","id":"demo_pyr_gg","chapter":"33 Tháp dân số và thang đo Likert","heading":"33.3 ggplot()","text":"Sử dụng ggplot() cho phép bạn xây dựng tháp tuổi một cách linh hoạt hơn, nhưng đòi hỏi nhiều nỗ lực và hiểu biết hơn về cách hoạt động của ggplot(). Việc vô tình mắc sai lầm cũng dễ dàng hơn.Để sử dụng ggplot() tạo tháp nhân khẩu học, bạn tạo hai biểu đồ cột (cho từng giới tính), chuyển đổi các giá trị trong một biểu đồ thành âm và cuối cùng lật các trục x và y để hiển thị các biểu đồ cột theo chiều dọc, xuất phát điểm của chúng gặp nhau ở chính giữa biểu đồ.","code":""},{"path":"age-pyramid.html","id":"chuẩn-bị-25","chapter":"33 Tháp dân số và thang đo Likert","heading":"Chuẩn bị","text":"Cách tiếp cận này sử dụng cột tuổi ở dạng numeric, không phải cột nhóm tuổi age_cat5 dạng categorical. Vì vậy, chúng ta cần kiểm tra để đảm bảo rằng kiểu của cột này thực sự là dạng số.Bạn có thể sử dụng logic tương tự như dưới đây để xây dựng một kim tự tháp từ dữ liệu dạng danh mục sử dụng geom_col() thay vì geom_histogram().","code":"\nclass(linelist$age)## [1] \"numeric\""},{"path":"age-pyramid.html","id":"xây-dựng-biểu-đồ","chapter":"33 Tháp dân số và thang đo Likert","heading":"Xây dựng biểu đồ","text":"Trước tiên, hãy hiểu rằng để tạo một kim tự tháp như vậy bằng cách sử dụng ggplot(), cách tiếp cận sẽ là như sau:Bên trong hàm ggplot(), tạo hai biểu đồ histograms sử dụng cột tuổi dạng numeric, tương ứng cho hai nhóm (trong trường hợp này là giới nam và nữ). Để thực hiện việc này, dữ liệu cho mỗi biểu đồ được chỉ định trong các lệnh geom_histogram() tương ứng của chúng, với các bộ lọc tương ứng được áp dụng cho bộ dữ liệu linelist.Bên trong hàm ggplot(), tạo hai biểu đồ histograms sử dụng cột tuổi dạng numeric, tương ứng cho hai nhóm (trong trường hợp này là giới nam và nữ). Để thực hiện việc này, dữ liệu cho mỗi biểu đồ được chỉ định trong các lệnh geom_histogram() tương ứng của chúng, với các bộ lọc tương ứng được áp dụng cho bộ dữ liệu linelist.Một biểu đồ sẽ có các giá trị dương, trong khi biểu đồ kia sẽ có các giá trị được chuyển thành giá trị âm - điều này tạo ra “kim tự tháp” với giá trị 0 ở giữa biểu đồ. Các giá trị âm được tạo bằng cách sử dụng thuật ngữ đặc biệt của ggplot2 là ..count.. và nhân với -1.Một biểu đồ sẽ có các giá trị dương, trong khi biểu đồ kia sẽ có các giá trị được chuyển thành giá trị âm - điều này tạo ra “kim tự tháp” với giá trị 0 ở giữa biểu đồ. Các giá trị âm được tạo bằng cách sử dụng thuật ngữ đặc biệt của ggplot2 là ..count.. và nhân với -1.Lệnh coord_flip() chuyển trục X và Y, dẫn đến các đồ thị quay dọc và tạo ra hình kim tự tháp.Lệnh coord_flip() chuyển trục X và Y, dẫn đến các đồ thị quay dọc và tạo ra hình kim tự tháp.Cuối cùng, các nhãn giá trị trục đếm phải được thay đổi để chúng xuất hiện dưới dạng số “dương” trên cả hai mặt của kim tự tháp (mặc dù các giá trị thực tế ở một mặt là âm).Cuối cùng, các nhãn giá trị trục đếm phải được thay đổi để chúng xuất hiện dưới dạng số “dương” trên cả hai mặt của kim tự tháp (mặc dù các giá trị thực tế ở một mặt là âm).Một phiên bản đơn giản của biểu đồ, sử dụng hàm geom_histogram(), như dưới đây:NGUY HIỂM: Nếu như giới hạn của trục counts được thiết lập quá nhỏ, và cột số lượng vượt quá giá trị đó, cột sẽ biến mất hoàn toàn hoặc bị rút ngắn một cách không tự nhiên! Hãy chú ý điều này nếu dữ liệu phân tích thường xuyên được cập nhật. Có thể ngăn chặn điều này bằng cách tự động điều chỉnh các giới hạn trục count cho phù hợp với dữ liệu của bạn, như dưới đây.Có nhiều thứ bạn có thể thay đổi/thêm vào phiên bản đơn giản này, bao gồm:Tự động điều chỉnh tỷ lệ trục count cho dữ liệu của bạn (tránh các lỗi được thảo luận trong cảnh báo bên dưới)Chỉ định màu sắc và nhãn chú giải một cách thủ côngChuyển đổi số lượng thành tỷ lệ phần trămĐể chuyển đổi số lượng thành phần trăm (của tổng số), hãy thực hiện điều này với dữ liệu của bạn trước khi vẽ biểu đồ. Dưới đây, chúng ta lấy số lượng của age-gender, sau đó ungroup(), và tiếp tục mutate() để tạo cột phần trăm mới. Nếu bạn muốn phần trăm theo giới tính, hãy bỏ qua bước hủy nhóm.Quan trọng là, chúng ta lưu các giá trị lớn nhất vầ nhỏ nhất để chúng ta biết giới hạn của thang đo. Chúng sẽ được sử dụng trong lệnh ggplot() dưới đây.Cuối cùng, chúng ta dùng hàm ggplot() trên dữ liệu phần trăm. Chúng ta chỉ rõ scale_y_continuous() để mở rộng độ dài được xác định trước theo mỗi hướng (dương và “âm”). Chúng ta sử dụng hàm floor() vả ceiling() để làm tròn số thập phân theo cách thích hợp (làm tròn xuống hoặc lên).","code":"\n  # begin ggplot\n  ggplot(mapping = aes(x = age, fill = gender)) +\n  \n  # female histogram\n  geom_histogram(data = linelist %>% filter(gender == \"f\"),\n                 breaks = seq(0,85,5),\n                 colour = \"white\") +\n  \n  # male histogram (values converted to negative)\n  geom_histogram(data = linelist %>% filter(gender == \"m\"),\n                 breaks = seq(0,85,5),\n                 mapping = aes(y = ..count..*(-1)),\n                 colour = \"white\") +\n  \n  # flip the X and Y axes\n  coord_flip() +\n  \n  # adjust counts-axis scale\n  scale_y_continuous(limits = c(-600, 900),\n                     breaks = seq(-600,900,100),\n                     labels = abs(seq(-600, 900, 100)))\n# create dataset with proportion of total\npyramid_data <- linelist %>%\n  count(age_cat5,\n        gender,\n        name = \"counts\") %>% \n  ungroup() %>%                 # ungroup so percents are not by group\n  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1), \n         percent = case_when(\n            gender == \"f\" ~ percent,\n            gender == \"m\" ~ -percent,     # convert male to negative\n            TRUE          ~ NA_real_))    # NA val must by numeric as well\nmax_per <- max(pyramid_data$percent, na.rm=T)\nmin_per <- min(pyramid_data$percent, na.rm=T)\n\nmax_per## [1] 10.9\nmin_per## [1] -7.1\n# begin ggplot\n  ggplot()+  # default x-axis is age in years;\n\n  # case data graph\n  geom_col(data = pyramid_data,\n           mapping = aes(\n             x = age_cat5,\n             y = percent,\n             fill = gender),         \n           colour = \"white\")+       # white around each bar\n  \n  # flip the X and Y axes to make pyramid vertical\n  coord_flip()+\n  \n\n  # adjust the axes scales\n  # scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) +\n  scale_y_continuous(\n    limits = c(min_per, max_per),\n    breaks = seq(from = floor(min_per),                # sequence of values, by 2s\n                 to = ceiling(max_per),\n                 by = 2),\n    labels = paste0(abs(seq(from = floor(min_per),     # sequence of absolute values, by 2s, with \"%\"\n                            to = ceiling(max_per),\n                            by = 2)),\n                    \"%\"))+  \n\n  # designate colors and legend labels manually\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",\n               \"m\" = \"darkgreen\"),\n    labels = c(\"Female\", \"Male\")) +\n  \n  # label values (remember X and Y flipped now)\n  labs(\n    title = \"Age and gender of cases\",\n    x = \"Age group\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Data are from linelist \\nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \\nData as of: {format(Sys.Date(), '%d %b %Y')}\")) +\n  \n  # display themes\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0.5), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\")\n    )"},{"path":"age-pyramid.html","id":"so-sánh-với-đường-cơ-sở","chapter":"33 Tháp dân số và thang đo Likert","heading":"So sánh với đường cơ sở","text":"flexibility ggplot(), can second layer bars background represent “true” “baseline” population pyramid. can provide nice visualization compare observed baseline.Với sự linh hoạt của ggplot(), bạn có thể có lớp thanh thứ hai trong nền đại diện cho tháp dân số “chuẩn” hoặc “đường cơ sở”. Điều này có thể cung cấp khả năng trực quan hóa tốt để sánh những gì quan sát được với đường cơ sở.Nhập và xem dữ liệu dân số (xem chương Tải sách và dữ liệu):Đầu tiên là một số bước quản lý dữ liệu:Ở đây chúng ta sắp xếp lại thứ tự của các danh mục tuổi mà chúng ta muốn chúng xuất hiện. một số điểm khác biệt trong cách thực thi ggplot(), trong trường hợp cụ thể này, dễ dàng nhất là lưu trữ chúng dưới dạng vectơ ký tự và sử dụng chúng sau này trong hàm vẽ đồ thị.Kết hợp dữ liệu quần thể và dữ liệu trường hợp thông qua hàm bind_rows() của package dplyr:Trước tiên, hãy đảm bảo hai bộ dữ liệu có tên cột giống nhau, các giá trị nhóm tuổi và giá trị giới tínhLàm cho chúng có cấu trúc dữ liệu giống nhau: cột nhóm tuổi, giới tính, số lượng và phần trăm tổng sốGắn chúng lại với nhau, một bộ dữ liệu này ở trên bộ dữ liệu kia (bind_rows())Xem lại bộ dữ liệu dân số đã thay đổiBây giờ thực hiện tương tự cho bộ linelist. Sẽ hơi khác một chút bởi vì nó bắt đầu với các trường hợp theo hàng, không phải số lượng.Xem lại bộ dữ liệu trường hợp đã thay đổiBây giờ hai data frame sẽ được kết hợp, cái này ở trên cái kia (chúng có cùng tên cột). Chúng ta có thể “đặt tên” cho từng data frame, và sử dụng đối số .id = để tạo một cột mới “data_source” sẽ cho biết dữ liệu có nguồn gốc từ data frame nào. Chúng tôi có thể sử dụng cột này để lọc với hàm ggplot().Lưu trữ các giá trị phần trăm tối đa và tối thiểu, được sử dụng trong hàm vẽ biểu đồ để xác định phạm vi của biểu đồ (và không cắt ngắn bất kỳ cột nào!)Bây giờ biểu đồ được tạo bởi ggplot() có:Một biểu đồ cột ngang của dữ liệu dan số (rộng hơn, trong suốt)Một biểu đồ cột ngang của dữ liệu các trường hợp (nhỏ hơn, đậm hơn)","code":"\n# import the population demographics data\npop <- rio::import(\"country_demographics.csv\")\n# record correct age cat levels\nage_levels <- c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-24\",\n                \"25-29\",\"30-34\", \"35-39\", \"40-44\", \"45-49\",\n                \"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\",\n                \"75-79\", \"80-84\", \"85+\")\n# create/transform populaton data, with percent of total\n########################################################\npop_data <- pop %>% \n  pivot_longer(      # pivot gender columns longer\n    cols = c(m, f),\n    names_to = \"gender\",\n    values_to = \"counts\") %>% \n  \n  mutate(\n    percent  = round(100*(counts / sum(counts, na.rm=T)),1),  # % of total\n    percent  = case_when(                                                        \n     gender == \"f\" ~ percent,\n     gender == \"m\" ~ -percent,               # if male, convert % to negative\n     TRUE          ~ NA_real_))\n# create case data by age/gender, with percent of total\n#######################################################\ncase_data <- linelist %>%\n  count(age_cat5, gender, name = \"counts\") %>%  # counts by age-gender groups\n  ungroup() %>% \n  mutate(\n    percent = round(100*(counts / sum(counts, na.rm=T)),1),  # calculate % of total for age-gender groups\n    percent = case_when(                                     # convert % to negative if male\n      gender == \"f\" ~ percent,\n      gender == \"m\" ~ -percent,\n      TRUE          ~ NA_real_))\n# combine case and population data (same column names, age_cat values, and gender values)\npyramid_data <- bind_rows(\"cases\" = case_data, \"population\" = pop_data, .id = \"data_source\")\n# Define extent of percent axis, used for plot limits\nmax_per <- max(pyramid_data$percent, na.rm=T)\nmin_per <- min(pyramid_data$percent, na.rm=T)\n# begin ggplot\n##############\nggplot()+  # default x-axis is age in years;\n\n  # population data graph\n  geom_col(\n    data = pyramid_data %>% filter(data_source == \"population\"),\n    mapping = aes(\n      x = age_cat5,\n      y = percent,\n      fill = gender),\n    colour = \"black\",                               # black color around bars\n    alpha = 0.2,                                    # more transparent\n    width = 1)+                                     # full width\n  \n  # case data graph\n  geom_col(\n    data = pyramid_data %>% filter(data_source == \"cases\"), \n    mapping = aes(\n      x = age_cat5,                               # age categories as original X axis\n      y = percent,                                # % as original Y-axis\n      fill = gender),                             # fill of bars by gender\n    colour = \"black\",                               # black color around bars\n    alpha = 1,                                      # not transparent \n    width = 0.3)+                                   # half width\n  \n  # flip the X and Y axes to make pyramid vertical\n  coord_flip()+\n  \n  # manually ensure that age-axis is ordered correctly\n  scale_x_discrete(limits = age_levels)+     # defined in chunk above\n  \n  # set percent-axis \n  scale_y_continuous(\n    limits = c(min_per, max_per),                                          # min and max defined above\n    breaks = seq(floor(min_per), ceiling(max_per), by = 2),                # from min% to max% by 2 \n    labels = paste0(                                                       # for the labels, paste together... \n              abs(seq(floor(min_per), ceiling(max_per), by = 2)), \"%\"))+                                                  \n\n  # designate colors and legend labels manually\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",         # assign colors to values in the data\n               \"m\" = \"darkgreen\"),\n    labels = c(\"f\" = \"Female\",\n               \"m\"= \"Male\"),      # change labels that appear in legend, note order\n  ) +\n\n  # plot labels, titles, caption    \n  labs(\n    title = \"Case age and gender distribution,\\nas compared to baseline population\",\n    subtitle = \"\",\n    x = \"Age category\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Cases shown on top of country demographic baseline\\nCase data are from linelist, n = {nrow(linelist)}\\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\\nCase data as of: {format(max(linelist$date_onset, na.rm=T), '%d %b %Y')}\")) +\n  \n  # optional aesthetic themes\n  theme(\n    legend.position = \"bottom\",                             # move legend to bottom\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\"))"},{"path":"age-pyramid.html","id":"thang-đo-likert","chapter":"33 Tháp dân số và thang đo Likert","heading":"33.4 Thang đo Likert","text":"Các kỹ thuật được sử dụng để tạo tháp dân số với ggplot() cũng có thể được sử dụng để lập các biểu đồ của dữ liệu khảo sát từ thang đo Likert.Nhập dữ liệu (xem chương Tải sách và dữ liệu nếu cần).Bắt đầu với dữ liệu giống như sau, với một biến phân loại từng người trả lời (status) và câu trả lời của họ cho 8 câu hỏi trên thang điểm Likert 4 mức độ (“Rất kém”, “Kém”, “Tốt”, “Rất tốt”).Đầu tiên là một vài bước quản lý số liệu:Xoay trục dữ liệu dài hơnTạo cột mới direction tùy thuộc vào việc phản hồi “tích cực” hay “tiêu cực”Thiết lập thứ bậc kiểu factor cho cột status và cột ResponseLưu trữ giá trị đếm tối đa để các giới hạn của biểu đồ là phù hợpBây giờ hãy cùng vẽ biểu đồ. Tương tự các tháp tuổi ở trên, chúng ta đang tạo hai biểu đồ thanh và đảo các giá trị của một trong số chúng thành âm.Chúng ta sử dụng hàm geom_bar() bởi vì dữ liệu của chúng ta mỗi quan sát nằm trên một hàng, không phải là số lượng tổng hợp. Chúng ta sử dụng thuật ngữ đặc biệt của ggplot2 là ..count.. ở một biểu đồ thanh để đảo ngược các giá trị thành âm(*-1), sau đó chúng ta thiết lập position = \"stack\" để các giá trị xếp chồng lên nhau.","code":"\n# import the likert survey response data\nlikert_data <- rio::import(\"likert_data.csv\")\nmelted <- likert_data %>% \n  pivot_longer(\n    cols = Q1:Q8,\n    names_to = \"Question\",\n    values_to = \"Response\") %>% \n  mutate(\n    \n    direction = case_when(\n      Response %in% c(\"Poor\",\"Very Poor\")  ~ \"Negative\",\n      Response %in% c(\"Good\", \"Very Good\") ~ \"Positive\",\n      TRUE                                 ~ \"Unknown\"),\n    \n    status = fct_relevel(status, \"Junior\", \"Intermediate\", \"Senior\"),\n    \n    # must reverse 'Very Poor' and 'Poor' for ordering to work\n    Response = fct_relevel(Response, \"Very Good\", \"Good\", \"Very Poor\", \"Poor\")) \n\n# get largest value for scale limits\nmelted_max <- melted %>% \n  count(status, Question) %>% # get counts\n  pull(n) %>%                 # column 'n'\n  max(na.rm=T)                # get max\n# make plot\nggplot()+\n     \n  # bar graph of the \"negative\" responses \n     geom_bar(\n       data = melted %>% filter(direction == \"Negative\"),\n       mapping = aes(\n         x = status,\n         y = ..count..*(-1),    # counts inverted to negative\n         fill = Response),\n       color = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # bar graph of the \"positive responses\n     geom_bar(\n       data = melted %>% filter(direction == \"Positive\"),\n       mapping = aes(\n         x = status,\n         fill = Response),\n       colour = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # flip the X and Y axes\n     coord_flip()+\n  \n     # Black vertical line at 0\n     geom_hline(yintercept = 0, color = \"black\", size=1)+\n     \n    # convert labels to all positive numbers\n    scale_y_continuous(\n      \n      # limits of the x-axis scale\n      limits = c(-ceiling(melted_max/10)*11,    # seq from neg to pos by 10, edges rounded outward to nearest 5\n                 ceiling(melted_max/10)*10),   \n      \n      # values of the x-axis scale\n      breaks = seq(from = -ceiling(melted_max/10)*10,\n                   to = ceiling(melted_max/10)*10,\n                   by = 10),\n      \n      # labels of the x-axis scale\n      labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10),\n                            seq(0, ceiling(melted_max/10)*10, 10))))) +\n     \n    # color scales manually assigned \n    scale_fill_manual(\n      values = c(\"Very Good\"  = \"green4\", # assigns colors\n                \"Good\"      = \"green3\",\n                \"Poor\"      = \"yellow\",\n                \"Very Poor\" = \"red3\"),\n      breaks = c(\"Very Good\", \"Good\", \"Poor\", \"Very Poor\"))+ # orders the legend\n     \n    \n     \n    # facet the entire plot so each question is a sub-plot\n    facet_wrap( ~ Question, ncol = 3)+\n     \n    # labels, titles, caption\n    labs(\n      title = str_glue(\"Likert-style responses\\nn = {nrow(likert_data)}\"),\n      x = \"Respondent status\",\n      y = \"Number of responses\",\n      fill = \"\")+\n\n     # display adjustments \n     theme_minimal()+\n     theme(axis.text = element_text(size = 12),\n           axis.title = element_text(size = 14, face = \"bold\"),\n           strip.text = element_text(size = 14, face = \"bold\"),  # facet sub-titles\n           plot.title = element_text(size = 20, face = \"bold\"),\n           panel.background = element_rect(fill = NA, color = \"black\")) # black box around each facet"},{"path":"age-pyramid.html","id":"nguồn-8","chapter":"33 Tháp dân số và thang đo Likert","heading":"33.5 Nguồn","text":"apyramid documentation","code":""},{"path":"heatmaps.html","id":"heatmaps","chapter":"34 Biểu đồ nhiệt","heading":"34 Biểu đồ nhiệt","text":"Biểu đồ nhiệt, còn được gọi là “bản đồ nhiệt” hoặc “bảng nhiệt”, là những hình ảnh trực quan hữu ích khi cố gắng hiển thị 3 biến (trục x, trục y và màu sắc). Dưới đây chúng tôi minh họa hai ví dụ:Ma trận trực quan về các sự kiện lây truyền theo độ tuổi (“ai lây nhiễm cho ai”)Theo dõi các chỉ số báo cáo trên nhiều cơ sở/khu vực theo thời gian","code":""},{"path":"heatmaps.html","id":"chuẩn-bị-26","chapter":"34 Biểu đồ nhiệt","heading":"34.1 Chuẩn bị","text":"","code":""},{"path":"heatmaps.html","id":"gọi-packages-11","chapter":"34 Biểu đồ nhiệt","heading":"Gọi packages","text":"Đoạn code dưới đây hiển thị cách gọi các packages cần thiết cho việc phân tích dữ liệu. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt packages nếu cần và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các packages trong R.Bộ dữ liệuChương này sẽ sử dụng bộ dữ liệu linelist-một vụ dịch mô phỏng trong mục ma trận lây truyền và bộ dữ liệu về số trường hợp sốt rét được ghi nhận hàng ngày theo cơ sở trong phần theo dõi các chỉ số báo cáo. Các bộ dữ liệu sẽ được gọi và làm sạch trong khi trình bày.","code":"\npacman::p_load(\n  tidyverse,       # data manipulation and visualization\n  rio,             # importing data \n  lubridate        # working with dates\n  )"},{"path":"heatmaps.html","id":"ma-trận-lây-truyền-1","chapter":"34 Biểu đồ nhiệt","heading":"34.2 Ma trận lây truyền","text":"Bảng nhiệt có thể hữu ích để trực quan hóa ma trận. Một ví dụ là hiển thị “ai đã lây nhiễm cho ai” trong một vụ dịch. Giả sử rằng bạn có đầy đủ thông tin về các sự kiện lây truyền.Lưu ý rằng chương Truy vết tiếp xúc có một ví dụ khác về tạo ma trận tiếp xúc thành bảng nhiệt, sử dụng một dataset khác (có lẽ đơn giản hơn) trong đó tuổi của các trường hợp và nguồn lây của chúng được căn chỉnh gọn gàng trên cùng một hàng của data frame. Dataset này cũng được sử dụng để tạo bản đồ mật độ trong chương Các tips với ggplot. Ví dụ dưới đây bắt đầu từ một danh sách các trường hợp và yêu cầu nhiều thao tác biến đổi dữ liệu trước khi thành một data frame sẵn sàng để vẽ biểu đồ. Vì vậy, có rất nhiều kịch bản để bạn lựa chọn…Chúng tôi bắt đầu từ danh sách trường hợp của một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, hãy bấm để tải bộ dữ liệu linelist “đã làm sạch” (.rds file). Nhập dữ liệu của bạn bằng hàm import() từ package rio (hàm này chấp nhận nhiều loại tệp như .xlsx, .rds, .csv - Xem chương Nhập xuất dữ liệu để biết thêm chi tiết).Danh sách dưới đây bao gồm 50 hàng đầu tiên của linelist:Trong bộ dữ liệu linelist này:Mỗi trường hợp được thể hiện trên một hàng, được định danh bằng case_idKéo sang phải bạn sẽ thấy cột infector có chứa case_id của nguồn lây, mỗi nguồn lây cũng là một trường hợp trong linelist","code":"\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"heatmaps.html","id":"chuẩn-bị-dữ-liệu","chapter":"34 Biểu đồ nhiệt","heading":"Chuẩn bị dữ liệu","text":"Mục tiêu: Chúng ta cần tạo một data frame dạng “dọc”, tức là mỗi đường lây truyền theo lứa tuổi có thể có nằm trên một hàng, với một cột số chứa tỷ lệ của hàng đó đối với tất cả các sự kiện lây nhiễm được quan sát trong linelist.Để đạt được mục tiêu này, một số bước biến đổi dữ liệu cần được thực hiện:","code":""},{"path":"heatmaps.html","id":"tạo-data-frame-các-trường-hợp","chapter":"34 Biểu đồ nhiệt","heading":"Tạo data frame các trường hợp","text":"Để bắt đầu, chúng ta tạo một data frame về các trường hợp, bao gồm độ tuổi và nguồn lây nhiễm của chúng - chúng ta đặt tên data frame này là case_ages. 50 hàng đầu tiên của bộ dữ liệu dữ liệu được hiển thị bên dưới.","code":"\ncase_ages <- linelist %>% \n  select(case_id, infector, age_cat) %>% \n  rename(\"case_age_cat\" = \"age_cat\")"},{"path":"heatmaps.html","id":"tạo-data-frame-nguồn-lây-nhiễm","chapter":"34 Biểu đồ nhiệt","heading":"Tạo data frame nguồn lây nhiễm","text":"Tiếp theo, chúng ta tạo một data frame các nguồn lây nhiễm - tại thời điểm này, nó chỉ gồm một cột duy nhất. Đây là các ID của các nguồn lâu nhiễm trong bộ dữ liệu linelist. Không phải mọi trường hợp đều xác định được nguồn lây, vì vậy chúng ta cần loại bỏ các giá trị missing. 50 hàng đầu tiên được hiển thị bên dưới.Tiếp theo, chúng ta sử dụng hàm join để thu thập tuổi của những nguồn lây nhiễm. Điều này không đơn giản, vì trong linelist, tuổi của người lây nhiễm không được liệt kê như vậy. Chúng ta sẽ đạt được kết quả này bằng cách nối dữ liệu các trường hợp trong linelist với dữ liệu những người lây nhiễm. Chúng ta bắt đầu với bộ dữ liệu infectors, sau đó dùng hàm left_join() thêm các trường hợp trong linelist sao cho cột id của các trường hợp lây nhiễm trong bộ dữ liệu infector nối với cột case_id trong bộ dữ liệu linelist.đó, dữ liệu từ bản ghi trường hợp của người lây nhiễm trong linelist (bao gồm cả tuổi) được thêm vào hàng của người lây nhiễm. 50 hàng đầu tiên được hiển thị bên dưới.Sau đó, chúng ta kết hợp các trường hợp và tuổi của chúng với những người lây nhiễm và tuổi của những người này lại. Mỗi data frame đều có chung cột infector, vì vậy nó được sử dụng cho phép nối. Các hàng đầu tiên được hiển thị bên dưới:Dưới đây là bảng chéo đơn giản về số lượng các trường hợp và người lây nhiễm theo nhóm tuổi. Nhãn được thêm vào để phân biệt.Chúng ta có thể chuyển đổi bảng này thành data frame với hàm data.frame() từ base R, hàm sẽ tự động chuyển đổi dữ liệu sang dạng “dọc” để có thể áp dụng trong hàm ggplot(). Các hàng đầu tiên được hiển thị bên dưới.Bây giờ chúng ta làm tương tự, nhưng áp dụng hàm prop.table() từ base R vào bảng để thay vì nhận số lượng, chúng ta nhận được tỷ lệ của tất cả các biến. 50 hàng đầu tiên được hiển thị bên dưới.","code":"\ninfectors <- linelist %>% \n  select(infector) %>% \n  drop_na(infector)\ninfector_ages <- infectors %>%             # begin with infectors\n  left_join(                               # add the linelist data to each infector  \n    linelist,\n    by = c(\"infector\" = \"case_id\")) %>%    # match infector to their information as a case\n  select(infector, age_cat) %>%            # keep only columns of interest\n  rename(\"infector_age_cat\" = \"age_cat\")   # rename for clarity\nages_complete <- case_ages %>%  \n  left_join(\n    infector_ages,\n    by = \"infector\") %>%        # each has the column infector\n  drop_na()                     # drop rows with any missing data\ntable(cases = ages_complete$case_age_cat,\n      infectors = ages_complete$infector_age_cat)##        infectors\n## cases   0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+\n##   0-4   105 156   105   114   143   117    13   0\n##   5-9   102 132   110   102   117    96    12   5\n##   10-14 104 109    91    79   120    80    12   4\n##   15-19  85 105    82    39    75    69     7   5\n##   20-29 101 127   109    80   143   107    22   4\n##   30-49  72  97    56    54    98    61     4   5\n##   50-69   5   6    15     9     7     5     2   0\n##   70+     1   0     2     0     0     0     0   0\nlong_counts <- data.frame(table(\n    cases     = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat))\nlong_prop <- data.frame(prop.table(table(\n    cases = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat)))"},{"path":"heatmaps.html","id":"tạo-biểu-đồ-nhiệt","chapter":"34 Biểu đồ nhiệt","heading":"Tạo biểu đồ nhiệt","text":"Cuối cùng, chúng ta có thể vẽ biểu đồ nhiệt với hàm geom_tile() trong package ggplot2. Xem chương Các tips với ggplot để tìm hiểu sâu hơn về thang màu/tô màu cho biểu đồ, đặc biệt là hàm scale_fill_gradient().Bên trong hàm aes() của hàm geom_tile(), thiết lập trục x và y tương ứng với tuổi của các trường hợp và tuổi của người lây nhiễmNgoài ra trong hàm aes(), hãy đặt đối số fill = tới cột tần suất Freq - đây là giá trị sẽ được chuyển đổi thành màu gạchĐặt màu thang đo với scale_fill_gradient() - bạn có thể chỉ định màu cao/thấp\nLưu ý rằng scale_color_gradient() là một cái khác! Trong trường hợp này, bạn sẽ sử dụng fill\nLưu ý rằng scale_color_gradient() là một cái khác! Trong trường hợp này, bạn sẽ sử dụng fillBởi vì màu được tạo thông qua “fill”, bạn có thể sử dụng đối số fill = đối số trong hàm labs() để thay đổi tiêu đề chú giải","code":"\nggplot(data = long_prop)+       # use long data, with proportions as Freq\n  geom_tile(                    # visualize it in tiles\n    aes(\n      x = cases,         # x-axis is case age\n      y = infectors,     # y-axis is infector age\n      fill = Freq))+            # color of the tile is the Freq column in the data\n  scale_fill_gradient(          # adjust the fill color of the tiles\n    low = \"blue\",\n    high = \"orange\")+\n  labs(                         # labels\n    x = \"Case age\",\n    y = \"Infector age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # legend title\n  )"},{"path":"heatmaps.html","id":"các-chỉ-số-báo-cáo-theo-thời-gian","chapter":"34 Biểu đồ nhiệt","heading":"34.3 Các chỉ số báo cáo theo thời gian","text":"Thông thường, trong lĩnh vực y tế công cộng, một mục tiêu là đánh giá xu hướng theo thời gian của nhiều thực thể (cơ sở, khu vực pháp lý, v.v.). Một cách để hình dung các xu hướng như vậy theo thời gian là biểu đồ nhiệt trong đó trục x là thời gian và trên trục y là các thực thể.","code":""},{"path":"heatmaps.html","id":"chuẩn-bị-dữ-liệu-1","chapter":"34 Biểu đồ nhiệt","heading":"Chuẩn bị dữ liệu","text":"Chúng ta bắt đầu bằng cách nhập bộ dữ liệu báo cáo về bệnh sốt rét hàng ngày từ nhiều cơ sở. Các báo cáo chứa dữu liệu về ngày, tỉnh, huyện và số trường hợp sốt rét. Xem chương Tải sách và dữ liệu để biết thông tin về cách tải xuống các dữ liệu này. Dưới đây là 30 hàng đầu tiên:","code":"\nfacility_count_data <- import(\"malaria_facility_count_data.rds\")"},{"path":"heatmaps.html","id":"tổng-hợp-và-tóm-tắt","chapter":"34 Biểu đồ nhiệt","heading":"Tổng hợp và tóm tắt","text":"Mục tiêu của ví dụ này là chuyển đổi tổng số số ca bệnh sốt rét hàng ngày tại các cơ sở (xem trong tab trước) thành số liệu thống kê tóm tắt hàng tuần về hiệu suất báo cáo của cơ sở - trong trường hợp này là tỷ lệ số ngày mỗi tuần mà cơ sở báo cáo bất kỳ dữ liệu nào. Đối với ví dụ này, chúng ta sẽ chỉ hiển thị dữ liệu cho Spring District.Để đạt được điều này, chúng ta sẽ thực hiện các bước quản lý dữ liệu sau:Lọc dữ liệu phù hợp (theo địa điểm, ngày tháng)Tạo cột tuần bằng cách sử dụng hàm floor_date() trong package lubridate\nHàm này trả về ngày bắt đầu trong tuần của một ngày cụ thể, sử dụng ngày bắt đầu được chỉ định của mỗi tuần (ví dụ: “Thứ Hai”)\nHàm này trả về ngày bắt đầu trong tuần của một ngày cụ thể, sử dụng ngày bắt đầu được chỉ định của mỗi tuần (ví dụ: “Thứ Hai”)Dữ liệu được nhóm theo cột “location” và “week” để tạo ra các đơn vị phân tích “facility-week”Hàm summarise() tạo các cột mới để trình bày thống kê tóm tắt cho từng nhóm cơ sở theo tuần (facility-week):\nSố ngày mỗi tuần (7 - một giá trị không đổi)\nSố lượng báo cáo nhận được từ cơ sở-tuần (có thể nhiều hơn 7!)\nTổng số ca sốt rét cơ sở báo cáo trong tuần (chỉ dành cho ai quan tâm)\nSố ngày duy nhất trong mỗi cơ sở-tuần có dữ liệu được báo cáo\nPhần trăm trong số 7 ngày mỗi cơ sở-tuần mà dữ liệu được báo cáo\nSố ngày mỗi tuần (7 - một giá trị không đổi)Số lượng báo cáo nhận được từ cơ sở-tuần (có thể nhiều hơn 7!)Tổng số ca sốt rét cơ sở báo cáo trong tuần (chỉ dành cho ai quan tâm)Số ngày duy nhất trong mỗi cơ sở-tuần có dữ liệu được báo cáoPhần trăm trong số 7 ngày mỗi cơ sở-tuần mà dữ liệu được báo cáoData frame được kết hợp bằng hàm right_join() thành một danh sách hoàn chỉnh về tất cả các kết hợp cơ sở-tuần có thể có, để làm cho tập dữ liệu hoàn thiện. Ma trận của tất cả các kết hợp có thể có được tạo bằng cách áp dụng hàm expand() cho hai cột đó của data frame giống như tại thời điểm đó trong chuỗi pipe (được biểu thị bằng .). Vì sử dụng hàm right_join(), nên tất cả các hàng trong data frame expand() mở rộng được giữ lại và được thêm vào agg_weeks nếu cần. Các hàng mới này xuất hiện với các giá trị tóm tắt NA (missing).Dưới đây là từng bước thực hiện:Bây giờ tập dữ liệu có số lượng hàng tính theo agg_week nrow(agg_weeks), trong khi trước được tính theo facility_count_data nrow(facility_count_data).Tiếp theo, chúng ta tạo cột tuần để phản ánh ngày bắt đầu trong tuần cho mỗi bản ghi. Thực hiện điều này với hàm floor_date () trong package lubridate, giúp thiết lập theo “tuần” và các tuần sẽ bắt đầu vào Thứ Hai (ngày 1 trong tuần - Chủ Nhật sẽ là 7). Các hàng đầu tiên được hiển thị như bên dưới.Cột tuần mới này có thể được nhìn thấy ở ngoài cùng bên phải của data frame được tạo ra:Bây giờ chúng ta nhóm dữ liệu thành các cơ sở-tuần và tóm tắt chúng để tạo ra số liệu thống kê cho mỗi cơ sở-tuần. Xem thêm chương Bảng mô tả để biết các mẹo. Bản thân việc nhóm sẽ không làm thay đổi data frame, nhưng nó ảnh hưởng đến cách các thống kê tóm tắt tiếp theo được tính toán.Các hàng đầu tiên được hiển thị bên dưới. Lưu ý cách các cột đã thay đổi hoàn toàn để phản ánh thống kê tóm tắt mong muốn. Mỗi hàng phản ánh một cơ sở-tuần.Cuối cùng, chúng ta chạy lệnh bên dưới để đảm bảo rằng TẤT CẢ các cơ sở-tuần có thể có trong dữ liệu, ngay cả khi chúng bị missing trước đó.Chúng ta đang sử dụng hàm right_join() trên chính nó (tập dữ liệu được thể hiện bởi dấu “.”) nhưng đã được mở rộng để bao gồm tất cả các kết hợp có thể có của các cột week và location_name. Xem tài liệu về hàm expand() trong chương Xoay trục dữ liệu. Trước khi chạy đoạn code này, tập dữ liệu cần chứa nrow(agg_weeks) hàng.Đây là expanded_weeks:TRước khi chạy dòng lệnh này, agg_weeks bao gồm nrow(agg_weeks) hàng.Sau khi chạy dòng lệnh này, agg_weeks vẫn bao gồm nrow(agg_weeks) hàng.","code":"\n# Create weekly summary dataset\nagg_weeks <- facility_count_data %>% \n  \n  # filter the data as appropriate\n  filter(\n    District == \"Spring\",\n    data_date < as.Date(\"2020-08-01\")) \nagg_weeks <- agg_weeks %>% \n  # Create week column from data_date\n  mutate(\n    week = lubridate::floor_date(                     # create new column of weeks\n      data_date,                                      # date column\n      unit = \"week\",                                  # give start of the week\n      week_start = 1))                                # weeks to start on Mondays \nagg_weeks <- agg_weeks %>%   \n\n  # Group into facility-weeks\n  group_by(location_name, week) %>%\n  \n  # Create summary statistics columns on the grouped data\n  summarize(\n    n_days          = 7,                                          # 7 days per week           \n    n_reports       = dplyr::n(),                                 # number of reports received per week (could be >7)\n    malaria_tot     = sum(malaria_tot, na.rm = T),                # total malaria cases reported\n    n_days_reported = length(unique(data_date)),                  # number of unique days reporting per week\n    p_days_reported = round(100*(n_days_reported / n_days)))      # percent of days reporting\n# Create data frame of every possible facility-week\nexpanded_weeks <- agg_weeks %>% \n  mutate(week = as.factor(week)) %>%         # convert date to a factor so expand() works correctly\n  tidyr::expand(., week, location_name) %>%  # expand data frame to include all possible facility-week combinations\n                                             # note: \".\" represents the dataset at that moment in the pipe chain\n  mutate(week = as.Date(week))               # re-convert week to class Date so the subsequent right_join works\n# Use a right-join with the expanded facility-week list to fill-in the missing gaps in the data\nagg_weeks <- agg_weeks %>%      \n  right_join(expanded_weeks) %>%                            # Ensure every possible facility-week combination appears in the data\n  mutate(p_days_reported = replace_na(p_days_reported, 0))  # convert missing values to 0                           ## Joining, by = c(\"location_name\", \"week\")"},{"path":"heatmaps.html","id":"tạo-biểu-đồ-nhiệt-1","chapter":"34 Biểu đồ nhiệt","heading":"Tạo biểu đồ nhiệt","text":"Hàm ggplot() được thực hiện bằng cách sử dụng hàm geom_tile() từ package ggplot2:Các tuần trên trục x được chuyển đổi thành ngày tháng, cho phép sử dụng scale_x_date()location_name trên trục y sẽ hiển thị tất cả các tên cơ sởfill được gán cho p_days_reported, hiệu suất cho cơ sở-tuần đó (dạng số)scale_fill_gradient() được sử dụng để tô màu cho biến dạng số, cụ thể màu sắc gồm cao, thấp và NAscale_x_date() được sử dụng trên trục x, chỉ định các nhãn 2 tuần một lần và định dạng của chúngCác chủ đề và nhãn hiển thị có thể được điều chỉnh khi cần thiết","code":""},{"path":"heatmaps.html","id":"cơ-bản","chapter":"34 Biểu đồ nhiệt","heading":"Cơ bản","text":"Biểu đồ nhiệt cơ bản sẽ được tạo như bên dưới, sử dụng màu, thang đo, v.v mặc định. Như đã giải thích ở trên, trong aes() của hàm geom_tile(), bạn phải cung cấp cột trục x, cột trục y, và một cột cho fill =. Phần tô là giá trị số thể hiện dưới dạng màu ô.","code":"\nggplot(data = agg_weeks)+\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported))"},{"path":"heatmaps.html","id":"làm-sạch-biểu-đồ-nhiệt","chapter":"34 Biểu đồ nhiệt","heading":"Làm sạch biểu đồ nhiệt","text":"Chúng ta có thể làm cho biểu đồ này trông đẹp hơn bằng cách thêm các hàm ggplot2 bổ sung, như được hiển thị bên dưới. Xem thêm chương Các tips với ggplot để biết thêm chi tiết.","code":"\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                  # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")"},{"path":"heatmaps.html","id":"sắp-xếp-thứ-tự-trục-y","chapter":"34 Biểu đồ nhiệt","heading":"Sắp xếp thứ tự trục y","text":"Hiện tại, các cơ sở được sắp xếp theo thứ tự “theo bảng chữ cái” từ dưới lên trên. Nếu bạn muốn điều chỉnh thứ tự các cơ sở trục y, hãy chuyển đổi chúng thành factor thứ bậc và cung cấp thứ tự. Xem thêm chương Factors để biết các mẹo để thực hiện điều này.Vì có rất nhiều cơ sở và chúng ta không muốn viết hết chúng ra, chúng ta sẽ thử một cách tiếp cận khác - sắp xếp thứ tự các cơ sở trong data frame và sử dụng cột tên kết quả làm thứ tự của factor. Bên dưới, cột location_name được chuyển đổi thành một factor và thứ tự của các cấp của nó được đặt dựa trên tổng số ngày báo cáo cơ sở nộp trong toàn bộ khoảng thời gian.Để làm điều này, chúng ta tạo một data frame đại diện cho tổng số báo cáo cho mỗi cơ sở, được sắp xếp theo thứ tự tăng dần. Chúng ta có thể sử dụng vectơ này để sắp xếp các mức thứ tự trong biểu đồ.Xem data frame bên dưới:Bây giờ, hãy sử dụng một cột từ data frame bên trên (facility_order$location_name) để trở thành thứ bậc factors của biến location_name trong data frame agg_weeks:Và bây giờ dữ liệu được vẽ lại, với location_name trở thành một factor có thứ tự:","code":"\nfacility_order <- agg_weeks %>% \n  group_by(location_name) %>% \n  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %>% \n  arrange(tot_reports) # ascending order\n# load package \npacman::p_load(forcats)\n\n# create factor and define levels manually\nagg_weeks <- agg_weeks %>% \n  mutate(location_name = fct_relevel(\n    location_name, facility_order$location_name)\n    )\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                  # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")"},{"path":"heatmaps.html","id":"biểu-diễn-các-giá-trị","chapter":"34 Biểu đồ nhiệt","heading":"Biểu diễn các giá trị","text":"Bạn có thể thêm lớp văn bản geom_text() lên phía trên các ô, để hiển thị số lượng thực của mỗi ô. Hãy lưu ý rằng điều này có thể trông không đẹp nếu bạn có nhiều ô nhỏ!Đoạn code sau đã được thêm vào: geom_text(aes(label = p_days_reported)). Điều này giúp thêm văn bản vào từng ô. Văn bản được hiển thị là giá trị được gán cho đối số label =, trong trường hợp này đã được đặt thành cùng một cột số p_days_reported cũng được sử dụng để tạo gradient màu.","code":"\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  # text\n  geom_text(\n    aes(\n      x = week,\n      y = location_name,\n      label = p_days_reported))+      # add text on top of tile\n  \n  # fill scale\n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                    # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")"},{"path":"heatmaps.html","id":"nguồn-9","chapter":"34 Biểu đồ nhiệt","heading":"34.4 Nguồn","text":"scale_fill_gradient()R graph gallery - heatmap","code":""},{"path":"diagrams.html","id":"diagrams","chapter":"35 Sơ đồ và biểu đồ","heading":"35 Sơ đồ và biểu đồ","text":"Chương này này bao gồm hướng dẫn sử dụng code để vẽ:Biểu đồ flow diagram bằng DiagrammeR và ngôn ngữ DOTBiểu đồ Alluvial/SankeyChuỗi sự kiện theo thời gian","code":""},{"path":"diagrams.html","id":"chuẩn-bị-27","chapter":"35 Sơ đồ và biểu đồ","heading":"35.1 Chuẩn bị","text":"","code":""},{"path":"diagrams.html","id":"gọi-packages-12","chapter":"35 Sơ đồ và biểu đồ","heading":"Gọi packages","text":"Đoạn code dưới đây hiển thị cách gọi các packages cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt gói nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() từ base R. Xem chương R Cơ bản để biết thêm thông tin về các package R.","code":"\npacman::p_load(\n  DiagrammeR,     # for flow diagrams\n  networkD3,      # For alluvial/Sankey diagrams\n  tidyverse)      # data management and visualization"},{"path":"diagrams.html","id":"nhập-dữ-liệu-19","chapter":"35 Sơ đồ và biểu đồ","heading":"Nhập dữ liệu","text":"Hầu hết nội dung trong chương này không yêu cầu bộ dữ liệu. Tuy nhiên, trong phần sơ đồ Sankey, chúng ta sẽ sử dụng bộ dữ liệu linelist từ một vụ dịch Ebola mô phỏng. Để tiện theo dõi, hãy bấm để tải bộ dữ liệu linelist “đã làm sạch” ở đây (.rds file). Nhập dữ liệu bằng hàm import () từ package rio (có thể xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương Nhập xuất dữ liệu để biết chi tiết).50 hàng đầu tiên của linelist được hiển thị bên dưới:","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"diagrams.html","id":"sơ-đồ-flow","chapter":"35 Sơ đồ và biểu đồ","heading":"35.2 Sơ đồ flow","text":"Chúng ta có thể sử dụng package R DiagrammeR để vẽ biểu đồ/sơ đồ flow. Chúng có thể là sơ đồ tĩnh hoặc có động dựa thay đổi theo những thay đổi trong tập dữ liệu.Công cụHàm grViz() được sử dụng để tạo sơ đồ “Graphviz”. Hàm này chấp nhận một chuỗi ký tự đầu vào chứa các hướng dẫn để tạo sơ đồ. Trong chuỗi đó, các hướng dẫn được viết bằng một ngôn ngữ khác, được gọi là ngôn ngữ DOT - khá dễ dàng để học những điều cơ bản.Cấu trúc cơ bảnMở hướng dẫn grViz(\"Chỉ định hướng và tên của biểu đồ, đồng thời mở ngoặc, vd: digraph my_flow_chart {Câu lệnh biểu đồ (bố cục, hướng sắp xếp các biến số)Câu lệnh nút (tạo nút)Câu lệnh Edges (cung cấp liên kết giữa các nút)Đóng các hướng dẫn }\")","code":""},{"path":"diagrams.html","id":"ví-dụ-đơn-giản-1","chapter":"35 Sơ đồ và biểu đồ","heading":"Ví dụ đơn giản","text":"Dưới đây là hai ví dụ đơn giảnMột ví dụ rất đơn giản:Một ví dụ khác áp dụng trong y tế công cộng:","code":"\n# A minimal plot\nDiagrammeR::grViz(\"digraph {\n  \ngraph[layout = dot, rankdir = LR]\n\na\nb\nc\n\na -> b -> c\n}\")\ngrViz(\"                           # All instructions are within a large character string\ndigraph surveillance_diagram {    # 'digraph' means 'directional graph', then the graph name \n  \n  # graph statement\n  #################\n  graph [layout = dot,\n         rankdir = TB,\n         overlap = true,\n         fontsize = 10]\n  \n  # nodes\n  #######\n  node [shape = circle,           # shape = circle\n       fixedsize = true\n       width = 1.3]               # width of circles\n  \n  Primary                         # names of nodes\n  Secondary\n  Tertiary\n\n  # edges\n  #######\n  Primary   -> Secondary [label = ' case transfer']\n  Secondary -> Tertiary [label = ' case transfer']\n}\n\")"},{"path":"diagrams.html","id":"cú-pháp","chapter":"35 Sơ đồ và biểu đồ","heading":"Cú pháp","text":"Cú pháp cơ bảnTên nút hoặc biểu thức cạnh, có thể được phân tách bằng dấu cách, dấu chấm phẩy hoặc dòng mới.Điều hướngMột biểu đồ có thể được định hướng lại để di chuyển từ trái sang phải bằng cách điều chỉnh đối số rankdir trong câu lệnh biểu đồ. Mặc định là TB (từ trên xuống dưới), nhưng nó có thể là LR (trái sang phải), RL hoặc BT.Tên nútTên nút có thể là các từ đơn, như trong ví dụ đơn giản ở trên. Để sử dụng tên nhiều từ hoặc các ký tự đặc biệt (ví dụ: dấu ngoặc đơn, dấu gạch ngang), hãy đặt tên nút trong dấu ngoặc đơn (’ ’). Có thể dễ dàng hơn để có một tên nút ngắn và gán một nhãn, như được hiển thị bên dưới trong dấu ngoặc vuông [ ]. Nếu bạn muốn có một dòng mới trong tên của nút, bạn phải thực hiện điều đó thông qua một nhãn - sử dụng \\n trong nhãn của nút trong bên dấu ngoặc kép, như được trình bày bên dưới.Nhóm phụTrong các biểu thức cạnh, nhóm phụ có thể được tạo ở hai bên của cạnh bằng dấu ngoặc nhọn ({ }). Sau đó, cạnh áp dụng cho tất cả các nút trong dấu ngoặc - nó là cách viết tắt.Bố cụcdot (đặt đối số rankdir cho một trong các giá trị sau TB, LR, RL, BT, )neatotwopicircoNút - có thể chỉnh sửalabel (ký tự, trong dấu ngoặc kép nếu nhiều từ)fillcolor (nhiều màu)width shape borderfontcoloralpha (độ trong suốt 0-1)shape (hình elip, hình bầu dục, kim cương, trứng, bản rõ, điểm, hình vuông, hình tam giác)stylesidesperipheriesfixedsize (h x w)heightwidthdistortionpenwidth (độ dày của đường viền)x (dịch chuyển trái/phải)y (dịch chuyển lên/xuống )fontnamefontsizeiconCác cạnh - có thể chỉnh sửaarrowsizearrowhead (normal, box, crow, curve, diamond, dot, inv, none, tee, vee)arrowtaildir (điều hướng, )style (gạch ngang, …)coloralphaheadport (văn bản phía trước đầu mũi tên )tailport (văn bản phía sau đuôi mũi tên)fontnamefontsizefontcolorpenwidth (độ dày của mũi tên)minlen (chiều dài tối thiểu)Tên màu: mã màu theo bảng mã hex hoặc tên màu ‘X11’, xem tại đây để biết thông tin chi tiết về X11","code":""},{"path":"diagrams.html","id":"ví-dụ-phức-tạp","chapter":"35 Sơ đồ và biểu đồ","heading":"Ví dụ phức tạp","text":"Ví dụ dưới đây mở rộng trên một sơ đồ giám sát, thêm các tên nút phức tạp, các cạnh được nhóm lại, màu sắc và styleCác cụm biểu đồ phụĐể nhóm các nút thành các cụm có khung, hãy đặt chúng trong cùng một đồ thị con được đặt tên (subgraph name {}). Để xác định từng đồ thị con trong một khung giới hạn, hãy bắt đầu tên của đồ thị con bằng “cluster”, như được trình bày ở 4 khung bên dưới.Hình dạng nútVí dụ dưới đây, tham khảo từtài liệu trực tuyến này, hiển thị các hình dạng nút được áp dụng và cách viết tắt cho các kết nối cạnh nối tiếp.","code":"DiagrammeR::grViz(\"               # All instructions are within a large character string\ndigraph surveillance_diagram {    # 'digraph' means 'directional graph', then the graph name \n  \n  # graph statement\n  #################\n  graph [layout = dot,\n         rankdir = TB,            # layout top-to-bottom\n         fontsize = 10]\n  \n\n  # nodes (circles)\n  #################\n  node [shape = circle,           # shape = circle\n       fixedsize = true\n       width = 1.3]                      \n  \n  Primary   [label = 'Primary\\nFacility'] \n  Secondary [label = 'Secondary\\nFacility'] \n  Tertiary  [label = 'Tertiary\\nFacility'] \n  SC        [label = 'Surveillance\\nCoordination',\n             fontcolor = darkgreen] \n  \n  # edges\n  #######\n  Primary   -> Secondary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  Secondary -> Tertiary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  \n  # grouped edge\n  {Primary Secondary Tertiary} -> SC [label = 'case reporting',\n                                      fontcolor = darkgreen,\n                                      color = darkgreen,\n                                      style = dashed]\n}\n\")DiagrammeR::grViz(\"             # All instructions are within a large character string\ndigraph surveillance_diagram {  # 'digraph' means 'directional graph', then the graph name \n  \n  # graph statement\n  #################\n  graph [layout = dot,\n         rankdir = TB,            \n         overlap = true,\n         fontsize = 10]\n  \n\n  # nodes (circles)\n  #################\n  node [shape = circle,                  # shape = circle\n       fixedsize = true\n       width = 1.3]                      # width of circles\n  \n  subgraph cluster_passive {\n    Primary   [label = 'Primary\\nFacility'] \n    Secondary [label = 'Secondary\\nFacility'] \n    Tertiary  [label = 'Tertiary\\nFacility'] \n    SC        [label = 'Surveillance\\nCoordination',\n               fontcolor = darkgreen] \n  }\n  \n  # nodes (boxes)\n  ###############\n  node [shape = box,                     # node shape\n        fontname = Helvetica]            # text font in node\n  \n  subgraph cluster_active {\n    Active [label = 'Active\\nSurveillance'] \n    HCF_active [label = 'HCF\\nActive Search']\n  }\n  \n  subgraph cluster_EBD {\n    EBS [label = 'Event-Based\\nSurveillance (EBS)'] \n    'Social Media'\n    Radio\n  }\n  \n  subgraph cluster_CBS {\n    CBS [label = 'Community-Based\\nSurveillance (CBS)']\n    RECOs\n  }\n\n  \n  # edges\n  #######\n  {Primary Secondary Tertiary} -> SC [label = 'case reporting']\n\n  Primary   -> Secondary [label = 'case transfer',\n                          fontcolor = red]\n  Secondary -> Tertiary [label = 'case transfer',\n                          fontcolor = red]\n  \n  HCF_active -> Active\n  \n  {'Social Media' Radio} -> EBS\n  \n  RECOs -> CBS\n}\n\")\n\nDiagrammeR::grViz(\"digraph {\n\ngraph [layout = dot, rankdir = LR]\n\n# define the global styles of the nodes. We can override these in box if we wish\nnode [shape = rectangle, style = filled, fillcolor = Linen]\n\ndata1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]\ndata2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]\nprocess [label =  'Process \\n Data']\nstatistical [label = 'Statistical \\n Analysis']\nresults [label= 'Results']\n\n# edge definitions with the node IDs\n{data1 data2}  -> process -> statistical -> results\n}\")"},{"path":"diagrams.html","id":"kết-quả-đầu-ra","chapter":"35 Sơ đồ và biểu đồ","heading":"Kết quả đầu ra","text":"Cách xử lý và lưu kết quả đầu raKết quả đầu ra sẽ xuất hiện trong cửa sổ RStudio’s Viewer, theo mặc định ở phía dưới bên phải cùng với các mục Files, Plots, Packages, và Help.Để xuất, bạn có thể chọn “Save image” để lưu dưới dạng ảnh hoặc “Copy clipboard” để sao chép vào bộ nhớ tạm từ Viewer. Hình ảnh sẽ điều chỉnh theo kích thước được chỉ định.","code":""},{"path":"diagrams.html","id":"đồ-thị-được-tham-số-hóa","chapter":"35 Sơ đồ và biểu đồ","heading":"Đồ thị được tham số hóa","text":"Mục này được trích dẫn từ nguồn sau: https://mikeyharper.uk/flowcharts--r-using-diagrammer/“Các biểu đồ được tham số hóa: Lợi ích tuyệt vời của việc thiết kế các đồ thị trong R là chúng ta có thể kết nối các đồ thị trực tiếp với phân tích của mình bằng cách đọc các giá trị R trực tiếp vào flowchart của chúng ta. Ví dụ: giả sử bạn đã tạo một quy trình lọc để loại bỏ các giá trị sau mỗi giai đoạn của một quy trình, bạn có thể có một đồ thị hiển thị số lượng giá trị còn lại trong tập dữ liệu sau mỗi giai đoạn trong quy trình của bạn. Để làm điều này, chúng ta có thể sử dụng ký hiệu @@X trực tiếp trong đồ thị, sau đó tham chiếu tới footer của biểu đồ bằng cách sử dụng [X]:, trong đó X là chỉ số số duy nhất.”Chúng tôi khuyến khích bạn xem lại hướng dẫn này nếu tham số hóa là điều bạn quan tâm.","code":""},{"path":"diagrams.html","id":"sơ-đồ-alluvialsankey-1","chapter":"35 Sơ đồ và biểu đồ","heading":"35.3 Sơ đồ Alluvial/Sankey","text":"","code":""},{"path":"diagrams.html","id":"gọi-packages-13","chapter":"35 Sơ đồ và biểu đồ","heading":"Gọi packages","text":"Đoạn code dưới đây hiển thị cách gọi các packages cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt gói nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() từ base R. Xem chương R Cơ bản để biết thêm thông tin về các package R.Chúng ta gọi package networkD3 để vẽ sơ đồ và package tidyverse cho các bước chuẩn bị dữ liệu.","code":"\npacman::p_load(\n  networkD3,\n  tidyverse)"},{"path":"diagrams.html","id":"vẽ-đồ-thị-từ-một-tập-dữ-liệu","chapter":"35 Sơ đồ và biểu đồ","heading":"Vẽ đồ thị từ một tập dữ liệu","text":"Vẽ những mối liên quan trong một tập dữ liệu. Dưới đây, chúng tôi minh họa việc sử dụng package này với bộ số liệu linelist. Hãy đọc thêm hướng dẫn trực tuyến sau..Chúng ta sẽ bắt đầu bằng cách lấy số lượng các trường hợp theo sự kết hợp của nhóm tuổi và bệnh viện. Chúng ta cũng xóa các giá trị thiếu nhóm tuổi để làm sạch. Chúng ta cũng gắn lại nhãn các cột hospital và cột age_cat tương ứng là source và target. Đây sẽ là hai mặt của sơ đồ Alluvial.Tập dữ liệu bây giờ trông như thế này:Bây giờ chúng ta tạo một data frame cho tất cả các nút của sơ đồ, dưới cột name. Điều này bao gồm tất cả các giá trị cho cột hospital và cột age_cat. Lưu ý rằng chúng ta cần đảm bảo tất cả chúng đều có kiểu Ký tự trước khi kết hợp chúng và điều chỉnh cột ID thành dạng số thay vì dạng nhãn:Chúng ta tiếp tục chỉnh sửa data frame có tên links mà chúng ta đã tạo ở trên với hàm count(). Chúng ta thêm hai cột dạng số là cột IDsource và IDtarget để thực sự phản ánh/tạo liên kết giữa các nút. Các cột này sẽ giữ số thứ tự hàng (vị trí) của nút nguồn và nút đích. Số 1 sẽ bị trừ để các số vị trí này bắt đầu bằng 0 (không phải 1).Tập dữ liệu link bây giờ trông như sau:Bây giờ, chúng ta vẽ sơ đồ Sankey với hàm sankeyNetwork(). Bạn có thể đọc thêm về từng đối số bằng cách chạy lệnh ?sankeyNetwork trong bảng điều khiển. Lưu ý rằng trừ khi bạn đặt iterations = 0, thứ tự các nút của bạn có thể sẽ không như bạn mong đợi.Đây là một ví dụ trong đó Kết quả của bệnh nhân cũng được bao gồm. Lưu ý trong bước chuẩn bị dữ liệu, chúng ta phải tính toán số lượng các trường hợp giữa tuổi và bệnh viện, và phân biệt biệt giữa bệnh viện và outcome - sau đó liên kết tất cả các số lượng này với nhau bằng hàm bind_rows().https://www.displayr.com/sankey-diagrams-r/","code":"\n# counts by hospital and age category\nlinks <- linelist %>% \n  drop_na(age_cat) %>% \n  select(hospital, age_cat) %>%\n  count(hospital, age_cat) %>% \n  rename(source = hospital,\n         target = age_cat)\n# The unique node names\nnodes <- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %>% \n    unique()\n  )\n\nnodes  # print##                                    name\n## 1                      Central Hospital\n## 2                     Military Hospital\n## 3                               Missing\n## 4                                 Other\n## 5                         Port Hospital\n## 6  St. Mark's Maternity Hospital (SMMH)\n## 7                                   0-4\n## 8                                   5-9\n## 9                                 10-14\n## 10                                15-19\n## 11                                20-29\n## 12                                30-49\n## 13                                50-69\n## 14                                  70+\n# match to numbers, not names\nlinks$IDsource <- match(links$source, nodes$name)-1 \nlinks$IDtarget <- match(links$target, nodes$name)-1\n# plot\n######\np <- sankeyNetwork(\n  Links = links,\n  Nodes = nodes,\n  Source = \"IDsource\",\n  Target = \"IDtarget\",\n  Value = \"n\",\n  NodeID = \"name\",\n  units = \"TWh\",\n  fontSize = 12,\n  nodeWidth = 30,\n  iterations = 0)        # ensure node order is as in data\np\n# counts by hospital and age category\nage_hosp_links <- linelist %>% \n  drop_na(age_cat) %>% \n  select(hospital, age_cat) %>%\n  count(hospital, age_cat) %>% \n  rename(source = age_cat,          # re-name\n         target = hospital)\n\nhosp_out_links <- linelist %>% \n    drop_na(age_cat) %>% \n    select(hospital, outcome) %>% \n    count(hospital, outcome) %>% \n    rename(source = hospital,       # re-name\n           target = outcome)\n\n# combine links\nlinks <- bind_rows(age_hosp_links, hosp_out_links)\n\n# The unique node names\nnodes <- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %>% \n    unique()\n  )\n\n# Create id numbers\nlinks$IDsource <- match(links$source, nodes$name)-1 \nlinks$IDtarget <- match(links$target, nodes$name)-1\n\n# plot\n######\np <- sankeyNetwork(Links = links,\n                   Nodes = nodes,\n                   Source = \"IDsource\",\n                   Target = \"IDtarget\",\n                   Value = \"n\",\n                   NodeID = \"name\",\n                   units = \"TWh\",\n                   fontSize = 12,\n                   nodeWidth = 30,\n                   iterations = 0)\np"},{"path":"diagrams.html","id":"chuỗi-sự-kiện-trong-thời-gian","chapter":"35 Sơ đồ và biểu đồ","heading":"35.4 Chuỗi sự kiện trong thời gian","text":"Để tạo dòng thời gian hiển thị các sự kiện cụ thể, bạn có thể sử dụng package vistime.Xem thêm vignette nàyĐây là tập dữ liệu mà chúng ta sẽ bắt đầu sử dụng:","code":"\n# load package\npacman::p_load(vistime,  # make the timeline\n               plotly    # for interactive visualization\n               )\np <- vistime(data)    # apply vistime\n\nlibrary(plotly)\n\n# step 1: transform into a list\npp <- plotly_build(p)## Warning: `arrange_()` was deprecated in dplyr 0.7.0.\n## Please use `arrange()` instead.\n## See vignette('programming') for more help\n# step 2: Marker size\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"markers\") pp$x$data[[i]]$marker$size <- 10\n}\n\n# step 3: text size\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textfont$size <- 10\n}\n\n\n# step 4: text position\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textposition <- \"right\"\n}\n\n#print\npp"},{"path":"diagrams.html","id":"sơ-đồ-dags","chapter":"35 Sơ đồ và biểu đồ","heading":"35.5 Sơ đồ DAGs","text":"Bạn có thể tạo sơ đồ DAG theo cách thủ công bằng cách sử dụng package DiagammeR và ngôn ngữ DOT như đã mô tả ở trên.Ngoài ra, có các package như ggdag và daggityGiới thiệu về sơ đồ DAGsSuy luận nhân quả với dags trong R","code":""},{"path":"diagrams.html","id":"tài-nguyên-học-liệu-13","chapter":"35 Sơ đồ và biểu đồ","heading":"35.6 Tài nguyên học liệu","text":"Phần lớn nội dung ở trên liên quan đến ngôn ngữ DOT được tham khảo từ hướng dẫn nàyMột tài liệu khác chuyên sâu hơn tại đây Tài liệu về DiagammeRXem thêm về Sơ đồ Sankey tại đây","code":""},{"path":"combination-analysis.html","id":"combination-analysis","chapter":"36 Biểu đồ kết hợp","heading":"36 Biểu đồ kết hợp","text":"Phân tích này vẽ biểu đồ tần suất của các kết hợp giá trị/phản hồi khác nhau. Trong ví dụ này, chúng ta sẽ vẽ biểu đồ tần suất các trường hợp có biểu hiện kết hợp nhiều triệu chứng khác nhau.Phân tích này còn thường được gọi bằng những tên khác như:“Phân tích nhiều lựa chọn”“Phân tích các bộ (sets)”“Phân tích kết hợp”Trong biểu đồ minh họa bên trên, năm triệu chứng được trình bày. Bên dưới mỗi thanh dọc là một đường và dấu chấm biểu thị sự kết hợp của các triệu chứng được phản ánh bởi thanh ở trên. Ở bên trái, các thanh ngang phản ánh tần suất của từng triệu chứng riêng lẻ.Phương pháp đầu tiên chúng tôi sẽ trình bày sử dụng package ggupset, phương pháp thứ hai sử dụng package UpSetR.","code":""},{"path":"combination-analysis.html","id":"chuẩn-bị-28","chapter":"36 Biểu đồ kết hợp","heading":"36.1 Chuẩn bị","text":"","code":""},{"path":"combination-analysis.html","id":"gọi-package-10","chapter":"36 Biểu đồ kết hợp","heading":"Gọi package","text":"Đoạn code này hiển thị việc gọi các gói cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package nếu cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.","code":"\npacman::p_load(\n  tidyverse,     # data management and visualization\n  UpSetR,        # special package for combination plots\n  ggupset)       # special package for combination plots"},{"path":"combination-analysis.html","id":"nhập-dữ-liệu-20","chapter":"36 Biểu đồ kết hợp","heading":"Nhập dữ liệu","text":"Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết.Bộ số liệu linelist bao gồm năm biến “có/không” về các triệu chứng được ghi nhận. Chúng ta sẽ cần phải biến đổi các biến số này một chút trước khi sử dụng package ggupset để tạo biểu đồ. Xem dữ liệu (cuộn sang phải để xem các biến triệu chứng).","code":"\n# import case linelist \nlinelist_sym <- import(\"linelist_cleaned.rds\")"},{"path":"combination-analysis.html","id":"định-dạng-lại-giá-trị","chapter":"36 Biểu đồ kết hợp","heading":"Định dạng lại giá trị","text":"Để tương đồng với định dạng của package ggupset, chúng ta cần đổi giá trị “yes” và “” thành tên các triệu chứng thực tế, sử dụng hàm case_when() từ package dplyr. Nếu giá trị là “”, chúng ta sẽ bỏ trống, nghĩa là biến mới sẽ có giá trị hoặc là NA hoặc là triệu chứng.Bây giờ chúng ta tạo hai cột cuối cùng:Kết hợp (ghép lại với nhau) tất cả các triệu chứng của bệnh nhân (thành một cột ký tự)Chuyển đổi định dạng cột bên trên thành kiểu danh sách để được chấp nhận bởi package ggupset khi vẽ biểu đồXem thêm chương Ký tự và chuỗi để biết thêm về hàm unite() trong package stringrBây giờ chúng ta cùng xem dữ liệu mới. Lưu ý hai cột ở cuối bên phải - các giá trị kết hợp được ghép và danh sách","code":"\n# create column with the symptoms named, separated by semicolons\nlinelist_sym_1 <- linelist_sym %>% \n  \n  # convert the \"yes\" and \"no\" values into the symptom name itself\n  mutate(\n    fever = case_when(\n      fever == \"yes\" ~ \"fever\",          # if old value is \"yes\", new value is \"fever\"\n      TRUE           ~ NA_character_),   # if old value is anything other than \"yes\", the new value is NA\n         \n    chills = case_when(\n       chills == \"yes\" ~ \"chills\",\n       TRUE           ~ NA_character_),\n    \n    cough = case_when(\n      cough == \"yes\" ~ \"cough\",\n      TRUE           ~ NA_character_),\n         \n    aches = case_when(\n      aches == \"yes\" ~ \"aches\",\n      TRUE           ~ NA_character_),\n         \n    vomit = case_when(\n      vomit == \"yes\" ~ \"vomit\",\n      TRUE           ~ NA_character_)\n    )\nlinelist_sym_1 <- linelist_sym_1 %>% \n  unite(col = \"all_symptoms\",\n        c(fever, chills, cough, aches, vomit), \n        sep = \"; \",\n        remove = TRUE,\n        na.rm = TRUE) %>% \n  mutate(\n    # make a copy of all_symptoms column, but of class \"list\" (which is required to use ggupset() in next step)\n    all_symptoms_list = as.list(strsplit(all_symptoms, \"; \"))\n    )"},{"path":"combination-analysis.html","id":"ggupset","chapter":"36 Biểu đồ kết hợp","heading":"36.2 ggupset","text":"Gọi packageVẽ biểu đồ. Chúng ta bắt đầu bằng hàm ggplot() và geom_bar(), nhưng sau đó chúng ta thêm hàm đặc biệt scale_x_upset() từ package ggupset.Bạn có thể đọc thêm về package ggupset ở tài liệu online này hoặc trong tài liệu trợ giúp của package bằng cách gõ vào cửa RStudio Help lệnh ?ggupset.","code":"\npacman::p_load(ggupset)\nggplot(\n  data = linelist_sym_1,\n  mapping = aes(x = all_symptoms_list)) +\ngeom_bar() +\nscale_x_upset(\n  reverse = FALSE,\n  n_intersections = 10,\n  sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"))+\nlabs(\n  title = \"Signs & symptoms\",\n  subtitle = \"10 most frequent combinations of signs and symptoms\",\n  caption = \"Caption here.\",\n  x = \"Symptom combination\",\n  y = \"Frequency in dataset\")"},{"path":"combination-analysis.html","id":"upsetr","chapter":"36 Biểu đồ kết hợp","heading":"36.3 UpSetR","text":"Package UpSetR cho phép tùy chỉnh biểu đồ sâu hơn, nhưng nó cũng khó thực hiện hơn:Gọi packageLàm sạch dữ liệuChúng ta phải chuyển đổi các triệu chứng trong bộ dữ liệu linelist thành các giá trị 1 / 0.Bây giờ chúng ta hãy vẽ biểu đồ bằng hàm tùy chỉnh upset() - chỉ sử dụng các cột triệu chứng. Bạn phải chỉ định “bộ” nào để sánh (tên của các cột triệu chứng). Một cách khác, sử dụng nsets = và order.= \"freq\" để chỉ hiện thị X các sự kết hợp nhiều nhất.","code":"\npacman::p_load(UpSetR)\n# Make using upSetR\n\nlinelist_sym_2 <- linelist_sym %>% \n  \n  # convert the \"yes\" and \"no\" values into the symptom name itself\n  mutate(\n    fever = case_when(\n      fever == \"yes\" ~ 1,    # if old value is \"yes\", new value is 1\n      TRUE           ~ 0),   # if old value is anything other than \"yes\", the new value is 0\n         \n    chills = case_when(\n      chills == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    cough = case_when(\n      cough == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    aches = case_when(\n      aches == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    vomit = case_when(\n      vomit == \"yes\" ~ 1,\n      TRUE           ~ 0)\n    )\n# Make the plot\nUpSetR::upset(\n  select(linelist_sym_2, fever, chills, cough, aches, vomit),\n  sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"),\n  order.by = \"freq\",\n  sets.bar.color = c(\"blue\", \"red\", \"yellow\", \"darkgreen\", \"orange\"), # optional colors\n  empty.intersections = \"on\",\n  # nsets = 3,\n  number.angles = 0,\n  point.size = 3.5,\n  line.size = 2, \n  mainbar.y.label = \"Symptoms Combinations\",\n  sets.x.label = \"Patients with Symptom\")"},{"path":"combination-analysis.html","id":"nguồn-10","chapter":"36 Biểu đồ kết hợp","heading":"36.4 Nguồn","text":"github page UpSetRA Shiny App version - can upload data*documentation - difficult interpret","code":""},{"path":"transmission-chains.html","id":"transmission-chains","chapter":"37 Chuỗi lây nhiễm","heading":"37 Chuỗi lây nhiễm","text":"","code":""},{"path":"transmission-chains.html","id":"tổng-quan-7","chapter":"37 Chuỗi lây nhiễm","heading":"37.1 Tổng quan","text":"Công cụ chính để xử lý, phân tích và trực quan hóa chuỗi lây nhiễm và dữ liệu theo dõi tiếp xúc là package epicontacts, được phát triển bởi những chuyên gia làm việc tại RECON. Hãy thử biểu đồ tương tác bên dưới bằng cách di chuột qua các nút để biết thêm thông tin, kéo-thả để di chuyển chúng và nhấp vào chúng để đánh dấu các trường hợp phía dưới.","code":""},{"path":"transmission-chains.html","id":"chuẩn-bị-29","chapter":"37 Chuỗi lây nhiễm","heading":"37.2 Chuẩn bị","text":"","code":""},{"path":"transmission-chains.html","id":"gọi-packages-14","chapter":"37 Chuỗi lây nhiễm","heading":"Gọi packages","text":"Đầu tiên hãy tải các package tiêu chuẩn cần thiết để nhập và xử lý dữ liệu. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, sẽ cài đặt package nếu cần và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các package bằng hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.Bạn sẽ sử dụng phiên bản phát triển của epicontacts, có thể được cài đặt từ github bằng cách sử dụng hàm p_install_github() từ package pacman. Bạn chỉ cần chạy lệnh này dưới đây một lần, không phải bất cứ khi nào bạn sử dụng package (sau đó, bạn có thể sử dụng hàm p_load() như bình thường).","code":"\npacman::p_load(\n   rio,          # File import\n   here,         # File locator\n   tidyverse,    # Data management + ggplot2 graphics\n   remotes       # Package installation from github\n)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")"},{"path":"transmission-chains.html","id":"nhập-dữ-liệu-21","chapter":"37 Chuỗi lây nhiễm","heading":"Nhập dữ liệu","text":"Chúng ta nhập bộ dữ liệu về các trường hợp bệnh từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải xuống dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương Tải sách và dữ liệu. Bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau.50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị bên dưới. Mối quan tâm đặc biệt là các cột case_id, generation, infector, và source.","code":"\n# import the linelist\nlinelist <- import(\"linelist_cleaned.xlsx\")"},{"path":"transmission-chains.html","id":"tạo-đối-tượng-epicontacts","chapter":"37 Chuỗi lây nhiễm","heading":"Tạo đối tượng epicontacts","text":"Sau đó, chúng ta cần tạo một đối tượng epicontacts, với yêu cầu hai kiểu dữ liệu như sau:Một bộ dữ liệu linelist ghi lại các trường hợp trong đó các cột là các biến và các hàng tương ứng với các trường hợp duy nhấtMột danh sách các cạnh (edge) thể hiện liên kết giữa các quan sát trên ID duy nhất (có thể là liên hệ, sự kiện lây nhiễm, v.v.)Bởi vì chúng ta đã có sẵn bộ dữ liệu linelist, chúng ta chỉ cần tạo một danh sách các đường liên kết giữa các trường hợp, cụ thể hơn là giữa các ID. Chúng ta có thể trích xuất các đường liên kết lây nhiễm từ bộ số liệu linelist bằng cách liên kết cột infector với cột case_id. Tại đây, chúng ta cũng có thể thêm các “thuộc tính cạnh - edge properties”, nghĩa là bất kỳ biến nào mô tả mối liên kết giữa hai trường hợp, không phải bản thân các trường hợp đó. Để minh họa, chúng ta sẽ thêm một biến location mô tả vị trí của sự kiện truyền nhiễm và một biến mô tả khoảng thời gian tiếp xúc tính bằng ngày.Trong đoạn code dưới đây, hàm transmute thuộc package dplyr tương tự như hàm mutate, ngoại trừ nó chỉ giữ các cột mà chúng ta đã chỉ định trong hàm. Hàm drop_na sẽ lọc ra bất kỳ hàng nào mà các cột được chỉ định có giá trị NA ; trong trường hợp này, chúng ta chỉ muốn giữ lại các hàng mà tác nhân lây nhiễm đã biết.Bây giờ chúng ta có thể tạo đối tượng epicontacts bằng cách sử dụng hàm make_epicontacts. Chúng ta cần chỉ định cột trong bộ dữ liệu linelist trỏ đến mã định danh trường hợp duy nhất (ID), cũng như cột trong điểm tiếp xúc tới mã định danh duy nhất của các trường hợp có liên quan trong mỗi liên kết. Các liên kết này có tính định hướng, nghĩa là việc lây nhiễm sẽ đi từ người lây nhiễm đến ca bệnh, vì vậy chúng ta cần chỉ định các đối số và cho phù hợp. Chúng ta cũng đặt đối số directed thành TRUE, điều này sẽ ảnh hưởng đến các hoạt động về sau.Sau khi kiểm tra các đối tượng epicontacts, chúng ta có thể thấy rằng cột case_id trong bộ dữ liệu linelist đã được đổi tên thành id và các cột case_id và cột infector trong liên hệ đã được đổi tên thành và . Điều này đảm bảo tính nhất quán trong các hoạt động xử lý, trực quan và phân tích tiếp theo.","code":"\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %>%\n  drop_na(infector)\n## generate epicontacts object\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n## view epicontacts object\nepic## \n## /// Epidemiological Contacts //\n## \n##   // class: epicontacts\n##   // 5,888 cases in linelist; 3,800 contacts; directed \n## \n##   // linelist\n## \n## # A tibble: 5,888 x 30\n##    id     generation date_infection date_onset date_hospitalis~ date_outcome outcome gender   age age_unit age_years age_cat age_cat5 hospital    lon   lat infector source\n##    <chr>       <dbl> <date>         <date>     <date>           <date>       <chr>   <chr>  <dbl> <chr>        <dbl> <fct>   <fct>    <chr>     <dbl> <dbl> <chr>    <chr> \n##  1 5fe599          4 2014-05-08     2014-05-13 2014-05-15       NA           <NA>    m          2 years            2 0-4     0-4      Other     -13.2  8.47 f547d6   other \n##  2 8689b7          4 NA             2014-05-13 2014-05-14       2014-05-18   Recover f          3 years            3 0-4     0-4      Missing   -13.2  8.45 <NA>     <NA>  \n##  3 11f8ea          2 NA             2014-05-16 2014-05-18       2014-05-30   Recover m         56 years           56 50-69   55-59    St. Mark~ -13.2  8.46 <NA>     <NA>  \n##  4 b8812a          3 2014-05-04     2014-05-18 2014-05-20       NA           <NA>    f         18 years           18 15-19   15-19    Port Hos~ -13.2  8.48 f90f5f   other \n##  5 893f25          3 2014-05-18     2014-05-21 2014-05-22       2014-05-29   Recover m          3 years            3 0-4     0-4      Military~ -13.2  8.46 11f8ea   other \n##  6 be99c8          3 2014-05-03     2014-05-22 2014-05-23       2014-05-24   Recover f         16 years           16 15-19   15-19    Port Hos~ -13.2  8.46 aec8ec   other \n##  7 07e3e8          4 2014-05-22     2014-05-27 2014-05-29       2014-06-01   Recover f         16 years           16 15-19   15-19    Missing   -13.2  8.46 893f25   other \n##  8 369449          4 2014-05-28     2014-06-02 2014-06-03       2014-06-07   Death   f          0 years            0 0-4     0-4      Missing   -13.2  8.46 133ee7   other \n##  9 f393b4          4 NA             2014-06-05 2014-06-06       2014-06-18   Recover m         61 years           61 50-69   60-64    Missing   -13.2  8.46 <NA>     <NA>  \n## 10 1389ca          4 NA             2014-06-05 2014-06-07       2014-06-09   Death   f         27 years           27 20-29   25-29    Missing   -13.3  8.47 <NA>     <NA>  \n## # ... with 5,878 more rows, and 12 more variables: wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>, temp <dbl>,\n## #   time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>\n## \n##   // contacts\n## \n## # A tibble: 3,800 x 4\n##    from   to     location   duration\n##    <chr>  <chr>  <chr>         <int>\n##  1 f547d6 5fe599 Community        10\n##  2 f90f5f b8812a Nosocomial        4\n##  3 11f8ea 893f25 Nosocomial        3\n##  4 aec8ec be99c8 Nosocomial       10\n##  5 893f25 07e3e8 Community         8\n##  6 133ee7 369449 Nosocomial        6\n##  7 996f3a 2978ac Nosocomial        5\n##  8 133ee7 57a565 Community         8\n##  9 37a6f6 fc15ef Community        10\n## 10 9f6884 2eaa9a Nosocomial       10\n## # ... with 3,790 more rows"},{"path":"transmission-chains.html","id":"xử-lý","chapter":"37 Chuỗi lây nhiễm","heading":"37.3 Xử lý","text":"","code":""},{"path":"transmission-chains.html","id":"chia-nhỏ-bộ-dữ-liệu","chapter":"37 Chuỗi lây nhiễm","heading":"Chia nhỏ bộ dữ liệu","text":"Phương thức subset() cho các đối tượng epicontacts cho phép lọc các mạng lưới dựa trên các thuộc tính của bộ dữ liệu linelist (“thuộc tính nút”) và cơ sở dữ liệu tiếp xýc (“thuộc tính cạnh”). Các giá trị này phải được chuyển đổi dưới dạng danh sách đã đặt tên cho đối số tương ứng. Ví dụ: trong đoạn code bên dưới, chúng tôi chỉ giữ lại các trường hợp nam giới trong bộ số liệu linelist có ngày lây nhiễm từ tháng 4 đến tháng 7 năm 2014 (ngày tháng được chỉ định dưới dạng khoảng) và các liên kết lây nhiễm xảy ra trong bệnh viện.Chúng ta có thể sử dụng hàm thin để lọc trong bộ số liệu linelist để bao gồm các trường hợp được tìm thấy trong danh sách “contacts” bằng cách đặt đối số = \"linelist\", hoặc lọc trong danh sách “contacts” để bao gồm các trường hợp được tìm thấy trong bộ số liệu linelist bằng cách đặt đối số = \"contacts\". Trong đoạn code dưới đây, chúng ta đang lọc thêm từ đối tượng epicontacts để chỉ giữ lại các đường liên kết lây nhiễm có liên quan đến các trường hợp nam giới bị lây nhiễm giữa tháng 4 và tháng 7 mà chúng ta đã lọc ở trên. Chúng ta có thể thấy rằng chỉ có hai liên kết lây nhiễm đã biết phù hợp với đặc điểm đó.Bên cạnh việc subset theo thuộc tính nút (node) và cạnh (edge), các mạng liên kết có thể được cắt tỉa để chỉ bao gồm các thành phần được kết nối với một số nút nhất định. Đối số cluster_id sẽ lấy một vectơ chứa ID các ca bệnh và trả về danh sách của các cá nhân được liên kết một cách trực tiếp hoặc gián tiếp tới các ID đó. Trong đoạn code dưới đây, chúng ta có thể thấy rằng tổng cộng 13 trường hợp trong bộ số liệu linelist có liên quan đến các cụm chứa 2ae019 và 71577a.Phương pháo subset() cho các đối tượng epicontacts cũng cho phép lọc theo kích thước cụm bằng cách sử dụng các đối số cs, cs_min và cs_max. Trong đoạn code bên dưới, chúng ta chỉ giữ lại các trường hợp được liên kết với các cụm 10 trường hợp hoặc lớn hơn và có thể thấy rằng 271 trường hợp trong trong bộ số liệu linelist có liên quan đến các cụm đó.","code":"\nsub_attributes <- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ), \n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes## \n## /// Epidemiological Contacts //\n## \n##   // class: epicontacts\n##   // 69 cases in linelist; 1,963 contacts; directed \n## \n##   // linelist\n## \n## # A tibble: 69 x 30\n##    id     generation date_infection date_onset date_hospitalis~ date_outcome outcome gender   age age_unit age_years age_cat age_cat5 hospital    lon   lat infector source\n##    <chr>       <dbl> <date>         <date>     <date>           <date>       <chr>   <chr>  <dbl> <chr>        <dbl> <fct>   <fct>    <chr>     <dbl> <dbl> <chr>    <chr> \n##  1 5fe599          4 2014-05-08     2014-05-13 2014-05-15       NA           <NA>    m          2 years            2 0-4     0-4      Other     -13.2  8.47 f547d6   other \n##  2 893f25          3 2014-05-18     2014-05-21 2014-05-22       2014-05-29   Recover m          3 years            3 0-4     0-4      Military~ -13.2  8.46 11f8ea   other \n##  3 2978ac          4 2014-05-30     2014-06-06 2014-06-08       2014-06-15   Death   m         12 years           12 10-14   10-14    Port Hos~ -13.2  8.48 996f3a   other \n##  4 57a565          4 2014-05-28     2014-06-13 2014-06-15       NA           Death   m         42 years           42 30-49   40-44    Military~ -13.3  8.46 133ee7   other \n##  5 fc15ef          6 2014-06-14     2014-06-16 2014-06-17       2014-07-09   Recover m         19 years           19 15-19   15-19    Missing   -13.2  8.48 37a6f6   other \n##  6 99e8fa          7 2014-06-24     2014-06-28 2014-06-29       2014-07-09   Recover m         19 years           19 15-19   15-19    Port Hos~ -13.2  8.47 ab634e   other \n##  7 f327be          6 2014-06-14     2014-07-12 2014-07-13       2014-07-14   Death   m         31 years           31 30-49   30-34    St. Mark~ -13.2  8.46 a15e13   other \n##  8 90e5fe          5 2014-06-18     2014-07-13 2014-07-14       2014-07-16   <NA>    m         67 years           67 50-69   65-69    Port Hos~ -13.3  8.46 ea3740   other \n##  9 a47529          5 2014-06-13     2014-07-17 2014-07-18       2014-07-26   Death   m         45 years           45 30-49   45-49    Military~ -13.2  8.48 a2086d   other \n## 10 da8ecb          5 2014-06-20     2014-07-18 2014-07-20       2014-08-01   <NA>    m         12 years           12 10-14   10-14    Missing   -13.2  8.48 eb2277   funer~\n## # ... with 59 more rows, and 12 more variables: wt_kg <dbl>, ht_cm <dbl>, ct_blood <dbl>, fever <chr>, chills <chr>, cough <chr>, aches <chr>, vomit <chr>, temp <dbl>,\n## #   time_admission <chr>, bmi <dbl>, days_onset_hosp <dbl>\n## \n##   // contacts\n## \n## # A tibble: 1,963 x 4\n##    from   to     location   duration\n##    <chr>  <chr>  <chr>         <int>\n##  1 f90f5f b8812a Nosocomial        4\n##  2 11f8ea 893f25 Nosocomial        3\n##  3 aec8ec be99c8 Nosocomial       10\n##  4 133ee7 369449 Nosocomial        6\n##  5 996f3a 2978ac Nosocomial        5\n##  6 9f6884 2eaa9a Nosocomial       10\n##  7 4802b1 bbfa93 Nosocomial        9\n##  8 8e104d ddddee Nosocomial        7\n##  9 ab634e 99e8fa Nosocomial        9\n## 10 5d9e4d 8bd1e8 Nosocomial        7\n## # ... with 1,953 more rows\nsub_attributes <- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)## [1] 5\nsub_id <- subset(epic, cluster_id = c(\"2ae019\",\"71577a\"))\nnrow(sub_id$linelist)## [1] 13\nsub_cs <- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)## [1] 271"},{"path":"transmission-chains.html","id":"truy-cập-thông-tin-id","chapter":"37 Chuỗi lây nhiễm","heading":"Truy cập thông tin ID","text":"Hàm get_id() truy xuất thông tin về ID ca bệnh trong bộ dữ liệu và có thể được tham số hóa như sau:linelist: ID trong bộ dữ liệu linelistcontacts: ID trong bộ dữ liệu contact (kết hợp “” và “”): ID trong cột “” của bộ dữ liệu contactto: ID trong cột “” của bộ dữ liệu contactall: các ID xuất hiện ở bất kỳ một trong hai bộ dữ liệucommon: các ID xuất hiện trong cả bộ dữ liệu contact và bộ dữ liệu linelistVí dụ: xem 10 ID đầu tiên trong bộ dữ liệu contact?Có bao nhiêu ID được tìm thấy trong cả hai bộ dữ liệu tiếp xúc và linelist?","code":"\ncontacts_ids <- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)##  [1] \"f547d6\" \"f90f5f\" \"11f8ea\" \"aec8ec\" \"893f25\" \"133ee7\" \"996f3a\" \"37a6f6\" \"9f6884\" \"4802b1\"\nlength(get_id(epic, \"common\"))## [1] 4352"},{"path":"transmission-chains.html","id":"trực-quan-hóa","chapter":"37 Chuỗi lây nhiễm","heading":"37.4 Trực quan hóa","text":"","code":""},{"path":"transmission-chains.html","id":"biểu-đồ-cơ-bản","chapter":"37 Chuỗi lây nhiễm","heading":"Biểu đồ cơ bản","text":"Tất cả các hình ảnh trực quan của các đối tượng epicontacts được xử lý bởi hàm plot. Trước tiên, chúng ta sẽ lọc đối tượng epicontacts để chỉ bao gồm các trường hợp có ngày bắt đầu vào tháng 6 năm 2014 bằng cách sử dụng hàm subset, và chỉ bao gồm các tiếp xúc được liên kết với các trường hợp đó bằng cách sử dụng hàm thin.Sau đó, chúng ta có thể tạo biểu đồ cơ bản, có tính tương tác rất đơn giản như sau:Bạn có thể di chuyển các nút xung quanh bằng cách kéo chúng, di chuột qua chúng để biết thêm thông tin và nhấp vào chúng để đánh dấu các trường hợp được kết nối.Có một số lượng lớn các đối số để tùy chỉnh biểu đồ này. Chúng ta sẽ trình bày những vấn đề chính ở đây, nhưng bạn có thể xem thêm tài liệu thông qua lệnh ?vis_epicontacts (hàm được gọi khi sử dụng biểu đồ trên đối tượng epicontacts) để có được mô tả đầy đủ về các đối số của hàm.","code":"\n## subset epicontacts object\nsub <- epic %>%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %>%\n thin(\"contacts\")\n## plot epicontacts object\nplot(\n  sub,\n  width = 700,\n  height = 700\n)"},{"path":"transmission-chains.html","id":"trực-quan-hóa-các-thuộc-tính-của-nút","chapter":"37 Chuỗi lây nhiễm","heading":"Trực quan hóa các thuộc tính của nút","text":"Màu nút, hình dạng nút và kích thước nút có thể được ánh xạ tới một cột nhất định trong bộ số liệu linelist bằng cách sử dụng các đối số node_color, node_shape và node_size. Điều này tương tự với cú pháp aes mà bạn có thể thấy trong ggplot2.Màu sắc, hình dạng và kích thước cụ thể của các nút có thể được chỉ định như sau:Màu sắc thông qua đối số col_pal, bằng cách cung cấp một danh sách tên được chỉ định cho từng màu cụ thể như được thực hiện bên dưới hoặc bằng cách cung cấp một hàm bảng màu như colorRampPalette(c(\"black\", \"red\", \"orange\")), mà sẽ giúp cung cấp một dải màu giữa các màu được chỉ định.Màu sắc thông qua đối số col_pal, bằng cách cung cấp một danh sách tên được chỉ định cho từng màu cụ thể như được thực hiện bên dưới hoặc bằng cách cung cấp một hàm bảng màu như colorRampPalette(c(\"black\", \"red\", \"orange\")), mà sẽ giúp cung cấp một dải màu giữa các màu được chỉ định.Hình dạng bằng cách chuyển một danh sách đã đặt tên đến đối số shapes, chỉ định một hình dạng cho mỗi phần tử duy nhất trong cột bộ số liệu linelist được chỉ định bởi đối số node_shape. Xem codeawesome để biết các hình dạng có sẵn.Hình dạng bằng cách chuyển một danh sách đã đặt tên đến đối số shapes, chỉ định một hình dạng cho mỗi phần tử duy nhất trong cột bộ số liệu linelist được chỉ định bởi đối số node_shape. Xem codeawesome để biết các hình dạng có sẵn.Kích thước bằng cách chuyển một phạm vi kích thước của các nút tới đối số size_range.Kích thước bằng cách chuyển một phạm vi kích thước của các nút tới đối số size_range.Dưới đây là một ví dụ, trong đó màu sắc thể hiện cho outcome, hình dạng thể hiện cho giới tính và kích thước thể hiện cho độ tuổi:","code":"\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = 'age',\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)"},{"path":"transmission-chains.html","id":"trực-quan-hóa-các-thuộc-tính-cạnh","chapter":"37 Chuỗi lây nhiễm","heading":"Trực quan hóa các thuộc tính cạnh","text":"Màu, độ dày và kiểu đường có thể được ánh xạ tới một cột nhất định trong bộ dữ liệu tiếp xúc bằng cách sử dụng các đối số edge_color, edge_width và edge_linetype. Các màu cụ và độ dày của các cạnh có thể được chỉ định như sau:Màu sắc thông qua đối số edge_col_pal, theo cách tương tự được sử dụng cho col_pal.Màu sắc thông qua đối số edge_col_pal, theo cách tương tự được sử dụng cho col_pal.Độ rộng bằng cách chuyển phạm vi kích thước của các nút tới đối số width_range.Độ rộng bằng cách chuyển phạm vi kích thước của các nút tới đối số width_range.Dưới đây là ví dụ:","code":"\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = 'age',\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = 'location',\n  edge_linetype = 'location',\n  edge_width = 'duration',\n  edge_col_pal = c(Community = \"orange\", Nosocomial = \"purple\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)"},{"path":"transmission-chains.html","id":"trục-thời-gian-1","chapter":"37 Chuỗi lây nhiễm","heading":"Trục thời gian","text":"Chúng ta cũng có thể trực quan hóa mạng lây nhiễm dọc theo trục thời gian bằng cách ánh xạ đối số x_axis vào một cột trong bộ số liệu linelist. Trong ví dụ dưới đây, trục x biểu thị ngày bắt đầu triệu chứng. Chúng ta cũng đã chỉ định đối số arrow_size để đảm bảo các mũi tên không quá lớn và đặt label = FALSE để làm cho hình bớt lộn xộn.Có một số lượng lớn các đối số bổ sung để cụ thể hơn cách mà mạng lưới này được hiển thị dọc theo trục thời gian, bạn có thể kiểm tra thông qua lệnh ?vis_temporal_interactive (hàm được gọi khi sử dụng hàm plot trên đối tượng epicontacts với đối số x_axis được chỉ định). Chúng tôi sẽ mô tả kỹ hơn ở bên dưới.","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)"},{"path":"transmission-chains.html","id":"chỉ-định-hình-dạng-cây-lây-nhiễm","chapter":"37 Chuỗi lây nhiễm","heading":"Chỉ định hình dạng cây lây nhiễm","text":"Có hai hình dạng chính mà cây lây nhiễm có thể giả định, được chỉ định bằng cách sử dụng đối số network_shape. Đầu tiên là hình dạng nhánh branching như hình trên, trong đó một cạnh thẳng nối hai nút bất kỳ. Đây là cách trình bày trực quan nhất, tuy nhiên có thể dẫn đến các cạnh chồng lên nhau trong một mạng kết nối dày đặc. Kiểu hình thứ hai là rectangle, sẽ tạo ra một cái cây giống như cây phát sinh loài. Ví dụ:Mỗi nút có thể được gán một vị trí dọc duy nhất bằng cách chuyển đổi đối số position_dodge. Vị trí của các trường hợp không được kết nối (tức là không có lây nhiễm được báo cáo) được xác định bằng cách sử dụng đối số unlinked_pos.Vị trí của nút “mẹ” với các nút “con” có thể được xác định bằng cách sử dụng đối số parent_pos. Tùy chọn mặc định là đặt nút “mẹ” ở giữa, tuy nhiên nó có thể được đặt ở dưới cùng (parent_pos = 'bottom') hoặc ở trên cùng (parent_pos = 'top').","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)"},{"path":"transmission-chains.html","id":"lưu-biểu-đồ-2","chapter":"37 Chuỗi lây nhiễm","heading":"Lưu biểu đồ","text":"Bạn có thể lưu một biểu đồ dưới dạng tệp tin html tương tác, độc lập với hàm visSave từ package VisNetwork:Rất tiếc, việc lưu các kết quả đầu ra mạng lưới lây nhiễm này dưới dạng hình ảnh trở nên khó khăn và bạn cần lưu dưới dạng tệp tin html và sau đó chụp ảnh màn hình của tệp tin này bằng backage webshot. Trong đoạn code dưới đây, chúng ta đang chuyển đổi tệp tin html được lưu ở trên thành dạng file ảnh PNG:","code":"\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n) %>%\n  visNetwork::visSave(\"network.html\")\nwebshot(url = \"network.html\", file = \"network.png\")"},{"path":"transmission-chains.html","id":"dòng-thời-gian","chapter":"37 Chuỗi lây nhiễm","heading":"Dòng thời gian","text":"Bạn cũng có thể thêm dòng thời gian cho mạng lưới truyền nhiễm, được biểu diễn trên trục x của mỗi trường hợp. Nó có thể được sử dụng để trực quan hóa các vị trí ca bệnh, hoặc thời gian dẫn đến outcome. Để tạo dòng thời gian, chúng ta cần tạo một data.frame gồm ít nhất ba cột bao gồm ID, ngày bắt đầu của “sự kiện” và ngày kết thúc của “sự kiện”. Bạn cũng có thể thêm bất kỳ cột giá trị nào khác mà sau đó có thể được ánh xạ tới các thuộc tính nút và cạnh của dòng thời gian. Trong đoạn code dưới đây, chúng ta tạo một dòng thời gian từ ngày bắt đầu có triệu chứng đến ngày có outcome và giữ các biến outcome và bệnh viện mà chúng ta đã sử dụng để xác định hình dạng và màu sắc của nút. Lưu ý rằng bạn có thể có nhiều hơn một dòng thời gian hàng/sự kiện cho mỗi trường hợp, ví dụ: nếu một trường hợp được chuyển viện giữa nhiều bệnh viện.Sau đó, chúng ta chuyển phần tử dòng thời gian vào đối số timeline. Chúng ta có thể ánh xạ các thuộc tính dòng thời gian với màu sắc, hình dạng và kích thước của nút dòng thời gian theo cùng một cách đã xác định trong các phần trước, ngoại trừ việc chúng ta có hai nút: nút bắt đầu và nút kết thúc của mỗi dòng thời gian, có các đối số riêng biệt. Ví dụ: tl_start_node_color xác định cột dòng thời gian nào được ánh xạ với màu của nút bắt đầu, trong khi tl_end_node_shape xác định cột dòng thời gian nào được ánh xạ tới hình dạng của nút kết thúc. Chúng ta cũng có thể ánh xạ màu, độ dày, kiểu đường kẻ và nhãn vào cạnh dòng thời gian thông qua các đối số tl_edge_.Xem ?vis_temporal_interactive (hàm được gọi khi vẽ biểu đồ một đối tượng epicontacts) để biết tài liệu chi tiết về các đối số. Mỗi đối số cũng được chú thích trong đoạn code bên dưới:","code":"\n## generate timeline\ntimeline <- linelist %>%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n## define shapes\nshapes <- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## define colours\ncolours <- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## make plot\nplot(\n  sub,\n  ## max x coordinate to date of onset\n  x_axis = \"date_onset\",\n  ## use rectangular network shape\n  network_shape = \"rectangle\",\n  ## mape case node shapes to gender column\n  node_shape = \"gender\",\n  ## we don't want to map node colour to any columns - this is important as the\n  ## default value is to map to node id, which will mess up the colour scheme\n  node_color = NULL,\n  ## set case node size to 30 (as this is not a character, node_size is not\n  ## mapped to a column but instead interpreted as the actual node size)\n  node_size = 30,\n  ## set transmission link width to 4 (as this is not a character, edge_width is\n  ## not mapped to a column but instead interpreted as the actual edge width)\n  edge_width = 4,\n  ## provide the timeline object\n  timeline = timeline,\n  ## map the shape of the end node to the outcome column in the timeline object\n  tl_end_node_shape = \"outcome\",\n  ## set the size of the end node to 15 (as this is not a character, this\n  ## argument is not mapped to a column but instead interpreted as the actual\n  ## node size)\n  tl_end_node_size = 15,\n  ## map the colour of the timeline edge to the hospital column\n  tl_edge_color = \"hospital\",\n  ## set the width of the timeline edge to 2 (as this is not a character, this\n  ## argument is not mapped to a column but instead interpreted as the actual\n  ## edge width)\n  tl_edge_width = 2,\n  ## map edge labels to the hospital variable\n  tl_edge_label = \"hospital\",\n  ## specify the shape for everyone node attribute (defined above)\n  shapes = shapes,\n  ## specify the colour palette (defined above)\n  col_pal = colours,\n  ## set the size of the arrow to 0.5\n  arrow_size = 0.5,\n  ## use two columns in the legend\n  legend_ncol = 2,\n  ## set font size\n  font_size = 15,\n  ## define formatting for dates\n  date_labels = c(\"%d %b %Y\"),\n  ## don't plot the ID labels below nodes\n  label = FALSE,\n  ## specify height\n  height = 1000,\n  ## specify width\n  width = 1200,\n  ## ensure each case node has a unique y-coordinate - this is very important\n  ## when using timelines, otherwise you will have overlapping timelines from\n  ## different cases\n  position_dodge = TRUE\n)## Warning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed as ID not found in linelist or start/end date is NA"},{"path":"transmission-chains.html","id":"phân-tích","chapter":"37 Chuỗi lây nhiễm","heading":"37.5 Phân tích","text":"","code":""},{"path":"transmission-chains.html","id":"tổng-hợp-1","chapter":"37 Chuỗi lây nhiễm","heading":"Tổng hợp","text":"Chúng ta có thể xem tổng quan về một số thuộc tính mạng lưới bằng cách sử dụng hàm summary.Ví dụ, chúng ta có thể thấy rằng chỉ có 57% các tiếp xúc có cả hai trường hợp trong bộ số liệu linelist; điều này có nghĩa là chúng ta không có dữ liệu trong bộ số liệu linelist về một số lượng đáng kể các trường hợp liên quan đến các chuỗi lây nhiễm này.","code":"\n## summarise epicontacts object\nsummary(epic)## \n## /// Overview //\n##   // number of unique IDs in linelist: 5888\n##   // number of unique IDs in contacts: 5511\n##   // number of unique IDs in both: 4352\n##   // number of contacts: 3800\n##   // contacts with both cases in linelist: 56.868 %\n## \n## /// Degrees of the network //\n##   // in-degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##  0.0000  0.0000  1.0000  0.5392  1.0000  1.0000 \n## \n##   // out-degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##  0.0000  0.0000  0.0000  0.5392  1.0000  6.0000 \n## \n##   // in and out degree summary:\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   0.000   1.000   1.000   1.078   1.000   7.000 \n## \n## /// Attributes //\n##   // attributes in linelist:\n##  generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp\n## \n##   // attributes in contacts:\n##  location duration"},{"path":"transmission-chains.html","id":"đặc-điểm-ghép-cặp","chapter":"37 Chuỗi lây nhiễm","heading":"Đặc điểm ghép cặp","text":"Hàm get_pairwise() cho phép xử lý (các) biến trong bộ số liệu linelist theo từng cặp trong bộ dữ liệu tiếp xúc. Ở ví dụ dưới đây, ngày khởi phát bệnh được trích xuất từ bộ số liệu linelist để tính toán sự khác biệt giữa ngày khởi phát bệnh cho từng cặp. Giá trị được tạo ra từ phép sánh này đại diện cho khoảng nối tiếp (serial interval - si).get_pairwise() sẽ diễn giải phân lớp của cột đang được sử dụng để sánh và sẽ điều chỉnh phương pháp sánh các giá trị của nó cho phù hợp. Đối với số và ngày (như ví dụ si ở trên), hàm sẽ trừ các giá trị. Khi được áp dụng cho các cột là ký tự hoặc phân loại, get_pairwise() sẽ gán các giá trị lại với nhau. Bởi vì hàm cũng cho phép xử lý tùy ý (xem đối số “f”), các kết hợp rời rạc này có thể dễ dàng được mô tả và phân tích.Ở đây, chúng ta thấy có một mối liên hệ lớn giữa các liên kết lây nhiễm và giới tính.","code":"\nsi <- get_pairwise(epic, \"date_onset\")   \nsummary(si)##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##    0.00    5.00    9.00   11.01   15.00   99.00    1820\ntibble(si = si) %>%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Serial interval\",\n    y = \"Frequency\"\n  )## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.## Warning: Removed 1820 rows containing non-finite values (stat_bin).\nhead(get_pairwise(epic, \"gender\"), n = 10)##  [1] \"f -> m\" NA       \"m -> m\" NA       \"m -> f\" \"f -> f\" NA       \"f -> m\" NA       \"m -> f\"\nget_pairwise(epic, \"gender\", f = table)##            values.to\n## values.from   f   m\n##           f 464 516\n##           m 510 468\nfisher.test(get_pairwise(epic, \"gender\", f = table))## \n##  Fisher's Exact Test for Count Data\n## \n## data:  get_pairwise(epic, \"gender\", f = table)\n## p-value = 0.03758\n## alternative hypothesis: true odds ratio is not equal to 1\n## 95 percent confidence interval:\n##  0.6882761 0.9892811\n## sample estimates:\n## odds ratio \n##  0.8252575"},{"path":"transmission-chains.html","id":"xác-định-cụm","chapter":"37 Chuỗi lây nhiễm","heading":"Xác định cụm","text":"Hàm get_clusters() có thể được sử dụng để xác định các thành phần được kết nối trong một đối tượng epicontacts. Đầu tiên, chúng ta sử dụng nó để truy xuất data.frame chứa thông tin cụm:Giờ chúng ta hãy xem xét các cụm lớn nhất. Đối với điều này, chúng ta thêm thông tin cụm vào đối tượng epicontacts và sau đó subset nó để chỉ giữ lại các cụm lớn nhất:","code":"\nclust <- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)## \n##    1    2    3    4    5    6    7    8    9   10   11   12   13   14 \n## 1536 1680 1182  784  545  342  308  208  171  100   99   24   26   42\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Cluster size\",\n    y = \"Frequency\"\n  )\nepic <- get_clusters(epic)\nmax_size <- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))"},{"path":"transmission-chains.html","id":"tính-toán-mức-độ","chapter":"37 Chuỗi lây nhiễm","heading":"Tính toán mức độ","text":"Mức độ của một nút tương ứng với số cạnh hoặc kết nối của nó với các nút khác. get_degree() cung cấp một phương pháp dễ dàng để tính toán giá trị này cho các mạng lưới epicontacts. Mức độ cao trong ngữ cảnh này cho biết một cá nhân đã tiếp xúc với nhiều người khác. Đối sôs type chỉ ra rằng chúng ta muốn đếm cả mức độ trong và ngoài, đối số only_linelist chỉ ra rằng chúng ta chỉ muốn tính mức độ cho các trường hợp trong bộ số liệu linelist.Những cá nhân nào có 10 tiếp xúc?Số lượng lây nhiễm trung bình là bao nhiêu?","code":"\ndeg_both <- get_degree(epic, type = \"both\", only_linelist = TRUE)\nhead(sort(deg_both, decreasing = TRUE), 10)## 916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd \n##      7      6      6      6      5      5      5      5      5      5\nmean(deg_both)## [1] 1.078473"},{"path":"transmission-chains.html","id":"tham-khảo","chapter":"37 Chuỗi lây nhiễm","heading":"37.6 Tham khảo","text":"Epicontacts page cung cấp tổng quan về các hàm và package bao gồm một số thông tin chi tiết chuyên sâu hơn.Github page có thể được sử dụng để nêu vấn đề và yêu cầu chỉnh sửa.","code":""},{"path":"phylogenetic-trees.html","id":"phylogenetic-trees","chapter":"38 Cây phả hệ","heading":"38 Cây phả hệ","text":"","code":""},{"path":"phylogenetic-trees.html","id":"tổng-quan-8","chapter":"38 Cây phả hệ","heading":"38.1 Tổng quan","text":"Cây phả hệ được sử dụng để trực quan hóa và mô tả mối liên hệ cũng như sự tiến hóa của các sinh vật dựa trên trình tự mã di truyền của chúng.Chúng có thể được xây dựng từ trình tự di truyền bằng các phương pháp dựa trên khoảng cách (distance-based methods) (chẳng hạn như phương pháp neighbor-joining) hoặc các phương pháp dựa trên ký tự (character-based methods) (chẳng hạn như phương pháp maximum likelihood và Bayesian Markov Chain Monte Carlo). Công nghệ giải trình tự gen thế hệ mới (Next Generation Sequencing - NGS) có giá thành ngày càng hợp lý và ngày càng được sử dụng rộng rãi hơn trong y tế công cộng để mô tả các mầm bệnh gây ra các bệnh truyền nhiễm. Các thiết bị giải trình tự di động giúp giảm thời gian quay vòng và hứa hẹn cung cấp dữ liệu để hỗ trợ điều tra ổ dịch trong thời gian thực. Dữ liệu NGS có thể được sử dụng để xác định nguồn gốc hoặc nguồn gốc của một chủng bùng phát và sự lan truyền của nó, cũng như xác định sự hiện diện của các gen kháng thuốc kháng sinh. Để trực quan hóa mối quan hệ di truyền giữa các mẫu, một cây phát sinh loài được xây dựng.Trong chương này chúng ta sẽ học cách sử dụng package ggtree, cho phép kết hợp cây phả hệ với dữ liệu bổ sung dưới dạng một dataframe. Điều này sẽ cho phép chúng ta quan sát các xu hướng và nâng cao hiểu biết về động học của dịch bệnh.","code":""},{"path":"phylogenetic-trees.html","id":"chuẩn-bị-30","chapter":"38 Cây phả hệ","heading":"38.2 Chuẩn bị","text":"","code":""},{"path":"phylogenetic-trees.html","id":"gọi-packages-15","chapter":"38 Cây phả hệ","heading":"Gọi packages","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.","code":"\npacman::p_load(\n  rio,             # import/export\n  here,            # relative file paths\n  tidyverse,       # general data management and visualization\n  ape,             # to import and export phylogenetic files\n  ggtree,          # to visualize phylogenetic files\n  treeio,          # to visualize phylogenetic files\n  ggnewscale)      # to add additional layers of color schemes"},{"path":"phylogenetic-trees.html","id":"nhập-dữ-liệu-22","chapter":"38 Cây phả hệ","heading":"Nhập dữ liệu","text":"Dữ liệu sử dụng trong chương này có thể tải xuống với hướng dẫn từ chương Tải sách và dữ liệu.Có một số định dạng khác nhau mà cây phát sinh loài có thể được lưu trữ (vd: Newick, NEXUS, Phylip). Định dạng phổ biến là ở dạng tệp Newick (.nwk), là tiêu chuẩn để biểu diễn cây ở dạng máy tính có thể đọc được. Điều này có nghĩa là toàn bộ cây có thể được biểu diễn ở định dạng chuỗi chẳng hạn như “((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59);”, liệt kê toàn bộ các nút và tips cũng như mối quan hệ của chúng (độ dài nhánh) với nhau.Lưu ý: Điều quan trọng là phải hiểu rằng bản thân tệp cây phát sinh loài không chứa dữ liệu trình tự, mà chỉ đơn thuần là kết quả của khoảng cách gen giữa các trình tự. đó, chúng ta không thể trích xuất dữ liệu trình tự từ tệp cây.Đầu tiên, chúng ta sử dụng hàm read.tree() từ package ape để nhập một tệp cây phát sinh loài Newick ở định dạng .txt, và lưu nó dưới dạng một đối tượng danh sách với kiểu dữ liệu (class) “phylo”. Nếu cần, hãy sử dụng hàm () từ package để chỉ định đường dẫn tệp tương đối.Lưu ý: Trong trường hợp này, newick tree được lưu dưới dạng tệp .txt để dễ dàng xử lý và tải xuống từ Github.Chúng ta khảo sát đối tượng cây của chúng ta và thấy nó chứa 299 tips (hoặc mẫu) và 236 nút (nodes).Thứ hai, chúng ta nhập một bảng được lưu trữ dưới dạng tệp .csv với thông tin bổ sung cho từng mẫu được giải trình tự, chẳng hạn như giới tính, quốc gia xuất xứ và các thuộc tính kháng kháng sinh, bằng cách sử dụng hàm import() từ package rio:Dưới đây là 50 dòng đầu tiên của bộ dữ liệu:","code":"\ntree <- ape::read.tree(\"Shigella_tree.txt\")\ntree## \n## Phylogenetic tree with 299 tips and 236 internal nodes.\n## \n## Tip labels:\n##   SRR5006072, SRR4192106, S18BD07865, S18BD00489, S17BD08906, S17BD05939, ...\n## Node labels:\n##   17, 29, 100, 67, 100, 100, ...\n## \n## Rooted; includes branch lengths.\nsample_data <- import(\"sample_data_Shigella_tree.csv\")"},{"path":"phylogenetic-trees.html","id":"làm-sạch-và-khảo-sát-dữ-liệu","chapter":"38 Cây phả hệ","heading":"Làm sạch và khảo sát dữ liệu","text":"Chúng ta làm sạch và khảo sát dữ liệu để gán dữ liệu mẫu chính xác cho cây phát sinh loài, các giá trị trong cột Sample_ID của data frame sample_data cần phải khớp với giá trị tip.labels ở trong tệp tree:Chúng ta kiểm tra định dạng của tip.labels trong tệp tree bằng cách xem xét 6 hàng đầu tiên với hàm head() của base R.Chúng ta cũng cần chắc chắn rằng cột đầu tiên trong data frame sample_data là cột Sample_ID. Chúng ta xem tên các cột của dataframe bằng cách sử dụng hàm colnames() từ base R.Chúng ta hãy để ý cột Sample_IDs trong data frame để chắc chắn rằng các định dạng là tương tự với tip.label (vd: các chữ cái đều viết hoa, không có dấu gạch dưới thừa _ giữa ký tự và số, v.v.)Chúng ta cũng có thể sánh nếu tất cả các mẫu có trong tệp tree và ngược lại bằng cách tạo một vectơ logic TRUE hoặc FALSE khi chúng khớp hoặc không khớp. Chúng không được ở đây để cho đơn giản.Chúng ta có thể sử dụng các vectơ này để hiển thị bất kỳ ID mẫu nào không có trên cây (không có ID nào).Sau khi khảo sát, chúng ta có thể thấy định dạng của cột Sample_ID trong dataframe tương ứng với định dạng của tên mẫu tại tip.labels. Chúng không cần phải được sắp xếp theo cùng một thứ tự để có thể khớp.Bây giờ chúng ta đã sẵn sàng!","code":"\nhead(tree$tip.label) ## [1] \"SRR5006072\" \"SRR4192106\" \"S18BD07865\" \"S18BD00489\" \"S17BD08906\" \"S17BD05939\"\ncolnames(sample_data)   ##  [1] \"Sample_ID\"                  \"serotype\"                   \"Country\"                    \"Continent\"                  \"Travel_history\"            \n##  [6] \"Year\"                       \"Belgium\"                    \"Source\"                     \"Gender\"                     \"gyrA_mutations\"            \n## [11] \"macrolide_resistance_genes\" \"MIC_AZM\"                    \"MIC_CIP\"\nhead(sample_data$Sample_ID) # we again inspect only the first 6 using head()## [1] \"S17BD05944\" \"S15BD07413\" \"S18BD07247\" \"S19BD07384\" \"S18BD07338\" \"S18BD02657\"\nsample_data$Sample_ID %in% tree$tip.label\n\ntree$tip.label %in% sample_data$Sample_ID\nsample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]## character(0)"},{"path":"phylogenetic-trees.html","id":"trực-quan-hóa-cây-đơn-giản","chapter":"38 Cây phả hệ","heading":"38.3 Trực quan hóa cây đơn giản","text":"","code":""},{"path":"phylogenetic-trees.html","id":"các-bố-cục-cây-khác-nhau","chapter":"38 Cây phả hệ","heading":"Các bố cục cây khác nhau","text":"ggtree cung cấp nhiều định dạng bố cục khác nhau và một số có thể phù hợp với mục đích cụ thể của bạn hơn những định dạng khác. Dưới đây là một vài minh hoạt. Đối với các tùy chọn khác, hãy xem cuốn sách trực tuyến này.Dưới đây là một số bố cục cây mẫu:","code":"\nggtree(tree)                                            # simple linear tree\nggtree(tree,  branch.length = \"none\")                   # simple linear tree with all tips aligned\nggtree(tree, layout=\"circular\")                         # simple circular tree\nggtree(tree, layout=\"circular\", branch.length = \"none\") # simple circular tree with all tips aligned"},{"path":"phylogenetic-trees.html","id":"cây-đơn-giản-cộng-với-dữ-liệu-mẫu","chapter":"38 Cây phả hệ","heading":"Cây đơn giản cộng với dữ liệu mẫu","text":"Toán tử %<+% được sử dụng để kết nối data frame sample_data tới tệp tree.\nCách chú thích dễ dàng nhất cho cây của bạn là thêm tên mẫu ở các ngọn, cũng như tô màu các điểm ngọn và các nhánh nếu muốn :example circular tree:Bạn có thể xuất biểu đồ cây với hàm ggsave() như cách bạn làm với bất kỳ đối tượng ggplot nào khác. Được viết theo cách này,\nggsave() lưu hình ảnh cuối cùng được tạo vào đường dẫn tệp bạn chỉ định. Hãy nhớ rằng bạn có thể sử dụng hàm () và các đường dẫn tệp tương đối để dễ dàng lưu trong các thư mục con, v.v.","code":"\nggtree(tree, layout = \"circular\", branch.length = 'none') %<+% sample_data + # %<+% adds dataframe with sample data to tree\n  aes(color = I(Belgium))+                       # color the branches according to a variable in your dataframe\n  scale_color_manual(\n    name = \"Sample Origin\",                      # name of your color scheme (will show up in the legend like this)\n    breaks = c(\"Yes\", \"No\"),                     # the different options in your variable\n    labels = c(\"NRCSS Belgium\", \"Other\"),        # how you want the different options named in your legend, allows for formatting\n    values = c(\"blue\", \"black\"),                  # the color you want to assign to the variable \n    na.value = \"black\") +                        # color NA values in black as well\n  new_scale_color()+                             # allows to add an additional color scheme for another variable\n    geom_tippoint(\n      mapping = aes(color = Continent),          # tip color by continent. You may change shape adding \"shape = \"\n      size = 1.5)+                               # define the size of the point at the tip\n  scale_color_brewer(\n    name = \"Continent\",                    # name of your color scheme (will show up in the legend like this)\n    palette = \"Set1\",                      # we choose a set of colors coming with the brewer package\n    na.value = \"grey\") +                    # for the NA values we choose the color grey\n  geom_tiplab(                             # adds name of sample to tip of its branch \n    color = 'black',                       # (add as many text lines as you wish with + , but you may need to adjust offset value to place them next to each other)\n    offset = 1,\n    size = 1,\n    geom = \"text\",\n    align = TRUE)+    \n  ggtitle(\"Phylogenetic tree of Shigella sonnei\")+       # title of your graph\n  theme(\n    axis.title.x = element_blank(), # removes x-axis title\n    axis.title.y = element_blank(), # removes y-axis title\n    legend.title = element_text(    # defines font size and format of the legend title\n      face = \"bold\",\n      size = 12),   \n    legend.text=element_text(       # defines font size and format of the legend text\n      face = \"bold\",\n      size = 10),  \n    plot.title = element_text(      # defines font size and format of the plot title\n      size = 12,\n      face = \"bold\"),  \n    legend.position = \"bottom\",     # defines placement of the legend\n    legend.box = \"vertical\",        # defines placement of the legend\n    legend.margin = margin())   \nggsave(\"example_tree_circular_1.png\", width = 12, height = 14)"},{"path":"phylogenetic-trees.html","id":"thao-tác-với-cây","chapter":"38 Cây phả hệ","heading":"38.4 Thao tác với cây","text":"Đôi khi bạn có thể có một cây phát sinh loài rất lớn và bạn chỉ quan tâm đến một phần của cây. Ví dụ, bạn muốn tạo ra một cây bao gồm các mẫu lịch sử hoặc quốc tế để có cái nhìn tổng quan về vị trí mà tập dữ liệu của bạn có thể phù hợp trong bức tranh lớn hơn. Nhưng sau đó để xem xét kỹ hơn dữ liệu của bạn, bạn chỉ muốn kiểm tra phần đó của cây lớn hơn.Vì tệp cây phát sinh loài chỉ là sản phẩm đầu ra của phân tích dữ liệu trình tự, chúng ta không thể thao tác trên thứ tự của các nút và nhánh trên chính tệ đó. Chúng đã được xác định trong phân tích trước đó từ dữ liệu NGS thô. Mặc dù vậy, chúng ta có thể phóng các thành phần, ẩn các thành phần và thậm chí tạo tập con một phần của cây.","code":""},{"path":"phylogenetic-trees.html","id":"phóng-to","chapter":"38 Cây phả hệ","heading":"Phóng to","text":"Nếu bạn không muốn “chặt” cây của mình mà chỉ kiểm tra kỹ hơn một phần của nó, bạn có thể phóng để xem một phần cụ thể.Đầu tiên, chúng ta vẽ toàn bộ cây ở định dạng tuyến tính và thêm các nhãn số cho mỗi nút trong cây.Để phóng vào một nhánh cụ thể (nhô ra bên phải), hãy sử dụng hàm viewClade() trên đối tượng ggtree có tên p và cung cấp số nút để xem gần hơn:","code":"\np <- ggtree(tree,) %<+% sample_data +\n  geom_tiplab(size = 1.5) +                # labels the tips of all branches with the sample name in the tree file\n  geom_text2(\n    mapping = aes(subset = !isTip,\n                  label = node),\n    size = 5,\n    color = \"darkred\",\n    hjust = 1,\n    vjust = 1)                            # labels all the nodes in the tree\n\np  # print\nviewClade(p, node = 452)"},{"path":"phylogenetic-trees.html","id":"thu-gọn-nhánh","chapter":"38 Cây phả hệ","heading":"Thu gọn nhánh","text":"Tuy nhiên, chúng ta có thể muốn bỏ qua nhánh này và có thể thu gọn nó tại cùng một nút đó (nút nr. 452) bằng cách sử dụng hàm collapse(). Cây này sẽ được gán cho đối tượng mới có tên p_collapsed.Để rõ ràng, khi chúng ta p_collapsed, chúng ta thêm một điểm (viên kim cương màu xanh) với hàm geom_point2() tại nút của nhánh được thu gọn.","code":"\np_collapsed <- collapse(p, node = 452)\np_collapsed\np_collapsed + \ngeom_point2(aes(subset = (node == 452)),  # we assign a symbol to the collapsed node\n            size = 5,                     # define the size of the symbol\n            shape = 23,                   # define the shape of the symbol\n            fill = \"steelblue\")           # define the color of the symbol"},{"path":"phylogenetic-trees.html","id":"tạo-tập-con-một-cây","chapter":"38 Cây phả hệ","heading":"Tạo tập con một cây","text":"Nếu chúng ta muốn thực hiện một thay đổi lâu dài hơn và tạo một cây mới, gọn hơn để làm việc, chúng ta có thể subset một phần của nó với hàm tree_subset(). Sau đó, bạn có thể lưu nó dưới dạng tệp newick tree hoặc tệp .txt mới.Đầu tiên, chúng ta kiểm tra các nút cây và các nhãn của tips để quyết định cái gì sẽ được subset.Bây giờ, giả sử chúng ta đã quyết định subset cây tại nút số 528 (chỉ giữ lại các tips bên trong nhánh sau nút 528) và lưu nó vào một đối tượng mới sub_tree1:Hãy cùng xem cây con 1:Bạn cũng có thể subset dựa trên một mẫu cụ thể, bằng cách chỉ định số lượng nút “backwards” bạn muốn đưa vào. Hãy subset chính phần đó của cây dựa trên một mẫu, trong trường hợp này là S17BD07692, quay lại 9 nút và chúng ta lưu nó dưới dạng đối tượng sub_tree2 mớit:Giờ hãy cùng xem cây con 2:Bạn cũng có thể lưu cây mới của mình dưới dạng kiểu Newick hoặc thậm chí là tệp văn bản bằng cách sử dụng hàm write.tree() từ package ape:","code":"\nggtree(\n  tree,\n  branch.length = 'none',\n  layout = 'circular') %<+% sample_data +               # we add the asmple data using the %<+% operator\n  geom_tiplab(size = 1)+                                # label tips of all branches with sample name in tree file\n  geom_text2(\n    mapping = aes(subset = !isTip, label = node),\n    size = 3,\n    color = \"darkred\") +                                # labels all the nodes in the tree\n theme(\n   legend.position = \"none\",                            # removes the legend all together\n   axis.title.x = element_blank(),\n   axis.title.y = element_blank(),\n   plot.title = element_text(size = 12, face=\"bold\"))\nsub_tree1 <- tree_subset(\n  tree,\n  node = 528)                                            # we subset the tree at node 528\nggtree(sub_tree1) +\n  geom_tiplab(size = 3) +\n  ggtitle(\"Subset tree 1\")\nsub_tree2 <- tree_subset(\n  tree,\n  \"S17BD07692\",\n  levels_back = 9) # levels back defines how many nodes backwards from the sample tip you want to go\nggtree(sub_tree2) +\n  geom_tiplab(size =3)  +\n  ggtitle(\"Subset tree 2\")\n# to save in .nwk format\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')\n\n# to save in .txt format\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')"},{"path":"phylogenetic-trees.html","id":"xoay-các-nút-trong-một-cây","chapter":"38 Cây phả hệ","heading":"Xoay các nút trong một cây","text":"Như đã đề cập bên trên, chúng ta không thể thay đổi thứ tự của các tips hoặc nút trong cây, vì điều này dựa trên mối liên hệ di truyền của chúng và không phải là đối tượng cho các điều chỉnh thị giác. Nhưng chúng ta có thể xoay các nhánh xung quanh nút nếu điều đó giúp chúng ta dễ nhìn hơn.Đầu tiên, chúng ta hãy vẽ subset tree 2 với nhãn nút để chọn nút mà chúng ta muốn thao tác và lưu nó vào một đối tượng biểu đồ ggtree có tên p.Sau đó chúng ta có thể thao tác với các nút bằng cách áp dụng hàm ggtree::rotate() hoặc ggtree::flip():\nLưu ý: để biểu diễn những nút nào chúng ta đang thao tác, trước tiên chúng ta áp dụng hàm geom_hilight() từ package ggtree để đánh dấu các mẫu trong các nút mà chúng ta quan tâm và lưu trữ sang một đối tượng biểu đồ mới có tên p1.Bây giờ chúng ta có thể xoay nút 37 trong đối tượng p1 để các mẫu trên nút 38 di chuyển lên đỉnh. Chúng ta lưu trữ cây đã xoay trong một đối tượng mới có tên p2.Hoặc chúng ta có thể sử dụng lệnh flip để xoay nút 36 trong đối tượng p1 và đổi nút 37 lên đỉnh và nút 39 xuống dưới đáy. Chúng ta lưu cây đã được lật lại vào một đối tượng mới có tên p3.","code":"\np <- ggtree(sub_tree2) +  \n  geom_tiplab(size = 4) +\n  geom_text2(aes(subset=!isTip, label=node), # labels all the nodes in the tree\n             size = 5,\n             color = \"darkred\", \n             hjust = 1, \n             vjust = 1) \np\np1 <- p + geom_hilight(  # highlights node 39 in blue, \"extend =\" allows us to define the length of the color block\n  node = 39,\n  fill = \"steelblue\",\n  extend = 0.0017) +  \ngeom_hilight(            # highlights the node 37 in yellow\n  node = 37,\n  fill = \"yellow\",\n  extend = 0.0017) +               \nggtitle(\"Original tree\")\n\n\np1 # print\np2 <- rotate(p1, 37) + \n      ggtitle(\"Rotated Node 37\")\n\n\np2   # print\np3 <-  flip(p1, 39, 37) +\n      ggtitle(\"Rotated Node 36\")\n\n\np3   # print"},{"path":"phylogenetic-trees.html","id":"ví-dụ-về-cây-con-với-chú-thích-dữ-liệu-mẫu","chapter":"38 Cây phả hệ","heading":"Ví dụ về cây con với chú thích dữ liệu mẫu","text":"Giả sử chúng tôi đang điều tra cụm các trường hợp với nhân bản vô tính xảy ra vào năm 2017 và 2018 tại nút 39 trong cây con của chúng ta. Chúng ta thêm năm phân lập chủng cũng như lịch sử di chuyển và màu sắc theo quốc gia để xem nguồn gốc của các chủng có liên quan gần khác:Quan sát của chúng ta hướng tới một sự kiện nhập khẩu các chủng từ châu Á, sau đó lưu hành ở Bỉ trong nhiều năm và dường như đã gây ra đợt bùng phát mới nhất của chúng ta.","code":"\nggtree(sub_tree2) %<+% sample_data +     # we use th %<+% operator to link to the sample_data\n  geom_tiplab(                          # labels the tips of all branches with the sample name in the tree file\n    size = 2.5,\n    offset = 0.001,\n    align = TRUE) + \n  theme_tree2()+\n  xlim(0, 0.015)+                       # set the x-axis limits of our tree\n  geom_tippoint(aes(color=Country),     # color the tip point by continent\n                size = 1.5)+ \n  scale_color_brewer(\n    name = \"Country\", \n    palette = \"Set1\", \n    na.value = \"grey\")+\n  geom_tiplab(                          # add isolation year as a text label at the tips\n    aes(label = Year),\n    color = 'blue',\n    offset = 0.0045,\n    size = 3,\n    linetype = \"blank\" ,\n    geom = \"text\",\n    align = TRUE)+ \n  geom_tiplab(                          # add travel history as a text label at the tips, in red color\n    aes(label = Travel_history),\n    color = 'red',\n    offset = 0.006,\n    size = 3,\n    linetype = \"blank\",\n    geom = \"text\",\n    align = TRUE)+ \n  ggtitle(\"Phylogenetic tree of Belgian S. sonnei strains with travel history\")+  # add plot title\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+                    # add a label to the x-axis \n  theme(\n    axis.title.x = element_text(size = 10),\n    axis.title.y = element_blank(),\n    legend.title = element_text(face = \"bold\", size = 12),\n    legend.text = element_text(face = \"bold\", size = 10),\n    plot.title = element_text(size = 12, face = \"bold\"))"},{"path":"phylogenetic-trees.html","id":"các-cây-phức-tạp-hơn-thêm-bản-đồ-nhiệt-của-dữ-liệu-mẫu","chapter":"38 Cây phả hệ","heading":"Các cây phức tạp hơn: thêm bản đồ nhiệt của dữ liệu mẫu","text":"Chúng tôi có thể thêm thông tin phức tạp hơn, chẳng hạn như sự phân loại của các gen kháng thuốc và các giá trị đo lường về khả năng kháng thuốc dưới dạng bản đồ nhiệt bằng cách sử dụng hàm ggtree::gheatmap().Trước tiên, chúng ta cần vẽ cây của mình (có thể là tuyến tính hoặc hình tròn) và lưu trữ nó trong một đối tượng biểu đồ ggtree mới có tên p: Chúng ta sẽ sử dụng sub_tree từ phần 3.)Thứ hai, chúng ta chuẩn bị dữ liệu của mình. Để trực quan hóa các biến khác nhau bằng các phối màu mới, chúng ta subset dataframe thành các biến mong muốn. Điều quan trọng là phải thêm Sample_ID làm tên hàng nếu không nó không thể khớp dữ liệu với cây tip.labels:Trong ví dụ của này, chúng ta muốn xem xét giới tính và các đột biến có thể dẫn đến kháng Ciprofloxacin, một loại kháng sinh hàng đầu quan trọng được sử dụng để điều trị nhiễm trùng Shigella.Chúng ta tạo một dataframe cho biến giới tính:Chúng ta tạo một dataframe cho đột biến ở gen gyrA, gen này tạo ra khả năng kháng Ciprofloxacin:Chúng ta tạo một dataframe đối với nồng độ ức chế tối thiểu đo được (MIC) đối với Ciprofloxacin trong phòng thí nghiệm:Chúng ta tạo một biểu đồ đầu tiên và thêm bản đồ nhiệt nhị phân cho giới tính vào cây phát sinh loài và lưu trữ nó trong một đối tượng biểu đồ ggtree mới h1:Sau đó, chúng ta thêm thông tin về các đột biến trong gen gyrA, gen này tạo ra khả năng kháng Ciprofloxacin:Lưu ý: Sự hiện diện của đột biến điểm nhiễm sắc thể trong dữ liệu WGS đã được xác định trước bằng cách sử dụng công cụ PointFinder Zankari et al phát triển. (xem tham khảo trong phần tài liệu tham khảo bổ sung)Đầu tiên, chúng ta gán một bảng màu mới cho đối tượng biểu đồ h1 có sẵn và lưu nó thành một đối tượng mới có tên h2. Điều này cho phép chúng ta xác định và thay đổi màu sắc cho biến thứ hai của chúng tôi trong bản đồ nhiệt.Sau đó, chúng ta thêm lớp bản đồ nhiệt thứ hai vào h2 và lưu biểu đồ thành đối tượng mới có tên h3:Chúng tôi lặp lại quy trình trên, trước tiên bằng cách thêm một lớp thang màu mới vào đối tượng hiện có h3, sau đó thêm dữ liệu liên tục về nồng độ ức chế tối thiểu (MIC) của Ciprofloxacin cho mỗi chủng vào đối tượng kết quả h4 để tạo ra đối tượng cuối cùng h5:Chúng ta có thể thực hiện tương tự đối với cây tuyến tính:Đầu tiên chúng ta thêm giới:Sau đó, chúng ta thêm các đột biến kháng Ciprofloxacin sau khi thêm một lớp phối màu khác:Sau đó, chúng ta thêm nồng độ ức chế tối thiểu được xác định bởi phòng thí nghiệm (MIC):","code":"\np <- ggtree(sub_tree2, branch.length='none', layout='circular') %<+% sample_data +\n  geom_tiplab(size =3) + \n theme(\n   legend.position = \"none\",\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    plot.title = element_text(\n      size = 12,\n      face = \"bold\",\n      hjust = 0.5,\n      vjust = -15))\np\ngender <- data.frame(\"gender\" = sample_data[,c(\"Gender\")])\nrownames(gender) <- sample_data$Sample_ID\ncipR <- data.frame(\"cipR\" = sample_data[,c(\"gyrA_mutations\")])\nrownames(cipR) <- sample_data$Sample_ID\nMIC_Cip <- data.frame(\"mic_cip\" = sample_data[,c(\"MIC_CIP\")])\nrownames(MIC_Cip) <- sample_data$Sample_ID\nh1 <-  gheatmap(p, gender,                                 # we add a heatmap layer of the gender dataframe to our tree plot\n                offset = 10,                               # offset shifts the heatmap to the right,\n                width = 0.10,                              # width defines the width of the heatmap column,\n                color = NULL,                              # color defines the boarder of the heatmap columns\n         colnames = FALSE) +                               # hides column names for the heatmap\n  scale_fill_manual(name = \"Gender\",                       # define the coloring scheme and legend for gender\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())## Scale for 'y' is already present. Adding another scale for 'y', which will replace the existing scale.## Scale for 'fill' is already present. Adding another scale for 'fill', which will replace the existing scale.\nh1\nh2 <- h1 + new_scale_fill() \nh3 <- gheatmap(h2, cipR,         # adds the second row of heatmap describing Ciprofloxacin resistance mutations\n               offset = 12, \n               width = 0.10, \n               colnames = FALSE) +\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))## Scale for 'y' is already present. Adding another scale for 'y', which will replace the existing scale.## Scale for 'fill' is already present. Adding another scale for 'fill', which will replace the existing scale.\nh3\n# First we add the new coloring scheme:\nh4 <- h3 + new_scale_fill()\n\n# then we combine the two into a new plot:\nh5 <- gheatmap(h4, MIC_Cip,  \n               offset = 14, \n               width = 0.10,\n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",  # here we define a gradient color scheme for the continuous variable of MIC\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0, 0.50, 1.00),\n                      na.value = \"white\") +\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())## Scale for 'y' is already present. Adding another scale for 'y', which will replace the existing scale.## Scale for 'fill' is already present. Adding another scale for 'fill', which will replace the existing scale.\nh5\np <- ggtree(sub_tree2) %<+% sample_data +\n  geom_tiplab(size = 3) + # labels the tips\n  theme_tree2()+\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+\n  xlim(0, 0.015)+\n theme(legend.position = \"none\",\n      axis.title.y = element_blank(),\n      plot.title = element_text(size = 12, \n                                face = \"bold\",\n                                hjust = 0.5,\n                                vjust = -15))\np\nh1 <-  gheatmap(p, gender, \n                offset = 0.003,\n                width = 0.1, \n                color=\"black\", \n         colnames = FALSE)+\n  scale_fill_manual(name = \"Gender\",\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())## Scale for 'y' is already present. Adding another scale for 'y', which will replace the existing scale.## Scale for 'fill' is already present. Adding another scale for 'fill', which will replace the existing scale.\nh1\nh2 <- h1 + new_scale_fill()\nh3 <- gheatmap(h2, cipR,   \n               offset = 0.004, \n               width = 0.1,\n               color = \"black\",\n                colnames = FALSE)+\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))## Scale for 'y' is already present. Adding another scale for 'y', which will replace the existing scale.## Scale for 'fill' is already present. Adding another scale for 'fill', which will replace the existing scale.\n h3\nh4 <- h3 + new_scale_fill()\nh5 <- gheatmap(h4, MIC_Cip, \n               offset = 0.005,  \n               width = 0.1,\n               color = \"black\", \n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0,0.50,1.00),\n                      na.value = \"white\")+\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 8),\n        legend.box = \"horizontal\", legend.margin = margin())+\n  guides(shape = guide_legend(override.aes = list(size = 2)))## Scale for 'y' is already present. Adding another scale for 'y', which will replace the existing scale.## Scale for 'fill' is already present. Adding another scale for 'fill', which will replace the existing scale.\nh5"},{"path":"phylogenetic-trees.html","id":"nguồn-11","chapter":"38 Cây phả hệ","heading":"38.5 Nguồn","text":"http://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors\nhttps://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html\nhttps://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html\nhttps://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.htmlEa Zankari, Rosa Allesøe, Katrine G Joensen, Lina M Cavaco, Ole Lund, Frank M Aarestrup, PointFinder: novel web tool WGS-based detection antimicrobial resistance associated chromosomal point mutations bacterial pathogens, Journal Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764–2768, https://doi.org/10.1093/jac/dkx217","code":""},{"path":"interactive-plots.html","id":"interactive-plots","chapter":"39 Biểu đồ tương tác","heading":"39 Biểu đồ tương tác","text":"Trực quan hóa dữ liệu ngày càng đòi hỏi có khả năng truy vấn được bởi người đọc. Hệ quả là, các biểu đồ tương tác ngày càng được tạo ra nhiều hơn. Có nhiều cách để tạo biểu đồ tương tác, nhưng hai cách phổ biến nhất là sử dụng package plotly và shiny.Trong chương này chúng ta sẽ tập trung vào việc chuyển đổi một biểu đồ có sẵn được tạo bởi ggplot() thành một biểu đồ tương tác với plotly. Bạn có thể đọc thêm về shiny trong chương Dashboards với Shiny. Cũng cần nhấn mạnh là biểu đồ tương tác chỉ sử dụng được ở định dạng HTML trong tệp R markdown và không dùng được với tệp PDF hoặc Word.Dưới đây là một đường cong dịch bệnh đơn giản đã được biến đổi thành thành biểu đồ tương tác với sự kết hợp của ggplot2 và plotly (hover trỏ chuột phía trên biểu đồ, phóng , hoặc nhấp vào một item trong chú thích).","code":""},{"path":"interactive-plots.html","id":"chuẩn-bị-31","chapter":"39 Biểu đồ tương tác","heading":"39.1 Chuẩn bị","text":"","code":""},{"path":"interactive-plots.html","id":"gọi-packages-16","chapter":"39 Biểu đồ tương tác","heading":"Gọi packages","text":"Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.","code":"\npacman::p_load(\n  rio,       # import/export\n  here,      # filepaths\n  lubridate, # working with dates\n  plotly,    # interactive plots\n  scales,    # quick percents\n  tidyverse  # data management and visualization\n  ) "},{"path":"interactive-plots.html","id":"bắt-đầu-với-ggplot","chapter":"39 Biểu đồ tương tác","heading":"Bắt đầu với ggplot()","text":"Trong chương này chúng ta giả định rằng bạn đang bắt đầu với một biểu đồ tạo bởi ggplot() và muốn chuyển đổi nó thành biểu đồ tương tác. Chúng ta sẽ xây dựng một số biểu đồ như vậy trong chương này, sử dụng bộ dữ liệu linelist đã được đề cập ở rất nhiều chương trong cuốn sổ tay này.","code":""},{"path":"interactive-plots.html","id":"nhập-dữ-liệu-23","chapter":"39 Biểu đồ tương tác","heading":"Nhập dữ liệu","text":"Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới.","code":"\n# import case linelist \nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"interactive-plots.html","id":"vẽ-biểu-đồ-với-ggplotly","chapter":"39 Biểu đồ tương tác","heading":"39.2 Vẽ biểu đồ với ggplotly()","text":"Hàm ggplotly() thuộc package plotly hỗ trợ chuyển đổi dễ dàng một biểu đồ ggplot() thành có tính tương tác. Đơn giản chỉ cần lưu biểu đồ ggplot() và sau đó pipe nó tới hàm ggplotly().Dưới đây, chúng ta biểu diễn một đường đơn giản đại diện cho tỷ lệ các trường hợp tử vong trong một tuần xác định:Chúng ta bắt đầu bằng cách tạo một bộ dữ liệu tổng hợp cho từng tuần dịch tễ học, và phần trăm các trường hợp có outcome là tử vong.Đây là 50 hàng đầu tiên của bộ dữ liệu weekly_deaths.Sau đó chúng ta vẽ biểu đồ với hàm geom_line() thuộc ggplot2.Chúng ta có thể tạo tính tương tác cho biểu đồ bằng cách chuyển nó tới hàm ggplotly() như dưới đây. Di chuyển trỏ chuột của bạn tới vị trí các đường để hiện thị giá trị x và y. Bạn có thể phóng và kéo thả trong biểu đồ. Bạn cũng sẽ thấy các biểu tượng ở góc phải trên của biểu đồ. Theo thứ tự, chúng cho phép bạn:Tải xuống trạng thái hiện tại của biểu đồ dưới dạng ảnh PNGPhóng với hộp thoại lựa chọn“Pan”, hay còn gọi là di chuyển biểu đồ bằng cách nhấp và kéo thả biểu đồPhóng , thu nhỏ, hoặc quay trở về mặc địnhReset trục về mặc địnhBật/tắt “spike lines - đường vnah đai”, là các đường chấm chấm mở rộng theo trục x và y từ các điểm tương tácĐiều chỉnh hiển thị dữ liệu ngay cả khi bạn không rê chuột tới đường thẳngDữ liệu được nhóm cũng hoạt động với hàm ggplotly(). Dưới đây đường cong dịch tễ theo tuần được tạo, nhóm theo outcome. Các cột chồng có tính tương tác. Hãy thử nhấp vào các items khác nhau trong phần chú giải (chúng sẽ xuất hiện/biến mất).","code":"\nweekly_deaths <- linelist %>%\n  group_by(epiweek = floor_date(date_onset, \"week\")) %>%  # create and group data by epiweek column\n  summarise(                                              # create new summary data frame:\n    n_known_outcome = sum(!is.na(outcome), na.rm=T),      # number of cases per group with known outcome\n    n_death  = sum(outcome == \"Death\", na.rm=T),          # number of cases per group who died\n    pct_death = 100*(n_death / n_known_outcome)           # percent of cases with known outcome who died\n  )\ndeaths_plot <- ggplot(data = weekly_deaths)+            # begin with weekly deaths data\n  geom_line(mapping = aes(x = epiweek, y = pct_death))  # make line \n\ndeaths_plot   # print\ndeaths_plot %>% plotly::ggplotly()\n# Make epidemic curve with incidence2 pacakge\np <- incidence2::incidence(\n  linelist,\n  date_index = date_onset,\n  interval = \"weeks\",\n  groups = outcome) %>% plot(fill = outcome)\n# Plot interactively  \np %>% plotly::ggplotly()"},{"path":"interactive-plots.html","id":"điều-chỉnh","chapter":"39 Biểu đồ tương tác","heading":"39.3 Điều chỉnh","text":"","code":""},{"path":"interactive-plots.html","id":"kích-thước-tệp","chapter":"39 Biểu đồ tương tác","heading":"Kích thước tệp","text":"Khi xuất một tệp HTML sinh ra bởi một tệp R Markdown (như cuốn sách này!), bạn sẽ muốn dung lượng của biểu đồ nhỏ nhất có thể (mà không có các tác dụng phụ tiêu cực trong phần lớn trường hợp). Để làm điều này, chỉ cần pipe biểu đồ tương tác tới hàm partial_bundle(), cũng thuộc plotly.","code":"\np <- p %>% \n  plotly::ggplotly() %>%\n  plotly::partial_bundle()"},{"path":"interactive-plots.html","id":"nút-bấm","chapter":"39 Biểu đồ tương tác","heading":"Nút bấm","text":"Một số nút bẩm trong biểu đồ plotly khá thừa thải vã gây mất tập trung, vì vậy bạn có thể loại bỏ chúng. Đơn giản bạn chỉ cần piping đầu ra tới hàm config() thuộc plotly và cụ thể tên của nút bấm muốn loại bỏ. Trong ví dụ dưới đây, chúng ta cụ thể trước tên của nút bấm muốn loại bỏ vào một danh sách, sau đó cung cấp chúng tới đối số modeBarButtonsToRemove =. Chúng ta cũng thiết lập displaylogo = FALSE để loại bỏ logo của plotly.","code":"\n## these buttons are distracting and we want to remove them\nplotly_buttons_remove <- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',\n                              'zoomOut2d','autoScale2d','hoverClosestCartesian',\n                              'toggleSpikelines','hoverCompareCartesian')\n\np <- p %>%          # re-define interactive plot without these buttons\n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)"},{"path":"interactive-plots.html","id":"biểu-đồ-nhiệt","chapter":"39 Biểu đồ tương tác","heading":"39.4 Biểu đồ nhiệt","text":"Bạn có thể khiến bất kỳ loại biểu đồ nào tạo bởi ggplot() có khả năng tương tác, bao gồm biểu đồ nhiệt. Trong chương [Biểu đò nhiệt], bạn có thể đọc thêm về cách tạo biểu đồ dưới đây để hiển thị tỷ lệ số ngày trong tuần mà các cơ sở y tế báo cáo dữ liệu lên tuyến tỉnh.Sau đây là code, mặc dù chúng tôi sẽ không giải thích chi tiết tại đây.Sau đó, chúng tôi biến nó trở thành biểu đồ tương tác và điều chỉnh các nút bấm và dung lượng tệp.–>\n","code":"\n# import data\nfacility_count_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\"))\n\n# aggregate data into Weeks for Spring district\nagg_weeks <- facility_count_data %>% \n  filter(District == \"Spring\",\n         data_date < as.Date(\"2020-08-01\")) %>% \n  mutate(week = aweek::date2week(\n    data_date,\n    start_date = \"Monday\",\n    floor_day = TRUE,\n    factor = TRUE)) %>% \n  group_by(location_name, week, .drop = F) %>%\n  summarise(\n    n_days          = 7,\n    n_reports       = n(),\n    malaria_tot     = sum(malaria_tot, na.rm = T),\n    n_days_reported = length(unique(data_date)),\n    p_days_reported = round(100*(n_days_reported / n_days))) %>% \n  right_join(tidyr::expand(., week, location_name)) %>% \n  mutate(week = aweek::week2date(week))\n\n# create plot\nmetrics_plot <- ggplot(agg_weeks,\n       aes(x = week,\n           y = location_name,\n           fill = p_days_reported))+\n  geom_tile(colour=\"white\")+\n  scale_fill_gradient(low = \"orange\", high = \"darkgreen\", na.value = \"grey80\")+\n  scale_x_date(expand = c(0,0),\n               date_breaks = \"2 weeks\",\n               date_labels = \"%d\\n%b\")+\n  theme_minimal()+ \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),\n    legend.key.width  = grid::unit(0.6,\"cm\"),\n    axis.text.x = element_text(size=12),\n    axis.text.y = element_text(vjust=0.2),\n    axis.ticks = element_line(size=0.4),\n    axis.title = element_text(size=12, face=\"bold\"),\n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),\n    plot.caption = element_text(hjust = 0, face = \"italic\")\n    )+\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, April-May 2019\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\nmetrics_plot # print\nmetrics_plot %>% \n  plotly::ggplotly() %>% \n  plotly::partial_bundle() %>% \n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)"},{"path":"interactive-plots.html","id":"tài-nguyên-học-liệu-14","chapter":"39 Biểu đồ tương tác","heading":"39.5 Tài nguyên học liệu","text":"Plotly không chỉ dành riêng cho R mà còn hoạt động tốt với Python (và bất cứ ngôn ngữ khoa học dữ liệu nào khác bởi vì nó được xây dựng trên JavaScript). Bạn có thể tìm hiểu thêm về nở ở website của plotly","code":""},{"path":"rmarkdown.html","id":"rmarkdown","chapter":"40 Báo cáo với R Markdown","heading":"40 Báo cáo với R Markdown","text":"R Markdown là một công cụ được sử dụng rộng rãi nhằm tạo ra tài liệu tự động, tái lập và chia sẻ được, như các báo cáo. Nó có thể tạo ra kết quả thống kê hoặc tương tác, ở định dạng Word, pdf, html, powerpoint, và các định dạng khác.Một R Markdown script chứa xen kẽ các code R và văn bản khiến script này thật sự trở thành một tài liệu đầu ra của bạn. Bạn có thể tạo ra một tài liệu đã được định dạng toàn bộ, gồm có văn bản thuần túy (có thể thay đổi dựa trên số liệu của bạn), bảng, biểu đồ, đầu mục/số, thư mục, v.v.Những tài liệu như vậy có thể được cập nhật thường xuyên (ví dụ: báo cáo giám sát hàng ngày) và/hoặc chạy một tập dữ liệu (ví dụ: báo cáo cho mỗi jurisdiction-quyền xét xử).Những chương khác trong cuốn sách này mở rộng các chủ đề khác:Chương Tổ chức báo cáo định kỳ trình bày cách tự động hóa các báo cáo sản phẩm với các tập tin tự tạo kèm theo thời gian.Chương Dashboards với R Markdown giải thích cách định dạng một báo cáo R Markdown dưới dạng một dashboard.Một lưu ý là dự án R4Epis đã tạo ra các mẫu R Markdown script cho những đợt dịch và trường hợp khảo sát phổ biến ở vị trí dự án MSF.","code":""},{"path":"rmarkdown.html","id":"chuẩn-bị-32","chapter":"40 Báo cáo với R Markdown","heading":"40.1 Chuẩn bị","text":"Nền tảng về R MarkdownNhằm giải thích một số khái niệm và packages cần thiết:Markdown là một “ngôn ngữ” cho phép bạn soạn tài liệu bằng chữ thuần túy, sau đó có thể chuyển đổi sang html và các định dạng khác. Nó không dành riêng cho R. Các tệp được viết trong Markdown có đuôi ‘.md’.R Markdown: là một biến thể trên markdown chỉ dành riêng cho R - nó cho phép bạn soạn một tài liệu sử dụng markdown để tạo chữ cũng như nhúng code R và hiển thị kết quả đầu ra. Các tệp R Markdown có đuôi ‘.Rmd’.Package rmarkdown: Package được R sử dụng để chuyển tệp .Rmd thành đầu ra mong muốn. Nó tập trung vào việc chuyển cú pháp markdown (chữ), vì vậy chúng ta cũng cần tới…knitr: Package R này sẽ đọc các đoạn code, thực thi chúng, và ‘knit’ (kết hợp) chúng vào lại tài liệu. Đây là cách bảng, biểu đồ được thêm vào văn bản.Pandoc: Cuối cùng, pandoc thật sự chuyển đổi kết quả đầu ra thành word/pdf/powerpoint, v.v. Nó là một phần mềm tách biệt khỏi R nhưng được cài đặt tự động cùng với RStudio.Tổng kết lại, quá trình được tiến hành trong nền (bạn không cần biết tới tất cả những bước này!), gồm chuyển tệp .Rmd tới knitr để thực thi các đoạn code R và tạo một tệp .md (markdown) mới bao gồm cả code R lẫn kết quả đầu ra đã được chuyển đổi. Các tệp .md này sau đó được pandoc chạy để tạo ra sản phẩm hoàn thiện như là một tài liệu Microsoft Word, tệp HTML, tài liệu powerpoint, pdf, v.v.(Nguồn: https://rmarkdown.rstudio.com/authoring_quick_tour.html):Cài đặtĐể tạo một kết quả đầu ra của R Markdown, bạn cần phải cài đặt:Package rmarkdown (knitr cũng sẽ được cài đặt tự động)Pandoc sẽ được cài đặt cùng với RStudio. Nếu bạn không dùng RStudio, bạn có thể tải Pandoc tại đây: http://pandoc.org.Nếu bạn muốn tạo đầu ra là tệp PDF (phức tạp hơn một chút), bạn sẽ cần cài đặt LaTex. Với những người dùng R Markdown chưa cài đặt LaTex trước đó, các bạn có thể cài đặt TinyTeX (https://yihui.name/tinytex/). Bạn có thể sử dụng lệnh sau để cài đặt:","code":"\npacman::p_load(tinytex)     # install tinytex package\ntinytex::install_tinytex()  # R command to install TinyTeX software "},{"path":"rmarkdown.html","id":"bắt-đầu","chapter":"40 Báo cáo với R Markdown","heading":"40.2 Bắt đầu","text":"","code":""},{"path":"rmarkdown.html","id":"cài-đặt-package-rmarkdown","chapter":"40 Báo cáo với R Markdown","heading":"Cài đặt package rmarkdown","text":"Cài đặt R package rmarkdown. Trong quyển sổ tay này chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt package nếu cần và gọi ra để sử dụng. Bạn cũng có thể cài đặt package với library() từ base R. Xem thêm ở chương R cơ bản để biết thêm thông tin về R packages.","code":"\npacman::p_load(rmarkdown)"},{"path":"rmarkdown.html","id":"bắt-đầu-một-tệp-rmd-mới","chapter":"40 Báo cáo với R Markdown","heading":"Bắt đầu một tệp Rmd mới","text":"Trong RStudio, để mở một tệp R markdown mới, bắt đầu với ‘File’, rồi ‘New file’, rồi ‘R markdown…’.R Studio sẽ đưa ra cho bạn một số lựa chọn kết quả đầu ra. Trong ví dụ bên dưới, chúng tôi chọn “HTML” bởi chúng tôi muốn tạo ra một văn bản html. Tiêu đề và tên các tác giả không quan trọng. Nếu loại tài liệu đầu ra bạn muốn không có, đừng lo - bạn có thể chọn bất kỳ loại nào và thay đổi trong script sau đó.Như vậy sẽ mở ra một script .Rmd mới.","code":""},{"path":"rmarkdown.html","id":"điều-quan-trọng-cần-phải-biết","chapter":"40 Báo cáo với R Markdown","heading":"Điều quan trọng cần phải biết","text":"Thư mục làm việcThư mục làm việc của một tệp markdown là ở bất kỳ vị trí nào tệp được lưu. Ví dụ, nếu R project nằm trong ~/Documents/projectX và tệp Rmd được lưu ở thư mục con ~/Documents/projectX/markdownfiles/markdown.Rmd, thì lệnh read.csv(“data.csv”) trong markdown sẽ tìm tệp csv trong thư mục markdownfiles, mà không phải là ở thư mục gốc nơi mà scripts trong projects sẽ thường tự động tìm kiếm.Để tìm kiếm các tệp này ở chỗ khác, bạn sẽ vừa cần sử dụng cả đường dẫn tệp đầy đủ và sử dụng package . Package cài đặt thư mục làm việc tới thư mục gốc của R project và sẽ được giải thích chi tiết trong các chương Dự án R và Nhập xuất dữ liệu của sổ tay này. Ví dụ, để nhập một tệp tên “data.csv” từ trong thư mục projectX, code sẽ là import((“data.csv”)).Lưu ý rằng không nên sử dụng setwd() trong R Markdown scripts - nó chỉ dùng cho các đoạn code được viết trong đó.Làm việc với ổ cứng mạng với trên máy tính của bạnVì R Markdown có thể gặp các vấn đề với pandoc khi chạy trên một ổ cứng mạng được chia sẻ, thư mục của bạn nên nằm ở ở cứng vật lý, ví dụ trong dự án thuộc ‘Documents’. Nếu bạn dùng Git (rất khuyến khích!), nó sẽ thân thuộc hơn. Để biết thêm chi tiết, xem thêm chương R trên ổ cứng mạng và Các lỗi thường gặp.","code":""},{"path":"rmarkdown.html","id":"các-cấu-phần-của-r-markdown","chapter":"40 Báo cáo với R Markdown","heading":"40.3 Các cấu phần của R Markdown","text":"Một tài liệu R Markdown có thể chỉnh sửa trong RStudio giống như một R script tiêu chuẩn. Khi bạn tạo một R Markdown script mới, RStudio vô cùng hữu ích bằng cách đưa ra một mẫu có các phần khác nhau của một tệp R Markdown script.Dưới đây là khung hiển thị khi bắt đầu một Rmd script mới có kết quả đầu ra là html (như phần trước)Như bạn có thể thấy, một tệp Rmd gồm có 3 cấu phần: YAML, chữ Markdown, và đoạn code R.Chúng sẽ tạo ra và trở thành tài liệu đầu ra của bạn. Xem biểu đồ bên dưới:","code":""},{"path":"rmarkdown.html","id":"yaml-metadata","chapter":"40 Báo cáo với R Markdown","heading":"YAML metadata","text":"‘YAML metadata’ hoặc chỉ ‘YAML’ nằm ở trên cùng trong tài liệu R Markdown. Phần này của script sẽ cho tệp Rmd của bạn biết cần tạo loại kết quả đầu ra nào, định dạng mong muốn, và metadata khác như tiêu đề tài liệu, tác giả, và ngày. Có những công dụng khác không được nhắc ở đây (nhưng được nhắc tới trong ‘Tạo kết quả đầu ra’). Lưu ý rằng có sự thụt đầu dòng, nhưng chỉ chấp nhận spaces chứ không nhận tabs.Phần này phải được bắt đầu với với một dòng gồm có 3 dấu gạch ngang --- và phải kết thúc với một dòng chỉ có 3 dấu gạch ngang ---. Tham số của YAML ở dạng cặp key:value. Dấu hai chấm trong YAML có vị trí quan trọng - cặp key:value được tách ra bởi dấu hai chấm (không phải dấu bằng!)YAML nên bắt đầu với metadata cho tài liệu. Thứ tự của những tham số YAML chính (không thụt lề) không quan trọng. Ví dụ:Bạn có thể sử dụng code R trong giá trị YAML bằng cách viết nó như code tại dòng (mở đầu bằng r trong dấu back-ticks/nháy đơn ngược) nhưng nằm trong trích dẫn (xem tại ví dụ phía trên với date:).Trong hình ảnh phía trên, vì chúng ta ấn vào kết quả đầu ra mặc định là tệp html, chúng ta có thể thấy rằng YAML hiện output: html_document. Tuy nhiên, chúng ta cũng có thể thay đổi thành powerpoint_presentation hoặc word_document hoặc cả pdf_document.","code":"title: \"My document\"\nauthor: \"Me\"\ndate: \"2021-10-06\""},{"path":"rmarkdown.html","id":"văn-bản","chapter":"40 Báo cáo với R Markdown","heading":"Văn bản","text":"Đây là phần diễn giải trong tài liệu của bạn, gồm các tiêu đề và đề mục. Nó được viết bằng ngôn ngữ “markdown”, được sử dụng trên nhiều phần mềm khác nhau.Dưới đây là những cách cốt lõi để viết văn bản định dạng này. Xem thêm tài liệu mở rộng có sẵn trên R Markdown “cheatsheet” tại Trang web RStudio.","code":""},{"path":"rmarkdown.html","id":"dòng-mới","chapter":"40 Báo cáo với R Markdown","heading":"Dòng mới","text":"Duy nhất trong R Markdown, để bắt đầu một dòng mới, nhập *hai dấu cách** vào cuối dòng trước đó và ấn Enter/Return.","code":""},{"path":"rmarkdown.html","id":"định-dạng","chapter":"40 Báo cáo với R Markdown","heading":"Định dạng","text":"Đặt các chữ bình thường bên trong các kí tự sau để thay đổi định dạng của chúng ở đầu ra.Gạch dưới (_chữ_) hoặc dấu hoa thị đơn (*chữ*) để nghiêngDấu hoa thị kép (**chữ**) để đậmDấu nháy đơn ngược (chữ) để hiển thị chữ như codePhông chữ hiển thị thực tế có thể được đặt bằng cách sử dụng các mẫu cụ thể (được chỉ định trong YAML metadata; xem các tab ví dụ).","code":""},{"path":"rmarkdown.html","id":"màu-sắc-1","chapter":"40 Báo cáo với R Markdown","heading":"Màu sắc","text":"Không có cơ chế đơn giản nào để thay đổi màu chữ trong R Markdown. Một giải pháp khác, NẾU đầu ra của bạn là tệp HTML, là thêm một dòng HTML vào văn bản markdown. Đoạn mã HTML dưới đây sẽ ra một dòng văn bản có màu đỏ đậm.DANGER: warning.","code":"<span style=\"color: red;\">**_DANGER:_** This is a warning.<\/span>  "},{"path":"rmarkdown.html","id":"tiêu-đề-và-đầu-mục","chapter":"40 Báo cáo với R Markdown","heading":"Tiêu đề và đầu mục","text":"Dấu thăng trong phần văn bản của một script R Markdown tạo ra đầu mục. Điều này khác với một đoạn code R trong script, trong đó ký hiệu thăng là cơ chế nhận xét/chú thích/hủy kích hoạt, như trong R script bình thường.Các mức tiêu đề khác nhau được thiết lập với số lượng ký hiệu thăng khác nhau khi bắt đầu một dòng mới. Một ký hiệu thăng là tiêu đề hoặc đầu mục chính. Hai ký hiệu thăng là một đầu mục cấp hai. Các đầu mục cấp ba và cấp bốn có thể được tạo bằng các ký hiệu thăng liên tiếp.","code":"# Đầu mục cấp một / Tiêu đề\n\n## Đầu mục cấp hai\n\n### Đầu mục cấp ba"},{"path":"rmarkdown.html","id":"dấu-đầu-dòng-và-đánh-số","chapter":"40 Báo cáo với R Markdown","heading":"Dấu đầu dòng và đánh số","text":"Sử dụng dấu hoa thị (*) để tạo danh sách gạch đầu dòng. Kết thúc câu trước, nhập hai dấu cách, Enter/Return hai lần, và bắt đầu tạo gạch đầu dòng. Thêm một dấu cách vào giữa dấu hoa thị và chữ đầu dòng. Sau mỗi đầu dòng nhập hai dấu cách và Enter/Return. Gạch đầu dòng phụ được tạo tương tự nhưng được thụt vào. Các số cũng hoạt động tương tự nhưng thay vì dấu hoa thị, viết 1), 2), v.v. Dưới đây là cách văn bản R Markdown script của bạn trông như thế nào.","code":"Đây là gạch đầu dòng của tôi (có hai dấu cách sau dấu hai chấm này):  \n\n* Gạch đầu dòng 1 (theo sau là 2 dấu cách và Enter/Return)  \n* Gạch đầu dòng 2 (theo sau là 2 dấu cách và Enter/Return)  \n  * Gạch đầu dòng phụ 1 (theo sau là 2 dấu cách và Enter/Return)  \n  * Gạch đầu dòng phụ 2 (theo sau là 2 dấu cách và Enter/Return)  \n  "},{"path":"rmarkdown.html","id":"chữ-chú-giải","chapter":"40 Báo cáo với R Markdown","heading":"Chữ chú giải","text":"Bạn có thể “chú giải” văn bản R Markdown giống như bạn sử dụng “#” để chú giải một dòng code R trong một đoạn code R. Chỉ cần đánh dấu văn bản và nhấn Ctrl+Shift+c (Cmd+Shift+c cho Mac). Văn bản sẽ được bao quanh bởi các mũi tên và chuyển sang màu xanh lục. Nó sẽ không xuất hiện trong kết quả đầu ra của bạn.","code":""},{"path":"rmarkdown.html","id":"đoạn-code","chapter":"40 Báo cáo với R Markdown","heading":"Đoạn Code","text":"Các phần của script dành riêng để chạy code R được gọi là “chunk - đoạn”. Đây là nơi bạn có thể tải các package, nhập dữ liệu và thực hiện quản lý và trực quan hóa dữ liệu thực tế. Có thể có nhiều đoạn code, vì vậy chúng có thể giúp bạn tổ chức code R của mình thành các phần, có thể xen kẽ với văn bản. Cần lưu ý:\nNhững ‘đoạn’ này sẽ có màu nền hơi khác với phần diễn giải của tài liệu.Mỗi đoạn code được mở với một dòng bắt đầu với 3 dấu nháy đơn ngược, và ngoặc nhọn chứa các tham số cho đoạn ({ }). Đoạn code kết thúc với 3 dấu nháy đơn ngược.Bạn có thể tạo một đoạn code mới bằng cách tự gõ nó ra, hoặc bằng cách sử dụng phím tắt “Ctrl + Alt + ” (hoặc Cmd + Shift + r trong Mac), hoặc bằng cách nhấp vào biểu tượng ‘insert new code chunk’ màu xanh lục ở đầu trình chỉnh sửa script của bạn.Một số lưu ý về nội dung bên trong dấu ngoặc nhọn { }:Chúng bắt đầu bằng ‘r’ để chỉ ra rằng tên ngôn ngữ trong đoạn này là RSau chữ r, bạn có thể tùy ý viết “tên” đoạn - việc này không cần thiết nhưng có thể giúp bạn sắp xếp công việc của mình tốt hơn. Lưu ý rằng nếu bạn đặt tên cho các phần của mình, bạn phải LUÔN sử dụng các tên độc nhất, nếu không R sẽ báo lỗi khi bạn cố gắng kết xuất.Dấu ngoặc nhọn cũng có thể bao gồm các tùy chọn khác, được viết dưới dạng tag = value, chẳng hạn như:eval = FALSE để không chạy code Recho = FALSE để không hiển thị mã nguồn code R của đoạn trong kết quả đầu rawarning = FALSE để không hiển thị cảnh báo được tạo bởi code Rmessage = FALSE để không hiển thị bất kỳ thông báo nào được tạo bởi code Rinclude = TRUE/FALSE có bao gồm đầu ra đoạn code (ví dụ: các đồ thị) trong tài liệu hay khôngout.width = và .height = - cung cấp theo kiểu .width = \"75%\"fig.align = \"center\" điều chỉnh cách một hình được căn trên trangfig.show='hold' nếu đoạn code của bạn hiển thị nhiều biểu đồ và bạn muốn chúng hiển thị cạnh nhau (cùng với .width = c(\"33%\", \"67%\"). Có thể đặt là fig.show='asis' để hiển thị chúng dưới code tạo chúng, 'hide' để ẩn, hoặc 'animate' để nối nhiều cái thành một ảnh động.Tiêu đề đoạn phải được viết trên một dòngCố gắng tránh dấu chấm, dấu gạch dưới và dấu cách. Sử dụng dấu gạch ngang ( - ) thay thế nếu bạn cần dấu ngăn cách.Đọc kĩ hơn về các tùy chọn knitr tại đây.Một số tùy chọn ở trên có thể được định cấu hình với trỏ và nhấp bằng cách sử dụng các nút cài đặt ở trên cùng bên phải của đoạn. Tại đây, bạn có thể chỉ định những phần nào của đoạn mà bạn muốn tài liệu được kết xuất bao gồm cụ thể là code, kết quả đầu ra và cảnh báo. Điều này sẽ xuất hiện dưới dạng tùy chọn được viết trong dấu ngoặc nhọn, ví dụ echo = FALSE nếu bạn muốn ‘Chỉ hiển thị đầu ra’.Ngoài ra còn có hai mũi tên ở trên cùng bên phải của mỗi đoạn code. Chúng rất hữu ích để chạy code trong một đoạn hoặc tất cả code trong các đoạn trước. Di chuột lên chúng để xem chúng làm gì.Để các tùy chọn toàn cục được áp dụng cho tất cả các đoạn trong tập lệnh, bạn có thể thiết lập điều này trong đoạn code R đầu tiên của mình trong tập lệnh. Ví dụ, để chỉ các kết quả đầu ra được hiển thị cho mỗi đoạn code chứ không phải bản thân code, bạn có thể đưa lệnh này vào đoạn code R:","code":"\nknitr::opts_chunk$set(echo = FALSE) "},{"path":"rmarkdown.html","id":"code-r-trong-văn-bản","chapter":"40 Báo cáo với R Markdown","heading":"Code R trong văn bản","text":"Bạn cũng có thể bao gồm code R đơn giản trong dấu nháy đơn ngược. Trong dấu nháy đơn ngược, hãy bắt đầu mã bằng “r” và một dấu cách, để RStudio biết đánh giá code đó là code R. Xem ví dụ bên dưới.Ví dụ bên dưới hiển thị nhiều cấp tiêu đề, dấu đầu dòng và sử dụng code R cho ngày hiện tại (Sys.Date ()) để chuyển thành ngày .Phía trên là một ví dụ đơn giản (hiển thị ngày hiện tại), nhưng sử dụng cùng một cú pháp, bạn có thể hiển thị các giá trị được tạo bởi code R phức tạp hơn (ví dụ: để tính toán giá trị nhỏ nhất, trung bình, giá trị lớn nhất của một cột). Bạn cũng có thể tích hợp các đối tượng hoặc giá trị R đã được tạo trong các đoạn code R trước đó trong script.Ví dụ, script dưới đây tính toán tỷ lệ các trường hợp dưới 18 tuổi, sử dụng các hàm tidyverse và tạo các đối tượng less18,total và less18prop. Giá trị động này được chèn vào văn bản tiếp theo. Chúng ta thấy nó trông như thế nào khi được knit vào một tài liệu word.","code":""},{"path":"rmarkdown.html","id":"ảnh","chapter":"40 Báo cáo với R Markdown","heading":"Ảnh","text":"Bạn có thể đưa hình ảnh vào R Markdown của mình theo một trong hai cách:Nếu cách trên không được, thử dùng knitr::include_graphics()(hãy nhớ rằng, đường dẫn tệp của bạn có thể được viết bằng cách sử dụng package )","code":"![](\"path/to/image.png\")  \nknitr::include_graphics(\"path/to/image.png\")\nknitr::include_graphics(here::here(\"path\", \"to\", \"image.png\"))"},{"path":"rmarkdown.html","id":"bảng","chapter":"40 Báo cáo với R Markdown","heading":"Bảng","text":"Tạo bảng bằng dấu gạch ngang ( - ) và dấu thanh ( | ). Số lượng dấu gạch nối trước/giữa các thanh cho phép số lượng khoảng trắng trong ô trước khi văn bản bắt đầu được bao lại.Code trên tạo ra bảng ở dưới:","code":"Cột 1    |Cột  2    |Cột 3\n---------|----------|--------\nÔ A      |Ô B       |Ô C\nÔ D      |Ô E       |Ô F"},{"path":"rmarkdown.html","id":"các-phần-được-chia-thẻ","chapter":"40 Báo cáo với R Markdown","heading":"Các phần được chia thẻ","text":"Đối với đầu ra là tệp HTML, bạn có thể sắp xếp các phần thành các “tab - thẻ”. Chỉ cần thêm .tabset vào trong dấu ngoặc nhọn{}được đặt sau đề mục. Bất kỳ đề mục phụ nào bên dưới tiêu đề đó (cho đến khi tiêu đề khác cùng cấp) sẽ xuất hiện dưới dạng các tab mà người dùng có thể nhấp qua. Đọc thêm tại đâyBạn có thể thêm một tùy chọn bổ sung .tabset-pills sau .tabset để tạo cho các thẻ có giao diện “được tô màu”. Lưu ý rằng khi xem đầu ra HTML theo thẻ, chức năng tìm kiếm Ctrl+f sẽ chỉ tìm kiếm các tab “đang hoạt động” chứ không phải các thẻ ẩn.","code":""},{"path":"rmarkdown.html","id":"cấu-trúc-tệp","chapter":"40 Báo cáo với R Markdown","heading":"40.4 Cấu trúc tệp","text":"Có nhiều cách để tổ chức R Markdown của bạn và bất kỳ script R nào liên quan. Mỗi cách đều có cả ưu điểm và nhược điểm:R Markdown khép kín - mọi thứ cần thiết cho báo cáo đều được nhập hoặc tạo trong R Markdown\nNguồn từ các tệp khác - Bạn có thể chạy các script R bên ngoài bằng lệnh source () và sử dụng đầu ra của chúng trong Rmd\nScipt con - một cơ chế thay thế cho source()\nNguồn từ các tệp khác - Bạn có thể chạy các script R bên ngoài bằng lệnh source () và sử dụng đầu ra của chúng trong RmdScipt con - một cơ chế thay thế cho source()Sử dụng “runfile” - Chạy các lệnh trong script R trước khi kết xuất tệp R Markdown","code":""},{"path":"rmarkdown.html","id":"rmd-khép-kín","chapter":"40 Báo cáo với R Markdown","heading":"Rmd khép kín","text":"Đối với một báo cáo tương đối đơn giản, bạn có thể chọn tổ chức tập lệnh R Markdown của mình sao cho nó “khép kín” và không liên quan đến bất kỳ tập lệnh bên ngoài nào.Mọi thứ bạn cần để chạy R markdown đều được nhập hoặc tạo trong tệp Rmd, bao gồm tất cả các đoạn code và package. Cách tiếp cận “khép kín” này phù hợp khi bạn không cần xử lý nhiều dữ liệu (ví dụ: nó mang đến một tệp dữ liệu sạch hoặc gần sạch) và việc kết xuất R Markdown sẽ không mất quá nhiều thời gian.Trong trường hợp này, một cấu trúc hợp lý của script R Markdown có thể là:Thiết lập các tùy chọn knitr chungTải packagesNhập dữ liệuXử lý dữ liệuTạo kết quả đầu ra (bảng, đồ thị, etc.)Lưu kết quả đầu ra nếu cần (.csv, .png, v.v.)","code":""},{"path":"rmarkdown.html","id":"nguồn-từ-các-tệp-khác","chapter":"40 Báo cáo với R Markdown","heading":"Nguồn từ các tệp khác","text":"Một biến thể của cách tiếp cận “khép kín” là có các đoạn code R Markdown “nguồn” (chạy) chạy các script R khác. Điều này có thể làm cho tập lệnh R Markdown của bạn ít lộn xộn hơn, đơn giản hơn và dễ tổ chức hơn. Nó cũng có thể hữu ích nếu bạn muốn hiển thị số liệu cuối cùng ở đầu báo cáo. Theo cách tiếp cận này, script R Markdown cuối cùng chỉ đơn giản là kết hợp các đầu ra được xử lý trước thành một tài liệu.Một cách để làm điều này là cung cấp script R (đường dẫn tệp và tên có phần mở rộng) cho lệnh R base source().Lưu ý rằng khi sử dụng source () trong R Markdown, các tệp bên ngoài sẽ vẫn được chạy trong quá trình kết xuất tệp Rmd của bạn. đó, mỗi tập lệnh được chạy mỗi lần bạn kết xuất báo cáo. đó, việc có các lệnh source () này trong R Markdown không tăng tốc thời gian chạy của bạn, cũng như không hỗ trợ nhiều cho việc gỡ lỗi, vì lỗi vẫn được hiển thị khi tạo R Markdown.Một giải pháp thay thế là sử dụng tùy chọn child = của knitr. GIẢI THÍCH THÊM ĐỂ LÀMBạn phải để ý các môi trường R khác nhau. Các đối tượng được tạo trong một môi trường sẽ không nhất thiết phải có sẵn cho môi trường được R Markdown sử dụng.","code":"\nsource(\"your-script.R\", local = knitr::knit_global())\n# or sys.source(\"your-script.R\", envir = knitr::knit_global())"},{"path":"rmarkdown.html","id":"runfile","chapter":"40 Báo cáo với R Markdown","heading":"Runfile","text":"Cách tiếp cận này liên quan đến việc sử dụng R script có chứa (các) lệnh render () để xử lý trước các đối tượng đưa vào R markdown.Ví dụ, bạn có thể tải các package, tải và làm sạch dữ liệu, và thậm chí tạo các biểu đồ trước khi render(). Các bước này có thể xảy ra trong R script hoặc trong các script khác được lưu nguồn. Miễn là các lệnh này diễn ra trong cùng một phiên RStudio và các đối tượng được lưu vào môi trường, các đối tượng sau đó có thể được gọi trong nội dung Rmd. Sau đó, bản thân R markdown sẽ chỉ được sử dụng cho bước cuối cùng - để tạo ra kết quả với tất cả các đối tượng được xử lý trước. Điều này dễ dàng hơn để gỡ lỗi nếu có sự cố.Cách tiếp cận này hữu ích vì những lý sau:Thông báo lỗi mang nhiều thông tin hơn - những thông báo này sẽ được tạo từ R script, không phải R Markdown. Lỗi R Markdown có xu hướng cho bạn biết đoạn nào có vấn đề, nhưng sẽ không cho bạn biết dòng nào.Thông báo lỗi mang nhiều thông tin hơn - những thông báo này sẽ được tạo từ R script, không phải R Markdown. Lỗi R Markdown có xu hướng cho bạn biết đoạn nào có vấn đề, nhưng sẽ không cho bạn biết dòng nào.Nếu có thể, bạn có thể chạy các bước xử lý dài trước lệnh render () - chúng sẽ chỉ chạy một lần.Nếu có thể, bạn có thể chạy các bước xử lý dài trước lệnh render () - chúng sẽ chỉ chạy một lần.Trong ví dụ bên dưới, chúng ta có một R script riêng biệt, trong đó chúng tôi xử lý trước một đối tượng data vào Môi trường R và sau đó kết xuất “create_output.Rmd” bằng cách sử dụng render().","code":"\ndata <- import(\"datafile.csv\") %>%       # Load data and save to environment\n  select(age, hospital, weight)          # Select limited columns\n\nrmarkdown::render(input = \"create_output.Rmd\")   # Create Rmd file"},{"path":"rmarkdown.html","id":"cấu-trúc-thư-mục","chapter":"40 Báo cáo với R Markdown","heading":"Cấu trúc thư mục","text":"Quy trình làm việc cũng liên quan đến cấu trúc thư mục tổng thể, chẳng hạn như có thư mục ‘đầu ra’ cho các tài liệu và số liệu đã tạo và thư mục ‘dữ liệu’ hoặc ‘đầu vào’ cho dữ liệu đã được làm sạch. Chúng tôi không đi sâu vào chi tiết ở đây, nhưng hãy xem chương Tổ chức báo cáo định kỳ.","code":""},{"path":"rmarkdown.html","id":"tạo-tài-liệu","chapter":"40 Báo cáo với R Markdown","heading":"40.5 Tạo tài liệu","text":"Bạn có thể tạo tài liệu theo những cách sau:Thủ công bằng cách nhấn nút “Knit” ở đầu trình chỉnh sửa script RStudio (nhanh chóng và dễ dàng)Chạy lệnh render() (được thực thi bên ngoài R Markdown script)","code":""},{"path":"rmarkdown.html","id":"cách-1-nút-knit","chapter":"40 Báo cáo với R Markdown","heading":"Cách 1: Nút “Knit”","text":"Khi bạn mở tệp Rmd, hãy nhấn vào biểu tượng/nút ‘Knit’ ở đầu tệp.R Studio sẽ cho bạn thấy tiến trình trong tab ‘R Markdown’ gần R console của bạn. Tài liệu sẽ tự động mở khi hoàn tất.Tài liệu sẽ được lưu trong cùng một thư mục với R markdown script của bạn và có cùng tên tệp (ngoại trừ phần mở rộng). Điều này rõ ràng không phải là lý tưởng cho việc kiểm soát phiên bản (nó sẽ bị ghi đè lên mỗi lần bạn knit, trừ khi được di chuyển theo cách thủ công), như sau đó bạn có thể cần phải tự đổi tên tệp (ví dụ: thêm ngày).Đây là nút tắt của RStudio cho hàm render () từ rmarkdown. Cách tiếp cận này chỉ tương thích với R markdown khép kín, nơi tất cả các thành phần cần thiết tồn tại hoặc có nguồn trong tệp.","code":""},{"path":"rmarkdown.html","id":"cách-2-lệnh-render","chapter":"40 Báo cáo với R Markdown","heading":"Cách 2: Lệnh render()","text":"Một cách khác để tạo đầu ra R Markdown của bạn là chạy hàm render () (từ package rmarkdown). Bạn phải thực hiện lệnh này bên ngoài R Markdown script - vì vậy hoặc trong một tập lệnh R riêng biệt (thường được gọi là “run file”) hoặc dưới dạng lệnh độc lập trong R Console.Như với “knit”, cài đặt mặc định sẽ lưu đầu ra Rmd vào cùng thư mục với Rmd script, với cùng tên tệp (ngoài phần mở rộng tệp). Ví dụ: “my_report.Rmd” khi được knit sẽ tạo ra “my_report.docx” nếu bạn đang knit vào một tài liệu word. Tuy nhiên, bằng cách sử dụng render (), bạn có tùy chọn sử dụng các cài đặt khác nhau. render () có thể chấp nhận các đối số bao gồm:output_format = Đây là định dạng đầu ra để chuyển đổi (e.g. \"html_document\", \"pdf_document\", \"word_document\", hoặc \"\"). Bạn cũng có thể chỉ định điều này trong YAML bên trong R Markdown script.output_file = Đây là tên của tệp đầu ra (và đường dẫn tệp). Điều này có thể được tạo thông qua các hàm R như () hoặc str_glue() như minh họa bên dưới.output_dir = Đây là thư mục đầu ra (thư mục) để lưu tệp. Điều này cho phép bạn chọn một thư mục khác với thư mục mà tệp Rmd được lưu vào.output_options = Bạn có thể cung cấp một danh sách các tùy chọn sẽ ghi đè các tùy chọn đó trong script YAML (ví dụ, )output_yaml = Bạn có thể cung cấp đường dẫn đến tệp .yml chứa thông số kỹ thuật YAMLparams = Xem phần thông số bên dướiXem danh sách đầy đủ tại đâyVí dụ, để cải thiện kiểm soát phiên bản, lệnh sau sẽ lưu tệp đầu ra trong thư mục con ‘đầu ra’, với ngày hiện tại trong tên tệp. Để tạo tên tệp, hàm str_glue () từ package stringr được sử dụng để ‘dán’ các chuỗi tĩnh lại với nhau (được viết đơn giản) với code R động (được viết trong dấu ngoặc nhọn). Ví dụ: nếu đó là ngày 10 tháng 4 năm 2021, tên tệp từ bên dưới sẽ là “Report_2021-04-10.docx”. Xem chương Ký tự và chuỗi để biết thêm chi tiết về str_glue ().Khi file đang kết xuất, RStudio Console sẽ cho bạn thấy quá trình kết xuất tới 100%, và một thông báo cuối để báo rằng quá trình kết xuất đã hoàn thành.","code":"\nrmarkdown::render(input = \"my_report.Rmd\")\nrmarkdown::render(\n  input = \"create_output.Rmd\",\n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\")) "},{"path":"rmarkdown.html","id":"cách-3-reportfactory-package","chapter":"40 Báo cáo với R Markdown","heading":"Cách 3: reportfactory package","text":"R package reportfactory cung cấp một phương pháp thay thế để tổ chức và soạn báo cáo R Markdown phù hợp với các tình huống mà bạn chạy báo cáo thường xuyên (ví dụ hàng ngày, hàng tuần …). Nó giúp giảm bớt việc soạn nhiều tệp R Markdown và tổ chức đầu ra của chúng. Về bản chất, nó cung cấp một “nhà máy” mà từ đó bạn có thể chạy báo cáo R Markdown, nhận các thư mục được đánh dấu ngày tháng và thời gian tự động cho kết quả đầu ra và có cách kiểm soát phiên bản “nhẹ nhàng”.Đọc thêm về quy trình công việc này trong chương về Tổ chức báo cáo định kỳ.","code":""},{"path":"rmarkdown.html","id":"báo-cáo-được-tham-số-hóa","chapter":"40 Báo cáo với R Markdown","heading":"40.6 Báo cáo được tham số hóa","text":"Bạn có thể sử dụng tham số hóa để tạo báo cáo động, sao cho báo cáo có thể được chạy với cài đặt cụ thể (ví dụ: ngày hoặc địa điểm cụ thể hoặc với các tùy chọn knit nhất định). Dưới đây, chúng tôi tập trung vào những điều cơ bản, nhưng có thêm các tài liệu chi tiết trực tuyến về các báo cáo được tham số hóa.Sử dụng bộ dữ liệu Ebola có tên linelist làm ví dụ, giả sử chúng ta muốn chạy một báo cáo giám sát tiêu chuẩn cho từng bệnh viện mỗi ngày. Chúng ta chỉ ra cách người ta có thể làm điều này bằng cách sử dụng các tham số.Quan trọng: các báo cáo động cũng có thể thực hiện được mà không có cấu trúc tham số chính thức (không có params:), bằng cách sử dụng các đối tượng R đơn giản trong R script liền kề. Điều này được giải thích ở cuối phần này.","code":""},{"path":"rmarkdown.html","id":"cài-đặt-tham-số","chapter":"40 Báo cáo với R Markdown","heading":"Cài đặt tham số","text":"Bạn có nhiều cách để chỉ định giá trị tham số cho đầu ra R Markdown của mình.","code":""},{"path":"rmarkdown.html","id":"cách-1-đặt-tham-số-trong-yaml","chapter":"40 Báo cáo với R Markdown","heading":"Cách 1: Đặt tham số trong YAML","text":"Chỉnh sửa YAML để bao gồm tùy chọn params:, với các biểu thức được thụt lề cho mỗi tham số bạn muốn xác định. Trong ví dụ này, chúng tôi tạo các tham số date vàhospital, với các giá trị mà chúng tôi chỉ định. Các giá trị này có thể thay đổi mỗi khi chạy báo cáo. Nếu bạn sử dụng nút “Knit” để tạo ra đầu ra, các tham số sẽ có các giá trị mặc định này. Tương tự như vậy, nếu bạn sử dụng render (), các tham số sẽ có các giá trị mặc định này trừ khi được chỉ định khác trong lệnh render ().Ở chế độ nền, các giá trị tham số này được chứa trong danh sách chỉ đọc được gọi là params. đó, bạn có thể chèn các giá trị tham số trong code R như cách bạn làm với một đối tượng/giá trị R khác trong môi trường của bạn. Chỉ cần gõ params $ theo sau là tên tham số. Ví dụ: params $ Hospital để đại diện cho tên bệnh viện (“Central Hospital” theo mặc định).Lưu ý rằng các tham số cũng có thể giữ các giá trị true hoặc false, và vì vậy chúng có thể được đưa vào các tùy chọn knitr của bạn trong một đoạn code R. Ví dụ: bạn có thể đặt {r, eval=params$run} thay vì {r, eval=FALSE}, và bây giờ việc đoạn code chạy hay không phụ thuộc vào giá trị của tham số run:.Lưu ý rằng đối với các tham số là ngày tháng, chúng sẽ được nhập dưới dạng một chuỗi. Vì vậy, để params$date được diễn giải trong code R, nó có thể sẽ cần được bao bọc bằng .Date() hoặc một hàm tương tự để chuyển đổi thành lớp Date.","code":"---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: Central Hospital\n---"},{"path":"rmarkdown.html","id":"cách-2-đặt-tham-số-trong-render","chapter":"40 Báo cáo với R Markdown","heading":"Cách 2: Đặt tham số trong render()","text":"Như đã đề cập ở trên, thay thế cho việc nhấn nút “Knit” để tạo đầu ra là thực thi hàm render() từ một script riêng biệt. Trong trường hợp sau này, bạn có thể chỉ định các tham số được sử dụng trong việc hiển thị đó cho đối số params = của render ().Lưu ý rằng bất kỳ giá trị tham số nào được cung cấp ở đây sẽ ghi đè các giá trị mặc định của chúng nếu được viết trong YAML. Chúng tôi viết các giá trị trong dấu ngoặc kép vì trong trường hợp này chúng phải được định nghĩa là giá trị ký tự/chuỗi.Lệnh dưới đây kết xuất tệp “surveillance_report.Rmd”, chỉ định tên và thư mục tệp đầu ra động, đồng thời cung cấp một list() gồm hai tham số và giá trị của chúng cho đối số params =.","code":"\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = list(date = \"2021-04-10\", hospital  = \"Central Hospital\"))"},{"path":"rmarkdown.html","id":"cách-3-đặt-tham-số-sử-giao-diện-người-dùng-gui","chapter":"40 Báo cáo với R Markdown","heading":"Cách 3: Đặt tham số sử Giao diện Người dùng (GUI)","text":"Để có cảm giác tương tác hơn, bạn cũng có thể sử dụng Giao diện Người dùng (Graphical User Interface - GUI) để chọn thủ công các giá trị cho các tham số. Để thực hiện việc này, chúng ta có thể nhấp vào menu thả xuống bên cạnh nút ‘Knit’ và chọn ‘Knit parameter’.Một cửa sổ bật lên sẽ xuất hiện cho phép bạn nhập các giá trị cho các tham số được thiết lập trong YAML của tài liệu.Bạn có thể đạt được điều tương tự thông qua lệnh render() bằng cách chỉ định params = \"ask\", như được minh họa bên dưới.Tuy nhiên, việc nhập giá trị vào cửa sổ bật lên này có thể xảy ra lỗi và lỗi chính tả. Bạn có thể chọn thêm các hạn chế cho các giá trị có thể được nhập thông qua menu thả xuống. Bạn có thể làm điều này bằng cách thêm vào YAML một số thông số kỹ thuật cho mỗi mục nhập params:.label: là cách tiêu đề cho menu thả xuống cụ thể đóvalue: là giá trị mặc định (bắt đầu)input: đặt thành select cho menu thả xuốngchoices: cung cấp các giá trị đủ điều kiện trong menu thả xuốngDưới đây, các thông số kỹ thuật này được viết cho tham số hospital.Khi knit (thông qua nút ‘knit parameters’ hoặc bằng cách render()), cửa sổ bật lên sẽ có các tùy chọn thả xuống để bạn lựa chọn.","code":"rmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = “ask”)---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: \n  label: “Town:”\n  value: Central Hospital\n  input: select\n  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]\n---"},{"path":"rmarkdown.html","id":"ví-dụ-tham-số-hóa","chapter":"40 Báo cáo với R Markdown","heading":"Ví dụ tham số hóa","text":"Đoạn mã sau đây tạo các tham số cho date và hospital, được sử dụng trong R Markdown tương ứng là params$date và params$hospital.Trong kết quả đầu ra của báo cáo, hãy xem cách dữ liệu được lọc cho bệnh viện cụ thể và tiêu đề biểu đồ đề cập đến bệnh viện và ngày chính xác. Chúng tôi sử dụng tệp “linelist_cleaned.rds” ở đây, nhưng nó sẽ đặc biệt thích hợp nếu bản thân tệp linelist cũng có một dấu ngày tháng bên trong nó để căn chỉnh với ngày được tham số hóa.Knit sẽ tạo ra kết quả cuối cùng với phông chữ và bố cục mặc định.","code":""},{"path":"rmarkdown.html","id":"tham-số-hóa-không-có-params","chapter":"40 Báo cáo với R Markdown","heading":"Tham số hóa không có params","text":"Nếu bạn đang kết xuất tệp R Markdown với render () từ một script riêng biệt, bạn thực sự có thể tạo ra tác động của tham số hóa mà không cần sử dụng chức năng params:.Ví dụ, trong R script có chứa lệnh render (), bạn có thể chỉ cần xác định hospital và date là hai đối tượng R (giá trị) trước lệnh render (). Trong R Markdown, bạn sẽ không cần phải có phần params: trong YAML, và chúng tôi sẽ đề cập đến đối tượng date hơn là params$date và hospital hơn là params$hospital.Làm theo cách này có nghĩa là bạn không thể “knit với các tham số”, sử dụng GUI hoặc bao gồm các tùy chọn knit trong các tham số. Tuy nhiên, điều này có thể có ích vì nó cho phép code đơn giản hơn.","code":"\n# This is a R script that is separate from the R Markdown\n\n# define R objects\nhospital <- \"Central Hospital\"\ndate <- \"2021-04-10\"\n\n# Render the R markdown\nrmarkdown::render(input = \"create_output.Rmd\") "},{"path":"rmarkdown.html","id":"tạo-vòng-lặp-nhiều-báo-cáo","chapter":"40 Báo cáo với R Markdown","heading":"40.7 Tạo vòng lặp nhiều báo cáo","text":"Chúng ta có thể muốn chạy một báo cáo nhiều lần, thay đổi các thông số đầu vào, để tạo ra một báo cáo cho từng khu vực pháp lý/đơn vị. Điều này có thể được thực hiện bằng cách sử dụng các công cụ cho việc lặp lại, được giải thích chi tiết trong chương về [Lặp, vòng lặp và danh sách]. Các tùy chọn bao gồm package purrr hoặc sử dụng vòng lặp như được giải thích bên dưới.Dưới đây, chúng tôi sử dụng vòng lặp đơn giản để tạo báo cáo giám sát cho tất cả các bệnh viện được chọn. Điều này được thực hiện bằng một lệnh (thay vì thay đổi từng thông số bệnh viện theo cách thủ công). Lệnh kết xuất báo cáo phải tồn tại trong một script riêng biệt bên ngoài báo cáo Rmd. Script này cũng sẽ chứa các đối tượng được xác định để “lặp qua” - ngày hôm nay và một vectơ tên bệnh viện để lặp qua.Sau đó, chúng tôi cung cấp từng giá trị này vào lệnh render() bằng cách sử dụng một vòng lặp, lệnh này chạy lệnh một lần cho mỗi giá trị trong vectơ hospitals. Chữ cái đại diện cho vị trí chỉ mục (từ 1 đến 4) của bệnh viện hiện đang được sử dụng trong lần lặp đó, như vậy hospital_list[1] sẽ là “Central Hospital”. Thông tin này được cung cấp ở hai nơi trong lệnh render():Đối với tên tệp, sao cho tên tệp của lần lặp đầu tiên nếu được tạo vào ngày 10 tháng 4 năm 2021 sẽ là “Report_Central Hospital_2021-04-10.docx”, được lưu trong thư mục con ‘output’ của thư mục làm việc.Với params = sao cho Rmd sử dụng tên bệnh viện trong nội bộ bất cứ khi nào giá trị params$hospital được gọi (ví dụ: chỉ để lọc tập dữ liệu cho bệnh viện cụ thể). Trong ví dụ này, bốn tệp sẽ được tạo - mỗi tệp cho một bệnh viện.","code":"\nhospitals <- c(\"Central Hospital\",\n                \"Military Hospital\", \n                \"Port Hospital\",\n                \"St. Mark's Maternity Hospital (SMMH)\") \nfor(i in 1:length(hospitals)){\n  rmarkdown::render(\n    input = \"surveillance_report.Rmd\",\n    output_file = str_glue(\"output/Report_{hospitals[i]}_{Sys.Date()}.docx\"),\n    params = list(hospital  = hospitals[i]))\n}       "},{"path":"rmarkdown.html","id":"mẫu","chapter":"40 Báo cáo với R Markdown","heading":"40.8 Mẫu","text":"Bằng cách sử dụng tài liệu mẫu có chứa bất kỳ định dạng mong muốn nào, bạn có thể điều chỉnh tính thẩm mỹ của đầu ra Rmd sẽ trông như thế nào. Ví dụ, bạn có thể tạo tệp MS Word hoặc Powerpoint chứa các trang/trang trình bày với kích thước, hình đóng dấu, hình nền và phông chữ mong muốn.","code":""},{"path":"rmarkdown.html","id":"tài-liệu-word","chapter":"40 Báo cáo với R Markdown","heading":"Tài liệu Word","text":"Để tạo một mẫu, hãy bắt đầu một tài liệu word mới (hoặc sử dụng đầu ra hiện có với định dạng phù hợp với bạn) và chỉnh sửa phông chữ bằng cách xác định Kiểu. Trong Kiểu, Đầu mục 1, 2 và 3 đề cập đến các cấp đề mục markdown khác nhau (tương ứng #Đề mục 1, ##Đề mục 2 và ### Đề mục 3). Nhấp chuột phải vào kiểu và nhấp vào ‘sửa đổi’ để thay đổi định dạng phông chữ cũng như đoạn văn (ví dụ: bạn có thể giới thiệu các ngắt trang trước các kiểu nhất định có thể giúp giãn cách). Các khía cạnh khác của tài liệu word như lề, kích thước trang, đề mục, v.v., có thể được thay đổi giống như một tài liệu word thông thường mà bạn đang làm việc trực tiếp bên trong.","code":""},{"path":"rmarkdown.html","id":"tài-liệu-powerpoint","chapter":"40 Báo cáo với R Markdown","heading":"Tài liệu Powerpoint","text":"Như trên, hãy tạo một slide mới hoặc sử dụng một file powerpoint hiện có với định dạng mong muốn. Để chỉnh sửa thêm, hãy nhấp vào ‘View’ và ‘Slide Master’. Từ đây, bạn có thể thay đổi giao diện trang chiếu ‘master’ bằng cách chỉnh sửa định dạng văn bản trong các hộp văn bản, cũng như kích thước nền/trang cho trang tổng thể.Thật không may, việc chỉnh sửa tệp powerpoint hơi kém linh hoạt:Đề mục cấp đầu tiên (# Đề mục 1) sẽ tự động trở thành tiêu đề của trang trình bày mới,Chữ ## Đề mục 2 sẽ không xuất hiện dưới dạng phụ đề mà là chữ trong hộp văn bản chính của trang chiếu (trừ khi bạn tìm được cách để làm rộng chế độ xem Master).Các ô và bảng đã xuất sẽ tự động chuyển sang các trang trình bày mới. Bạn sẽ cần kết hợp chúng, chẳng hạn như hàm patchwork để kết hợp các ggplots, để chúng hiển thị trên cùng một trang. Xem bài đăng trên blog về cách sử dụng package patchwork để đặt nhiều hình ảnh trên một trang chiếu.Xem officer package để biết công cụ làm việc chuyên sâu hơn với các bài thuyết trình powerpoint.","code":""},{"path":"rmarkdown.html","id":"tích-hợp-các-mẫu-vào-yaml","chapter":"40 Báo cáo với R Markdown","heading":"Tích hợp các mẫu vào YAML","text":"Khi một mẫu được chuẩn bị, chi tiết của mẫu này có thể được thêm vào YAML của Rmd bên dưới dòng ‘đầu ra’ và bên dưới nơi loại tài liệu được chỉ định (chính nó sẽ đi đến một dòng riêng). Lưu ý reference_doc có thể được sử dụng cho các mẫu slide powerpoint.Dễ dàng nhất là lưu mẫu trong cùng một thư mục với nơi chứa tệp Rmd (như trong ví dụ bên dưới) hoặc trong một thư mục con bên trong.","code":"---\ntitle: Surveillance report\noutput: \n word_document:\n  reference_docx: \"template.docx\"\nparams:\n date: 2021-04-10\n hospital: Central Hospital\ntemplate:\n \n---"},{"path":"rmarkdown.html","id":"định-dạng-tệp-html","chapter":"40 Báo cáo với R Markdown","heading":"Định dạng tệp HTML","text":"Các tệp HTML không sử dụng các mẫu, nhưng có thể có các kiểu được định cấu hình trong YAML. HTML là tài liệu tương tác và đặc biệt linh hoạt. Chúng tôi đề cập đến một số tùy chọn cơ bản ở đây.Mục lục: Chúng ta có thể thêm mục lục với toc: true bên dưới, và cũng chỉ định rằng nó vẫn có thể xem được (“float”) khi bạn cuộn, vớitoc_float: true.Mục lục: Chúng ta có thể thêm mục lục với toc: true bên dưới, và cũng chỉ định rằng nó vẫn có thể xem được (“float”) khi bạn cuộn, vớitoc_float: true.Chủ đề: Chúng ta có thể tham khảo một số chủ đề được tạo sẵn, lấy từ thư viện chủ đề của Bootswatch. Trong ví dụ dưới đây, chúng tôi sử dụng cerulean. Các tùy chọn khác bao gồm: journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, và yeti.Chủ đề: Chúng ta có thể tham khảo một số chủ đề được tạo sẵn, lấy từ thư viện chủ đề của Bootswatch. Trong ví dụ dưới đây, chúng tôi sử dụng cerulean. Các tùy chọn khác bao gồm: journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, và yeti.Đánh dấu: Định cấu hình này sẽ thay đổi giao diện của chữ được đánh dấu (ví dụ: code trong các đoạn được hiển thị). Các kiểu được hỗ trợ bao gồm mặc định, tango, pygments, kate, monochrome, espresso, zenburn, hasdock, breezedark và textmate.Đánh dấu: Định cấu hình này sẽ thay đổi giao diện của chữ được đánh dấu (ví dụ: code trong các đoạn được hiển thị). Các kiểu được hỗ trợ bao gồm mặc định, tango, pygments, kate, monochrome, espresso, zenburn, hasdock, breezedark và textmate.Đây là một ví dụ về cách tích hợp các tùy chọn trên vào YAML.Dưới đây là hai ví dụ về kết quả đầu ra HTML, cả hai đều có mục lục nổi, nhưng chủ đề và kiểu đánh dấu khác nhau được chọn:","code":"---\ntitle: \"HTML example\"\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    theme: cerulean\n    highlight: kate\n    \n---"},{"path":"rmarkdown.html","id":"nội-dung-động","chapter":"40 Báo cáo với R Markdown","heading":"40.9 Nội dung động","text":"Trong đầu ra HTML, nội dung báo cáo của bạn có thể là động. Dưới đây là một số ví dụ:","code":""},{"path":"rmarkdown.html","id":"bảng-1","chapter":"40 Báo cáo với R Markdown","heading":"Bảng","text":"Trong báo cáo HTML, bạn có thể khung/ô dữ liệu sao cho nội dung là động, với các bộ lọc và thanh cuộn. Có một số packages cung cấp khả năng này.Để thực hiện việc này với package DT, như được sử dụng trong cuốn sổ tay này, bạn có thể chèn một đoạn code như sau:Hàm datatable() sẽ khung dữ liệu đã cung cấp dưới dạng bảng động cho trình đọc. Bạn có thể đặt rownames = FALSE để đơn giản hóa phần ngoài cùng bên trái của bảng. filter = \"top\" cung cấp một bộ lọc trên mỗi cột. Trong đối số option() cung cấp danh sách các thông số kỹ thuật khác. Dưới đây, chúng tôi bao gồm hai đối số: pageLength = 5 đặt số hàng xuất hiện là 5 (các hàng còn lại có thể được xem bằng cách phân trang thông qua các mũi tên) vàscrollX = TRUE bật thanh cuộn ở cuối bảng (đối với cột mở rộng quá xa sang bên phải).Nếu tập dữ liệu của bạn rất lớn, hãy xem xét chỉ hiển thị X hàng trên cùng bằng cách gói khung dữ liệu trong head().","code":""},{"path":"rmarkdown.html","id":"tiện-ích-html","chapter":"40 Báo cáo với R Markdown","heading":"Tiện ích HTML","text":"Tiện ích HTML cho R là một lớp packages R đặc biệt cho phép tăng tính tương tác bằng cách sử dụng các thư viện JavaScript. Bạn có thể nhúng chúng vào các đầu ra HTML R Markdown.Một số ví dụ phổ biến về các tiện ích này bao gồm:Plotly (được sử dụng trong chương sổ tay này và trong chương Biểu đồ tương tác)visNetwork (được sử dụng trong chương Chuỗi lây nhiễm của sổ tay này)Leaflet (được sử dụng trong chương GIS Cơ bản của sổ tay này)dygraphs ( hữu ích để hiển thị dữ liệu chuỗi thời gian tương tác)DT (datatable()) (được sử dụng để hiển thị các bảng động với bộ lọc, sắp xếp, v.v.)Hàm ggplotly() từ plotly đặc biệt dễ sử dụng. Xem chương Biểu đồ tương tác.","code":""},{"path":"rmarkdown.html","id":"tài-nguyên","chapter":"40 Báo cáo với R Markdown","heading":"40.10 Tài nguyên","text":"Tìm thêm thông tin tại:https://bookdown.org/yihui/rmarkdown/https://rmarkdown.rstudio.com/articles_intro.htmlMột giải thích tốt về sánh giữa markdown, knitr và Rmarkdown ở đây: https://stackoverflow.com/questions/40563479/relationship--r-markdown-knitr-pandoc--bookdown","code":""},{"path":"reportfactory.html","id":"reportfactory","chapter":"41 Tổ chức báo cáo định kỳ","heading":"41 Tổ chức báo cáo định kỳ","text":"Chương này bao gồm reportfactory package, là một package hỗ trợ việc báo cáo sử dụng R Markdown.Trong các tình huống mà bạn chạy báo cáo thường xuyên (hàng ngày, hàng tuần, v.v.), nó giúp giảm bớt việc soạn nhiều tệp R Markdown và tổ chức các kết quả đầu ra của chúng. Về bản chất, nó cung cấp một “nhà máy” mà từ đó bạn có thể chạy các báo cáo R Markdown, nhận các thư mục được đánh dấu ngày tháng và thời gian tự động cho kết quả đầu ra và có quyền kiểm soát phiên bản “nhẹ”.reportfactory là một trong những packages được phát triển bởi RECON (R Epidemics Consortium). Đây là website và Github của họ.","code":""},{"path":"reportfactory.html","id":"chuẩn-bị-33","chapter":"41 Tổ chức báo cáo định kỳ","heading":"41.1 Chuẩn bị","text":"","code":""},{"path":"reportfactory.html","id":"tải-packages-1","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Tải packages","text":"Từ trong RStudio, hãy cài đặt phiên bản mới nhất của reportfactory package từ Github.Bạn có thể thực hiện việc này thông qua pacman package với p_load_current_gh(), lệnh này sẽ buộc nhập phiên bản mới nhất từ Github. Cung cấp chuỗi ký tự “reconverse/reportfactory”, trong đó chỉ định tổ chức Github (reconverse) và kho lưu trữ (reportfactory). Bạn cũng có thể sử dụng install_github() từ remotes package để thay thế.","code":"\n# Install and load the latest version of the package from Github\npacman::p_load_current_gh(\"reconverse/reportfactory\")\n#remotes::install_github(\"reconverse/reportfactory\") # alternative"},{"path":"reportfactory.html","id":"nhà-máy-mới","chapter":"41 Tổ chức báo cáo định kỳ","heading":"41.2 Nhà máy mới","text":"Để tạo một nhà máy mới, chạy hàm new_factory(). Thao tác này sẽ tạo một thư mục dự án R độc lập mới. Mặc định là:Nhà máy sẽ được thêm vào thư mục làm việc của bạnTên của nhà máy dự án R sẽ được gọi là “new_factory.Rproj”Phiên RStudio của bạn sẽ “chuyển sang” dự án R nàyNhìn vào bên trong nhà máy, bạn có thể thấy rằng các thư mục con và một số tệp đã được tạo tự động.Thư mục report_sources sẽ chứa các scripts R Markdown của bạn, các scripts này sẽ tạo ra các báo cáo của bạnThư mục outputs sẽ chứa các kết quả đầu ra của báo cáo (ví dụ: HTML, Word, PDF, v.v.)Thư mục scripts có thể được sử dụng để lưu trữ các scripts R khác (ví dụ: được lấy từ các scripts Rmd của bạn)Thư mục data có thể được sử dụng để chứa dữ liệu của bạn (bao gồm các thư mục con “thô” và “sạch”)Tệp ., vì vậy bạn có thể sử dụng package để gọi các tệp trong thư mục con theo mối quan hệ của chúng với thư mục gốc này (xem chương [R projects] để biết thêm chi tiết)Tệp gitignore được tạo trong trường hợp bạn liên kết dự án R này với kho lưu trữ Github (xem [Version control collaboration Github])Tệp README trống, nếu bạn sử dụng kho lưu trữ GithubTHẬN TRỌNG: tùy thuộc vào cài đặt máy tính của bạn, các tệp như “.” có thể tồn tại nhưng ẩn.Trong số các cài đặt mặc định, dưới đây là một số cài đặt mà bạn có thể điều chỉnh trong lệnh new_factory():factory = - Đặt tên cho thư mục gốc (mặc định là “new_factory”)path = - Chỉ định đường dẫn tệp cho nhà máy mới (mặc định là thư mục làm việc)report_sources = Đặt tên thay thế cho thư mục con chứa các R Markdown scripts (mặc định là “report_sources”)outputs = Đặt tên thay thế cho thư mục chứa kết quả đầu ra báo cáo (mặc định là “outputs”)Xem ?new_factory để biết danh sách đầy đủ các đối số.Khi bạn tạo nhà máy mới, phiên R của bạn được chuyển sang dự án R mới, vì vậy bạn nên tải lại package reportfactory.Bây giờ bạn có thể chạy lệnh factory_overview() để xem cấu trúc bên trong (tất cả các thư mục và tệp) trong nhà máy.“Cây” các thư mục và tệp của nhà sản xuất được ra R console. Lưu ý rằng trong thư mục “data” có các thư mục con cho dữ liệu “raw” (thô) và “clean” (sạch) cũng như dữ liệu CSV mẫu. Ngoài ra còn có “example_report.Rmd” trong thư mục “report_sources”.","code":"\n# This will create the factory in the working directory\nnew_factory()\npacman::p_load(reportfactory)\nfactory_overview()            # print overview of the factory to console"},{"path":"reportfactory.html","id":"tạo-báo-cáo","chapter":"41 Tổ chức báo cáo định kỳ","heading":"41.3 Tạo báo cáo","text":"Từ bên trong dự án R của nhà máy, hãy tạo báo cáo R Markdown giống như bạn thường làm và lưu nó vào thư mục “report_sources”. Xem chương [R Markdown][Reports R Markdown] để biết hướng dẫn. Để ví dụ, chúng tôi đã thêm những thứ sau vào nhà máy:R markdown script mới có tên “daily_sitrep.Rmd”, được lưu trong thư mục “report_sources”Dữ liệu cho báo cáo (“linelist_cleaned.rds”), được lưu vào thư mục con “clean” trong thư mục “data”Chúng ta có thể thấy bằng cách sử dụng factory_overview() R Markdown trong thư mục “report_sources” và tệp dữ liệu trong thư mục dữ liệu “clean” (được đánh dấu):Dưới đây là ảnh chụp phần đầu của R Markdown “daily_sitrep.Rmd”. Bạn có thể thấy rằng định dạng đầu ra được đặt là HTML, thông qua tiêu đề YAML output: html_document.Trong script đơn giản này, có các lệnh để:Tải các packages cần thiếtNhập dữ liệu danh sách dòng bằng đường dẫn tệp từ package (đọc thêm trong chương [Import export])bảng tóm tắt các trường hợp và xuất nó với export() dưới dạng tệp .csvIn một đường cong dịch tễ và xuất nó bằng ggsave () dưới dạng tệp .pngBạn chỉ có thể xem lại danh sách các báo cáo R Markdown trong thư mục “report_sources” bằng lệnh này:","code":"\nlinelist <- import(here(\"data\", \"clean\", \"linelist_cleaned.rds\"))\nlist_reports()"},{"path":"reportfactory.html","id":"biên-soạn","chapter":"41 Tổ chức báo cáo định kỳ","heading":"41.4 Biên soạn","text":"Trong nhà máy báo cáo, để “biên soạn” báo cáo R Markdown có nghĩa là .Rmd script sẽ được chạy và đầu ra sẽ được tạo (như được chỉ định trong script YAML, ví dụ như HTML, Word, PDF, v.v.).Nhà máy sẽ tự động tạo một thư mục được đánh dấu ngày tháng và thời gian cho các kết quả đầu ra trong thư mục “outputs”.Bản thân báo cáo và mọi tệp đã xuất script tạo ra (ví dụ: csv, png, xlsx) sẽ được lưu vào thư mục này. Ngoài ra, bản thân script Rmd sẽ được lưu trong thư mục này, vì vậy bạn có bản ghi của phiên bản script đó.Điều này trái ngược với hoạt động bình thường của R Markdown “knitted” (kết hợp), lưu kết quả đầu ra vào vị trí của script Rmd. Hành vi mặc định này có thể dẫn đến các thư mục đông đúc, lộn xộn. Nhà máy nhằm mục đích cải thiện tổ chức khi một người cần chạy báo cáo thường xuyên.","code":""},{"path":"reportfactory.html","id":"biên-soạn-theo-tên","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Biên soạn theo tên","text":"Bạn có thể biên dịch một báo cáo cụ thể bằng cách chạy compile_reports() và đặt tên Rmd script (không có phần mở rộng .Rmd) cho reports =. Để đơn giản hơn, bạn có thể bỏ qua reports = và chỉ cần viết tên R Markdown trong dấu ngoặc kép, như bên dưới.Lệnh này sẽ chỉ biên dịch báo cáo “daily_sitrep.Rmd”, lưu báo cáo HTML, xuất bảng .csv và đường cong dịch bệnh .png vào một thư mục con được đóng dấu ngày và giờ cụ thể cho báo cáo, trong thư mục “outputs” .Lưu ý rằng nếu bạn chọn cung cấp phần mở rộng .Rmd, bạn phải nhập chính xác phần mở rộng vì nó được lưu trong tên tệp (.rmd với .Rmd).Cũng lưu ý rằng khi biên soạn, bạn có thể thấy một số tệp tạm thời xuất hiện trong thư mục “report_sources” - nhưng chúng sẽ sớm biến mất khi chúng được chuyển đến đúng thư mục “output”.","code":""},{"path":"reportfactory.html","id":"biên-soạn-theo-số","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Biên soạn theo số","text":"Bạn cũng có thể chỉ định Rmd script để biên dịch bằng cách cung cấp một số hoặc vectơ số cho reports =. Các con số phải phù hợp với thứ tự các báo cáo xuất hiện khi bạn chạy list_reports().","code":"\n# Compile the second and fourth Rmds in the \"report_sources\" folder\ncompile_reports(reports = c(2, 4))"},{"path":"reportfactory.html","id":"biên-soạn-tất-cả","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Biên soạn tất cả","text":"Bạn có thể biên soạn tất cả báo cáo R Markdown trong thư mục “report_sources” bằng cách đặt đối số report = thành TRUE.","code":""},{"path":"reportfactory.html","id":"biên-soạn-từ-thư-mục-con","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Biên soạn từ thư mục con","text":"Bạn có thể thêm các thư mục con vào thư mục “report_sources”. Để chạy báo cáo R Markdown từ một thư mục con, chỉ cần cung cấp tên của thư mục cho subfolder =. Dưới đây là ví dụ về code để biên soạn báo cáo Rmd nằm trong thư mục con của “report_sources”.Bạn có thể biên soạn tất cả các báo cáo Rmd trong một thư mục con bằng cách cung cấp tên thư mục con cho reports =, với một dấu gạch chéo ở cuối, như bên dưới.","code":"\ncompile_reports(\n     reports = \"summary_for_partners.Rmd\",\n     subfolder = \"for_partners\")\ncompile_reports(reports = \"for_partners/\")"},{"path":"reportfactory.html","id":"tham-số-hóa","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Tham số hóa","text":"Như đã lưu ý trong chương về [Reports R Markdown], bạn có thể chạy báo cáo với các thông số được chỉ định. Bạn có thể chuyển các tham số này dưới dạng danh sách tới compile_reports () thông qua đối số params =. Ví dụ, trong báo cáo hư cấu này, có ba tham số được cung cấp cho báo cáo R Markdown.","code":"\ncompile_reports(\n  reports = \"daily_sitrep.Rmd\",\n  params = list(most_recent_data = TRUE,\n                region = \"NORTHERN\",\n                rates_denominator = 10000),\n  subfolder = \"regional\"\n)"},{"path":"reportfactory.html","id":"dùng-run-file","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Dùng “run-file”","text":"Nếu bạn có nhiều báo cáo cần chạy, hãy cân nhắc tạo R script chứa tất cả các lệnh compile_reports(). Người dùng có thể chỉ cần chạy tất cả các lệnh trong R script này và tất cả các báo cáo sẽ được biên soạn. Bạn có thể lưu “run-file” này vào thư mục “scripts”.","code":""},{"path":"reportfactory.html","id":"kết-quả-đầu-ra-1","chapter":"41 Tổ chức báo cáo định kỳ","heading":"41.5 Kết quả đầu ra","text":"Sau khi chúng ta đã biên soạn các báo cáo một vài lần, thư mục “outputs” có thể trông giống như sau (các điểm nổi bật được thêm vào để rõ ràng):Trong “outputs”, các thư mục con đã được tạo cho mỗi báo cáo RmdTrong đó, các thư mục con khác đã được tạo cho mỗi lần biên soạn duy nhất\nĐây là những ngày tháng và thời gian được đóng dấu (“2021-04-23_T11-07-36” có nghĩa là ngày 23 tháng 4 năm 2021 lúc 11:07:36)\nBạn có thể chỉnh sửa định dạng dấu ngày/giờ. Xem ?compile_reports\nĐây là những ngày tháng và thời gian được đóng dấu (“2021-04-23_T11-07-36” có nghĩa là ngày 23 tháng 4 năm 2021 lúc 11:07:36)Bạn có thể chỉnh sửa định dạng dấu ngày/giờ. Xem ?compile_reportsTrong mỗi thư mục ngày/giờ được biên soạn, kết quả báo cáo được lưu trữ (ví dụ: HTML, PDF, Word) cùng với tập lệnh Rmd (kiểm soát phiên bản!) Và bất kỳ tệp nào được xuất khác (ví dụ: table.csv, translate_curve.png)Đây là chế độ xem bên trong một trong các thư mục được đánh dấu ngày/giờ cho báo cáo “daily_sitrep”. Đường dẫn tệp được đánh dấu bằng màu vàng để nhấn mạnh.Cuối cùng, bên dưới là ảnh chụp màn hình của kết quả báo cáo HTML.Bạn có thể sử dụng list_outputs() để xem lại danh sách các kết quả đầu ra.","code":""},{"path":"reportfactory.html","id":"mục-khác","chapter":"41 Tổ chức báo cáo định kỳ","heading":"41.6 Mục khác","text":"","code":""},{"path":"reportfactory.html","id":"knit","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Knit","text":"Bạn vẫn có thể “knit” một trong các báo cáo R Markdown của mình bằng cách nhấn nút “Knit” nếu muốn. Nếu bạn làm điều này, theo mặc định, kết quả đầu ra sẽ xuất hiện trong thư mục lưu Rmd - thư mục “report_sources”. Trong các phiên bản trước của reportfactory, việc có bất kỳ tệp nào không phải Rmd trong “report_sources” sẽ ngăn việc biên dịch, nhưng trường hợp này không còn nữa. Bạn có thể chạy compile_reports() và không có lỗi nào xảy ra.","code":""},{"path":"reportfactory.html","id":"scripts-1","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Scripts","text":"Chúng tôi khuyến khích bạn sử dụng thư mục “scripts” để lưu trữ “runfiles” hoặc các .R scripts được lấy từ các .R scripts của bạn. Xem trang trên [R Markdown][Reports R Markdown] để biết các mẹo về cách cấu trúc code của bạn trên một số tệp.","code":""},{"path":"reportfactory.html","id":"thêm","chapter":"41 Tổ chức báo cáo định kỳ","heading":"Thêm","text":"Với reportfactory, bạn có thể sử dụng hàm list_deps() để liệt kê tất cả các packages được yêu cầu trên tất cả các báo cáo trong toàn bộ nhà máy.Với reportfactory, bạn có thể sử dụng hàm list_deps() để liệt kê tất cả các packages được yêu cầu trên tất cả các báo cáo trong toàn bộ nhà máy.Có một package đi kèm trong quá trình phát triển được gọi là rfextras cung cấp nhiều chức năng trợ giúp hơn để hỗ trợ bạn trong việc xây dựng báo cáo, chẳng hạn như:\nload_scripts() - dẫn nguồn/tải tất cả các .R scripts trong một thư mục nhất định (thư mục “scripts” theo mặc định)\nfind_latest() - tìm phiên bản mới nhất của tệp (ví dụ: tập dữ liệu mới nhất)\nCó một package đi kèm trong quá trình phát triển được gọi là rfextras cung cấp nhiều chức năng trợ giúp hơn để hỗ trợ bạn trong việc xây dựng báo cáo, chẳng hạn như:load_scripts() - dẫn nguồn/tải tất cả các .R scripts trong một thư mục nhất định (thư mục “scripts” theo mặc định)find_latest() - tìm phiên bản mới nhất của tệp (ví dụ: tập dữ liệu mới nhất)","code":""},{"path":"reportfactory.html","id":"tài-nguyên-1","chapter":"41 Tổ chức báo cáo định kỳ","heading":"41.7 Tài nguyên","text":"Xem Github page của reportfactory packageXem Github page của rfextras package","code":""},{"path":"flexdashboard.html","id":"flexdashboard","chapter":"42 Dashboards với R Markdown","heading":"42 Dashboards với R Markdown","text":"Chương này sẽ trình bày cách sử dụng cơ bản của package flexdashboard. Package này cho phép bạn dễ dàng định dạng đầu ra R Markdown dưới dạng dashboard với các ô điều khiển và trang. Nội dung dashboard có thể là văn bản, số liệu/bảng tĩnh hoặc đồ họa tương tác.Ưu điểm của flexdashboard:Yêu cầu việc viết code R không chuẩn hóa là ít nhất - với rất ít thực hành, bạn có thể nhanh chóng tạo một dashboardDashboard thường có thể được gửi qua email cho đồng nghiệp dưới dạng tệp HTML độc lập - không cần máy chủBạn có thể kết hợp flexdashboard với shiny, ggplotly và “html widgets” khác để thêm tính tương tácNhược điểm của flexdashboard:Ít tùy chỉnh hơn với việc chỉ sử dụng shiny để tạo dashboardBạn có thể tìm thấy các hướng dẫn toàn diện về cách sử dụng flexdashboard được mô tả ở chương này trong phần Tài nguyên. Dưới đây, chúng tôi mô tả các tính năng cốt lõi và đưa ra ví dụ về việc xây dựng dashboard để khám phá một đợt bùng dịch, sử dụng dữ liệu linelist.","code":""},{"path":"flexdashboard.html","id":"chuẩn-bị-34","chapter":"42 Dashboards với R Markdown","heading":"42.1 Chuẩn bị","text":"","code":""},{"path":"flexdashboard.html","id":"gọi-các-packages-1","chapter":"42 Dashboards với R Markdown","heading":"Gọi các packages","text":"Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt package nếu cần và gọi nó để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các R packages.","code":"\npacman::p_load(\n  rio,             # nhập/xuất dữ liệu     \n  here,            # định vị tệp\n  tidyverse,       # quản lý và trực quan hóa dữ liệu \n  flexdashboard,   # phiên bản dashboard của báo cáo R Markdown\n  shiny,           # biểu đồ tương tác\n  plotly           # biểu đồ tương tác\n)"},{"path":"flexdashboard.html","id":"nhập-dữ-liệu-24","chapter":"42 Dashboards với R Markdown","heading":"Nhập dữ liệu","text":"Chúng ta nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, hãy  nhấp để tải xuống linelist “sạch” (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương Nhập xuất dữ liệu để biết chi tiết).50 hàng đầu tiên của linelist được hiển thị bên dưới.","code":"\n# nhập linelist\nlinelist <- import(\"linelist_cleaned.rds\")"},{"path":"flexdashboard.html","id":"tạo-r-markdown-mới","chapter":"42 Dashboards với R Markdown","heading":"42.2 Tạo R Markdown mới","text":"Sau khi bạn đã cài đặt package, hãy tạo một tệp R Markdown mới bằng cách nhấp qua File > New file > R Markdown.Trong cửa sổ mở ra, chọn “Template” và chọn mẫu “Flex Dashboard”. Sau đó, bạn sẽ được nhắc đặt tên cho tài liệu. Trong ví dụ của chương này, chúng tôi sẽ đặt tên R Markdown của chúng tôi là “outbreak_dashboard.Rmd”.","code":""},{"path":"flexdashboard.html","id":"script-1","chapter":"42 Dashboards với R Markdown","heading":"42.3 Script","text":"Script là một script R Markdown và đó có các thành phần và tổ chức tương tự như được mô tả trong chương Báo cáo với R Markdown. Chúng ta sẽ xem lại một cách ngắn gọn định dạng này và nêu rõ sự khác biệt với các định dạng đầu ra R Markdown khác.","code":""},{"path":"flexdashboard.html","id":"yaml","chapter":"42 Dashboards với R Markdown","heading":"YAML","text":"Ở đầu script là tiêu đề “YAML”. Mục này phải bắt đầu bằng ba dấu gạch ngang --- và phải kết thúc bằng ba dấu gạch ngang ---. Tham số YAML có trong cặp key:value. Thụt lề và đặt dấu hai chấm trong YAML là việc quan trọng - các cặp key:value được phân tách bằng dấu hai chấm (không phải dấu bằng!).YAML phải bắt đầu bằng metadata cho tài liệu. Thứ tự của các tham số YAML chính này (không thụt lề) không quan trọng. Ví dụ:Bạn có thể sử dụng code R trong các giá trị YAML bằng cách đặt nó giống như code nội dòng (bắt dầu bằng r trong dấu nháy đơn ngược) nhưng cũng trong dấu ngoặc kép (xem phần Ngày ở trên).Tham số YAML bắt buộc là output:, chỉ định loại tệp sẽ được tạo (ví dụ: html_document, pdf_document, word_document hoặcpowerpoint_presentation). Đối với flexdashboard giá trị tham số này hơi khó hiểu - nó phải được đặt là output:flexdashboard::flex_dashboard. Lưu ý dấu hai chấm đơn, dấu hai chấm đôi và dấu gạch dưới. Tham số đầu ra YAML này thường được theo sau bởi một dấu hai chấm nữa và các tham số phụ được thụt lề (xem các tham số orientation: và vertical_layout: bên dưới).Như hình trên, thụt lề (2 dấu cách) được sử dụng cho các tham số phụ. Trong trường hợp này, đừng quên đặt thêm một dấu hai chấm sau dấu chính, như key:value:.Nếu thích hợp, các giá trị logic phải được đưa ra trong YAML ở dạng chữ thường (true, false, null). Nếu dấu hai chấm là một phần giá trị của bạn (ví dụ: trong tiêu đề), hãy đặt giá trị trong dấu ngoặc kép. Xem các ví dụ trong các phần bên dưới.","code":"\ntitle: \"My document\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\ntitle: \"My dashboard\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\noutput:\n  flexdashboard::flex_dashboard:\n    orientation: rows\n    vertical_layout: scroll"},{"path":"flexdashboard.html","id":"đoạn-code-1","chapter":"42 Dashboards với R Markdown","heading":"Đoạn Code","text":"Một script R Markdown có thể chứa nhiều “đoạn” code - đây là những vùng của script mà bạn có thể viết code R nhiều dòng và chúng hoạt động giống như các scripts R nhỏ.Các đoạn code được tạo bằng ba dấu nháy đơn ngược và dấu ngoặc nhọn với chữ “r” viết thường bên trong. Đoạn code được đóng bằng ba dấu nháy đơn ngược. Bạn có thể tạo một đoạn code mới bằng cách tự gõ nó ra, bằng cách sử dụng phím tắt “Ctrl + Alt + ” (hoặc Cmd + Shift + r trong Mac) hoặc bằng cách nhấp vào biểu tượng ‘insert new code chunk’ màu xanh lục ở đầu trình chỉnh sửa script của bạn. Nhiều ví dụ được đưa ra dưới đây.","code":""},{"path":"flexdashboard.html","id":"văn-bản-tường-thuật","chapter":"42 Dashboards với R Markdown","heading":"Văn bản tường thuật","text":"Bên ngoài “đoạn” code R, bạn có thể viết văn bản tường thuật. Như được mô tả trong chương Báo cáo với R Markdown, bạn có thể nghiêng văn bản bằng cách bao quanh nó bằng một dấu hoa thị (*) hoặc đậm bằng cách bao quanh nó bằng hai dấu hoa thị (**). Nhớ lại rằng dấu đầu dòng và lược đồ đánh số nhạy cảm với dòng mới, thụt đầu dòng và kết thúc một dòng có hai dấu cách.Bạn cũng có thể chèn code R nội dòng vào văn bản như được mô tả trong chương Báo cáo với R Markdown, bằng cách bao quanh code bằng dấu nháy đơn ngược và bắt đầu lệnh bằng “r”: ` 1+1` (xem ví dụ với ngày ở trên).","code":""},{"path":"flexdashboard.html","id":"đầu-mục","chapter":"42 Dashboards với R Markdown","heading":"Đầu mục","text":"Các cấp đầu mục khác nhau được thiết lập với số lượng ký hiệu thăng khác nhau, như được mô tả trong chương Báo cáo với R Markdown.Trong flexdashboard, đầu mục chính (#) tạo một “trang” của dashboard. Đầu mục cấp hai (##) tạo một cột hoặc một hàng tùy thuộc vào thông số orientation: của bạn (xem chi tiết bên dưới). Đầu mục cấp ba (###) tạo bảng điều khiển cho các đồ thị, biểu đồ, bảng, văn bản, v.v.","code":"# Đầu mục cấp một (trang)\n\n## Đầu mục cấp hai (hàng hoặc cột)  \n\n### Đầu mục cấp ba (bảng điều khiển cho đồ thị, biểu đồ, v.v.)"},{"path":"flexdashboard.html","id":"thuộc-tính-mục","chapter":"42 Dashboards với R Markdown","heading":"42.4 Thuộc tính mục","text":"Như trong R markdown bình thường, bạn có thể chỉ định các thuộc tính để áp dụng cho các phần của dashboard của mình bằng cách bao gồm các tùy chọn key=value sau một đầu mục, trong dấu ngoặc nhọn { }. Ví dụ: trong một báo cáo HTML R Markdown điển hình, bạn có thể sắp xếp các tiêu đề phụ thành các tab với ## Đầu mục của tôi {.tabset}.Lưu ý rằng các thuộc tính này được viết sau một đầu mục trong một phần văn bản của script. Các tùy chọn này khác với các tùy chọn knitr được chèn bên trong ở đầu các đoạn code R, chẳng hạn như .height =.Các thuộc tính mục dành riêng cho flexdashboard bao gồm:{data-orientation=} Đặt thành rows (hàng) hoặc columns (cột). Nếu dashboard của bạn có nhiều trang, hãy thêm thuộc tính này vào mỗi trang để biểu thị hướng (được giải thích thêm trong layout section).{data-width=} và {data-height=} đặt kích thước tương đối của biểu đồ, cột, hàng được bố trí theo cùng một chiều (ngang hoặc dọc). Kích thước tuyệt đối được điều chỉnh để lấp đầy không gian tốt nhất trên bất kỳ thiết bị hiển thị nào nhờ công cụ flexbox.\nĐộ cao của biểu đồ cũng phụ thuộc vào việc bạn đặt tham số YAML vertical_layout: fill hay vertical_layout: scroll. Nếu được đặt thành cuộn, độ cao biểu đồ sẽ phản ánh tùy chọn fig.height = truyền thống trong đoạn code R.\nXem tài liệu về kích thước đầy đủ tại flexdashboard website\nĐộ cao của biểu đồ cũng phụ thuộc vào việc bạn đặt tham số YAML vertical_layout: fill hay vertical_layout: scroll. Nếu được đặt thành cuộn, độ cao biểu đồ sẽ phản ánh tùy chọn fig.height = truyền thống trong đoạn code R.Xem tài liệu về kích thước đầy đủ tại flexdashboard website{.hidden} Sử dụng tùy chọn này để loại trừ một trang cụ thể khỏi thanh điều hướng{data-navbar =} Sử dụng điều này trong đầu mục cấp trang để lồng nó vào menu thả xuống của thanh điều hướng. Cung cấp tên (trong dấu ngoặc kép) của menu thả xuống. Xem ví dụ bên dưới.","code":""},{"path":"flexdashboard.html","id":"layout","chapter":"42 Dashboards với R Markdown","heading":"42.5 Bố cục","text":"Điều chỉnh bố cục dashboard của bạn theo những cách sau:Thêm trang, cột/hàng và biểu đồ với đầu mục R Markdown (ví dụ: #, ## hoặc ###)Điều chỉnh tham số YAML orientation: thành rows hoặc columnsChỉ định xem bố cục lấp đầy trình duyệt hay cho phép cuộnThêm các tab vào một đầu mục phần cụ thể","code":""},{"path":"flexdashboard.html","id":"trang","chapter":"42 Dashboards với R Markdown","heading":"Trang","text":"Các đầu mục cấp đầu tiên (#) trong R Markdown sẽ đại diện cho “các trang” của dashboard. Theo mặc định, các trang sẽ xuất hiện trong thanh điều hướng dọc theo đầu dashboard.Bạn có thể nhóm các trang thành một “menu” trong thanh điều hướng trên cùng bằng cách thêm thuộc tính {data-navmenu=} vào đầu mục trang. Hãy cẩn thận - không bao gồm dấu cách xung quanh dấu bằng nếu không nó sẽ không hoạt động!Đây là những gì script tạo ra:Bạn cũng có thể chuyển đổi một trang hoặc một cột thành “thanh bên” ở phía bên trái của dashboard bằng cách thêm thuộc tính {.sidebar}. Nó có thể giữ văn bản (có thể xem từ bất kỳ trang nào) hoặc nếu bạn đã tích hợp tính năng tương tác shiny, nó có thể hữu ích để giữ các điều khiển nhập của người dùng như thanh trượt hoặc menu thả xuống.Đây là những gì script tạo ra:","code":""},{"path":"flexdashboard.html","id":"hướng","chapter":"42 Dashboards với R Markdown","heading":"Hướng","text":"Đặt thông số orientation: yaml để cho biết cách hiểu các đầu mục cấp hai R Markdown (##) của bạn - dưới dạng orientation: columns hoặc orientation: rows.Đầu mục cấp hai (##) sẽ được hiểu là các cột hoặc hàng mới dựa trên cài đặt orientation này.Nếu bạn đặt orientation: columns, đầu mục cấp hai sẽ tạo cột mới trong dashboard. Dashboard bên dưới có một trang, chứa hai cột, với tổng số ba bảng. Bạn có thể điều chỉnh độ rộng tương đối của các cột với {data-width=} như hình dưới đây.Đây là những gì script tạo ra:Nếu bạn đặt orientation: rows, đầu mục cấp hai sẽ tạo hàng mới thay vì cột. Dưới đây là script tương tự như trên, nhưng orientation: rows để các đầu mục cấp hai tạo ra hàng thay vì cột. Bạn có thể điều chỉnh chiều cao tương đối của các hàng với {data-height=} như hình dưới đây.Đây là những gì script tạo ra:Nếu dashboard của bạn có nhiều trang, bạn có thể chỉ định hướng cho từng trang cụ thể bằng cách thêm thuộc tính {data-orientation=} vào tiêu đề của mỗi trang (chỉ định rows hoặc columns mà không có dấu ngoặc kép).","code":""},{"path":"flexdashboard.html","id":"tabs","chapter":"42 Dashboards với R Markdown","heading":"Tabs","text":"Bạn có thể chia nội dung thành các tab bằng thuộc tính {.tabset}, như trong các đầu ra HTML R Markdown khác.Chỉ cần thêm thuộc tính này sau đầu mục mong muốn. Các đầu mục con dưới đầu mục đó sẽ được hiển thị dưới dạng tab. Ví dụ: trong script ví dụ bên dưới, cột 2 bên phải (##) được sửa đổi để đường cong dịch bệnh và ngăn bảng (###) được hiển thị trong các tab.Bạn có thể làm tương tự với các hàng nếu hướng của bạn là các hàng.Đây là những gì script tạo ra:","code":""},{"path":"flexdashboard.html","id":"thêm-nội-dung","chapter":"42 Dashboards với R Markdown","heading":"42.6 Thêm nội dung","text":"Hãy bắt đầu xây dựng một dashboard. Dashboard đơn giản của chúng tôi sẽ có 1 trang, 2 cột và 4 ô điều khiển. Chúng tôi sẽ xây dựng từng ô điều khiển một để minh họa.Bạn có thể dễ dàng bao gồm các đầu ra R tiêu chuẩn như văn bản, ggplots và bảng (xem chương Trình bày bảng). Đơn giản chỉ cần code chúng trong một đoạn code R như bạn làm đối với bất kỳ script R Markdown nào khác.Lưu ý: bạn có thể tải xuống script Rmd hoàn chỉnh và đầu ra dashboard HTML - xem chương Tải sách và dữ liệu.","code":""},{"path":"flexdashboard.html","id":"chữ","chapter":"42 Dashboards với R Markdown","heading":"Chữ","text":"Bạn có thể nhập văn bản Markdown và bao gồm code nội dòng như đối với bất kỳ đầu ra R Markdown nào khác. Xem chương Báo cáo với R Markdown để biết chi tiết.Trong dashboard này, chúng tôi bao gồm một ô điều khiển văn bản tóm tắt bao gồm văn bản động cho thấy ngày nhập viện mới nhất và số trường hợp được báo cáo trong các ổ dịch.","code":""},{"path":"flexdashboard.html","id":"bảng-2","chapter":"42 Dashboards với R Markdown","heading":"Bảng","text":"Bạn có thể bao gồm các đoạn code R kết quả đầu ra chẳng hạn như bảng. Nhưng kết quả đầu ra sẽ trông đẹp nhất và đáp ứng với kích thước cửa sổ nếu bạn sử dụng hàm kable() từ knitr để hiển thị các bảng của mình. Các hàm flextable có thể tạo ra các bảng được rút ngắn/cắt bỏ.Ví dụ: bên dưới chúng tôi cung cấp linelist() thông qua lệnh count() để tạo ra một bảng tóm tắt các trường hợp theo bệnh viện. Cuối cùng, bảng này được chuyển đến knitr::kable() và kết quả có một thanh cuộn ở bên phải. Bạn có thể đọc thêm về cách tùy chỉnh bảng của mình với kable() và kableExtra tại đây.Đây là những gì script tạo ra:Nếu bạn muốn hiển thị một bảng động cho phép người dùng lọc, sắp xếp và/hoặc nhấp qua “các trang” của dataframe, hãy sử dụng package DT và đó là hàm datatable(), như trong code bên dưới.Trong code ví dụ dưới đây, dataframe linelist được . Bạn có thể đặt rownames = FALSE để tiết kiệm không gian theo chiều ngang và filter = \"top\" để có bộ lọc ở đầu mỗi cột. Danh sách các thông số kỹ thuật khác có thể được cung cấp cho options =. Dưới đây, chúng tôi đặt pageLength = để 5 hàng xuất hiện và scrollX = để người dùng có thể sử dụng thanh cuộn ở dưới cùng để cuộn theo chiều ngang. Đối số class = 'white-space: nowrap' đảm bảo rằng mỗi hàng chỉ là một dòng (không phải nhiều dòng). Bạn có thể đọc về các đối số và giá trị có thể có khác tại đây hoặc bằng cách nhập ?datatable","code":"\nDT::datatable(linelist, \n              rownames = FALSE, \n              options = list(pageLength = 5, scrollX = TRUE), \n              class = 'white-space: nowrap' )"},{"path":"flexdashboard.html","id":"đồ-thị","chapter":"42 Dashboards với R Markdown","heading":"Đồ thị","text":"Bạn có thể các đồ thị vào cửa sổ dashboard như bạn làm trong script R. Trong ví dụ của chúng tôi, chúng tôi sử dụng package incidence2 để tạo một “epicurve” theo nhóm tuổi bằng hai lệnh đơn giản (xem trang Đường cong dịch bệnh). Tuy nhiên, bạn có thể sử dụng ggplot() và một đồ thị theo cách tương tự.Đây là những gì script tạo ra:","code":""},{"path":"flexdashboard.html","id":"đồ-thị-tương-tác","chapter":"42 Dashboards với R Markdown","heading":"Đồ thị tương tác","text":"Bạn cũng có thể chuyển một ggplot tiêu chuẩn hoặc đối tượng đồ thị khác vào ggplotly() từ package plotly (xem chương Đồ thị tương tác). Điều này sẽ làm cho đồ thị của bạn có tính tương tác, cho phép người đọc “phóng ” và hiển thị khi di chuột qua giá trị của mọi điểm dữ liệu (trong trường hợp này là số trường hợp mỗi tuần và nhóm tuổi trong đường cong).Đây là những gì hiển thị trong dashboard (gif). Chức năng tương tác này sẽ vẫn hoạt động ngay cả khi bạn gửi email dashboard dưới dạng tệp tĩnh (không trực tuyến trên máy chủ).","code":"\nage_outbreak <- incidence(linelist, date_onset, \"week\", groups = age_cat)\nplot(age_outbreak, fill = age_cat, col_pal = muted, title = \"\") %>% \n  plotly::ggplotly()"},{"path":"flexdashboard.html","id":"tiện-ích-html-1","chapter":"42 Dashboards với R Markdown","heading":"Tiện ích HTML","text":"Tiện ích HTML cho R là một loại package R đặc biệt giúp tăng tính tương tác bằng cách sử dụng các thư viện JavaScript. Bạn có thể nhúng chúng vào đầu ra R Markdown (chẳng hạn như flexdashboard) và trong dashboard Shiny.Một số ví dụ phổ biến về các tiện ích này bao gồm:Plotly (được sử dụng trong chương sổ tay này và trong chương Đồ thị tương tác)visNetwork (được sử dụng trong chương Chuỗi lây nhiễm của sổ tay này)Leaflet (được sử dụng trong chương GIS cơ bản của sổ tay này)dygraph (hữu ích để hiển thị dữ liệu chuỗi thời gian một cách tương tác)DT (datatable()) (được sử dụng để hiển thị các bảng động với bộ lọc, sắp xếp, v.v.)Dưới đây, chúng tôi biểu diễn thêm một chuỗi lây nhiễm dịch sử dụng visNetwork vào dashboard. Script chỉ hiển thị code mới được thêm vào phần “Cột 2” của script R Markdown. Bạn có thể tìm thấy code trong chương Chuỗi lây nhiễm của sổ tay này.Đây là những gì script tạo ra:","code":""},{"path":"flexdashboard.html","id":"tổ-chức-code","chapter":"42 Dashboards với R Markdown","heading":"42.7 Tổ chức Code","text":"Bạn có thể chọn có tất cả code trong script R Markdown flexdashboard. Ngoài ra, để có một script dashboard rõ ràng và ngắn gọn hơn, bạn có thể chọn gọi code/biểu đồ được lưu trữ hoặc tạo trong các scripts R bên ngoài. Điều này được mô tả chi tiết hơn trong chương Báo cáo với R Markdown.","code":""},{"path":"flexdashboard.html","id":"shiny-1","chapter":"42 Dashboards với R Markdown","heading":"42.8 Shiny","text":"Việc tích hợp package R shiny có thể giúp dashboards của bạn phản ứng mạnh hơn với thông tin nhập của người dùng. Ví dụ: bạn có thể yêu cầu người dùng chọn một khu vực pháp lý hoặc một phạm vi ngày và để các bảng phản ứng với lựa chọn của họ (ví dụ: lọc dữ liệu được hiển thị). Để nhúng phản ứng shiny vào flexdashboard, bạn chỉ cần thực hiện một số thay đổi đối với R Markdown script flexdashboard của mình.Bạn có thể sử dụng shiny để tạo ứng dụng/dashboards mà không cần đến flexdashboard (bảng điều khiển linh hoạt). Chương Dashboards với Shiny trong sổ tay cung cấp thông tin tổng quan về cách tiếp cận này, bao gồm phần bổ sung về cú pháp shiny, cấu trúc tệp ứng dụng và các tùy chọn chia sẻ/xuất bản (bao gồm cả tùy chọn máy chủ miễn phí). Cú pháp và các mẹo chung này cũng chuyển sang ngữ cảnh flexdashboard.Tuy nhiên, nhúng shiny vào flexdashboard là một thay đổi cơ bản đối với flexdashboard của bạn. Nó sẽ không còn tạo ra một đầu ra HTML mà bạn có thể gửi qua email và bất kỳ ai cũng có thể mở và xem. Thay vào đó, nó sẽ là một “ứng dụng”. Nút “Knit” ở đầu script sẽ được thay thế bằng biểu tượng “Run document”, biểu tượng này sẽ mở ra một phiên bản của dashboard tương tác cục bộ trên máy tính của bạn.Chia sẻ dashboard của bạn bây giờ sẽ yêu cầu bạn:Gửi script Rmd cho người xem, họ mở nó trên máy tính của họ và chạy ứng dụng, hoặcỨng dụng/dashboard được lưu trữ trên máy chủ mà người xem có thể truy cậpDo đó, có những lợi ích khi tích hợp shiny, nhưng cũng có những rắc rối. Nếu ưu tiên chia sẻ dễ dàng qua email và bạn không cần các khả năng phản ứng shiny, hãy xem xét khả năng tương tác giảm ggplotly() cung cấp như đã trình bày ở trên.Dưới đây, chúng tôi đưa ra một ví dụ rất đơn giản bằng cách sử dụng cùng một “outbreak_dashboard.Rmd” như trên. Tài liệu mở rộng về tích hợp Shiny vào flexdashboard có sẵn trực tuyến .","code":""},{"path":"flexdashboard.html","id":"cài-đặt-1","chapter":"42 Dashboards với R Markdown","heading":"Cài đặt","text":"Kích hoạt shiny trong flexdashboard bằng cách thêm thông số YAML `runtime: shiny ở cùng mức thụt lề như output:, như bên dưới:Nó cũng thuận tiện để kích hoạt một “thanh bên” để giữ các công cụ shiny đầu vào sẽ thu thập thông tin từ người dùng. Như đã giải thích ở trên, hãy tạo một cột và chỉ ra tùy chọn {.sidebar} để tạo một thanh bên ở phía bên trái. Bạn có thể thêm các đoạn văn bản và R chứa các lệnh shiny input trong cột này.Nếu ứng dụng/dashboard của bạn được lưu trữ trên một máy chủ và có thể có nhiều người dùng đồng thời, hãy đặt tên cho đoạn code R đầu tiên là global. Bao gồm các lệnh để nhập/tải dữ liệu của bạn trong đoạn này. Đoạn code có tên đặc biệt này được xử lý theo cách khác và dữ liệu được nhập trong nó chỉ được nhập một lần (không liên tục) và có sẵn cho tất cả người dùng. Điều này cải thiện tốc độ khởi động của ứng dụng.","code":"---\ntitle: \"Outbreak dashboard (Shiny demo)\"\noutput: \n  flexdashboard::flex_dashboard:\n    orientation: columns\n    vertical_layout: fill\nruntime: shiny\n---"},{"path":"flexdashboard.html","id":"ví-dụ-đã-làm-việc","chapter":"42 Dashboards với R Markdown","heading":"Ví dụ đã làm việc","text":"Ở đây chúng tôi điều chỉnh script flexdashboard “outbreak_dashboard.Rmd” để bao gồm shiny. Chúng tôi sẽ thêm khả năng để người dùng chọn bệnh viện từ menu thả xuống và để đường cong dịch bệnh chỉ phản ánh các trường hợp từ bệnh viện đó, với tiêu đề đồ thị động. Chúng tôi làm như sau:Thêm runtime: shiny vào YAMLĐặt lại tên cho đoạn code thiết lập là globalTạo một thanh bên chứa:\nCode để tạo vectơ tên bệnh viện duy nhất\nLệnh selectInput() (menu thả xuống shiny) với sự lựa chọn tên bệnh viện. Lựa chọn được lưu dưới dạng hospital_choice, có thể được tham chiếu trong mã sau này dưới dạng input$hospital_choice\nCode để tạo vectơ tên bệnh viện duy nhấtLệnh selectInput() (menu thả xuống shiny) với sự lựa chọn tên bệnh viện. Lựa chọn được lưu dưới dạng hospital_choice, có thể được tham chiếu trong mã sau này dưới dạng input$hospital_choiceCode đường cong dịch bệnh (cột 2) được đặt trong renderPlot({ }), gồm:\nBộ lọc trên tập dữ liệu giới hạn cột hospital thành giá trị hiện tại của input$hospital_choice\nTiêu đề đồ thị động kết hợp input$hospital_choice\nBộ lọc trên tập dữ liệu giới hạn cột hospital thành giá trị hiện tại của input$hospital_choiceTiêu đề đồ thị động kết hợp input$hospital_choiceLưu ý rằng bất kỳ code nào tham chiếu đến giá trị input$ phải nằm trong một hàm render({}) (là hàm phản ứng).Đây là phần trên cùng của script, bao gồm YAML, global chunk và sidebar:Đây là Cột 2, với đồ thi epicurve phản ứng:Và đây là dashboard:","code":""},{"path":"flexdashboard.html","id":"các-ví-dụ-khác","chapter":"42 Dashboards với R Markdown","heading":"Các ví dụ khác","text":"Để đọc một ví dụ liên quan đến sức khỏe về Shiny-flexdashboard bằng cách sử dụng tính năng tương tác shiny và tiện ích vẽ bản đồ leaflet, hãy xem chương này của sách trực tuyến Geospatial Health Data: Modeling Visualization R-INLA Shiny.","code":""},{"path":"flexdashboard.html","id":"chia-sẻ","chapter":"42 Dashboards với R Markdown","heading":"42.9 Chia sẻ","text":"Dashboards không chứa các phần tử Shiny sẽ xuất ra tệp HTML (.html), tệp này có thể được gửi qua email (nếu kích thước cho phép). Điều này rất hữu ích, vì bạn có thể gửi báo cáo “dashboard” và không phải thiết lập máy chủ để lưu trữ báo cáo đó dưới dạng trang web.Nếu bạn đã nhúng shiny, bạn sẽ không thể gửi đầu ra qua email, nhưng bạn có thể gửi chính script cho người dùng R hoặc lưu trữ dashboard trên một máy chủ như đã giải thích ở trên.","code":""},{"path":"flexdashboard.html","id":"tài-nguyên-học-liệu-15","chapter":"42 Dashboards với R Markdown","heading":"42.10 Tài nguyên học liệu","text":"Bạn có thể tìm thấy các hướng dẫn đầy đủ cho chương này bên dưới. Nếu bạn xem lại chúng, rất có thể trong vòng một giờ, bạn có thể có dashboard của riêng mình.https://bookdown.org/yihui/rmarkdown/dashboards.htmlhttps://rmarkdown.rstudio.com/flexdashboard/https://rmarkdown.rstudio.com/flexdashboard/using.htmlhttps://rmarkdown.rstudio.com/flexdashboard/examples.html","code":""},{"path":"shiny-basics.html","id":"shiny-basics","chapter":"43 Dashboards với Shiny","heading":"43 Dashboards với Shiny","text":"Dashboards thường là một cách tuyệt vời để chia sẻ kết quả từ các phân tích với những người khác. Tạo ra một dashboard với shiny đòi hỏi kiến thức tương đối nâng cao về ngôn ngữ R, nhưng cũng cung cấp cho bạn khả năng tùy chỉnh đáng kinh ngạc.Chúng tôi khuyến nghị rằng ai đó đang học dashboards với shiny phải có kiến thức tốt về biến đổi và trực quan hóa dữ liệu, đồng thời có thể tự tin gỡ lỗi code và viết hàm. Làm việc với dashboards không dễ khi bạn mới bắt đầu và đôi khi khó hiểu, nhưng là một kỹ năng tuyệt vời để học và trở nên dễ dàng hơn nhiều khi thực hành!Chương này sẽ cung cấp tổng quan ngắn gọn về cách tạo dashboards với shiny và các tiện ích mở rộng của nó.\nĐể biết một phương pháp thay thế tạo dashboards nhanh hơn, dễ dàng hơn nhưng có thể ít tùy chỉnh hơn, hãy xem thêm về flextable trong chương (Dashboards với R Markdown).","code":""},{"path":"shiny-basics.html","id":"chuẩn-bị-35","chapter":"43 Dashboards với Shiny","heading":"43.1 Chuẩn bị","text":"","code":""},{"path":"shiny-basics.html","id":"gọi-packages-17","chapter":"43 Dashboards với Shiny","heading":"Gọi packages","text":"Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.Chúng ta bắt đầu bằng cách cài đặt package shiny:","code":"\npacman::p_load(\"shiny\")"},{"path":"shiny-basics.html","id":"nhập-dữ-liệu-25","chapter":"43 Dashboards với Shiny","heading":"Nhập dữ liệu","text":"Nếu bạn muốn theo dõi chương này, hãy xem phần này trong chương Tải sách và dữ liệu. Có các liên kết để tải xuống scripts R và các tệp dữ liệu tạo ra ứng dụng Shiny cuối cùng.Nếu bạn cố gắng xây dựng lại app bằng các tệp này, hãy lưu ý về cấu trúc thư mục dự án R được tạo trong quá trình thực hiện (ví dụ: thư mục cho “data” và “funcs”).","code":""},{"path":"shiny-basics.html","id":"cấu-trúc-của-một-ứng-dụng-shiny","chapter":"43 Dashboards với Shiny","heading":"43.2 Cấu trúc của một ứng dụng shiny","text":"","code":""},{"path":"shiny-basics.html","id":"cấu-trúc-tệp-cơ-bản","chapter":"43 Dashboards với Shiny","heading":"Cấu trúc tệp cơ bản","text":"Để hiểu về shiny, trước tiên chúng ta cần hiểu cấu trúc tệp của một ứng dụng hoạt động như thế nào! Chúng ta nên tạo một thư mục hoàn toàn mới trước khi bắt đầu. Điều này thực sự có thể được thực hiện dễ dàng hơn bằng cách chọn New project trong Rstudio và chọn Shiny Web Application. Điều này sẽ giúp tạo ra cấu trúc cơ bản của một ứng dụng shiny cho bạn.Khi mở dự án này, bạn sẽ nhận thấy có một tệp .R có tên là app.R. Điều cần thiết là chúng ta có một trong hai cấu trúc tệp cơ bản:Một tệp có tên là app.R, hoặcHai tệp, một tệp có tên là ui.R và tệp còn lại là server.RTrong chương này, chúng tôi sẽ sử dụng cách tiếp cận đầu tiên là có một tệp có tên là app.R. Đây là một script ví dụ:Nếu bạn mở tệp này, bạn sẽ nhận thấy rằng hai đối tượng được xác định - một đối tượng được gọi là ui và đối tượng khác được gọi là server. Các đối tượng này phải được xác định trong mọi ứng dụng shiny và là trung tâm cấu trúc của chính ứng dụng đó! Trên thực tế, sự khác biệt duy nhất giữa hai cấu trúc tệp được mô tả ở trên là trong cấu trúc 1, cả ui và server đều được xác định trong một tệp, trong khi ở cấu trúc 2, chúng được định nghĩa trong các tệp riêng biệt. Lưu ý: chúng ta cũng có thể (và nên có nếu chúng ta có một ứng dụng lớn hơn) có các tệp .R khác trong cấu trúc để chúng ta có thể nhúng source() vào ứng dụng của mình.","code":"\n# an example of app.R\n\nlibrary(shiny)\n\nui <- fluidPage(\n\n    # Application title\n    titlePanel(\"My app\"),\n\n    # Sidebar with a slider input widget\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"input_1\")\n        ),\n\n        # Show a plot \n        mainPanel(\n           plotOutput(\"my_plot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n     \n     plot_1 <- reactive({\n          plot_func(param = input_1)\n     })\n     \n    output$my_plot <- renderPlot({\n       plot_1()\n    })\n}\n\n\n# Run the application \nshinyApp(ui = ui, server = server)"},{"path":"shiny-basics.html","id":"máy-chủ-và-giao-diện-người-dùng","chapter":"43 Dashboards với Shiny","heading":"Máy chủ và giao diện người dùng","text":"Tiếp theo, chúng ta cần hiểu các đối tượng server và ui thực sự làm gì. Nói một cách đơn giản, đây là hai đối tượng tương tác với nhau bất cứ khi nào người dùng tương tác với ứng dụng shiny.Phần tử UI (giao diện người dùng) của một ứng dụng shiny, ở cấp độ cơ bản, là code R tạo ra giao diện HTML. Điều này có nghĩa là mọi thứ được hiển thị trong giao diện người dùng của một ứng dụng. Điều này thường bao gồm:“Widgets (thành phần điều khiển)” - menu thả xuống, hộp kiểm, thanh trượt, v.v. mà người dùng có thể tương tácĐồ thị, bảng, v.v. - kết quả đầu ra được tạo bằng code RCác khía cạnh điều hướng của một ứng dụng - tab, cửa sổ, v.v.Văn bản chung, đường liên kết, v.v.Các phần tử HTML và CSSĐiều quan trọng nhất cần hiểu về UI là nó nhận đầu vào từ người dùng và hiển thị đầu ra từ máy chủ. Không có code hoạt động chạy trong ui tại bất kỳ thời điểm nào - tất cả các thay đổi được nhìn thấy trong UI đều được chuyển qua máy chủ (nhiều hơn hoặc ít hơn). Vì vậy, chúng ta phải tạo các đồ thị, tải xuống, v.v. trong máy chủMáy chủ của ứng dụng shiny là nơi tất cả code đang được chạy khi ứng dụng khởi động. Cách nó hoạt động hơi khó hiểu một chút. Chức năng máy chủ sẽ phản hồi một cách hiệu quả đối theo những gì người dùng giao tiếp với UI và chạy các đoạn code phản hồi tương ứng. Nếu mọi thứ thay đổi trong máy chủ, những thứ này sẽ được chuyển trở lại ui, nơi có thể nhìn thấy những thay đổi. Quan trọng là code trong máy chủ sẽ được thực thi không liên tiếp (hoặc tốt nhất là bạn nên nghĩ theo cách này). Về cơ bản, bất cứ khi nào đầu vào ui ảnh hưởng đến một đoạn code trong máy chủ, nó sẽ tự động chạy và đầu ra đó sẽ được tạo ra và hiển thị.Tất cả điều này bây giờ có vẻ rất trừu tượng, vì vậy chúng ta sẽ phải đi sâu vào một số ví dụ để có một ý tưởng rõ ràng về cách nó thực sự hoạt động.","code":""},{"path":"shiny-basics.html","id":"trước-khi-bạn-bắt-đầu-tạo-một-ứng-dụng","chapter":"43 Dashboards với Shiny","heading":"Trước khi bạn bắt đầu tạo một ứng dụng","text":"Trước khi bạn bắt đầu xây dựng một ứng dụng, việc biết những gì bạn muốn tạo sẽ vô cùng hữu ích. Vì UI của bạn sẽ được viết bằng code, bạn không thể thực sự hình dung những gì bạn đang tạo trừ khi bạn đang nhắm đến một cái gì đó cụ thể. Vì lý này, sẽ vô cùng hữu ích khi xem xét rất nhiều ví dụ về các ứng dụng shiny để biết được những gì bạn có thể tạo ra - thậm chí còn tốt hơn nếu bạn có thể xem code gốc đằng sau các ứng dụng này! Một số tài nguyên tuyệt vời cho việc này là:Thư viện ứng dụng của RstudioKhi bạn có ý tưởng về những gì có thể thực hiện, sẽ rất hữu ích nếu bạn phác thảo ra diện mạo sản phẩm - bạn có thể thực hiện việc này trên giấy hoặc trong bất kỳ phần mềm vẽ nào (PowerPoint, MS paint, v.v.). Sẽ hữu ích khi bắt đầu đơn giản cho ứng dụng đầu tiên của bạn! Cũng không có gì phải xấu hổ nếu bạn sử dụng code có sẵn trên mạng của một ứng dụng mẫu phục vụ cho công việc của bạn - việc này dễ dàng hơn nhiều với việc xây dựng thứ gì đó từ đầu!","code":""},{"path":"shiny-basics.html","id":"tạo-một-ui","chapter":"43 Dashboards với Shiny","heading":"43.3 Tạo một UI","text":"Khi xây dựng ứng dụng, trước tiên, bạn nên làm việc trên UI để chúng ta có thể thấy những gì đang làm và không có nguy cơ ứng dụng bị lỗi bất kỳ lỗi máy chủ nào. Như đã đề cập trước đây, bạn nên sử dụng một mẫu có sẵn khi tạo UI. Bạn có thể tìm thấy một số bố cục tiêu chuẩn có sẵn trong package shiny, ngoài ra là ở các package mở rộng khác, chằng hạn như shinydashboard. Chúng tôi sẽ sử dụng một ví dụ từ package shiny cơ sở để bắt đầu.Một shiny UI thường được định nghĩa là một loạt các hàm lồng nhau, theo thứ tự sauMột hàm xác định bố cục chung (cơ bản nhất là fluidPage(), nhưng có nhiều hàm khác)Các ô điều khiển trong bố cục như:\nmột thanh bên (sidebarPanel())\nmột bảng điều khiển “chính” (mainPanel())\nmột tab (tabPanel())\nmột “cột” chung (column())\nmột thanh bên (sidebarPanel())một bảng điều khiển “chính” (mainPanel())một tab (tabPanel())một “cột” chung (column())Các widget và đầu ra - những thứ này có thể đưa đầu vào cho máy chủ (tiện ích) hoặc đưa ra từ máy chủ (đầu ra)\nCác widget thường được thiết kế kiểu như xxxInput(), ví dụ: selectInput()\nKết quả đầu ra thường được thiết kế kiểu như xxxOutput(), ví dụ: plotOutput()\nCác widget thường được thiết kế kiểu như xxxInput(), ví dụ: selectInput()Kết quả đầu ra thường được thiết kế kiểu như xxxOutput(), ví dụ: plotOutput()Cần phải nói lại rằng những thứ này không thể được hình dung một cách dễ dàng theo cách trừu tượng, vì vậy tốt nhất hãy xem một ví dụ! Hãy xem xét tạo một ứng dụng cơ bản hiển thị dữ liệu số lượng cơ sở sốt rét theo quận. Dữ liệu này có rất nhiều tham số khác nhau, vì vậy sẽ thật tuyệt nếu cuối cùng người dùng có thể áp dụng một số bộ lọc để xem dữ liệu theo nhóm tuổi/quận khi họ thấy phù hợp! Chúng ta có thể sử dụng một bố cục shiny rất đơn giản để bắt đầu - bố cục thanh bên. Đây là một bố cục trong đó các widget được đặt trong một thanh bên ở bên trái và đồ thị được đặt ở bên phải.Hãy lập kế hoạch cho ứng dụng của chúng ta - chúng ta có thể bắt đầu với một bộ chọn cho phép chúng ta chọn quận nơi chúng ta muốn trực quan hóa dữ liệu và một bộ chọn khác để biểu diễn nhóm tuổi quan tâm. Chúng ta sẽ sử dụng các bộ lọc này để hiển thị một đường cong dịch bệnh phản ánh các tham số này. Vì vậy, chúng ta cần:Hai menu thả xuống cho phép chúng ta chọn quận chúng ta muốn và nhóm tuổi quan tâm.Một khu vực mà chúng ta có thể hiển thị đường cong dịch bệnh kết quả.Code minh họa có thể trông giống như sau:Khi app.R được chạy với code UI ở trên (không có code đang hoạt động trong phần server của app.R), bố cục sẽ xuất hiện như thế này - lưu ý rằng sẽ không có đồ thị nếu không có máy chủ để hiển thị nó, nhưng đầu vào của chúng ta đang hoạt động!Đây là cơ hội tốt để thảo luận về cách mà các widget hoạt động - lưu ý rằng mỗi widget đang chấp nhận một inputId, một label và một loạt các tùy chọn khác dành riêng cho loại widget. InputId này cực kỳ quan trọng - đây là những ID được sử dụng để truyền thông tin từ UI đến máy chủ. Vì lý này, chúng phải là duy nhất. Bạn nên cố gắng đặt cho chúng một cái tên gì đó hợp lý và cụ thể theo chức năng của chúng trong các trường hợp thiết kế một ứng dụng lớn.Bạn nên đọc kỹ tài liệu để biết chi tiết đầy đủ về chức năng của mỗi widget này. Các widget sẽ chuyển các loại dữ liệu cụ thể đến máy chủ tùy thuộc vào loại widget và điều này cần được hiểu đầy đủ. Ví dụ: selectInput() sẽ chuyển dữ liệu dạng ký tự cho máy chủ:Nếu chúng ta chọn Spring cho widget đầu tiên ở đây, nó sẽ chuyển đối tượng ký tự \"Spring\" đến máy chủ.Nếu chúng ta chọn hai mục từ menu thả xuống, chúng sẽ đi qua dưới dạng vectơ ký tự (ví dụ: c(\"Spring\", \"Bolo\")).Các widget khác sẽ chuyển các loại đối tượng khác nhau đến máy chủ! Ví dụ:numericInput() sẽ chuyển một đối tượng dạng số đến máy chủcheckboxInput() sẽ chuyển một đối tượng kiểu logic đến máy chủ (TRUE hoặc FALSE)Cũng cần lưu ý vectơ được đặt tên mà chúng ta đã sử dụng cho dữ liệu độ tuổi ở đây. Đối với nhiều widget, việc sử dụng vectơ được đặt tên làm các lựa chọn sẽ hiển thị tên của vectơ dưới dạng các lựa chọn hiển thị, nhưng chuyển giá trị thực của lựa chọn từ vectơ đến máy chủ. Ví dụng chúng ta chọn “15+” từ menu thả xuống và UI sẽ chuyển \"malaria_rdt_15\" đến máy chủ - đây chính là tên của cột mà chúng ta quan tâm!Có rất nhiều widget mà bạn có thể sử dụng để làm nhiều việc với ứng dụng của mình. Các widget cũng cho phép bạn tải tệp lên ứng dụng của mình và tải xuống kết quả đầu ra. Ngoài ra còn có một số gói shiny mở rộng tuyệt vời cho phép bạn truy cập vào nhiều widget hơn với shiny cơ bản - package shinyWidgets là một ví dụ tuyệt vời về điều này. Để xem một số ví dụ, bạn có thể xem các liên kết sau:base shiny widget galleryshinyWidgets gallery","code":"\nlibrary(shiny)\n\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)"},{"path":"shiny-basics.html","id":"tải-dữ-liệu-vào-ứng-dụng","chapter":"43 Dashboards với Shiny","heading":"43.4 Tải dữ liệu vào ứng dụng","text":"Bước tiếp theo trong quá trình phát triển ứng dụng là thiết lập và chạy máy chủ. Tuy nhiên, để làm điều này, chúng ta cần đưa một số dữ liệu vào ứng dụng của mình và tìm ra tất cả các phép tính mà chúng ta sẽ thực hiện. Một ứng dụng shiny không dễ để gỡ lỗi, vì thường không rõ lỗi đến từ đâu, đó, lý tưởng nhất là hãy chắc chắn tất cả code dùng để trực quan và xử lý dữ liệu của chúng ta hoạt động tốt trước khi chúng ta bắt đầu tự tạo máy chủ.Bây giờ chúng ta muốn tạo một ứng dụng hiển thị các đường cong dịch bệnh thay đổi dựa trên đầu vào của người dùng, chúng ta nên nghĩ về code chúng ta sẽ cần để chạy chúng trong một R script bình thường. Chúng ta sẽ cần:Gọi các packagesTải dữ liệuChuyển đổi dữ liệuPhát triển một hàm để trực quan hóa dữ liệu của chúng ta dựa trên đầu vào của người dùngDanh sách này khá đơn giản và không quá khó để thực hiện. Bây giờ, điều quan trọng là phải nghĩ về những phần nào của quy trình này chỉ được thực hiện một lần và những phần nào cần chạy dựa theo các đầu vào của người dùng. Điều này là các ứng dụng shiny thường chạy một số code trước khi chạy, code này chỉ được thực hiện một lần. Nó sẽ giúp cải thiện hiệu suất ứng dụng của chúng ta nếu có thể chuyển nhiều code đến phần này. Đối với ví dụ này, chúng ta chỉ cần tải dữ liệu/packages của mình và thực hiện các phép biến đổi cơ bản một lần, vì vậy chúng ta có thể đặt code đó bên ngoài máy chủ. Điều này có nghĩa là thứ duy nhất chúng ta cần trong máy chủ là code để trực quan hóa dữ liệu của chúng ta. Trước tiên, hãy phát triển tất cả các thành phần này trong một script. Tuy nhiên, vì chúng ta đang trực quan hóa dữ liệu của mình bằng một hàm, chúng ta cũng có thể đặt code cho hàm bên ngoài máy chủ để hàm của chúng ta ở trong môi trường khi ứng dụng chạy!Đầu tiên, hãy tải dữ liệu của chúng ta. Vì chúng ta đang làm việc với một dự án mới và chúng ta cần làm sạch số liệu, chúng ta có thể tạo một thư mục mới có tên là data và thêm bộ dữ liệu sốt rét vào đó. Chúng ta có thể chạy code bên dưới trong một script thử nghiệm mà cuối cùng chúng ta sẽ xóa khi chúng ta dọn cấu trúc ứng dụng của mình.Sẽ dễ dàng hơn để làm việc với dữ liệu này nếu chúng ta sử dụng các tiêu chuẩn dữ liệu tidy, vì vậy chúng ta cũng nên chuyển đổi dữ liệu sang định dạng dài hơn, trong đó nhóm tuổi là một cột và các trường hợp là một cột khác. Chúng ta có thể thực hiện việc này một cách dễ dàng bằng cách sử dụng những gì chúng ta đã học được trong chương Xoay trục dữ liệu.Và cùng với đó, chúng ta đã chuẩn bị xong dữ liệu của mình! Chúng ta đã hoàn thành các mục 1, 2 và 3 trong danh sách những thứ cần phát triển cho một “script R thử nghiệm”. Nhiệm vụ cuối cùng và khó khăn nhất sẽ là xây dựng một hàm để tạo ra một đường cong dịch bệnh dựa trên các thông số người dùng xác định. Như đã đề cập trước đây, chúng tôi rất khuyến khích bất kỳ ai học shiny trước tiên hãy xem phần về lập trình hướng chức năng (Viết hàm) để hiểu cách thức hoạt động của nó!Khi định nghĩa một hàm, có thể khó khăn khi nghĩ về những tham số chúng ta muốn đưa vào. Đối với lập trình hướng chức năng với shiny, mọi tham số liên quan thường sẽ có một widget liên kết với nó, vì vậy việc suy nghĩ về điều này thường khá dễ dàng! Ví dụ: trong ứng dụng hiện tại, chúng ta muốn có thể lọc theo quận và có một widget cho việc này, vì vậy chúng ta có thể thêm thông số quận để phản ánh điều này. Chúng ta (hiện tại) không có bất kỳ chức năng ứng dụng nào để lọc theo cơ sở, vì vậy chúng ta không cần thêm thông số này làm tham số. Hãy bắt đầu bằng cách tạo một hàm với ba tham số:Bộ dữ liệu cốt lõiQuận được lựa chọnNhóm tuổi được lựa chọnChúng ta sẽ không đi sâu vào chi tiết về hàm này, vì nó tương đối đơn giản về cách hoạt động. Tuy nhiên, một điều cần lưu ý là chúng ta xử lý lỗi bằng cách trả về NULL khi nó sẽ xuất hiện lỗi. Lý là khi một máy chủ shiny tạo ra một đối tượng NULL thay vì một đối tượng đồ thị, sẽ không có gì được hiển thị trong ui! Điều này rất quan trọng, vì nếu không, các lỗi thường sẽ khiến ứng dụng của bạn ngừng hoạt động.Một điều khác cần lưu ý là việc sử dụng toán tử %% khi đánh giá đầu vào district. Như đã đề cập ở trên, toán tử này có thể đến dưới dạng một vectơ ký tự có nhiều giá trị, vì vậy việc sử dụng %% sẽ linh hoạt hơn với nói,==.Hãy kiểm tra hàm này!Với một hàm hoạt động được, bây giờ chúng ta phải hiểu cách mà tất cả những thứ này sẽ được fit vào một ứng dụng shiny như thế nào. Chúng ta đã đề cập đến khái niệm code khởi động (startup code) trước đây, nhưng hãy xem cách chúng ta thực sự có thể kết hợp nó vào cấu trúc ứng dụng của chúng ta. Có hai cách chúng ta có thể làm điều này!Đặt code này vào tệp app.R của bạn ở phần đầu script (phía trên UI) hoặcTạo một tệp mới trong thư mục của ứng dụng có tên global.R và đặt code khởi động vào tệp này.Có một lưu ý ở điểm này đó là nó sẽ thường dễ dàng hơn, đặc biệt là với các ứng dụng lớn, khi bạn sử dụng cấu trúc tệp thứ hai, vì nó cho phép bạn tách cấu trúc tệp của mình theo cách đơn giản. Hãy phát triển đầy đủ script global.R này ngay bây giờ. Đây là những gì nó có thể hiển thị:Thật đơn giản! Một tính năng tuyệt vời của shiny là nó sẽ hiểu các tệp có tên app.R, server.R, ui.R và global.R dùng để làm gì, vì vậy không cần phải kết nối chúng với nhau thông qua bất kỳ code nào. Vì vậy, chỉ cần có code này trong global.R trong thư mục, nó sẽ chạy trước khi chúng ta khởi động ứng dụng của mình!Chúng ta cũng nên lưu ý rằng có thể cải thiện tổ chức ứng dụng nếu chúng ta chuyển hàm vẽ biểu đồ sang tệp riêng của nó - điều này sẽ đặc biệt hữu ích khi các ứng dụng trở nên lớn hơn. Để làm điều này, chúng ta có thể tạo một thư mục khác có tên funcs và đặt hàm này dưới một tệp có tên plot_epicurve.R. Sau đó, chúng ta có thể đọc hàm này thông qua lệnh sau trong global.RLưu ý rằng bạn nên luôn chỉ định local = TRUE trong các ứng dụng shiny, vì nó sẽ ảnh hưởng đến việc tìm nguồn khi/nếu ứng dụng được xuất bản trên máy chủ.","code":"\npacman::p_load(\"tidyverse\", \"lubridate\")\n\n# read data\nmalaria_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %>% \n  as_tibble()\n\nprint(malaria_data)## # A tibble: 3,038 x 10\n##    location_name data_date  submitted_date Province District `malaria_rdt_0-4` `malaria_rdt_5-14` malaria_rdt_15 malaria_tot newid\n##    <chr>         <date>     <date>         <chr>    <chr>                <int>              <int>          <int>       <int> <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring                  11                 12             23          46     1\n##  2 Facility 2    2020-08-11 2020-08-12     North    Bolo                    11                 10              5          26     2\n##  3 Facility 3    2020-08-11 2020-08-12     North    Dingo                    8                  5              5          18     3\n##  4 Facility 4    2020-08-11 2020-08-12     North    Bolo                    16                 16             17          49     4\n##  5 Facility 5    2020-08-11 2020-08-12     North    Bolo                     9                  2              6          17     5\n##  6 Facility 6    2020-08-11 2020-08-12     North    Dingo                    3                  1              4           8     6\n##  7 Facility 6    2020-08-10 2020-08-12     North    Dingo                    4                  0              3           7     6\n##  8 Facility 5    2020-08-10 2020-08-12     North    Bolo                    15                 14             13          42     5\n##  9 Facility 5    2020-08-09 2020-08-12     North    Bolo                    11                 11             13          35     5\n## 10 Facility 5    2020-08-08 2020-08-12     North    Bolo                    19                 15             15          49     5\n## # ... with 3,028 more rows\nmalaria_data <- malaria_data %>%\n  select(-newid) %>%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\nprint(malaria_data)## # A tibble: 12,152 x 7\n##    location_name data_date  submitted_date Province District age_group        cases_reported\n##    <chr>         <date>     <date>         <chr>    <chr>    <chr>                     <int>\n##  1 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_0-4              11\n##  2 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_5-14             12\n##  3 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_15               23\n##  4 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_tot                  46\n##  5 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_0-4              11\n##  6 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_5-14             10\n##  7 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_15                5\n##  8 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_tot                  26\n##  9 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_0-4               8\n## 10 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_5-14              5\n## # ... with 12,142 more rows\nplot_epicurve <- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  if (!(\"All\" %in% district)) {\n    data <- data %>%\n      filter(District %in% district)\n    \n    plot_title_district <- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district <- \"all districts\"\n    \n  }\n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data <- data %>%\n    filter(age_group == agegroup)\n  \n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title <- \"All ages\"\n  } else {\n    agegroup_title <- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\nplot_epicurve(malaria_data, district = \"Bolo\", agegroup = \"malaria_rdt_0-4\")\n# global.R script\n\npacman::p_load(\"tidyverse\", \"lubridate\", \"shiny\")\n\n# read data\nmalaria_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %>% \n  as_tibble()\n\n# clean data and pivot longer\nmalaria_data <- malaria_data %>%\n  select(-newid) %>%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\n\n# define plotting function\nplot_epicurve <- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  # create plot title\n  if (!(\"All\" %in% district)) {            \n    data <- data %>%\n      filter(District %in% district)\n    \n    plot_title_district <- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district <- \"all districts\"\n    \n  }\n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  # filter to age group\n  data <- data %>%\n    filter(age_group == agegroup)\n  \n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title <- \"All ages\"\n  } else {\n    agegroup_title <- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\nsource(here(\"funcs\", \"plot_epicurve.R\"), local = TRUE)"},{"path":"shiny-basics.html","id":"phát-triển-một-máy-chủ-ứng-dụng","chapter":"43 Dashboards với Shiny","heading":"43.5 Phát triển một máy chủ ứng dụng","text":"Bây giờ chúng ta đã có hầu hết code cần thiết, chúng ta chỉ cần phát triển thêm máy chủ. Đây là phần cuối cùng của ứng dụng và có lẽ là phần khó hiểu nhất. Máy chủ là một hàm R lớn, nhưng sẽ hữu ích nếu coi nó như một chuỗi các hàm hoặc nhiệm vụ nhỏ hơn mà ứng dụng có thể thực hiện. Điều quan trọng là phải hiểu rằng các hàm này không được thực thi theo thứ tự tuyến tính. Nghĩa là có một thứ tự cho chúng, nhưng không cần phải hiểu đầy đủ khi bắt đầu với shiny. Ở cấp độ rất cơ bản, các tác vụ hoặc chức năng này sẽ kích hoạt khi có thay đổi về đầu vào của người dùng ảnh hưởng đến chúng, trừ khi nhà phát triển đã thiết lập chúng để chúng hoạt động khác biệt. Một lần nữa, nó khá trừu tượng, nhưng trước tiên hãy xem qua ba loại cơ bản của đối tượng shinyNguồn phản hồi (Reactive sources) - đây là một thuật ngữ khác của đầu vào người dùng. Máy chủ shiny có quyền truy cập vào các đầu ra từ UI thông qua các widget mà chúng ta đã lập trình. Mỗi khi các giá trị được thay đổi, chúng được chuyển đến máy chủ.Nguồn phản hồi (Reactive sources) - đây là một thuật ngữ khác của đầu vào người dùng. Máy chủ shiny có quyền truy cập vào các đầu ra từ UI thông qua các widget mà chúng ta đã lập trình. Mỗi khi các giá trị được thay đổi, chúng được chuyển đến máy chủ.Vật dẫn phản hồi (Reactive conductors) - đây là những đối tượng tồn tại chỉ bên trong máy chủ shiny. Chúng ta không thực sự cần những thứ này cho các ứng dụng đơn giản, nhưng chúng tạo ra các đối tượng chỉ có thể được nhìn thấy bên trong máy chủ và được sử dụng trong các hoạt động khác. Chúng thường phụ thuộc vào các nguồn phản ứng.Vật dẫn phản hồi (Reactive conductors) - đây là những đối tượng tồn tại chỉ bên trong máy chủ shiny. Chúng ta không thực sự cần những thứ này cho các ứng dụng đơn giản, nhưng chúng tạo ra các đối tượng chỉ có thể được nhìn thấy bên trong máy chủ và được sử dụng trong các hoạt động khác. Chúng thường phụ thuộc vào các nguồn phản ứng.Điểm cuối (Endpoints) - đây là các đầu ra được chuyển từ máy chủ đến UI. Trong ví dụ của chúng ta, đây sẽ là đường cong dịch bệnh mà chúng ta đang tạo.Điểm cuối (Endpoints) - đây là các đầu ra được chuyển từ máy chủ đến UI. Trong ví dụ của chúng ta, đây sẽ là đường cong dịch bệnh mà chúng ta đang tạo.Với các khái niệm này, chúng ta hãy xây dựng máy chủ theo từng bước. Chúng tôi hiển thị lại code UI một lần nữa ở đây để bạn tham khảo:Từ UI code này, chúng ta có:Hai đầu vào:\nBộ chọn quận (với inputId là select_district)\nBộ chọn nhóm tuổi (với inputId là select_agegroup)\nBộ chọn quận (với inputId là select_district)Bộ chọn nhóm tuổi (với inputId là select_agegroup)Một đầu ra:\nĐường cong dịch bệnh (với outputId là malaria_epicurve)\nĐường cong dịch bệnh (với outputId là malaria_epicurve)Như đã nói ở trên, những tên riêng mà chúng ta đã gán cho các đầu vào và đầu ra là rất quan trọng. Chúng phải là duy nhất và được sử dụng để chuyển thông tin giữa ui và máy chủ. Trong máy chủ, chúng ta truy cập tới các đầu vào thông qua cú pháp input$inputID và các đầu ra, và chuyển đến ui thông qua cú pháp output$output_name Hãy cùng xem xét một ví dụ, bởi vì điều này rất khó hiểu!Máy chủ cho một ứng dụng đơn giản như thế này thực sự khá dễ dàng! Bạn sẽ nhận thấy rằng máy chủ là một hàm có ba tham số - input, output và session - điều này không quan trọng để hiểu ngay bây giờ, nhưng điều quan trọng là phải tuân theo thiết lập này! Trong máy chủ bên trên, chúng ta chỉ có một nhiệm vụ - đó là kết xuất một biểu đồ dựa trên hàm mà chúng ta đã thực hiện trước đó và các đầu vào từ máy chủ. Lưu ý cách tên của các đối tượng đầu vào và đầu ra tương ứng chính xác với các đối tượng trong ui.Để hiểu những điều cơ bản về cách máy chủ phản hồi với thông tin đầu vào của người dùng, bạn cần lưu ý rằng đầu ra sẽ biết (thông qua package nhầm) khi đầu vào thay đổi và chạy lại hàm này để tạo biểu đồ mỗi khi chúng thay đổi. Lưu ý rằng chúng tôi cũng sử dụng hàm renderPlot() ở đây - đây là một trong số họ các hàm dành riêng cho lớp truyền các đối tượng đó đến đầu ra ui. Có một số hàm hoạt động tương tự, nhưng bạn cần đảm bảo hàm được sử dụng khớp với lớp đối tượng mà bạn đang chuyển tới ui! Ví dụ:renderText() - gửi văn bản tới uirenderDataTable - gửi bảng tương tác tới ui.Hãy nhớ rằng chúng cũng cần phải khớp với hàm đầu ra được sử dụng trong ui - vì vậy renderPlot() được ghép cặp với plotOutput() và renderText() được kết hợp với textOutput().Cuối cùng chúng ta đã tạo ra một ứng dụng hoạt động! Chúng ta có thể chạy ứng dùng bằng cách nhấn nút Run App ở trên cùng bên phải của cửa sổ script trong Rstudio. Bạn nên lưu ý rằng bạn có thể chọn chạy ứng dụng của mình trong trình duyệt mặc định (thay vì Rstudio), điều này sẽ phản ánh chính xác hơn giao diện của ứng dụng đối với những người dùng khác.Lưu ý vui rằng trong R console, ứng dụng đang “lắng nghe”! Hãy nói về sự phản hồi!","code":"\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\nserver <- function(input, output, session) {\n  \n  output$malaria_epicurve <- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n}"},{"path":"shiny-basics.html","id":"thêm-nhiều-chức-năng-hơn","chapter":"43 Dashboards với Shiny","heading":"43.6 Thêm nhiều chức năng hơn","text":"Tại thời điểm này, cuối cùng chúng ta đã có một ứng dụng đang chạy, nhưng chúng ta có rất ít chức năng. Chúng ta cũng không thực sự khai thác hết những gì shiny có thể làm, vì vậy có nhiều thứ để tìm hiểu thêm! Hãy tiếp tục xây dựng ứng dụng hiện có của chúng ta bằng cách thêm một số tính năng bổ sung. Một số thứ hay bạn có thể thêm vào là:Một văn bản giải thíchNút tải đồ thị xuống - Cung cấp cho người dùng phiên bản chất lượng cao của hình ảnh mà họ đang tạo trong ứng dụngMột bộ chọn cho các cơ sở cụ thểMột trang dashboard khác - Có thể hiển thị một bảng cho dữ liệu của chúng ta.Có rất nhiều thứ để thêm, nhưng chúng ta có thể sử dụng nó để tìm hiểu về một loạt các tính năng shiny khác nhau sau này. Có rất nhiều thứ để tìm hiểu về Shiny (nó có thể trở nên rất nâng cao, nhưng hy vọng nó là trường hợp một khi người dùng có ý tưởng tốt hơn về cách sử dụng nó, họ có thể trở nên thoải mái hơn khi sử dụng các nguồn học tập bên ngoài).","code":""},{"path":"shiny-basics.html","id":"thêm-văn-bản-tĩnh","chapter":"43 Dashboards với Shiny","heading":"Thêm văn bản tĩnh","text":"Trước tiên hãy thảo luận về việc thêm văn bản tĩnh vào ứng dụng shiny. Thêm văn bản vào ứng dụng của chúng ta cực kỳ dễ dàng khi bạn có kiến thức cơ bản về nó. Vì văn bản tĩnh không thay đổi trong ứng dụng shiny (nếu bạn muốn thay đổi, bạn có thể sử dụng hàm kết xuất văn bản (text rendering) trong máy chủ!), Tất cả văn bản tĩnh của Shiny thường được thêm vào UI của ứng dụng. Chúng tôi sẽ không đi vào chi tiết cho điều này, nhưng bạn có thể thêm nhiều yếu tố khác nhau vào giao diện UI (và thậm chí cả tùy chỉnh) bằng cách giao tiếp R với HTML và css.HTML và css là các ngôn ngữ có liên quan mật thiết trong thiết kế giao diện người dùng. Chúng ta không cần phải hiểu quá rõ những thứ này, nhưng HTML tạo các đối tượng trong UI (như hộp văn bản hoặc bảng) và css thường được sử dụng để thay đổi kiểu và tính thẩm mỹ của các đối tượng đó. Shiny có quyền truy cập vào một mảng lớn của các thẻ HTML - các thẻ này trình bày các đối tượng hoạt động theo một cách cụ thể, chẳng hạn như các tiêu đề, đoạn văn bản, ngắt dòng, bảng, v.v. Chúng ta có thể sử dụng một số ví dụ này như sau:h1() - đây là một thẻ đầu mục, sẽ tự động tạo văn bản lớn hơn và thay đổi mặc định khi chúng liên quan đến mặt phông chữ, màu v.v (tùy thuộc vào theme tổng thể ứng dụng của bạn). Bạn có thể truy cập tiêu đề phụ nhỏ hơn và nhỏ hơn với h2() xuống tới cả h6(). Cách sử dụng sẽ trông như sau:\nh1(\"header - section 1\")\nh1() - đây là một thẻ đầu mục, sẽ tự động tạo văn bản lớn hơn và thay đổi mặc định khi chúng liên quan đến mặt phông chữ, màu v.v (tùy thuộc vào theme tổng thể ứng dụng của bạn). Bạn có thể truy cập tiêu đề phụ nhỏ hơn và nhỏ hơn với h2() xuống tới cả h6(). Cách sử dụng sẽ trông như sau:h1(\"header - section 1\")p() - đây là thẻ đoạn, sẽ khiến văn bản được chọn tương tự như văn bản trong một thân văn bản. Văn bản này sẽ tự động bao quanh, và có kích thước tương đối nhỏ (footers có thể còn nhỏ hơn). Hãy nghĩ về nó như phần thân văn bản của tài liệu Word. Cách sử dụng trông như sau\np(\"larger body text explaining function app\")\np() - đây là thẻ đoạn, sẽ khiến văn bản được chọn tương tự như văn bản trong một thân văn bản. Văn bản này sẽ tự động bao quanh, và có kích thước tương đối nhỏ (footers có thể còn nhỏ hơn). Hãy nghĩ về nó như phần thân văn bản của tài liệu Word. Cách sử dụng trông như saup(\"larger body text explaining function app\")tags$b() và tags$() - chúng được sử dụng để tạo đậm tags$b() và nghiêng tags$() với bất kỳ văn bản nào được chọn!tags$b() và tags$() - chúng được sử dụng để tạo đậm tags$b() và nghiêng tags$() với bất kỳ văn bản nào được chọn!tags$ul(), tags$ol() và tags$li() - đây là các thẻ được sử dụng trong việc tạo danh sách. Tất cả đều được sử dụng trong cú pháp bên dưới và cho phép người dùng tạo một danh sách theo thứ tự (tags$ol(); nghĩa là được đánh số) hoặc danh sách không có thứ tự (tags$ul(), nghĩa là tạo gạch đầu dòng). tags$li() được sử dụng để biểu thị các mục trong danh sách, bất kể loại danh sách nào được sử dụng. ví dụ:tags$ul(), tags$ol() và tags$li() - đây là các thẻ được sử dụng trong việc tạo danh sách. Tất cả đều được sử dụng trong cú pháp bên dưới và cho phép người dùng tạo một danh sách theo thứ tự (tags$ol(); nghĩa là được đánh số) hoặc danh sách không có thứ tự (tags$ul(), nghĩa là tạo gạch đầu dòng). tags$li() được sử dụng để biểu thị các mục trong danh sách, bất kể loại danh sách nào được sử dụng. ví dụ:br() và hr() - các thẻ này tương ứng tạo ngắt dòng và dòng ngang (với một ngắt dòng). Sử dụng chúng để tách riêng các phần của ứng dụng và văn bản của bạn! Không cần phải chuyền bất kỳ đối tượng nào vào các thẻ này (dấu ngoặc đơn có thể vẫn trống).br() và hr() - các thẻ này tương ứng tạo ngắt dòng và dòng ngang (với một ngắt dòng). Sử dụng chúng để tách riêng các phần của ứng dụng và văn bản của bạn! Không cần phải chuyền bất kỳ đối tượng nào vào các thẻ này (dấu ngoặc đơn có thể vẫn trống).div() - Đây là thẻ chung có thể chứa bất cứ thứ gì và có thể có bất cứ tên gì. Khi bạn tiến bộ với thiết kế UI, bạn có thể sử dụng chúng để phân các UI ra từng loại, cung cấp các style cho từng phần cụ thể và tạo các tương tác giữa các phần tử máy chủ và UI. Chúng tôi sẽ không đi sâu vào những chi tiết này, nhưng quan trọng để biết qua về chúng!div() - Đây là thẻ chung có thể chứa bất cứ thứ gì và có thể có bất cứ tên gì. Khi bạn tiến bộ với thiết kế UI, bạn có thể sử dụng chúng để phân các UI ra từng loại, cung cấp các style cho từng phần cụ thể và tạo các tương tác giữa các phần tử máy chủ và UI. Chúng tôi sẽ không đi sâu vào những chi tiết này, nhưng quan trọng để biết qua về chúng!Lưu ý rằng mỗi đối tượng này có thể được truy cập thông qua các thẻ tags$... hoặc chỉ qua hàm với một số khác. Chúng có hiệu quả như nhau, nhưng nó có thể giúp sử dụng kiểu tags$... nếu bạn thích rõ ràng hơn và không vô tình ghi đè các hàm. Điều này cũng không có nghĩa là có sẵn một danh sách thẻ đầy đủ. Có một danh sách khá đầy đủ tất cả các thẻ có sẵn trong shiny ở đây và thậm chí nhiều thẻ có thể được sử dụng hơn nếu bạn biết cách chèn HTML trực tiếp vào UI của bạn!Nếu bạn cảm thấy tự tin, bạn cũng có thể thêm bất kỳ phần tử tạo kiểu css nào vào các thẻ HTML của mình với đối số style trong bất kỳ phần tử nào. Chúng ta sẽ không đi vào chi tiết cách thức hoạt động, nhưng một mẹo để thử nghiệm các thay đổi thẩm mỹ đối với UI đang sử dụng chế độ HTML inspector trong Chrome (bên trong ứng dụng shiny của bạn khi bạn đang chạy trong trình duyệt) và tự chỉnh sửa style của các đối tượng!Hãy thêm một số văn bản vào ứng dụng của chúng ta","code":"\ntags$ol(\n  \n  tags$li(\"Item 1\"),\n  \n  tags$li(\"Item 2\"),\n  \n  tags$li(\"Item 3\")\n  \n)\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         h4(\"Options\"),\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n    tags$ul(\n      tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n      tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n      tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n      tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n      tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n      tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n      tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n    )\n    \n  )\n)\n)"},{"path":"shiny-basics.html","id":"thêm-liên-kết","chapter":"43 Dashboards với Shiny","heading":"Thêm liên kết","text":"Để thêm một liên kết đến một trang web, hãy sử dụng tags$() với liên kết và văn bản hiển thị như bên dưới. Để có một đoạn độc lập, hãy đặt nó trong p(). Để chỉ có một vài từ của một câu được gắn liên kết, hãy chia câu thành các phần và sử dụng tags$() cho thành phần gắn hyperlink. Để đảm bảo liên kết được mở trong một cửa sổ trình duyệt mới, hãy thêm target = \"_blank\" dưới dạng một đối số.","code":"\ntags$a(href = \"www.epiRhandbook.com\", \"Visit our website!\")"},{"path":"shiny-basics.html","id":"thêm-nút-tải-về","chapter":"43 Dashboards với Shiny","heading":"Thêm nút tải về","text":"Hãy cùng chuyển sang tính năng thứ hai. Nút tải xuống là một điều khá phổ biến để thêm vào một ứng dụng và khá dễ thực hiện. Chúng ta cần thêm một Widget khác vào giao diện người dùng và thêm một đầu ra khác tới máy chủ của chúng ta để đính kèm vào Widget đó. Chúng tôi cũng có thể giới thiệu về vật dẫn phản hồi trong ví dụ này!Hãy cập nhật giao diện người dùng của chúng ta trước - Điều này dễ dàng khi Shiny đi kèm với một widget có tên là downloadButton() - cho phép đặt inputId và nhãn.Lưu ý rằng chúng ta cũng đã thêm vào thẻ hr() - Điều này thêm một đường ngang ngăn cách các widget điều khiển với các widget tải xuống của chúng ta. Đây là một trong những thẻ HTML khác mà chúng ta đã thảo luận trước đây.Bây giờ khi giao diện người dùng của chúng ta đã sẵn sàng, chúng ta cần thêm thành phần máy chủ. Việc thiết kế tải xuống đã được hoàn thành trong máy chủ với hàm downloadHandler(). Tương tự như đồ thị, chúng ta cần đính kèm nó vào một đầu ra có cùng inputId như là nút tải xuống. Hàm này có hai đối số - filename và content - cả hai đều là các hàm. Như bạn có thể đoán, fileName được sử dụng để chỉ định tên của tệp đã tải xuống và content được sử dụng để chỉ định những gì nên tải xuống. content chứa một hàm mà bạn sẽ sử dụng để lưu dữ liệu cục bộ - vì vậy nếu bạn đang tải xuống tệp CSV, bạn có thể sử dụng hàm rio::export(). Bởi vì chúng ta đang tải xuống một đồ thị, chúng ta sẽ sử dụng hàm ggplot2::ggsave(). Hãy xem cách chúng ta sẽ lập trình nó như sau (chúng ta sẽ không thêm nó vào máy chủ).Lưu ý rằng hàm content luôn có đối số file, đối số giúp chúng ta chỉ định tên tệp đầu ra. Bạn cũng có thể nhận thấy rằng chúng ta đang lặp lại code tại đây - chúng ta đang sử dụng hàm plot_epicurve() hai lần trong máy chủ, một lần để tải xuống và một lần cho hình ảnh được hiển thị trong ứng dụng. Trong khi điều này sẽ không ảnh hưởng lớn đến hiệu suất, nghĩa là code để tạo ra đồ thị này sẽ phải chạy khi người dùng thay đổi các widget xác định nhóm quận và tuổi, và một lần nữa khi bạn muốn tải xuống đồ thị. Trong các ứng dụng lớn hơn, các quyết định làm giảm hiệu quả tối ưu như thế này sẽ càng ngày càng làm chậm mọi thứ, vì vậy sẽ tốt khi bạn học cách làm cho ứng dụng của chúng ta hiệu quả hơn theo nghĩa này. Sẽ hợp lý hơn nếu chúng ta có cách chạy code epicurve khi các nhóm quận/tuổi thay đổi, và để chúng được sử dụng bởi các hàm renderPlot() và downloadHandler(). Đây là khi mà các vật dẫn phản hồi có tác dụng!Vật dẫn phản hồi là các đối tượng được tạo trong máy chủ shiny theo cơ chế tương tác, nhưng không xuất hiện - chúng chỉ có thể được sử dụng bởi các phần khác của máy chủ. Có một số loại vật dẫn phản hồi khác nhau, nhưng chúng ta sẽ đi qua hai loại cơ bản.1.reactive() - đây là vật dẫn phản hồi cơ bản nhất - nó sẽ phản hồi bất cứ khi nào bất kỳ đầu vào nào được sử dụng bên trong bởi nó thay đổi (các widget nhóm/nhóm tuổi)\n2. eventReactive() - vật dẫn phản hồi này hoạt động giống với reactive(), ngoại trừ người dùng có thể quy định các đầu vào nào khiến nó tiến hành chạy lại. Cách này rất hữu ích nếu vật dẫn phản hồi của bạn mất nhiều thời gian để xử lý, nhưng chúng tôi sẽ giải thích rõ hơn ở phần sauHãy xem hai ví dụ:Khi chúng ta sử dụng thiết lập eventReactive(), chúng ta có thể chỉ định các đầu vào nào chạy đoạn code này - điều này không hữu ích với chúng ta vào lúc này, nên chúng ta có thể bỏ qua nó. Lưu ý rằng bạn có thể bao gồm nhiều đầu vào với c()Hãy xem cách chúng ta có thể tích hợp vào code máy chủ:Bạn có thể thấy chúng ta chỉ cần gọi đầu ra của phản hồi mà chúng ta đã xác định trong cả hai hàm tải xuống và tạo biểu đồ. Một điều cần lưu ý là bạn phải sử dụng các đầu ra của các phản hồi như thể chúng là các hàm - vì vậy bạn phải thêm dấu đơn ngoặc trống ở cuối chúng (tức là malaria_plot() là chính xác, còn malaria_plot thì không). Bây giờ khi chúng ta đã thêm giải pháp này, ứng dụng của chúng ta trở nên gọn gẽ hơn, nhanh hơn và dễ thay đổi hơn vì tất cả các code chạy hàm epicurve đều ở một nơi.","code":"\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # horizontal line\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\nserver <- function(input, output, session) {\n  \n  output$malaria_epicurve <- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n  output$download_epicurve <- downloadHandler(\n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\nmalaria_plot_r <- reactive({\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\n\n# only runs when the district selector changes!\nmalaria_plot_er <- eventReactive(input$select_district, {\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\nserver <- function(input, output, session) {\n  \n  malaria_plot <- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  })\n  \n  \n  \n  output$malaria_epicurve <- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve <- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}"},{"path":"shiny-basics.html","id":"thêm-bộ-chọn-cơ-sở-y-tế","chapter":"43 Dashboards với Shiny","heading":"Thêm bộ chọn cơ sở y tế","text":"Hãy chuyển sang tính năng tiếp theo của chúng ta - một bộ chọn cho các cơ sở cụ thể. Chúng ta sẽ thêm một tham số khác vào hàm của mình để có thể biến nó thành đối số từ code của chúng ta. Trước tiên, hãy xem việc thực hiện điều này - nó chỉ hoạt động theo các nguyên tắc tương tự như các tham số khác mà chúng ta đã thiết lập. Hãy cập nhật và kiểm tra hàm của chúng ta.Hãy kiểm tra nó:Với tất cả các cơ sở trong dữ liệu của chúng ta, sẽ khó để biết cơ sở nào tương ứng với các quận nào - và người dùng cuối cũng sẽ không biết. Điều này có thể làm cho việc sử dụng ứng dụng trở nên không trực quan. Vì lý này, chúng ta nên làm cho các tùy chọn cơ sở trong UI thay đổi động khi người dùng thay đổi khu vực - để cái này lọc cái kia! Vì chúng ta có rất nhiều biến đang sử dụng trong các tùy chọn, chúng ta cũng có thể muốn tạo một số tùy chọn cho ui trong tệp global.R từ số liệu. Ví dụ: chúng ta có thể thêm đoạn code này vào global.R sau khi đọc dữ liệu của mình:Hãy xem chúng:Chúng ta có thể chuyển các biến mới này tới giao diện người dùng mà không gặp bất kỳ vấn đề gì, vì chúng được hiển thị trên toàn bộ cả server và ui! Hãy cập nhật UI của chúng ta:Lưu ý cách chúng ta hiện đang chuyển các biến cho các lựa chọn thay vì mã hóa cứng chúng trong ui! Điều này cũng có thể làm cho code của chúng ta nhỏ gọn hơn! Cuối cùng, chúng ta sẽ phải cập nhật máy chủ. Sẽ dễ dàng cập nhật hàm của chúng ta để kết hợp với đầu vào mới (chúng ta chỉ cần chuyển nó làm đối số cho tham số mới), nhưng nên nhớ rằng chúng ta cũng muốn ui cập nhật khi người dùng thay đổi khu vực đã chọn. Điều quan trọng cần hiểu ở đây là chúng ta có thể thay đổi các tham số và đặc tính của widget trong khi ứng dụng đang chạy, nhưng điều này cần được thực hiện trên máy chủ. Chúng ta cần tìm hiểu một cách mới để xuất ra máy chủ.Các hàm chúng ta cần hiểu cách thực hiện điều này được gọi là các hàm observer (trình quan sát) và tương tự như các hàm reactive (phản ứng) về cách chúng hoạt động. Tuy nhiên, chúng có một điểm khác biệt chính:Các hàm phản ứng không ảnh hưởng trực tiếp đến kết quả đầu ra và tạo ra các đối tượng có thể được nhìn thấy ở các vị trí khác trong máy chủCác hàm quan sát có thể ảnh hưởng đến kết quả đầu ra của máy chủ, nhưng làm như vậy thông qua các hiệu ứng bên ngoài của các hàm khác. (Chúng cũng có thể làm những việc khác, nhưng đây là chức năng chính của chúng trong thực tế)Tương tự như các hàm phản ứng, có hai loại của các hàm quan sát và chúng được phân chia theo cùng một logic phân chia các hàm phản ứng:observe() - hàm này chạy bất cứ khi nào bất kỳ đầu vào nào được sử dụng bên trong nó thay đổiobserveEvent() - hàm này chạy khi đầu vào người dùng chỉ định thay đổiChúng ta cũng cần hiểu các hàm được shiny cung cấp giúp cập nhật các widget. Chúng khá đơn giản để chạy - trước tiên chúng lấy đối tượng session từ hàm máy chủ (tại thời điểm này bạn chưa cần phải hiểu), và sau đó thay đổi inputId của hàm. Sau đó, chúng ta chuyển các phiên bản mới của tất cả các tham số đã được lấy bởi selectInput() - những tham số này sẽ được cập nhật tự động trong widget.Hãy xem một ví dụ riêng lẻ về cách chúng ta có thể sử dụng điều này trong máy chủ của mình. Khi người dùng thay đổi quận, chúng ta muốn lọc các cơ sở theo quận và cập nhật các lựa chọn để chỉ hiển thị những cơ sở có sẵn trong quận đó (và một tùy chọn cho tất cả các cơ sở)Vậy đó! Chúng ta có thể thêm nó vào máy chủ và đặc tính đó bây giờ sẽ hoạt động. Đây là giao diện máy chủ mới của chúng ta:","code":"\nplot_epicurve <- function(data, district = \"All\", agegroup = \"malaria_tot\", facility = \"All\") {\n  \n  if (!(\"All\" %in% district)) {\n    data <- data %>%\n      filter(District %in% district)\n    \n    plot_title_district <- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district <- \"all districts\"\n    \n  }\n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data <- data %>%\n    filter(age_group == agegroup)\n  \n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title <- \"All ages\"\n  } else {\n    agegroup_title <- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n    if (!(\"All\" %in% facility)) {\n    data <- data %>%\n      filter(location_name == facility)\n    \n    plot_title_facility <- facility\n    \n  } else {\n    \n    plot_title_facility <- \"all facilities\"\n    \n  }\n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}; {plot_title_facility}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\nplot_epicurve(malaria_data, district = \"Spring\", agegroup = \"malaria_rdt_0-4\", facility = \"Facility 1\")\nall_districts <- c(\"All\", unique(malaria_data$District))\n\n# data frame of location names by district\nfacility_list <- malaria_data %>%\n  group_by(location_name, District) %>%\n  summarise() %>% \n  ungroup()\nall_districts## [1] \"All\"     \"Spring\"  \"Bolo\"    \"Dingo\"   \"Barnard\"\nfacility_list## # A tibble: 65 x 2\n##    location_name District\n##    <chr>         <chr>   \n##  1 Facility 1    Spring  \n##  2 Facility 10   Bolo    \n##  3 Facility 11   Spring  \n##  4 Facility 12   Dingo   \n##  5 Facility 13   Bolo    \n##  6 Facility 14   Dingo   \n##  7 Facility 15   Barnard \n##  8 Facility 16   Barnard \n##  9 Facility 17   Barnard \n## 10 Facility 18   Bolo    \n## # ... with 55 more rows\nui <- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = all_districts,\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # selector for facility\n         selectInput(\n           inputId = \"select_facility\",\n           label = \"Select Facility\",\n           choices = c(\"All\", facility_list$location_name),\n           selected = \"All\"\n         ),\n         \n         # horizontal line\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\nobserve({\n  \n  if (input$select_district == \"All\") {\n    new_choices <- facility_list$location_name\n  } else {\n    new_choices <- facility_list %>%\n      filter(District == input$select_district) %>%\n      pull(location_name)\n  }\n  \n  new_choices <- c(\"All\", new_choices)\n  \n  updateSelectInput(session, inputId = \"select_facility\",\n                    choices = new_choices)\n  \n})\nserver <- function(input, output, session) {\n  \n  malaria_plot <- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices <- facility_list$location_name\n    } else {\n      new_choices <- facility_list %>%\n        filter(District == input$select_district) %>%\n        pull(location_name)\n    }\n    \n    new_choices <- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve <- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve <- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  \n  \n}"},{"path":"shiny-basics.html","id":"thêm-một-bảng-vào-một-tab-khác","chapter":"43 Dashboards với Shiny","heading":"Thêm một bảng vào một tab khác","text":"Bây giờ chúng ta sẽ chuyển sang thành phần cuối cùng mà chúng ta muốn thêm vào ứng dụng của mình. Chúng ta sẽ muốn tách giao diện thành hai tab, trong đó 1 tab sẽ hiện thị một bảng tương tác nơi người dùng có thể xem dữ liệu mà họ đang tạo đường cong dịch bệnh. Để làm điều này, chúng ta có thể sử dụng các phần tử giao diện được đóng gói sẵn đi kèm với các tab shiny có liên quan. Ở cấp độ cơ bản, chúng ta có thể bao gồm hầu hết cửa sổ chính trong cấu trúc chung này:Bây giờ hãy áp dụng nó vào giao diện. Chúng ta sẽ sử dụng package DT ở đây - đây là một package tuyệt vời để tạo bảng tương tác từ dữ liệu có sẵn. Chúng ta có thể thấy nó được sử dụng cho DT::datatableOutput() trong ví dụ này.Bây giờ ứng dụng của chúng ta được sắp xếp thành các tab! Hãy thực hiện các chỉnh sửa cần thiết đối với máy chủ. Vì chúng ta không cần phải thao tác với dữ liệu trước khi kết xuất nên điều này thực sự rất đơn giản - chúng ta chỉ cần kết xuất bộ dữ liệu malaria_data qua DT::renderDT() tới ui!","code":"\n# ... the rest of ui\n\nmainPanel(\n  \n  tabsetPanel(\n    type = \"tabs\",\n    tabPanel(\n      \"Epidemic Curves\",\n      ...\n    ),\n    tabPanel(\n      \"Data\",\n      ...\n    )\n  )\n)\nui <- fluidPage(\n     \n     titlePanel(\"Malaria facility visualisation app\"),\n     \n     sidebarLayout(\n          \n          sidebarPanel(\n               # selector for district\n               selectInput(\n                    inputId = \"select_district\",\n                    label = \"Select district\",\n                    choices = all_districts,\n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # selector for age group\n               selectInput(\n                    inputId = \"select_agegroup\",\n                    label = \"Select age group\",\n                    choices = c(\n                         \"All ages\" = \"malaria_tot\",\n                         \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                         \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                         \"15+ yrs\" = \"malaria_rdt_15\"\n                    ), \n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # selector for facility\n               selectInput(\n                    inputId = \"select_facility\",\n                    label = \"Select Facility\",\n                    choices = c(\"All\", facility_list$location_name),\n                    selected = \"All\"\n               ),\n               \n               # horizontal line\n               hr(),\n               downloadButton(\n                    outputId = \"download_epicurve\",\n                    label = \"Download plot\"\n               )\n               \n          ),\n          \n          mainPanel(\n               tabsetPanel(\n                    type = \"tabs\",\n                    tabPanel(\n                         \"Epidemic Curves\",\n                         plotOutput(\"malaria_epicurve\")\n                    ),\n                    tabPanel(\n                         \"Data\",\n                         DT::dataTableOutput(\"raw_data\")\n                    )\n               ),\n               br(),\n               hr(),\n               p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n               tags$ul(\n                    tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n                    tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n                    tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n                    tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n                    tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n                    tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n                    tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n               )\n               \n               \n          )\n     )\n)\nserver <- function(input, output, session) {\n  \n  malaria_plot <- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices <- facility_list$location_name\n    } else {\n      new_choices <- facility_list %>%\n        filter(District == input$select_district) %>%\n        pull(location_name)\n    }\n    \n    new_choices <- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve <- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve <- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  # render data table to ui\n  output$raw_data <- DT::renderDT(\n    malaria_data\n  )\n  \n  \n}"},{"path":"shiny-basics.html","id":"chia-sẻ-các-ứng-dụng-shiny","chapter":"43 Dashboards với Shiny","heading":"43.7 Chia sẻ các ứng dụng shiny","text":"Sau khi bạn đã phát triển ứng dụng của riêng mình, bạn có thể muốn chia sẻ nó với những người khác - đây là lợi thế lớn nhất của shiny! Chúng ta có thể làm điều này bằng cách chia sẻ trực tiếp code hoặc chúng ta có thể xuất bản nó trên một máy chủ. Nếu chúng ta chia sẻ code, những người khác sẽ có thể thấy những gì bạn đã làm và xây dựng trên nó, nhưng điều này sẽ làm mất đi một trong những lợi thế chính của shiny - loại bỏ nhu cầu của người dùng cuối việc phải duy trì cài đặt R . Vì lý này, nếu bạn đang chia sẻ ứng dụng của mình với những người dùng không cảm thấy thoải mái với R, thì việc chia sẻ ứng dụng đã được xuất bản trên máy chủ sẽ dễ dàng hơn nhiều.Nếu muốn chia sẻ code, bạn có thể tạo tệp .zip của ứng dụng hoặc tốt hơn, xuất bản ứng dụng của bạn trên github và thêm cộng tác viên. Bạn có thể tham khảo thêm cách thực hiện trên github tại đây.Tuy nhiên, nếu chúng ta xuất bản ứng dụng trực tuyến, chúng ta cần phải làm thêm một số bước nữa. Mục đích cuối cùng là bạn muốn ứng dụng của bạn có thể được truy cập qua URL web để những người khác có thể truy cập nhanh chóng và dễ dàng. Thật không may, để xuất bản ứng dụng của bạn trên một máy chủ, bạn cần có quyền truy cập vào một máy chủ để xuất bản nó! Có một số tùy chọn lưu trữ khi nói đến điều này:shinyapps.io: đây là nơi dễ dàng nhất để xuất bản các ứng dụng shiny, vì bạn không cần thực hiện nhiều các tinh chỉnh cấu hình cần thiết và có một số giấy phép miễn phí nhưng có giới hạn.shinyapps.io: đây là nơi dễ dàng nhất để xuất bản các ứng dụng shiny, vì bạn không cần thực hiện nhiều các tinh chỉnh cấu hình cần thiết và có một số giấy phép miễn phí nhưng có giới hạn.RStudio Connect: đây là phiên bản mạnh hơn nhiều của máy chủ R, có thể thực hiện nhiều hoạt động, bao gồm cả xuất bản các ứng dụng shiny. Tuy nhiên, nó khó sử dụng hơn và ít được khuyến khích cho người dùng lần đầu.RStudio Connect: đây là phiên bản mạnh hơn nhiều của máy chủ R, có thể thực hiện nhiều hoạt động, bao gồm cả xuất bản các ứng dụng shiny. Tuy nhiên, nó khó sử dụng hơn và ít được khuyến khích cho người dùng lần đầu.Đối với mục đích của tài liệu này, chúng tôi sẽ sử dụng shinyapps.io, vì nó dễ dàng hơn cho người dùng mới. Bạn có thể tạo một tài khoản miễn phí tại đây để bắt đầu - cũng có các gói giá khác nhau cho giấy phép máy chủ nếu cần. Nếu bạn mong đợi có nhiều người sử dụng ứng dụng của bạn, gói giá sẽ đắt hơn, vì vậy hãy cân nhắc kỹ điều này. Nếu bạn đang muốn tạo thứ gì đó cho một nhóm nhỏ cá nhân sử dụng, một giấy phép miễn phí có thể hoàn toàn phù hợp, nhưng một ứng dụng công khai có thể cần nhiều giấy phép hơn.Trước hết nên đảm bảo rằng ứng dụng của chúng ta phù hợp để xuất bản trên máy chủ. Bên trong ứng dụng, bạn nên khởi động lại phiên R và đảm bảo rằng nó chạy tốt mà không cần chạy thêm bất kỳ code nào. Điều này rất quan trọng vì một ứng dụng yêu cầu tải package hoặc đọc dữ liệu không được xác định sẽ không chạy được trên máy chủ. Bạn cũng cần lưu ý rằng bạn không thể sử dụng các đường dẫn tệp đặc trưng trong ứng dụng của mình - những đường dẫn này sẽ không hợp lệ trong cài đặt máy chủ - sử dụng package sẽ giải quyết vấn đề này một cách triệt để. Cuối cùng, nếu bạn đang đọc dữ liệu từ một nguồn yêu cầu xác thực người dùng, chẳng hạn như máy chủ của tổ chức của bạn, thông thường nó sẽ không hoạt động trên máy chủ. Bạn sẽ cần phải làm việc với bộ phận (Công nghệ Thông tin) của mình để tìm ra cách đưa máy chủ shiny vào whitelist tại đây.đăng ký tài khoảnSau khi có tài khoản của mình, bạn có thể điều hướng đến trang mã đăng nhập (tokens) trong Accounts. Tại đây, bạn sẽ thêm mã đăng nhập mới - mã này sẽ được sử dụng để triển khai ứng dụng của bạn.Từ đây, bạn nên lưu ý rằng url của tài khoản sẽ hiển thị tên ứng dụng của bạn - vì vậy nếu ứng dụng của bạn có tên là my_app, url sẽ được thêm vào là xxx.io/my_app/. Hãy chọn tên ứng dụng của bạn một cách khôn ngoan! Khi bạn đã sẵn sàng, hãy nhấp vào triển khai (deploy) - nếu thành công, điều này sẽ chạy ứng dụng của bạn trên url web bạn đã chọn!something making apps documents?","code":""},{"path":"shiny-basics.html","id":"đọc-thêm","chapter":"43 Dashboards với Shiny","heading":"43.8 Đọc thêm","text":"Cho tới đây, chúng tôi đã đề cập rất nhiều khía cạnh của shiny, và hầu như không đi sâu vào những gì được cung cấp bởi shiny. Hướng dẫn này có chức năng như một phần giới thiệu, còn rất nhiều thứ nữa bạn phải học để hiểu đầy đủ về shiny. Bạn nên bắt đầu bằng cách tạo một ứng dụng cơ bản và dần dần thêm các chức năng cho nó.","code":""},{"path":"shiny-basics.html","id":"các-packages-mở-rộng-được-đề-xuất","chapter":"43 Dashboards với Shiny","heading":"43.9 Các packages mở rộng được đề xuất","text":"Những đề xuất dưới đây đại diện cho một số shiny extension chất lượng cao. Chúng tôi không sắp xếp chúng theo thứ tự đặc biệt nào cả:shinyWidgets - package này cung cấp cho bạn rất nhiều widget có thể được sử dụng trong ứng dụng của bạn. Chạy shinyWidgets::shinyWidgetsGallery() để xem một số lựa chọn các tiện ích có sẵn với package này. Xem các ví dụ ở đâyshinyWidgets - package này cung cấp cho bạn rất nhiều widget có thể được sử dụng trong ứng dụng của bạn. Chạy shinyWidgets::shinyWidgetsGallery() để xem một số lựa chọn các tiện ích có sẵn với package này. Xem các ví dụ ở đâyshinyjs - Đây là một package tuyệt vời mang đến cho người dùng khả năng mở rộng tiện ích của Shiny thông qua JavaScript. Các ứng dụng của package này từ rất đơn giản đến cực kỳ chuyên sâu, nhưng trước hết bạn sẽ muốn sử dụng nó để thao tác với giao diện người dùng theo những cách đơn giản, như ẩn/hiển thị các yếu tố hoặc bật/tắt các nút. Tìm hiểu thêm ở đâyshinyjs - Đây là một package tuyệt vời mang đến cho người dùng khả năng mở rộng tiện ích của Shiny thông qua JavaScript. Các ứng dụng của package này từ rất đơn giản đến cực kỳ chuyên sâu, nhưng trước hết bạn sẽ muốn sử dụng nó để thao tác với giao diện người dùng theo những cách đơn giản, như ẩn/hiển thị các yếu tố hoặc bật/tắt các nút. Tìm hiểu thêm ở đâyshinydashboard - package này mở rộng UI có sẵn có thể được sử dụng trong shiny, đặc biệt để người dùng tạo dashboard phức tạp với nhiều bố cục phức tạp. Xem thêm ở đâyshinydashboard - package này mở rộng UI có sẵn có thể được sử dụng trong shiny, đặc biệt để người dùng tạo dashboard phức tạp với nhiều bố cục phức tạp. Xem thêm ở đâyshinydashboardPlus - Nhận nhiều tính năng hơn nữa với shinydashboard! Xem thêm ở đâyshinydashboardPlus - Nhận nhiều tính năng hơn nữa với shinydashboard! Xem thêm ở đâyshinythemes - Thay đổi chủ đề css mặc định cho ứng dụng shiny của bạn với một loạt các mẫu có sẵn! Xem thêm ở đâyshinythemes - Thay đổi chủ đề css mặc định cho ứng dụng shiny của bạn với một loạt các mẫu có sẵn! Xem thêm ở đâyNgoài ra còn có một số packages có thể được sử dụng để tạo các đầu ra tương tác tương thích với shiny.DT được bán liên kết hóa vào bản shiny cơ sở, cung cấp một tập hợp các hàm tuyệt vời để tạo các bảng tương tác.DT được bán liên kết hóa vào bản shiny cơ sở, cung cấp một tập hợp các hàm tuyệt vời để tạo các bảng tương tác.plotly là một package để tạo các đồ thị tương tác mà người dùng có thể thao tác trong ứng dụng. Bạn cũng có thể chuyển đổi đồ thị của mình sang các phiên bản tương tác thông qua plotly::ggplotly()! Các lựa chọn thay thế như dygraphs và highcharter cũng rất tuyệt vời.plotly là một package để tạo các đồ thị tương tác mà người dùng có thể thao tác trong ứng dụng. Bạn cũng có thể chuyển đổi đồ thị của mình sang các phiên bản tương tác thông qua plotly::ggplotly()! Các lựa chọn thay thế như dygraphs và highcharter cũng rất tuyệt vời.","code":""},{"path":"shiny-basics.html","id":"tài-nguyên-đề-xuất","chapter":"43 Dashboards với Shiny","heading":"43.10 Tài nguyên đề xuất","text":"","code":""},{"path":"writing-functions.html","id":"writing-functions","chapter":"44 Viết hàm","heading":"44 Viết hàm","text":"","code":""},{"path":"writing-functions.html","id":"chuẩn-bị-36","chapter":"44 Viết hàm","heading":"44.1 Chuẩn bị","text":"","code":""},{"path":"writing-functions.html","id":"gọi-packages-18","chapter":"44 Viết hàm","heading":"Gọi packages","text":"Đoạn code này hiển thị việc tải các gói lệnh cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() trong package pacman, giúp cài đặt package nếu cần thiết và gọi chúng ra để sử dụng. Các package đã cài đặt cũng có thể được gọi ra bằng hàm library() từ base R. Xem chương R cơ bản để biết thêm thong tin về các packages trong R.","code":""},{"path":"writing-functions.html","id":"nhập-dữ-liệu-26","chapter":"44 Viết hàm","heading":"Nhập dữ liệu","text":"Chúng tôi nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Nếu muốn tải số liệu để làm theo từng bước, xem hướng dẫn trong chương Tải sách và dữ liệu. Bộ số liệu được nhập vào bằng hàm import() từ package rio. Xem chương [Nhập xuất số liệu] để biết các cách nhập dữ liệu khác.Chúng tôi cũng sẽ sử dụng một vài số liệu về bệnh cúm H7N9 xảy ra năm 2013 ở phần cuối của chương này.","code":""},{"path":"writing-functions.html","id":"hàm-1","chapter":"44 Viết hàm","heading":"44.2 Hàm","text":"Các hàm rất hữu ích trong lập trình vì chúng cho phép tạo ra các code dễ hiểu hơn, ngắn hơn và ít bị lỗi hơn (vì không có lỗi trong chính hàm này).Nếu bạn đã xem đến chương này, có nghĩa là bạn đã đi qua vô số các hàm bởi vì trong R, mỗi toán tử là một lần gọi hàm\n+, , , [, $, { …. Ví dụ, x + y là tương đương với'+'(x, y)R là một ngôn ngữ cung cấp nhiều khả năng nhất để thực hiện các hàm và cung cấp đầy đủ các công cụ để người dùng dễ dàng viết chúng. Chúng ta không nên nghĩ các hàm là cố định ở đầu hay ở cuối chuỗi lập trình, R cung cấp các khả năng sử dụng chúng như thể chúng là các véc tơ và thậm chí sử dụng chúng bên trong các hàm, danh sách…Có rất nhiều nguồn nâng cao về lập trình hướng chức năng và chúng tôi sẽ chỉ cung cấp cho bạn một cái nhìn bao quát để giúp bạn bắt đầu với lập trình hướng chức năng với các ví dụ thực tế, ngắn gọn. Sau đó, bạn có thể truy cập thêm các tài liệu tham khảo ở phía dưới.","code":""},{"path":"writing-functions.html","id":"tại-sao-chúng-ta-sử-dụng-hàm","chapter":"44 Viết hàm","heading":"44.3 Tại sao chúng ta sử dụng hàm?","text":"Trước khi trả lời câu hỏi này, điều quan trọng cần lưu ý là chúng ta đã biết các mẹo để viết các hàm đầu tiên trong R trong chương [Lặp, vòng lặp và danh sách] trong cuốn sổ tay này. Nói tóm lại, việc sử dụng “/else” và vòng lặp thường là một phần cốt lõi trong nhiều hàm vì chúng dễ dàng giúp mở rộng tính ứng dụng code của chúng ta, cho phép nhiều điều kiện hoặc lặp lại code cho các tác vụ lặp lại.Tôi có đang lặp lại nhiều lần cùng một đoạn code để áp dụng nó cho một biến hoặc số liệu khác không?Tôi có đang lặp lại nhiều lần cùng một đoạn code để áp dụng nó cho một biến hoặc số liệu khác không?Loại bỏ nó có rút ngắn đáng kể số dòng code tổng thể và giúp việc thực hiện nhanh hơn không?Loại bỏ nó có rút ngắn đáng kể số dòng code tổng thể và giúp việc thực hiện nhanh hơn không?Đoạn code có thể sử dụng lại với giá trị khác ở nhiều vị trí trong code không?Đoạn code có thể sử dụng lại với giá trị khác ở nhiều vị trí trong code không?Nếu một trong những trả lời cho các câu hỏi bên trên là “CÓ”, bạn có thể sẽ cần phải viết hàm","code":""},{"path":"writing-functions.html","id":"cách-viết-hàm-trong-r","chapter":"44 Viết hàm","heading":"44.4 Cách viết hàm trong R","text":"Các hàm trong R có ba thành phần chính:phần hình thức formals() là danh sách các đối số mà kiểm soát cách chúng ta có thể gọi hàmphần hình thức formals() là danh sách các đối số mà kiểm soát cách chúng ta có thể gọi hàmphần thân body() là đoạn code bên trong hàm, vd: bên trong hoặc theo sau các dấu ngoặc, tùy thuộc vào cách chúng ta viết nóphần thân body() là đoạn code bên trong hàm, vd: bên trong hoặc theo sau các dấu ngoặc, tùy thuộc vào cách chúng ta viết nóvà,phần môi trường thực hiện environment() để giúp chúng ta xác định vị trí các biến trong hàm và xác định cách các hàm tìm giá trị.Một khi đã tạo hàm, chúng ta cần kiểm tra mỗi thành phần này bằng cách gọi các hàm liên kết.","code":""},{"path":"writing-functions.html","id":"cấu-trúc-và-cú-pháp-cơ-bản","chapter":"44 Viết hàm","heading":"44.5 Cấu trúc và cú pháp cơ bản","text":"Một hàm cần được đặt tên cẩn thận theo đúng công việc của nó để có thể hiểu được khi chúng ta đọc tên hàm. Thực tế, điều này đã được sử dụng trong phần lớn các kiến trúc của base R. Các hàm như mean(), print(), summary() có những cái tên đúng như nhiệm vụ của nóMột hàm cần được đặt tên cẩn thận theo đúng công việc của nó để có thể hiểu được khi chúng ta đọc tên hàm. Thực tế, điều này đã được sử dụng trong phần lớn các kiến trúc của base R. Các hàm như mean(), print(), summary() có những cái tên đúng như nhiệm vụ của nóMột hàm cần các đối số như là số liệu để thực hiện và các đối tượng khác mà có thể là các giá trị tĩnh trong một danh sách các tùy chọn khácMột hàm cần các đối số như là số liệu để thực hiện và các đối tượng khác mà có thể là các giá trị tĩnh trong một danh sách các tùy chọn khácVà cuối cùng, một hàm sẽ cho kết quả đầu ra dựa trên nhiệm vụ cốt lõi của nó và các đối số đã được đưa ra. Thông thường, chúng ta sẽ sử dụng các hàm có sẵn như print(), return()… để tạo ra kết quả đầu ra. Kết quả đầu ra có thể là giá trị logic, một số, một ký tự, một data frame…mà gọi ngắn gọn là đối tượng của R.Và cuối cùng, một hàm sẽ cho kết quả đầu ra dựa trên nhiệm vụ cốt lõi của nó và các đối số đã được đưa ra. Thông thường, chúng ta sẽ sử dụng các hàm có sẵn như print(), return()… để tạo ra kết quả đầu ra. Kết quả đầu ra có thể là giá trị logic, một số, một ký tự, một data frame…mà gọi ngắn gọn là đối tượng của R.Về cơ bản, đây là thành phần của một hàm:Chúng ta tạo hàm đầu tiên với tên gọi là contain_covid19().Sau đó, chúng ta kiểm tra các thành phần của hàm vừa mới được tạo ra.Bây giờ, chúng ta sẽ kiểm tra hàm này. Để gọi hàm đã biết, chúng ta sử dụng nó như sử dụng tất cả các hàm trong R, tức là bằng cách viết tên hàm và thêm các đối số cần phải có.Chúng ta có thể viết lại tên của mỗi đối số cho cẩn thận. Nhưng kể cả khi không cụ thể chúng, code cũng sẽ thực hiện vì R đã nhớ vị trí của mỗi đối số. Vì thế, miễn là chúng ta đặt các giá trị của các đối số theo đúng thứ tự, chúng ta có thể bỏ qua việc viết tên các đối số khi gọi hàm.Sau đó, hãy xem điều gì sẽ xảy ra nếu một trong các giá trị là \"\" hoặc \"yes\".Nếu chúng ta cung cấp các đối số không nhận diện được, chúng ta sẽ gặp lỗi:Error contain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\",  :  find function \"contain_covid19\"LƯU Ý: Một số hàm (hầu hết là rất ngắn và không phức tạp) có thể không cần tên và có thể sử dụng trực tiếp trên một dòng code hoặc bên trong một hàm khác để thực hiện tác vụ nhanh chóng. Các hàm này được gọi là hàm ẩn danh .Ví dụ bên dưới là một hàm ẩn danh đầu tiên mà chỉ giữ các biến ký tự trong bộ số liệu.Sau đó, một hàm khác chọn mỗi quan sát thứ hai của bộ số liệu (có thể thích hợp khi chúng ta có số liệu dọc với nhiều bản ghi cho một bệnh nhân, ví dụ như ngày đặt lịch khám hoặc lần khám). Trong trường hợp này, việc viết hàm thích hợp bên ngoài gói lệnh dplyr sẽ là function (x) (x%%2 == 0) để áp dụng đối với véc tơ chứa tất cả các số hàng.Một code trong base R có thể thực hiện tác vụ tương đương:THẬN TRỌNG: Mặc dù đúng là việc sử dụng hàm có thể giúp chúng ta viết code, tuy nhiên, việc viết một số hàm hay sửa hàm có thể tốn thời gian nếu chưa được suy nghĩ thấu đáo, viết đầy đủ và kết quả là báo lỗi. Vì lý này, đầu tiên chúng ta nên viết code trước, chạy thử và đảm bảo nó thực hiện những gì chúng ta mong muốn và sau đó chuyển nó vào trong một hàm với ba thành phần chính như đã liệt kê bên trên. ","code":"\nfunction_name <- function(argument_1, argument_2, argument_3){\n  \n           function_task\n  \n           return(output)\n}\ncontain_covid19 <- function(barrier_gest, wear_mask, get_vaccine){\n  \n                            if(barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \"yes\" ) \n       \n                            return(\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\nformals(contain_covid19)## $barrier_gest\n## \n## \n## $wear_mask\n## \n## \n## $get_vaccine\nbody(contain_covid19)## {\n##     if (barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \n##         \"yes\") \n##         return(\"success\")\n##     else (\"please make sure all are yes, this pandemic has to end!\")\n## }\nenvironment(contain_covid19)## <environment: R_GlobalEnv>\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"yes\")## [1] \"success\"\ncontain_covid19(\"yes\", \"yes\", \"yes\")## [1] \"success\"\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"no\")## [1] \"please make sure all are yes, this pandemic has to end!\"\ncontain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\", get_vaccine = \"no\")\nlinelist %>% \n  dplyr::slice_head(n=10) %>%  #equivalent to R base \"head\" function and that return first n observation of the  dataset\n  select(function(x) is.character(x)) \nlinelist %>%   \n   slice_head(n=20) %>% \n   tibble::rownames_to_column() %>% # add indices of each obs as rownames to clearly see the final selection\n   filter(row_number() %%2 == 0)\nlinelist_firstobs <- head(linelist, 20)\n\nlinelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]"},{"path":"writing-functions.html","id":"các-ví-dụ-2","chapter":"44 Viết hàm","heading":"44.6 Các ví dụ","text":"","code":""},{"path":"writing-functions.html","id":"trả-về-các-bảng-tỷ-lệ-cho-một-số-cột","chapter":"44 Viết hàm","heading":"Trả về các bảng tỷ lệ cho một số cột","text":"Đúng vậy, chúng ta đã có các hàm trong nhiều package mà cho phép tóm tắt thông tin một cách dễ dàng và đẹp mắt. Nhưng chúng ta vẫn cố gắng thử tạo ra hàm riêng trong những bước đầu tiên để làm quen với việc viết hàm.Trong ví dụ này, chúng tôi muốn chỉ ra cách viết một hàm đơn giản để tránh việc sao chép và dán cùng một code nhiều lần.MẸO: Như đã trình bày bên trên, việc chú thích cho các hàm là rất quan trọng, là một thói quen lập trình nói chung. BHãy nhớ rằng mục đích của một hàm là làm cho code sẵn sàng để đọc, ngắn hơn và hiệu quả hơn. Sau đó, người đọc có thể hiểu được hàm này sẽ làm gì chỉ bằng cách đọc tên nó và có thêm thông tin chi tiết khi đọc các chú thích.Cách thứ hai là sử dụng hàm này trong một hàm khác thông qua vòng lặp để thực hiện quá trình một cách đồng thời:Một cách đơn giản hơn có thể là sử dụng “apply” trong base R thay vì dùng “loop” như được trình bày bên dưới:MẸO: R thường được định nghĩa như một ngôn ngữ lập trình hướng chức năng và hầu như bất cứ lúc nào chúng ta thực hiện một dòng code, chúng ta đang sử dụng một số hàm có sẵn. Một thói quen tốt để cảm thấy thoải mái hơn với việc viết hàm là thường xuyên nhìn bên trong cách các hàm cơ bản được viết mà chúng ta sử dụng hàng ngày. Phím tắt để làm như vậy là chọn tên hàm và sau đó bấm Ctrl+F2 hoặc fn+F2 hoặc Cmd+F2 (tùy thuộc vào máy tính của bạn) .","code":"\nproptab_multiple <- function(my_data, var_to_tab){\n  \n  #print the name of each variable of interest before doing the tabulation\n  print(var_to_tab)\n\n  with(my_data,\n       rbind( #bind the results of the two following function by row\n        #tabulate the variable of interest: gives only numbers\n          table(my_data[[var_to_tab]], useNA = \"no\"),\n          #calculate the proportions for each variable of interest and round the value to 2 decimals\n         round(prop.table(table(my_data[[var_to_tab]]))*100,2)\n         )\n       )\n}\n\n\nproptab_multiple(linelist, \"gender\")## [1] \"gender\"##            f       m\n## [1,] 2807.00 2803.00\n## [2,]   50.04   49.96\nproptab_multiple(linelist, \"age_cat\")## [1] \"age_cat\"##          0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n## [1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n## [2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\nproptab_multiple(linelist, \"outcome\")## [1] \"outcome\"##        Death Recover\n## [1,] 2582.00 1983.00\n## [2,]   56.56   43.44\nfor(var_to_tab in c(\"gender\",\"age_cat\",  \"outcome\")){\n  \n  print(proptab_multiple(linelist, var_to_tab))\n  \n}## [1] \"gender\"\n##            f       m\n## [1,] 2807.00 2803.00\n## [2,]   50.04   49.96\n## [1] \"age_cat\"\n##          0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n## [1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n## [2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n## [1] \"outcome\"\n##        Death Recover\n## [1,] 2582.00 1983.00\n## [2,]   56.56   43.44"},{"path":"writing-functions.html","id":"sử-dụng-purrr-viết-các-hàm-với-vòng-lặp","chapter":"44 Viết hàm","heading":"44.7 Sử dụng purrr: viết các hàm với vòng lặp","text":"","code":""},{"path":"writing-functions.html","id":"sửa-đổi-kiểu-biến-trên-nhiều-cột-trong-một-bộ-số-liệu","chapter":"44 Viết hàm","heading":"Sửa đổi kiểu biến trên nhiều cột trong một bộ số liệu","text":"Giả sử nhiều biến kiểu ký tự trong bộ số liệu gốc linelist cần được thay đổi thành “factor” nhằm mục đích phân tích và vẽ biểu đồ. Thay vì lặp lại bước nhiều lần, chúng ta có thể sử dụng hàm lapply() để chuyển đổi tất cả các biến có liên quan trong một dòng code.THẬN TRỌNG: hàm lapply() trả về một danh sách, vì thế, sử dụng danh sách này có thể đòi hỏi một sửa đổi bổ sung như là một bước cuối cùng.Bước tương tự có thể được thực hiện bằng cách sử dụng hàm map_if() từ package purrr","code":"\nlinelist_factor2 <- linelist %>%\n  purrr::map_if(is.character, as.factor)\n\n\nlinelist_factor2 %>%\n        glimpse()## List of 30\n##  $ case_id             : Factor w/ 5888 levels \"00031d\",\"00086d\",..: 2134 3022 396 4203 3084 4347 179 1241 5594 430 ...\n##  $ generation          : num [1:5888] 4 4 2 3 3 3 4 4 4 4 ...\n##  $ date_infection      : Date[1:5888], format: \"2014-05-08\" NA NA \"2014-05-04\" ...\n##  $ date_onset          : Date[1:5888], format: \"2014-05-13\" \"2014-05-13\" \"2014-05-16\" \"2014-05-18\" ...\n##  $ date_hospitalisation: Date[1:5888], format: \"2014-05-15\" \"2014-05-14\" \"2014-05-18\" \"2014-05-20\" ...\n##  $ date_outcome        : Date[1:5888], format: NA \"2014-05-18\" \"2014-05-30\" NA ...\n##  $ outcome             : Factor w/ 2 levels \"Death\",\"Recover\": NA 2 2 NA 2 2 2 1 2 1 ...\n##  $ gender              : Factor w/ 2 levels \"f\",\"m\": 2 1 2 1 2 1 1 1 2 1 ...\n##  $ age                 : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n##  $ age_unit            : Factor w/ 2 levels \"months\",\"years\": 2 2 2 2 2 2 2 2 2 2 ...\n##  $ age_years           : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n##  $ age_cat             : Factor w/ 8 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 7 4 1 4 4 1 7 5 ...\n##  $ age_cat5            : Factor w/ 18 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 12 4 1 4 4 1 13 6 ...\n##  $ hospital            : Factor w/ 6 levels \"Central Hospital\",..: 4 3 6 5 2 5 3 3 3 3 ...\n##  $ lon                 : num [1:5888] -13.2 -13.2 -13.2 -13.2 -13.2 ...\n##  $ lat                 : num [1:5888] 8.47 8.45 8.46 8.48 8.46 ...\n##  $ infector            : Factor w/ 2697 levels \"00031d\",\"002e6c\",..: 2594 NA NA 2635 180 1799 1407 195 NA NA ...\n##  $ source              : Factor w/ 2 levels \"funeral\",\"other\": 2 NA NA 2 2 2 2 2 NA NA ...\n##  $ wt_kg               : num [1:5888] 27 25 91 41 36 56 47 0 86 69 ...\n##  $ ht_cm               : num [1:5888] 48 59 238 135 71 116 87 11 226 174 ...\n##  $ ct_blood            : num [1:5888] 22 22 21 23 23 21 21 22 22 22 ...\n##  $ fever               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ chills              : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ cough               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 2 ...\n##  $ aches               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n##  $ vomit               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 1 ...\n##  $ temp                : num [1:5888] 36.8 36.9 36.9 36.8 36.9 37.6 37.3 37 36.4 35.9 ...\n##  $ time_admission      : Factor w/ 1072 levels \"00:10\",\"00:29\",..: NA 308 746 415 514 589 609 297 409 387 ...\n##  $ bmi                 : num [1:5888] 117.2 71.8 16.1 22.5 71.4 ...\n##  $ days_onset_hosp     : num [1:5888] 2 1 2 2 1 1 2 1 1 2 ..."},{"path":"writing-functions.html","id":"vòng-lặp-tạo-biểu-đồ-cho-nhiều-giá-trị-khác-nhau-của-biến","chapter":"44 Viết hàm","heading":"Vòng lặp tạo biểu đồ cho nhiều giá trị khác nhau của biến","text":"Ở đây, chúng ta sẽ tạo biểu đồ tròn để xem phân bố outcome của bệnh nhân trong đợt dịch H7N9 cho từng tỉnh tại Trung Quốc. Thay vì lặp lại code cho từng tỉnh, chúng ta chỉ áp dụng một hàm mà chúng ta sẽ tạo ra.","code":"\n#precising options for the use of highchart\noptions(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))\n\n\n#create a function called \"chart_outcome_province\" that takes as argument the dataset and the name of the province for which to plot the distribution of the outcome.\n\nchart_outcome_province <- function(data_used, prov){\n  \n  tab_prov <- data_used %>% \n    filter(province == prov,\n           !is.na(outcome))%>% \n    group_by(outcome) %>% \n    count() %>%\n    adorn_totals(where = \"row\") %>% \n    adorn_percentages(denominator = \"col\", )%>%\n    mutate(\n        perc_outcome= round(n*100,2))\n  \n  \n  tab_prov %>%\n    filter(outcome != \"Total\") %>% \n  highcharter::hchart(\n    \"pie\", hcaes(x = outcome, y = perc_outcome),\n    name = paste0(\"Distibution of the outcome in:\", prov)\n    )\n  \n}\n\nchart_outcome_province(flu_china, \"Shanghai\")\nchart_outcome_province(flu_china,\"Zhejiang\")\nchart_outcome_province(flu_china,\"Jiangsu\")"},{"path":"writing-functions.html","id":"vòng-lặp-tạo-bảng-cho-nhiều-giá-trị-khác-nhau-của-biến","chapter":"44 Viết hàm","heading":"Vòng lặp tạo bảng cho nhiều giá trị khác nhau của biến","text":"Ở đây, chúng ta sẽ tạo ba chỉ số để tóm tắt một bảng và chúng ta muốn tạo bảng này theo từng tỉnh. Các chỉ số của chúng ta là khoảng thời gian từ lúc khởi phát bệnh đến lúc nhập viện, tỷ lệ hồi phục và tuổi trung vị của các ca bệnh.Indicateurs pour la province de: ShanghaiIndicateursEstimationMean delay onset-hosp4.00Percentage recovery46.67Median age cases67.00Indicateurs pour la province de: JiangsuIndicateursEstimationMean delay onset-hosp6.00Percentage recovery71.43Median age cases55.00","code":"\nindic_1 <- flu_china %>% \n  group_by(province) %>% \n  mutate(\n    date_hosp= strptime(date_of_hospitalisation, format = \"%m/%d/%Y\"),\n    date_ons= strptime(date_of_onset, format = \"%m/%d/%Y\"), \n    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,\n    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %>%\n  select(province, mean_delay_onset_hosp)  %>% \n  distinct()\n     \n\nindic_2 <-  flu_china %>% \n            filter(!is.na(outcome)) %>% \n            group_by(province, outcome) %>% \n            count() %>%\n            pivot_wider(names_from = outcome, values_from = n) %>% \n    adorn_totals(where = \"col\") %>% \n    mutate(\n        perc_recovery= round((Recover/Total)*100,2))%>% \n  select(province, perc_recovery)\n    \n    \n    \nindic_3 <-  flu_china %>% \n            group_by(province) %>% \n            mutate(\n                    median_age_cases = median(as.numeric(age), na.rm = TRUE)\n            ) %>% \n  select(province, median_age_cases)  %>% \n  distinct()## Warning in median(as.numeric(age), na.rm = TRUE): NAs introduced by coercion\n#join the three indicator datasets\n\ntable_indic_all <- indic_1 %>% \n  dplyr::left_join(indic_2, by = \"province\") %>% \n        left_join(indic_3, by = \"province\")\n\n\n#print the indicators in a flextable\n\n\nprint_indic_prov <-  function(table_used, prov){\n  \n  #first transform a bit the dataframe for printing ease\n  indic_prov <- table_used %>%\n    filter(province==prov) %>%\n    pivot_longer(names_to = \"Indicateurs\", cols = 2:4) %>% \n   mutate( indic_label = factor(Indicateurs,\n   levels= c(\"mean_delay_onset_hosp\",\"perc_recovery\",\"median_age_cases\"),\n   labels=c(\"Mean delay onset-hosp\",\"Percentage of recovery\", \"Median age of the cases\"))\n   ) %>% \n    ungroup(province) %>% \n    select(indic_label, value)\n  \n\n    tab_print <- flextable(indic_prov)  %>%\n    theme_vanilla() %>% \n    flextable::fontsize(part = \"body\", size = 10) \n    \n    \n     tab_print <- tab_print %>% \n                  autofit()   %>%\n                  set_header_labels( \n                indic_label= \"Indicateurs\", value= \"Estimation\") %>%\n    flextable::bg( bg = \"darkblue\", part = \"header\") %>%\n    flextable::bold(part = \"header\") %>%\n    flextable::color(color = \"white\", part = \"header\") %>% \n    add_header_lines(values = paste0(\"Indicateurs pour la province de: \", prov)) %>% \nbold(part = \"header\")\n \n tab_print <- set_formatter_type(tab_print,\n   fmt_double = \"%.2f\",\n   na_str = \"-\")\n\ntab_print \n    \n}\n\n\n\n\nprint_indic_prov(table_indic_all, \"Shanghai\")\nprint_indic_prov(table_indic_all, \"Jiangsu\")"},{"path":"writing-functions.html","id":"mẹo-và-thực-hành-tốt-để-các-hàm-hoạt-động-tốt","chapter":"44 Viết hàm","heading":"44.8 Mẹo và thực hành tốt để các hàm hoạt động tốt","text":"Lập trình hàm có nghĩa là để dễ dàng viết và đọc code. Tuy nhiên, điều ngược lại có thể xảy ra. Những mẹo dưới đây sẽ giúp bạn có một đoạn code gọn gàng và dễ đọc.","code":""},{"path":"writing-functions.html","id":"đặt-tên-và-cú-pháp","chapter":"44 Viết hàm","heading":"Đặt tên và cú pháp","text":"Tránh sử dụng ký tự có thể đã được sử dụng bởi các hàm khác trong hàm của chúng taTránh sử dụng ký tự có thể đã được sử dụng bởi các hàm khác trong hàm của chúng taNên đặt tên hàm ngắn gọn và dễ hiểu cho người đọcNên đặt tên hàm ngắn gọn và dễ hiểu cho người đọcƯu tiên sử dụng động từ làm tên hàm và danh từ làm tên các đối số.Ưu tiên sử dụng động từ làm tên hàm và danh từ làm tên các đối số.","code":""},{"path":"writing-functions.html","id":"tên-cột-và-lượng-giá-tính-gọn-gàng","chapter":"44 Viết hàm","heading":"Tên cột và lượng giá tính gọn gàng","text":"Nếu bạn muốn biết cách tham chiếu tên cột để đưa vào code của bạn như một đối số, hãy đọc hướng dẫn lập trình của tidyverse này. Trong số các chủ đề, nên đọc về tidy evaluation và sử dụng embrace {{ }} “hai dấu ngoặc nhọn”Ví dụ: đây là đoạn code mẫu từ trang hướng dẫn được đề cập bên trên:","code":"\nvar_summary <- function(data, var) {\n  data %>%\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\nmtcars %>% \n  group_by(cyl) %>% \n  var_summary(mpg)"},{"path":"writing-functions.html","id":"kiểm-tra-và-xử-lý-lỗi","chapter":"44 Viết hàm","heading":"Kiểm tra và xử lý lỗi","text":"Công việc của hàm càng phức tạp thì khả năng xảy ra lỗi càng cao. Vì thế, đôi khi cần phải thêm một vài kiểm tra bên trong hàm để giúp nhanh chóng biết được lỗi ở đâu và tìm cách sửa nó.Rất nên đưa một hàm kiểm tra tính thiếu sót của một đối số bằng cách sử dụng missing(argument). Việc kiểm tra đơn giản này trả về giá trị “TRUE” hoặc “FALSE”.Sử dụng hàm stop() để dễ phát hiện lỗi hơn.Như đã thấy khi chúng ta thực hiện hầu hết các hàm có sẵn, có các thông báo và cảnh báo có thể xuất hiện trong một số điều kiện nhất định. Chúng ta có thể tích hợp chúng trong các hàm đã viết bằng cách sử dụng hàm message() và warning().Như đã thấy khi chúng ta thực hiện hầu hết các hàm có sẵn, có các thông báo và cảnh báo có thể xuất hiện trong một số điều kiện nhất định. Chúng ta có thể tích hợp chúng trong các hàm đã viết bằng cách sử dụng hàm message() và warning().Chúng ta cũng có thể xử lý lỗi bằng cách sử dụng hàm safely() để lấy một hàm làm đối số và thực hiện nó một cách toàn. Trên thực tế, hàm sẽ thực hiện mà không dừng lại nếu nó gặp lỗi. Hàm safely() trả về kết quả đầu ra dưới dạng một list với hai đối tượng là kết quả và lỗi mà nó đã “bỏ qua”.Chúng ta cũng có thể xử lý lỗi bằng cách sử dụng hàm safely() để lấy một hàm làm đối số và thực hiện nó một cách toàn. Trên thực tế, hàm sẽ thực hiện mà không dừng lại nếu nó gặp lỗi. Hàm safely() trả về kết quả đầu ra dưới dạng một list với hai đối tượng là kết quả và lỗi mà nó đã “bỏ qua”.Chúng ta có thể kiểm tra bằng cách thực hiện hàm mean() trước, sau đó thực hiện nó với hàm safely().Như đã nói trước đây, chú thích rõ ràng trong các đoạn mã là một cách tốt để có tư liệu cho các công việc đã thực hiện.","code":"\ncontain_covid19_missing <- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if (missing(barrier_gest)) (print(\"please provide arg1\"))\n  if (missing(wear_mask)) print(\"please provide arg2\")\n  if (missing(get_vaccine)) print(\"please provide arg3\")\n\n\n  if (!barrier_gest == \"yes\" | wear_mask ==\"yes\" | get_vaccine == \"yes\" ) \n       \n       return (\"you can do better\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_missing(get_vaccine = \"yes\")## [1] \"please provide arg1\"\n## [1] \"please provide arg2\"## Error in contain_covid19_missing(get_vaccine = \"yes\"): argument \"barrier_gest\" is missing, with no default\ncontain_covid19_stop <- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if(!is.character(barrier_gest)) (stop(\"arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\"))\n  \n  if (barrier_gest == \"yes\" & wear_mask ==\"yes\" & get_vaccine == \"yes\" ) \n       \n       return (\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_stop(barrier_gest=1, wear_mask=\"yes\", get_vaccine = \"no\")## Error in contain_covid19_stop(barrier_gest = 1, wear_mask = \"yes\", get_vaccine = \"no\"): arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\nmap(linelist, mean)## $case_id\n## [1] NA\n## \n## $generation\n## [1] 16.56165\n## \n## $date_infection\n## [1] NA\n## \n## $date_onset\n## [1] NA\n## \n## $date_hospitalisation\n## [1] \"2014-11-03\"\n## \n## $date_outcome\n## [1] NA\n## \n## $outcome\n## [1] NA\n## \n## $gender\n## [1] NA\n## \n## $age\n## [1] NA\n## \n## $age_unit\n## [1] NA\n## \n## $age_years\n## [1] NA\n## \n## $age_cat\n## [1] NA\n## \n## $age_cat5\n## [1] NA\n## \n## $hospital\n## [1] NA\n## \n## $lon\n## [1] -13.23381\n## \n## $lat\n## [1] 8.469638\n## \n## $infector\n## [1] NA\n## \n## $source\n## [1] NA\n## \n## $wt_kg\n## [1] 52.64487\n## \n## $ht_cm\n## [1] 124.9633\n## \n## $ct_blood\n## [1] 21.20686\n## \n## $fever\n## [1] NA\n## \n## $chills\n## [1] NA\n## \n## $cough\n## [1] NA\n## \n## $aches\n## [1] NA\n## \n## $vomit\n## [1] NA\n## \n## $temp\n## [1] NA\n## \n## $time_admission\n## [1] NA\n## \n## $bmi\n## [1] 46.89023\n## \n## $days_onset_hosp\n## [1] NA\nsafe_mean <- safely(mean)\nlinelist %>% \n  map(safe_mean)## $case_id\n## $case_id$result\n## [1] NA\n## \n## $case_id$error\n## NULL\n## \n## \n## $generation\n## $generation$result\n## [1] 16.56165\n## \n## $generation$error\n## NULL\n## \n## \n## $date_infection\n## $date_infection$result\n## [1] NA\n## \n## $date_infection$error\n## NULL\n## \n## \n## $date_onset\n## $date_onset$result\n## [1] NA\n## \n## $date_onset$error\n## NULL\n## \n## \n## $date_hospitalisation\n## $date_hospitalisation$result\n## [1] \"2014-11-03\"\n## \n## $date_hospitalisation$error\n## NULL\n## \n## \n## $date_outcome\n## $date_outcome$result\n## [1] NA\n## \n## $date_outcome$error\n## NULL\n## \n## \n## $outcome\n## $outcome$result\n## [1] NA\n## \n## $outcome$error\n## NULL\n## \n## \n## $gender\n## $gender$result\n## [1] NA\n## \n## $gender$error\n## NULL\n## \n## \n## $age\n## $age$result\n## [1] NA\n## \n## $age$error\n## NULL\n## \n## \n## $age_unit\n## $age_unit$result\n## [1] NA\n## \n## $age_unit$error\n## NULL\n## \n## \n## $age_years\n## $age_years$result\n## [1] NA\n## \n## $age_years$error\n## NULL\n## \n## \n## $age_cat\n## $age_cat$result\n## [1] NA\n## \n## $age_cat$error\n## NULL\n## \n## \n## $age_cat5\n## $age_cat5$result\n## [1] NA\n## \n## $age_cat5$error\n## NULL\n## \n## \n## $hospital\n## $hospital$result\n## [1] NA\n## \n## $hospital$error\n## NULL\n## \n## \n## $lon\n## $lon$result\n## [1] -13.23381\n## \n## $lon$error\n## NULL\n## \n## \n## $lat\n## $lat$result\n## [1] 8.469638\n## \n## $lat$error\n## NULL\n## \n## \n## $infector\n## $infector$result\n## [1] NA\n## \n## $infector$error\n## NULL\n## \n## \n## $source\n## $source$result\n## [1] NA\n## \n## $source$error\n## NULL\n## \n## \n## $wt_kg\n## $wt_kg$result\n## [1] 52.64487\n## \n## $wt_kg$error\n## NULL\n## \n## \n## $ht_cm\n## $ht_cm$result\n## [1] 124.9633\n## \n## $ht_cm$error\n## NULL\n## \n## \n## $ct_blood\n## $ct_blood$result\n## [1] 21.20686\n## \n## $ct_blood$error\n## NULL\n## \n## \n## $fever\n## $fever$result\n## [1] NA\n## \n## $fever$error\n## NULL\n## \n## \n## $chills\n## $chills$result\n## [1] NA\n## \n## $chills$error\n## NULL\n## \n## \n## $cough\n## $cough$result\n## [1] NA\n## \n## $cough$error\n## NULL\n## \n## \n## $aches\n## $aches$result\n## [1] NA\n## \n## $aches$error\n## NULL\n## \n## \n## $vomit\n## $vomit$result\n## [1] NA\n## \n## $vomit$error\n## NULL\n## \n## \n## $temp\n## $temp$result\n## [1] NA\n## \n## $temp$error\n## NULL\n## \n## \n## $time_admission\n## $time_admission$result\n## [1] NA\n## \n## $time_admission$error\n## NULL\n## \n## \n## $bmi\n## $bmi$result\n## [1] 46.89023\n## \n## $bmi$error\n## NULL\n## \n## \n## $days_onset_hosp\n## $days_onset_hosp$result\n## [1] NA\n## \n## $days_onset_hosp$error\n## NULL"},{"path":"writing-functions.html","id":"nguồn-12","chapter":"44 Viết hàm","heading":"44.9 Nguồn","text":"R Data Science linkCheatsheet advance R programmingCheatsheet purr PackageVideo-ACM talk Hadley Wickham: joy functional programming (map_dbl work)","code":""},{"path":"directories.html","id":"directories","chapter":"45 Tương tác với thư mục làm việc","heading":"45 Tương tác với thư mục làm việc","text":"Trong chương này, chúng tôi sẽ bao gồm các tình huống phổ biến, nơi chúng ta sẽ tạo, tương tác, lưu và nhập với thư mục.","code":""},{"path":"directories.html","id":"chuẩn-bị-37","chapter":"45 Tương tác với thư mục làm việc","heading":"45.1 Chuẩn bị","text":"","code":""},{"path":"directories.html","id":"fs-package","chapter":"45 Tương tác với thư mục làm việc","heading":"fs package","text":"Package fs thuộc hệ sinh thái tidyverse giúp thuận tiện cho việc tương tác với thư mục, cải thiện một số hàm trong base R. Trong các phần bên dưới, chúng ta sẽ dùng các hàm từ fs.","code":"\npacman::p_load(\n  fs,             # file/directory interactions\n  rio,            # import/export\n  here,           # relative file pathways\n  tidyverse)      # data management and visualization"},{"path":"directories.html","id":"in-thư-mục-dưới-dạng-cây-biểu-đồ-dendrogram","chapter":"45 Tương tác với thư mục làm việc","heading":"In thư mục dưới dạng cây biểu đồ dendrogram","text":"Sử dụng hàm dir_tree() từ package fs.Cung cấp đường dẫn thư mục cho đối số path = và quyết định xem có hay không chúng ta muốn hiển thị chỉ ở một cấp độ (recurse = FALSE) hay tất cả các tập tin trong tất cả các thư mục con (recurse = TRUE). Bên dưới chúng ta sử dụng hàm () để hiển thị kết quả dưới dạng viết tốc ký trong dự án R và cụ thể thư mục con “data” của nó, mà chứa tất các số liệu được sử dụng cho cuốn sổ tay này. Chúng ta thiết lập nó để hiện thị tất cả các tệp bên trong thư mục “data” và các thư mục con của nó (vd: “cache”, “epidemic models”, “population”, “shp”, và “weather”).","code":"\nfs::dir_tree(path = here(\"data\"), recurse = TRUE)## D:/Book Writing/4. EpiR Book/epiRhandbook_vn/data\n## +-- cache\n## |   \\-- epidemic_models\n## |       +-- 2015-04-30\n## |       |   +-- estimated_reported_cases_samples.rds\n## |       |   +-- estimate_samples.rds\n## |       |   +-- latest_date.rds\n## |       |   +-- reported_cases.rds\n## |       |   +-- summarised_estimated_reported_cases.rds\n## |       |   +-- summarised_estimates.rds\n## |       |   \\-- summary.rds\n## |       +-- epinow_res.rds\n## |       +-- epinow_res_small.rds\n## |       +-- generation_time.rds\n## |       \\-- incubation_period.rds\n## +-- case_linelists\n## |   +-- cleaning_dict.csv\n## |   +-- fluH7N9_China_2013.csv\n## |   +-- linelist_cleaned.rds\n## |   +-- linelist_cleaned.xlsx\n## |   \\-- linelist_raw.xlsx\n## +-- example\n## |   +-- Central Hospital.csv\n## |   +-- district_weekly_count_data.xlsx\n## |   +-- fluH7N9_China_2013.csv\n## |   +-- hospital_linelists.xlsx\n## |   +-- linelists\n## |   |   +-- 20201007linelist.csv\n## |   |   +-- case_linelist20201006.csv\n## |   |   +-- case_linelist_2020-10-02.csv\n## |   |   +-- case_linelist_2020-10-03.csv\n## |   |   +-- case_linelist_2020-10-04.csv\n## |   |   +-- case_linelist_2020-10-05.csv\n## |   |   \\-- case_linelist_2020-10-08.xlsx\n## |   +-- Military Hospital.csv\n## |   +-- Missing.csv\n## |   +-- Other.csv\n## |   +-- Port Hospital.csv\n## |   \\-- St. Mark's Maternity Hospital (SMMH).csv\n## +-- flexdashboard\n## |   +-- outbreak_dashboard.html\n## |   +-- outbreak_dashboard.Rmd\n## |   +-- outbreak_dashboard_shiny.Rmd\n## |   +-- outbreak_dashboard_test.html\n## |   \\-- outbreak_dashboard_test.Rmd\n## +-- gis\n## |   +-- africa_countries.geo.json\n## |   +-- covid_incidence.csv\n## |   +-- covid_incidence_map.R\n## |   +-- linelist_cleaned_with_adm3.rds\n## |   +-- population\n## |   |   +-- sle_admpop_adm3_2020.csv\n## |   |   \\-- sle_population_statistics_sierraleone_2020.xlsx\n## |   \\-- shp\n## |       +-- README.txt\n## |       +-- sle_adm3.CPG\n## |       +-- sle_adm3.dbf\n## |       +-- sle_adm3.prj\n## |       +-- sle_adm3.sbn\n## |       +-- sle_adm3.sbx\n## |       +-- sle_adm3.shp\n## |       +-- sle_adm3.shp.xml\n## |       +-- sle_adm3.shx\n## |       +-- sle_hf.CPG\n## |       +-- sle_hf.dbf\n## |       +-- sle_hf.prj\n## |       +-- sle_hf.sbn\n## |       +-- sle_hf.sbx\n## |       +-- sle_hf.shp\n## |       \\-- sle_hf.shx\n## +-- godata\n## |   +-- cases_clean.rds\n## |   +-- contacts_clean.rds\n## |   +-- followups_clean.rds\n## |   \\-- relationships_clean.rds\n## +-- likert_data.csv\n## +-- linelist_cleaned.xlsx\n## +-- make_evd_dataset.R\n## +-- malaria_app\n## |   +-- app.R\n## |   +-- data\n## |   |   \\-- facility_count_data.rds\n## |   +-- funcs\n## |   |   \\-- plot_epicurve.R\n## |   +-- global.R\n## |   +-- malaria_app.Rproj\n## |   +-- server.R\n## |   \\-- ui.R\n## +-- malaria_facility_count_data.rds\n## +-- phylo\n## |   +-- sample_data_Shigella_tree.csv\n## |   +-- Shigella_subtree_2.nwk\n## |   +-- Shigella_subtree_2.txt\n## |   \\-- Shigella_tree.txt\n## +-- rmarkdown\n## |   +-- outbreak_report.docx\n## |   +-- outbreak_report.html\n## |   +-- outbreak_report.pdf\n## |   +-- outbreak_report.pptx\n## |   +-- outbreak_report.Rmd\n## |   +-- report_tabbed_example.html\n## |   \\-- report_tabbed_example.Rmd\n## +-- standardization\n## |   +-- country_demographics.csv\n## |   +-- country_demographics_2.csv\n## |   +-- deaths_countryA.csv\n## |   +-- deaths_countryB.csv\n## |   \\-- world_standard_population_by_sex.csv\n## +-- surveys\n## |   +-- population.xlsx\n## |   +-- survey_data.xlsx\n## |   \\-- survey_dict.xlsx\n## \\-- time_series\n##     +-- campylobacter_germany.xlsx\n##     \\-- weather\n##         +-- germany_weather2002.nc\n##         +-- germany_weather2003.nc\n##         +-- germany_weather2004.nc\n##         +-- germany_weather2005.nc\n##         +-- germany_weather2006.nc\n##         +-- germany_weather2007.nc\n##         +-- germany_weather2008.nc\n##         +-- germany_weather2009.nc\n##         +-- germany_weather2010.nc\n##         \\-- germany_weather2011.nc"},{"path":"directories.html","id":"liệt-kê-các-tập-tin-trong-một-thư-mục","chapter":"45 Tương tác với thư mục làm việc","heading":"45.2 Liệt kê các tập tin trong một thư mục","text":"Để chỉ liệt kê các tên tập tin trong một thư mục, chúng ta có thể sử dụng hàm dir() từ base Ví dụ, lệnh này liệt kê tên các tập tin của các tập tin trong thư mục con có tên “population” trong thư mục “data” của một dự án R. Đường dẫn tập tin tương đối được cung cấp bằng cách sử dụng hàm () (đọc thêm trong chương Nhập xuất dữ liệu).Để liệt kê đường dẫn đầy đủ của các tập tin trong thư mục, chúng ta có thể sử dụng hàm dir_ls() từ package fs. Một cách khác là dùng hàm list.files() trong base R.Để lấy tất cả thông tin chi tiết của mỗi tập tin trong một thư mục (ví dụ: đường dẫn, ngày sửa đổi, .v.v.), chúng ta có thể sử dụng hàm dir_info() của package fs.Điều này có thể đặc biệt hữu ích nếu chúng ta muốn trích xuất thời gian sửa đổi sau cùng của tập tin, ví dụ như nếu chúng ta muốn nhập phiên bản mới nhất của tập tin. Ví dụ cho việc này, xem trong chương Nhập xuất dữ liệu.Sau đây là data frame được trả về. Cuộn qua phải để xem tất cả các cột.","code":"\n# file names\ndir(here(\"data\", \"gis\", \"population\"))## [1] \"sle_admpop_adm3_2020.csv\"                        \"sle_population_statistics_sierraleone_2020.xlsx\"\n# file paths\ndir_ls(here(\"data\", \"gis\", \"population\"))## D:/Book Writing/4. EpiR Book/epiRhandbook_vn/data/gis/population/sle_admpop_adm3_2020.csv\n## D:/Book Writing/4. EpiR Book/epiRhandbook_vn/data/gis/population/sle_population_statistics_sierraleone_2020.xlsx\n# file info\ndir_info(here(\"data\", \"gis\", \"population\"))"},{"path":"directories.html","id":"thông-tin-tệp","chapter":"45 Tương tác với thư mục làm việc","heading":"45.3 Thông tin tệp","text":"Để trích xuất thông tin chi tiết của một tập tin cụ thể, chúng ta có thể sử dụng hàme file_info() từ package fs (hoặc file.info() từ base R).Ở đây, chúng ta sử dụng ký hiệu $ để chỉ rõ kết quả và xuất chỉ mỗi giá trị về thời gian sửa đổi modification_time.","code":"\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))$modification_time## [1] \"2021-10-06 15:28:28 CEST\""},{"path":"directories.html","id":"kiểm-tra-sự-tồn-tại","chapter":"45 Tương tác với thư mục làm việc","heading":"45.4 Kiểm tra sự tồn tại","text":"","code":""},{"path":"directories.html","id":"đối-tượng-r","chapter":"45 Tương tác với thư mục làm việc","heading":"Đối tượng R","text":"Bạn có thể sử dụng hàm exists() trong base R để kiểm tra xem một đối tượng R có tồn tại bên trong môi trường R hay không (cung cấp tên đối tượng trong dấu ngoặc kép).Lưu ý rằng một số gói lệnh trong base R sử dụng các tên chung làm tên cho các đối tượng như “data” trong môi trường R, mà kết quả kiểm tra sẽ là TRUE trừ khi chúng ta chỉ rõ inherit = FALSE. Đây là một lý để không đặt tên cho bộ số liệu của chúng ta là “data”.Nếu bạn đang viết một hàm, bạn nên sử dụng hàm missing() từ base R để kiểm tra xem có một đối số hiện diện hay không, thay vì dùng hàm exists().","code":"\nexists(\"linelist\")## [1] TRUE\nexists(\"data\")## [1] TRUE\nexists(\"data\", inherit = FALSE)## [1] FALSE"},{"path":"directories.html","id":"thư-mục","chapter":"45 Tương tác với thư mục làm việc","heading":"Thư mục","text":"Để kiểm tra xem một thư mục có tồn tại không, cung cấp đường dẫn tập tin (và tên tập tin) đến hàm is_dir() của package fs. Cuộn qua bên phải để thấy thông báo TRUE được ra.Một cách làm khác là dùng hàm file.exists() từ base R.","code":"\nis_dir(here(\"data\"))## D:/Book Writing/4. EpiR Book/epiRhandbook_vn/data \n##                                              TRUE"},{"path":"directories.html","id":"tệp","chapter":"45 Tương tác với thư mục làm việc","heading":"Tệp","text":"Để kiểm tra xem một tập tin cụ thể có tồn tại hay không, sử dụng hàm is_file() của package fs. Cuộn qua bên phải để thấy thông báo TRUE được ra.Một cách làm khác là dùng hàm file.exists() từ base R.","code":"\nis_file(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))## D:/Book Writing/4. EpiR Book/epiRhandbook_vn/data/case_linelists/linelist_cleaned.rds \n##                                                                                  TRUE"},{"path":"directories.html","id":"tạo-mới","chapter":"45 Tương tác với thư mục làm việc","heading":"45.5 Tạo mới","text":"","code":""},{"path":"directories.html","id":"thư-mục-1","chapter":"45 Tương tác với thư mục làm việc","heading":"Thư mục","text":"Để tạo một thư mục mới, bạn có thể sử dụng hàm dir_create() từ package fs. Nếu thư mục đã tồn tại, thư mục này sẽ không bị ghi đè và không bị trả lại lỗi.Một cách làm khác là dùng hàm dir.create() từ base R, mà sẽ hiển thị lỗi nếu thư mục đó đã tồn tại. Ngược lại, dir_create() sẽ không thông báo gì.","code":"\ndir_create(here(\"data\", \"test\"))"},{"path":"directories.html","id":"tệp-1","chapter":"45 Tương tác với thư mục làm việc","heading":"Tệp","text":"Chúng ta có thể tạo một tâp tin (rỗng) bằng hàm file_create() từ package fs. Nếu tập tin này đã tồn tại, nó sẽ không bị ghi đè hoặc thay đổi.Một cách làm khác là dùng hàm file.create() từ base R. Nhưng nếu tập tin này đã tồn tại, tùy chọn này sẽ cắt xén tập tin đó. Nếu dùng hàm file_create() tập tin này sẽ được giữ nguyên.","code":"\nfile_create(here(\"data\", \"test.rds\"))"},{"path":"directories.html","id":"tạo-nếu-không-tồn-tại","chapter":"45 Tương tác với thư mục làm việc","heading":"Tạo nếu không tồn tại","text":"ĐANG XÂY DỰNG","code":""},{"path":"directories.html","id":"xóa","chapter":"45 Tương tác với thư mục làm việc","heading":"45.6 Xóa","text":"","code":""},{"path":"directories.html","id":"đối-tượng-r-1","chapter":"45 Tương tác với thư mục làm việc","heading":"Đối tượng R","text":"Dùng hàm rm() từ base R để loại bỏ một đối tượng R.","code":""},{"path":"directories.html","id":"thư-mục-2","chapter":"45 Tương tác với thư mục làm việc","heading":"Thư mục","text":"Dùng hàm dir_delete() từ package fs.","code":""},{"path":"directories.html","id":"tệp-2","chapter":"45 Tương tác với thư mục làm việc","heading":"Tệp","text":"Chúng ta có thể xóa các tệp bằng hàm file_delete() từ package fs.","code":""},{"path":"directories.html","id":"chạy-các-tệp-khác","chapter":"45 Tương tác với thư mục làm việc","heading":"45.7 Chạy các tệp khác","text":"","code":""},{"path":"directories.html","id":"source","chapter":"45 Tương tác với thư mục làm việc","heading":"source()","text":"Để chạy một R script từ một R script khác, bạn có thể sử dụng hàm source() (trong base R).ở phía trên bên phải của tập lệnh. Điều này sẽ thực hiện tập lệnh này nhưng sẽ thực hiện một cách âm thầm (không có kết quả đầu ra trong bảng điều khiển R) trừ khi có chủ ý cụ thể. Xem các ví dụ ở chương [Bảng điều khiển tương tác] về cách sử dụng source() để tương tác với người dùng qua bảng điều khiên R ở chế độ hỏi và trả lời.","code":"\nsource(here(\"scripts\", \"cleaning_scripts\", \"clean_testing_data.R\"))"},{"path":"directories.html","id":"render","chapter":"45 Tương tác với thư mục làm việc","heading":"render()","text":"Hàm render() là một biến thể của hàm source() mà thường được sử dụng nhất cho các tập lệnh của R markdown. Chúng ta cung cấp input = tập tin R markdown, và cũng vậy output_format = (thường là “html_document”, “pdf_document”, “word_document”, ““)Xem chương Báo cáo với R Markdown để biết thêm chi tiết. Ngoài ra, bạn có thể xem thêm tài liệu về render() tại đây hoặc bằng cách gõ ?render.","code":""},{"path":"directories.html","id":"chạy-các-tệp-trong-một-thư-mục","chapter":"45 Tương tác với thư mục làm việc","heading":"Chạy các tệp trong một thư mục","text":"Bạn có thể tạo một vòng lặp và sử dụng nó để source() từng tệp trong một thư mục, đã được nhận dạng bởi hàm dir().Nếu chúng ta chỉ muốn thực hiện một vài scripts, chúng ta có thể xác định chúng bằng tên như sau:Đây là một sánh giữa các hàm của fs và base R.","code":"\nfor(script in dir(here(\"scripts\"), pattern = \".R$\")) {   # for each script name in the R Project's \"scripts\" folder (with .R extension)\n  source(here(\"scripts\", script))                        # source the file with the matching name that exists in the scripts folder\n}\nscripts_to_run <- c(\n     \"epicurves.R\",\n     \"demographic_tables.R\",\n     \"survival_curves.R\"\n)\n\nfor(script in scripts_to_run) {\n  source(here(\"scripts\", script))\n}"},{"path":"directories.html","id":"nhập-tệp-vào-một-thư-mục","chapter":"45 Tương tác với thư mục làm việc","heading":"Nhập tệp vào một thư mục","text":"Xem chương Nhập xuất dữ liệu để nhập và xuất các tập tin riêng lẻ.Ngoài ra cũng xem thêm chương Nhập xuất dữ liệu để biết các phương pháp nhập một cách tự động các tập tin gần đây nhất dựa trên ngày trong tên tập tin hoặc bằng cách xem các thông tin chi tiết của tập tin.Xem một ví dụ trong chương [Lặp, vòng lặp và danh sách] để thấy rõ cách sử dụng package purrr:Để tách một data frame và lưu nó ra dưới dạng nhiều tập tinTách một data frame và lưu từng phần vào một trang tính riêng biệt trong một tập tin ExcelNhập nhiều tập tin CSV và kết hợp chúng thành một dataframeNhập một tập tin Excel có nhiều trang tính riêng biệt và kết hợp chúng thành một dataframe","code":""},{"path":"directories.html","id":"base-r-3","chapter":"45 Tương tác với thư mục làm việc","heading":"45.8 base R","text":"Xem bên dưới các hàm list.files() và dir(), thực hiện cùng một thao tác liệt kê các tập tin trong một thư mục cụ thể. Chúng ta có thể cụ thể cho đối số ignore.case = hoặc cụ thể một pattern để tìm kiếm.Nếu một tập tin hiện tại đang “mở”, nó sẽ hiện thị trong thư mục với dấu ngã phía trước, chẳng hạn như “~$hospital_linelists.xlsx”.","code":"\nlist.files(path = here(\"data\"))\n\nlist.files(path = here(\"data\"), pattern = \".csv\")\n# dir(path = here(\"data\"), pattern = \".csv\")\n\nlist.files(path = here(\"data\"), pattern = \"evd\", ignore.case = TRUE)"},{"path":"directories.html","id":"nguồn-13","chapter":"45 Tương tác với thư mục làm việc","heading":"45.9 Nguồn","text":"https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html","code":""},{"path":"collaboration.html","id":"collaboration","chapter":"46 Version control với Git và Github","heading":"46 Version control với Git và Github","text":"Chương này trình bày tổng quan về việc sử dụng Git để làm việc nhóm với những người khác. Bạn có thể tìm các hướng dẫn nâng cao hơn ở trong phần Tài nguyên học liệu.","code":""},{"path":"collaboration.html","id":"git-là-gì","chapter":"46 Version control với Git và Github","heading":"46.1 Git là gì?","text":"Git là một phần mềm kiểm soát phiên bản cho phép theo dõi các thay đổi trong một thư mục. Nó có thể được sử dụng như tùy chọn “track change” trong Word, LibreOffice hoặc Google docs, nhưng dành cho tất cả các loại tệp. Nó là một trong những công cụ mạnh mẽ nhất và được sử dụng nhiều nhất để kiểm soát phiên bản.Tại sao tôi chưa bao giờ nghe nói về Git? - Trong khi hầu hết những nhà lập trình thường xuyên phải học cách sử dụng phần mềm để kiểm soát phiên bản (Git, Mercurial, Subversion hoặc những phần mềm khác), ít người trong chúng ta xuất thân từ các ngành định lượng được dạy các kỹ năng này. đó, hầu hết các nhà dịch tễ học không bao giờ nghe nói về nó trong các nghiên cứu của họ, và phải tìm hiểu nó một cách nhanh chóng.Chờ đã, tôi có nghe nói về Github, chúng có giống nhau không? - Không hoàn toàn, nhưng bạn thường sử dụng chúng cùng nhau và chúng tôi sẽ hướng dẫn bạn cách thực hiện. Nói ngắn gọn như sau:Git là hệ thống kiểm soát phiên bản, là một phần của phần mềm. Bạn có thể tải phần mềm để sử dụng trên máy tính của mình hoặc để đồng bộ hóa một thư mục với một máy chủ trên web. Theo mặc định, bạn sử dụng terminal để đưa ra hướng dẫn cho Git thông qua các dòng lệnh.Git là hệ thống kiểm soát phiên bản, là một phần của phần mềm. Bạn có thể tải phần mềm để sử dụng trên máy tính của mình hoặc để đồng bộ hóa một thư mục với một máy chủ trên web. Theo mặc định, bạn sử dụng terminal để đưa ra hướng dẫn cho Git thông qua các dòng lệnh.Bạn có thể sử dụng ứng dụng người dùng/giao diện Git để không phải gõ lệnh và thực hiện các hành động tương tự (ít nhất là đối với những hành động đơn giản, rất thường dùng).Bạn có thể sử dụng ứng dụng người dùng/giao diện Git để không phải gõ lệnh và thực hiện các hành động tương tự (ít nhất là đối với những hành động đơn giản, rất thường dùng).Nếu bạn muốn lưu trữ thư mục của mình trong một host website để cùng làm việc với những người khác, bạn có thể tạo một tài khoản tại Github, Gitlab, Bitbucket hoặc những nền tảng khác.Nếu bạn muốn lưu trữ thư mục của mình trong một host website để cùng làm việc với những người khác, bạn có thể tạo một tài khoản tại Github, Gitlab, Bitbucket hoặc những nền tảng khác.Vì vậy, bạn có thể sử dụng ứng dụng/giao diện Github Desktop, sử dụng Git trong nền để quản lý các tệp của bạn, cả cục bộ trên máy tính của bạn và từ xa trên máy chủ Github.","code":""},{"path":"collaboration.html","id":"tại-sao-lại-sử-dụng-combo-git-và-github","chapter":"46 Version control với Git và Github","heading":"46.2 Tại sao lại sử dụng combo Git và Github?","text":"Sử dụng Git để:Lưu trữ các phiên bản của tài liệu với sự ghi nhận các thay đổi để bạn có thể dễ dàng chuyển lại về bất kỳ trạng thái nào trước đóCó các nhánh (branches) song song, tức là các phiên bản đang phát triển/“đang làm việc” hoạt động có cấu trúc để tích hợp các thay đổi sau khi đánh giáĐiều này có thể được thực hiện cục bộ trên máy tính của bạn, ngay cả khi bạn không cộng tác với những người khác. Bạn đã bao giờ từng:hối tiếc vì đã xóa một đoạn mã, chỉ để nhận ra hai tháng sau bạn thực sự cần nó?hối tiếc vì đã xóa một đoạn mã, chỉ để nhận ra hai tháng sau bạn thực sự cần nó?quay lại một dự án đã bị tạm dừng và cố gắng nhớ liệu bạn đã thực hiện một sửa đổi gì đó phức tạp ở một trong những mô hình?quay lại một dự án đã bị tạm dừng và cố gắng nhớ liệu bạn đã thực hiện một sửa đổi gì đó phức tạp ở một trong những mô hình?có một tệp model_1.R và một tệp khác model_1_test.R và một tệp model_1_not_working.R để thử mọi thứ?có một tệp model_1.R và một tệp khác model_1_test.R và một tệp model_1_not_working.R để thử mọi thứ?có một tệp report.Rmd, tệp report_full.Rmd, tệp report_true_final.Rmd, tệp report_final_20210304.Rmd, tệp report_final_20210402.Rmd và khó chịu với kỹ năng lưu trữ của bạn?có một tệp report.Rmd, tệp report_full.Rmd, tệp report_true_final.Rmd, tệp report_final_20210304.Rmd, tệp report_final_20210402.Rmd và khó chịu với kỹ năng lưu trữ của bạn?Git sẽ giúp bạn giải quyết tất cả vấn đề trên, và đây cũng là những thứ rất đáng để học.Tuy nhiên, nó thậm chí còn trở nên mạnh mẽ hơn khi được sử dụng với kho lưu trữ trực tuyến chẳng hạn như Github để hỗ trợ các dự án hợp tác. Điều này tạo điều kiện cho việc:Cộng tác: những người khác có thể đánh giá, nhận xét và chấp nhận/từ chối các thay đổiCộng tác: những người khác có thể đánh giá, nhận xét và chấp nhận/từ chối các thay đổiChia sẻ mã, dữ liệu và kết quả đầu ra của bạn và mời phản hồi từ công chúng (hoặc riêng tư, với nhóm của bạn) và tránh:Chia sẻ mã, dữ liệu và kết quả đầu ra của bạn và mời phản hồi từ công chúng (hoặc riêng tư, với nhóm của bạn) và tránh:“Rất tiếc, tôi đã quên gửi phiên bản cuối cùng và bây giờ bạn cần làm lại tệp mới này trong hai ngày làm việc”“Rất tiếc, tôi đã quên gửi phiên bản cuối cùng và bây giờ bạn cần làm lại tệp mới này trong hai ngày làm việc”Mina, Henry và Oumar đều làm việc cùng lúc trên một script và cần phải hợp nhất các thay đổi của họ theo cách thủ côngMina, Henry và Oumar đều làm việc cùng lúc trên một script và cần phải hợp nhất các thay đổi của họ theo cách thủ côngHai người cố gắng sửa đổi cùng một tệp trên Dropbox và Sharepoint và điều này tạo ra một lỗi đồng bộ hóa.Hai người cố gắng sửa đổi cùng một tệp trên Dropbox và Sharepoint và điều này tạo ra một lỗi đồng bộ hóa.","code":""},{"path":"collaboration.html","id":"điều-này-nghe-có-vẻ-phức-tạp-tôi-không-phải-là-một-lập-trình-viên","chapter":"46 Version control với Git và Github","heading":"Điều này nghe có vẻ phức tạp, tôi không phải là một lập trình viên","text":"Bạn hoàn toàn có thể. Ví dụ về cách sử dụng nâng cao có thể khá đáng sợ. Tuy nhiên, giống với như R, hoặc thậm chí là Excel, bạn không cần phải trở thành một chuyên gia để tận dụng lợi ích của công cụ. Học một số nhỏ các hàm và khái niệm cho phép bạn theo dõi các thay đổi của mình, đồng bộ hóa các tệp của bạn trên kho lưu trữ trực tuyến và cộng tác với đồng nghiệp của bạn với thời gian ngắn.tiến trình học tập, khi bạn cần hoàn thiện một công viêc trong trường hợp khẩn cấp, đó có thể không phải là thời điểm tốt nhất để tìm hiểu các công cụ này. Nhưng việc học có thể đạt được theo từng bước. Một khi bạn có được một vài khái niệm, quy trình làm việc của bạn có thể khá hiệu quả và nhanh chóng. Nếu bạn chưa làm việc trong một dự án cộng tác với mọi người và buộc phải sử dụng qua Git, đó thực sự là thời điểm tốt để có được sự tự tin khi sử dụng Git trước khi bắt tay vào cộng tác với người khác.","code":""},{"path":"collaboration.html","id":"cài-đặt-2","chapter":"46 Version control với Git và Github","heading":"46.3 Cài đặt","text":"","code":""},{"path":"collaboration.html","id":"cài-đặt-git","chapter":"46 Version control với Git và Github","heading":"Cài đặt Git","text":"Git là công cụ phía sau hậu trường trên máy tính của bạn, theo dõi các thay đổi, các nhánh (phiên bản), hợp nhất và hoàn nguyên. Đầu tiên bạn phải cài đặt Git từ đường link sau https://git-scm.com/downloads.","code":""},{"path":"collaboration.html","id":"cài-đặt-giao-diện-tùy-chọn-nhưng-được-khuyến-nghị","chapter":"46 Version control với Git và Github","heading":"Cài đặt giao diện (tùy chọn nhưng được khuyến nghị)","text":"Git có ngôn ngữ lệnh riêng, có thể được nhập vào terminal. Tuy nhiên, có nhiều phần mềm/giao diện và với tư cách không phải là một lập trình viên, trong quá trình sử dụng hàng ngày, bạn sẽ hiếm khi cần tương tác trực tiếp với Git và giao diện người dùng thường cung cấp các công cụ trực quan đẹp mắt để sửa đổi tệp hoặc các nhánh.Có nhiều tùy chọn, trên tất cả các hệ điều hành, từ thân thiện với người mới bắt đầu đến những tùy chọn phức tạp hơn. Các tùy chọn tốt cho người mới bắt đầu bao gồm cửa sổ RStudio Git và Github Desktop, mà chúng tôi sẽ giới thiệu trong chương này. Các tùy chọn trung gian (tiện ích hơn nhưng phức tạp hơn) bao gồm Source Tree, Gitkracken, Smart Git và những tùy chọn khác.Giải thích ngắn gọn về Git clients ở đây.Lưu ý: vì thực tế tất cả các giao diện đều sử dụng Git nội bộ, bạn có thể thử một số trong đó, chuyển từ dạng này sang dạng khác trong một dự án nhất định, sử dụng console đối với một hành động mà giao diện của bạn không hỗ trợ hoặc thậm chí thực hiện bất kỳ hành động nào trực tuyến trên Github.Như đã lưu ý bên dưới, đôi khi bạn có thể phải viết các lệnh Git trong termial chẳng hạn như cửa sổ Ternmial trong RStudio (một tab liền kề với R Console) hoặc terminal của Git Bash.","code":""},{"path":"collaboration.html","id":"tài-khoản-github","chapter":"46 Version control với Git và Github","heading":"Tài khoản Github","text":"Đăng ký tài khoản miễn phí tại github.com.Bạn có thể được đề nghị thiết lập xác thực hai yếu tố với một ứng dụng trên điện thoại của bạn. Đọc thêm trong tài liệu trợ giúp của Github .Nếu bạn sử dụng Github Desktop, bạn có thể nhập thông tin đăng nhập Gitub của mình sau khi cài đặt các bước sau. Nếu bạn không biết, thông tin đăng nhập sẽ được hỏi sau khi bạn cố gắng clone một dự án từ Github.","code":""},{"path":"collaboration.html","id":"thuật-ngữ-khái-niệm-và-các-hàm-cơ-bản","chapter":"46 Version control với Git và Github","heading":"46.4 Thuật ngữ, khái niệm và các hàm cơ bản","text":"Giống như khi học R, bạn cần nhớ một chút thuật ngữ để hiểu Git. Đây là những điều cơ bản giúp bạn làm việc / hướng dẫn tương tác. Ở phần tiếp theo, chúng tôi sẽ chỉ ra cách sử dụng các giao diện, nhưng tốt hơn là bạn nên có một số thuật ngữ và khái niệm trong đầu, để xây dựng mô hình tinh thần của bạn, và vì bạn sẽ cần chúng khi sử dụng các giao diện.","code":""},{"path":"collaboration.html","id":"kho-lưu-trữ-repository","chapter":"46 Version control với Git và Github","heading":"Kho lưu trữ (Repository)","text":"Kho lưu trữ Git (“repo”) là một thư mục chứa tất cả các thư mục con và tệp cho dự án của bạn (dữ liệu, mã code, hình ảnh, v.v.) và lịch sử sửa đổi của chúng. Khi bạn bắt đầu theo dõi những thay đổi trong kho lưu trữ, Git sẽ tạo một thư mục ẩn chứa tất cả các thông tin theo dõi. Một kho lưu trữ Git điển hình là thư mục Dự án R của bạn (xem thêm chương Dự án R để biết thêm chi tiết).Chúng tôi sẽ hướng dẫn bạn cách tạo (initialize) một kho lưu trữ Git từ Github, Github Desktop hoặc Rstudio trong phần tiếp theo của chương này.","code":""},{"path":"collaboration.html","id":"commits","chapter":"46 Version control với Git và Github","heading":"Commits","text":"Một commit là một ảnh chụp nhanh của dự án tại một thời điểm xác định. Khi bạn thực hiện một thay đổi đối với dự án, bạn sẽ tạo một commit mới để theo dõi những thay đổi (delta) được thực hiện đối với các tập tin của bạn. Ví dụ: bạn đã chỉnh sửa một vài dòng lệnh và cập nhật bộ dữ liệu liên quan. Sau khi các thay đổi của bạn được lưu, bạn có đóng gói các thay đổi cùng nhau tạo thành một “commit”.Mỗi commit có một ID duy nhất (một hash). Đối với mục tiêu kiểm soát phiên bản, bạn có thể khôi phục dự án của mình theo thời gian dựa trên các commit, vì vậy tốt nhất là bạn nên tạo các commit tương đối nhỏ và mạch lạc. Bạn cũng sẽ đính kèm một bản tóm tắt mô tả về những thay đổi được gọi là “commit message”.Tổ chức các thay đổi (Staged change)? Tổ chức các thay đổi nghĩa là thêm chúng vào một staging area - khu vực sân khẩu để chuẩn bị cho lần commit tiếp theo. Ý tưởng là bạn có thể quyết định rõ ràng những thay đổi nào sẽ bao gồm trong một commit cụ thể. Ví dụ, nếu bạn đã làm việc với mô hình trong một script và sau đó làm việc với một biểu đồ trong một script khác, sẽ hợp lý nếu có hai commit khác nhau (sẽ dễ dàng hơn trong trường hợp bạn muốn khôi phục các thay đổi trên biểu đồ nhưng không phải trên mô hình).","code":""},{"path":"collaboration.html","id":"branches","chapter":"46 Version control với Git và Github","heading":"Branches","text":"Một nhánh (branch) đại diện cho một con đường độc lập chứa các thay đổi trong kho lưu trữ (repo) của bạn. Nó là một phiên bản song song của các tệp dự án của bạn.Các nhánh rất hữu ích để thử nghiệm các thay đổi trước khi chúng được tích hợp vào nhánh chính (main branch), thường là phiên bản chính/cuối cùng/“live” của dự án của bạn. Khi bạn hoàn thành việc thử nghiệm trên một nhánh, bạn có thể hợp nhất những thay đổi đó vào nhánh chính của bạn, hoặc xóa những thay đổi không thành công.Lưu ý: bạn không cần phải cộng tác với người khác để sử dụng các nhánh, cũng như không cần phải có một kho lưu trữ trực tuyến từ xa.","code":""},{"path":"collaboration.html","id":"kho-lưu-trữ-cục-bộ-và-từ-xa","chapter":"46 Version control với Git và Github","heading":"Kho lưu trữ cục bộ và từ xa","text":"Clone (Nhân bản) là tạo một bản sao của kho lưu trữ Git ở một nơi khác.Ví dụ: bạn có thể clone một kho lưu trữ trực tuyến từ Github xuống máy tính của bạn hoặc bắt đầu với một kho lưu trữ cục bộ (local repository) và clone nó trực tuyến lên Github.Khi bạn đã clone một kho lưu trữ, các tệp dự án tồn tại ở hai nơi:kho lưu trữ CỤC BỘ (LOCAL) trên máy tính của bạn. Đây là nơi bạn thực hiện các thay đổi thực tế đối với các tệp/code.kho lưu trữ CỤC BỘ (LOCAL) trên máy tính của bạn. Đây là nơi bạn thực hiện các thay đổi thực tế đối với các tệp/code.TỪ XA (REMOTE), kho lưu trữ trực tuyến: các phiên bản của tệp dự án trên kho lưu trữ Github (hoặc trên bất kỳ nền tảng nào khác).TỪ XA (REMOTE), kho lưu trữ trực tuyến: các phiên bản của tệp dự án trên kho lưu trữ Github (hoặc trên bất kỳ nền tảng nào khác).Để đồng bộ hóa các kho này, chúng ta sẽ sử dụng nhiều hàm hơn. Thật vậy, không giống như Sharepoint, Dropbox hoặc các phần mềm đồng bộ hóa khác, Git không thực hiện tự động cập nhật kho lưu trữ cục bộ của bạn dựa trên những gì có trên cloud, hoặc ngược lại. Tuy nhiên, bạn có thể chọn thời điểm và cách thức đồng bộ hóa.git fetch tải xuống các thay đổi mới từ kho lưu trữ từ xa nhưng không làm thay đổi kho lưu trữ cục bộ của bạn. Hãy coi như nó giống như việc kiểm tra trạng thái của kho lưu trữ từ xa.git fetch tải xuống các thay đổi mới từ kho lưu trữ từ xa nhưng không làm thay đổi kho lưu trữ cục bộ của bạn. Hãy coi như nó giống như việc kiểm tra trạng thái của kho lưu trữ từ xa.git pull tải xuống các thay đổi mới từ kho lưu trữ từ xa và cập nhật kho lưu trữ cục bộ của bạn.git pull tải xuống các thay đổi mới từ kho lưu trữ từ xa và cập nhật kho lưu trữ cục bộ của bạn.Khi bạn đã thực hiện một hoặc một số commit cục bộ, bạn có thể git push để đẩy các commit đến kho lưu trữ từ xa. Điều này giúp gửi các thay đổi của bạn tới Github để người khác có thể xem và kéo về (pull) nếu họ muốn.Khi bạn đã thực hiện một hoặc một số commit cục bộ, bạn có thể git push để đẩy các commit đến kho lưu trữ từ xa. Điều này giúp gửi các thay đổi của bạn tới Github để người khác có thể xem và kéo về (pull) nếu họ muốn.","code":""},{"path":"collaboration.html","id":"bắt-đầu-tạo-một-kho-lưu-trữ-mới","chapter":"46 Version control với Git và Github","heading":"46.5 Bắt đầu: tạo một kho lưu trữ mới","text":"Có nhiều cách để tạo kho lưu trữ mới. Bạn có thể làm điều đó từ R console, từ Github, hoặc thông qua giao diện người dùng.Hai cách tiếp cận thường dùng để tạo một kho lưu trữ là:Tạo một Dự án R mới từ kho lưu trữ Github hiện có hoặc mới (ưu tiên cho người mới bắt đầu), hoặcTạo kho lưu trữ Github cho một dự án R hiện có","code":""},{"path":"collaboration.html","id":"các-tệp-khởi-động","chapter":"46 Version control với Git và Github","heading":"Các tệp khởi động","text":"Khi bạn tạo một kho lưu trữ mới, bạn có thể tùy chọn tạo tất cả các tệp bên dưới hoặc bạn có thể thêm chúng vào kho lưu trữ của mình ở giai đoạn sau. Chúng thường nằm trong thư mục “gốc” của kho lưu trữ.Tệp README là tệp mà người khác có thể đọc để hiểu tại sao dự án của bạn tồn tại và những điều họ nên biết để sử dụng nó. Tệp này ban đầu sẽ trống, nhưng bạn có thể hoàn thiện nó sau đó.Tệp README là tệp mà người khác có thể đọc để hiểu tại sao dự án của bạn tồn tại và những điều họ nên biết để sử dụng nó. Tệp này ban đầu sẽ trống, nhưng bạn có thể hoàn thiện nó sau đó.Tệp .gitignore là tệp văn bản trong đó mỗi dòng sẽ chứa các thư mục hoặc tệp mà Git nên bỏ qua (không theo dõi các thay đổi). Đọc thêm về điều này và xem các ví dụ tại đây.Tệp .gitignore là tệp văn bản trong đó mỗi dòng sẽ chứa các thư mục hoặc tệp mà Git nên bỏ qua (không theo dõi các thay đổi). Đọc thêm về điều này và xem các ví dụ tại đây.Bạn có thể chọn license cho dự án của mình, để những người khác biết họ có thể sử dụng hoặc tái lập dự án của bạn trong những điều kiện nào. Để biết thêm thông tin, hãy xem Creative Commons licenses.Bạn có thể chọn license cho dự án của mình, để những người khác biết họ có thể sử dụng hoặc tái lập dự án của bạn trong những điều kiện nào. Để biết thêm thông tin, hãy xem Creative Commons licenses.","code":""},{"path":"collaboration.html","id":"tạo-một-kho-lưu-trữ-mới-trong-github","chapter":"46 Version control với Git và Github","heading":"Tạo một kho lưu trữ mới trong Github","text":"Để tạo một kho lưu trữ mới, hãy đăng nhập vào Github và tìm một nút màu xanh lục để tạo một kho lưu trữ mới. Một kho lưu trữ trống được tạo ra và có thể được clone xuống máy tính của bạn (xem phần tiếp theo để biết thêm chi tiết).Bạn phải chọn nếu bạn muốn kho lưu trữ của mình ở dạng công khai (hiển thị với mọi người trên internet) hoặc riêng tư (chỉ hiển thị với những người trong sự cho phép của bạn). Điều này có ý nghĩa quan trọng nếu dữ liệu của bạn nhạy cảm. Nếu kho lưu trữ của bạn là riêng tư, bạn sẽ gặp phải một số giới hạn trong các trường hợp đặc biệt, chẳng hạn như nếu bạn đang sử dụng actions trong Github để tự động chạy code trên cloud.","code":""},{"path":"collaboration.html","id":"clone-từ-kho-lưu-trữ-github","chapter":"46 Version control với Git và Github","heading":"Clone từ kho lưu trữ Github","text":"Bạn có thể clone một kho lưu trữ Github có sẵn để tạo một dự án R mới cục bộ trên máy tính của bạn.Kho lưu trữ Github có thể là một kho lưu trữ đã tồn tại và chứa nội dung, hoặc có thể là một kho lưu trữ trống mà bạn vừa tạo. Trong trường hợp thứ hai, về cơ bản bạn đang tạo một repo Github và dự án R cục bộ trên máy tính của bạn cùng một lúc (xem hướng dẫn ở trên)Lưu ý: nếu bạn không có quyền đóng góp trên kho lưu trữ Github, trước tiên bạn có thể fork kho lưu trữ đó vào hồ sơ riêng của bạn, và sau đó tiếp tục với các hành động khác. Forking được giải thích ở phần cuối của chương này nhưng chúng tôi khuyên bạn nên đọc các phần khác trước.Bước 1: Điều hướng trong Github đến kho lưu trữ, nhấp vào nút màu xanh lá cây “Code” và sao chép HTTPS clone URL (xem hình ảnh minh họa bên dưới)Bước tiếp theo có thể được thực hiện trong bất kỳ giao diện người dùng nào. Chúng tôi sẽ minh họa bằng Rstudio và Github desktop.","code":""},{"path":"collaboration.html","id":"trong-rstudio","chapter":"46 Version control với Git và Github","heading":"Trong Rstudio","text":"Trong RStudio, để bắt đầu một dự án R mới, bạn cần nhấp vào File > New Project > Version Control > GitKhi được yêu cầu nhập “Repository URL”, hãy dán URL HTTPS từ Github Gán cho dự án R một cái tên ngắn gọn, đầy đủ thông tinChọn nơi Dự án R mới sẽ được lưu cục bộ trên máy tính của bạnChọn “Open new session” và nhấp vào mục “Create project”Bạn hiện đang trong một dự án RStudio mới, cục bộ trên máy tính của bạn, là một bản sao của kho lưu trữ online trên Github. Dự án cục bộ này và kho lưu trữ Github hiện đã được liên kết.","code":""},{"path":"collaboration.html","id":"trong-github-desktop","chapter":"46 Version control với Git và Github","heading":"Trong Github Desktop","text":"Nhấn vào File > Clone repositoryNhấn vào File > Clone repositoryChọn tab URLChọn tab URLDán đường dẫn HTTPS URL từ Github vào hộp đầu tiênDán đường dẫn HTTPS URL từ Github vào hộp đầu tiênChọn thư mục mà bạn muốn lưu kho lưu trữ cục bộ của mìnhChọn thư mục mà bạn muốn lưu kho lưu trữ cục bộ của mìnhNhấn vào “CLONE”Nhấn vào “CLONE”","code":""},{"path":"collaboration.html","id":"tạo-một-github-repo-mới-từ-dự-án-r-đã-có-sẵn","chapter":"46 Version control với Git và Github","heading":"Tạo một Github repo mới từ dự án R đã có sẵn","text":"Một kịch bản khác là bạn có một dự án R đã tồn tại với các nội dung và bạn muốn tạo một kho lưu trữ Github cho nó.Tạo một kho lưu trữ Github mới, trống cho dự án (Xem hướng dẫn ở trên)Clone cục bộ kho lưu trữ này (Xem hướng dẫn về HTTPS ở trên)Sao chép tất cả nội dung từ dự án R đã có từ trước của bạn (mã, dữ liệu, v.v.) vào kho lưu trữ trống, cục bộ, mới này (ví dụ: sử dụng sao chép và dán).Mở dự án mới của bạn trong RStudio và chuyển đến cửa sổ Git. Các tệp mới sẽ được đăng ký dưới dạng tệp có thay đổi, và hiện được theo dõi bởi Git. đó, bạn có thể đóng gói những thay đổi này dưới dạng một commit và push chúng lên Github. Sau khi được push, kho lưu trữ trên Github của bạn sẽ theo dõi sự thay đổi của tất cả các tệp.Xem phần quy trình làm việc Github bên dưới để biết chi tiết về quy trình này.","code":""},{"path":"collaboration.html","id":"bây-giờ-nó-trông-như-thế-nào","chapter":"46 Version control với Git và Github","heading":"Bây giờ, nó trông như thế nào?","text":"","code":""},{"path":"collaboration.html","id":"trong-rstudio-1","chapter":"46 Version control với Git và Github","heading":"Trong RStudio","text":"Khi bạn đã clone kho lưu trữ Github sang một dự án R mới, bây giờ bạn sẽ thấy trong RStudio có một tab “Git”. Tab này xuất hiện bên cạnh cửa sổ RStudio Environment của bạn:Lưu ý các nút được khoanh tròn trong hình trên, vì chúng sẽ được giới thiệu dưới đây (từ trái sang phải):Nút để commit những tệp có thay đổi đã được lưu tới nhánh cục bộ “local branch” (sẽ mở ra một cửa sổ mới)Mũi lên màu xanh lam hướng lên để pull (cập nhật phiên bản của nhánh cục bộ với bất kỳ các thay đổi được thực hiện trên phiên bản từ xa/Github của nhánh đó)Mũi tên màu xanh lục hướng xuống push (gửi bất kỳ các commits/thay đổi nào trong phiên bản cục bộ lên phiên bản từ xa/Github của nhánh đó)Tab Git trong RStudioNút để tạo một nhánh MỚI bằng cách sử dụng bất kỳ nhánh cục bộ nào được hiển thị bên phải làm cơ sở. Bạn hầu như luôn muốn tách khỏi nhánh chính (sau khi bạn pull lần đầu tiên để cập nhật nhánh chính)Nhánh bạn hiện đang làm việcNhững thay đổi bạn đã thực hiện đối với code hoặc các tệp khác sẽ xuất hiện bên dưới","code":""},{"path":"collaboration.html","id":"trong-github-desktop-1","chapter":"46 Version control với Git và Github","heading":"Trong Github Desktop","text":"Github Desktop là một ứng dụng độc lập trong máy tính cho phép bạn quản lý tất cả các kho lưu trữ của bạn. Khi bạn mở nó, giao diện của nó cho phép bạn chọn kho lưu trữ bạn muốn làm việc và sau đó thực hiện các thao tác Git cơ bản tại đây.","code":""},{"path":"collaboration.html","id":"quy-trình-làm-việc-với-git-github","chapter":"46 Version control với Git và Github","heading":"46.6 Quy trình làm việc với Git + Github","text":"","code":""},{"path":"collaboration.html","id":"tổng-quan-về-quy-trình","chapter":"46 Version control với Git và Github","heading":"Tổng quan về quy trình","text":"Khi bạn đã hoàn tất các bước thiết lập (được mô tả ở trên), bạn sẽ có một Github repo được kết nối (cloned) với một dự án R cục bộ. Nhánh chính (được tạo theo mặc định) còn được gọi là phiên bản “live” của tất cả các tệp tin. Khi bạn muốn sửa đổi, một thực hành tốt đó là tạo một nhánh mới từ nhánh chính (giống như “Tạo một bản sao”). Đây là quy trình làm việc điển hình trong Git vì việc tạo một nhánh là dễ dàng và nhanh chóng.Quy trình làm việc điển hình như sau:Đảm bảo rằng kho lưu trữ cục bộ của bạn được cập nhật, hãy cập nhật nó nếu nó chưa phải bản mới nhấtĐảm bảo rằng kho lưu trữ cục bộ của bạn được cập nhật, hãy cập nhật nó nếu nó chưa phải bản mới nhấtChuyển đến nhánh mà bạn đã làm việc trước đây hoặc tạo một nhánh làm việc mới để thử một số thứChuyển đến nhánh mà bạn đã làm việc trước đây hoặc tạo một nhánh làm việc mới để thử một số thứLàm việc với các tệp trực tiếp trên máy tính của bạn, tạo một hoặc nhiều commit với nhánh làm việc nàyLàm việc với các tệp trực tiếp trên máy tính của bạn, tạo một hoặc nhiều commit với nhánh làm việc nàyCập nhật phiên bản từ xa của nhánh làm việc với các thay đổi của bạn (push)Cập nhật phiên bản từ xa của nhánh làm việc với các thay đổi của bạn (push)Khi bạn hài lòng với nhánh làm việc này, bạn có thể hợp nhất phiên bản trực tuyến vào nhánh “chính” trực tuyến để chuyển tiếp các thay đổiKhi bạn hài lòng với nhánh làm việc này, bạn có thể hợp nhất phiên bản trực tuyến vào nhánh “chính” trực tuyến để chuyển tiếp các thay đổiCác thành viên khác trong nhóm có thể đang làm điều tương tự với các nhánh của riêng họ, hoặc cũng có thể đóng góp các commits vào nhánh làm việc của bạn.Chúng ta sẽ đi qua một cách chi tiết hơn từng bước của quá trình trên ở phần sau. Đây là một giản đồ mà chúng tôi đã phát triển - nó ở định dạng bảng hai chiều vì vậy nó sẽ giúp các nhà dịch tễ học dễ dàng hiểu được.Dây là một sơ đồ khác.Lưu ý: cho đến gần đây, thuật ngữ nhánh “master” vẫn được sử dụng, nhưng bây giờ thuật ngữ này được gọi là nhánh “main (chính)”.Nguồn hình ảnh","code":""},{"path":"collaboration.html","id":"tạo-một-nhánh-mới","chapter":"46 Version control với Git và Github","heading":"46.7 Tạo một nhánh mới","text":"Khi bạn chọn một nhánh để làm việc, Git đặt lại trạng thái thư mục làm việc của bạn trở lại lần cuối cùng bạn ở trên nhánh này.","code":""},{"path":"collaboration.html","id":"trong-cửa-sổ-rstudio-git","chapter":"46 Version control với Git và Github","heading":"Trong cửa sổ Rstudio Git","text":"Đảm bảo bạn đang ở trong nhánh “chính”, sau đó nhấp vào biểu tượng màu tím để tạo một nhánh mới (xem hình trên).Bạn sẽ được yêu cầu đặt tên nhánh của mình trong một từ (có thể sử dụng dấu gạch dưới nếu cần).Bạn sẽ thấy rằng bạn vẫn đang ở trong cùng một dự án R, nhưng bạn không còn làm việc trên nhánh “chính” nữa.Sau khi được tạo, nhánh mới cũng sẽ xuất hiện trên trang web Github dưới dạng một nhánh.Bạn có thể xem các nhánh tại cửa sổ Git trong Rstudio bằng cách nhấp vào “History”","code":""},{"path":"collaboration.html","id":"trong-github-desktop-2","chapter":"46 Version control với Git và Github","heading":"Trong Github Desktop","text":"Quy trình tương tự bên trên, bạn được yêu cầu đặt tên cho nhánh làm việc của mình. Sau đó, bạn sẽ được yeu cầu “Publish branch Github - Xuất bản nhánh làm việc của bạn lên Github” để làm cho nhánh mới cũng xuất hiện trong kho lưu trữ từ xa.","code":""},{"path":"collaboration.html","id":"trong-console","chapter":"46 Version control với Git và Github","heading":"Trong console","text":"Điều thực sự đang xảy ra ẩn phía sau là bạn tạo ra một nhánh với lệnh git branch, sau đó chuyển đến nhánh đó bằng lệnh git checkout (vd: nói cho Git biết rằng các commit tiếp theo của bạn sẽ xảy ra trên nhánh đó). Từ kho lưu trữ git của bạn, hãy gõ:Để biết thêm thông tin về cách sử dụng bảng console, hãy xem phần Lệnh Git ở cuối.","code":"git branch my-new-branch  # Create the new branch branch\ngit checkout my-new-branch # Go to the branch\ngit checkout -b my-new-branch # Both at once (shortcut)"},{"path":"collaboration.html","id":"commit-các-thay-đổi","chapter":"46 Version control với Git và Github","heading":"46.8 Commit các thay đổi","text":"Giờ đây, bạn có thể chỉnh sửa code, thêm tệp mới, cập nhật bộ dữ liệu, v.v.Mọi thay đổi của bạn đều được theo dõi, sau khi tệp tương ứng được lưu. Các tệp đã thay đổi sẽ xuất hiện trong tab RStudio Git, trong Github Desktop hoặc sử dụng lệnh git status trong terminal (xem bên dưới).Bất cứ khi nào bạn thực hiện các thay đổi quan trọng (ví dụ: thêm hoặc cập nhật một phần của code), bạn hãy tạm dừng việc thay đổi và commit những thay đổi đó. Hãy tưởng tượng mỗi một commit là một “lô (batch)” của các thay đổi cùng hướng tới một mục đích chung. Bạn sẽ luôn có thể tiếp tục sửa đổi tệp sau khi đã commit các thay đổi trên đó.Lời khuyên về cách commit: nói chung, tốt hơn là bạn nên tạo các commit nhỏ để có thể dễ dàng khôi phục các chỉnh sửa nếu có vấn đề phát sinh, sau đó commit chúng cùng nhau. Để làm được điều này, bạn sẽ cần phải commit thường xuyên. Khi mới bắt đầu, bạn có thể sẽ quên commit thường xuyên, nhưng sau đó thói quen commit thường xuyên bắt đầu xuất hiện.","code":""},{"path":"collaboration.html","id":"trong-rstudio-2","chapter":"46 Version control với Git và Github","heading":"Trong Rstudio","text":"Ví dụ dưới đây cho thấy rằng, kể từ lần commit cuối cùng, tập lệnh R Markdown “collab.Rmd” đã thay đổi, và một số hình ảnh PNG đã được thêm vào.Bạn có thể tự hỏi những hình vuông màu vàng, xanh lam, xanh lá cây và đỏ bên cạnh tên tệp có ý nghĩa gì. Đây là ảnh chụp nhanh từ RStudio cheatsheet trong đó giải thích ý nghĩa của chúng. Lưu ý rằng các thay đổi với màu vàng “?” có thể hoặc là staged, commited và pushed.Nhấn vào nút “Commit” trong cửa sổ Git, nút này sẽ mở ra một cửa sổ mới (hiển thị bên dưới)Nhấn vào nút “Commit” trong cửa sổ Git, nút này sẽ mở ra một cửa sổ mới (hiển thị bên dưới)Nhấp vào tên tệp trong hộp phía trên bên tráiNhấp vào tên tệp trong hộp phía trên bên tráiXem lại những thay đổi bạn đã thực hiện đối với tệp đó (được đánh dấu màu xanh lá cây hoặc đỏ)Xem lại những thay đổi bạn đã thực hiện đối với tệp đó (được đánh dấu màu xanh lá cây hoặc đỏ)“Trình bày - Stage” các tệp, sẽ bao gồm những thay đổi có trong commit. Bạn có thể thực hiện việc này bằng cách chọn hộp bên cạnh tên tệp. Ngoài ra, bạn có thể đánh dấu nhiều tên tệp và sau đó nhấp vào “Stage”“Trình bày - Stage” các tệp, sẽ bao gồm những thay đổi có trong commit. Bạn có thể thực hiện việc này bằng cách chọn hộp bên cạnh tên tệp. Ngoài ra, bạn có thể đánh dấu nhiều tên tệp và sau đó nhấp vào “Stage”Viết một thông điệp commit mô tả ngắn gọn những thay đổi (bắt buộc)Viết một thông điệp commit mô tả ngắn gọn những thay đổi (bắt buộc)Ấn vào nút “Commit”. Một hộp thoại xuất hiện cho biết lệnh commit được thực hiện thành công hoặc một thông báo về thực hiện lỗi.Ấn vào nút “Commit”. Một hộp thoại xuất hiện cho biết lệnh commit được thực hiện thành công hoặc một thông báo về thực hiện lỗi.Giờ đây, bạn có thể thực hiện nhiều thay đổi hơn và nhiều lần commit hơn, bao nhiêu lần tùy ý","code":""},{"path":"collaboration.html","id":"trong-github-desktop-3","chapter":"46 Version control với Git và Github","heading":"Trong Github Desktop","text":"Bạn có thể xem danh sách các tệp đã được thay đổi ở bên trái. Nếu như bạn chọn một tệp văn bản, bạn sẽ thấy một bản tóm tắt về các sửa đổi đã được thực hiện trong ngăn bên phải (chế độ xem sẽ không hoạt động trên các tệp phức tạp hơn như .docs hoặc .xlsx).Để stage các thay đổi, chỉ cần đánh dấu vào ô nhỏ gần tên tệp. Khi bạn đã chọn các tệp bạn muốn thêm vào lần commit này, hãy đặt một cái tên cho commit và mô tả (tùy chọn) và sau đó nhấp vào nút commit.","code":""},{"path":"collaboration.html","id":"trong-console-1","chapter":"46 Version control với Git và Github","heading":"Trong console","text":"Hai hàm thực sự thực hiện các thao tác trên là git add để chọn/stage tệp và git commit để thực hiện commit.","code":"git status # see the changes \n\ngit add new_pages/collaboration.Rmd  # select files to commit (= stage the changes)\n\ngit commit -m \"Describe commit from Github Desktop\" # commit the changes with a message\n\ngit log  # view information on past commits"},{"path":"collaboration.html","id":"thêm-vào-một-commit-trước-đó","chapter":"46 Version control với Git và Github","heading":"Thêm vào một commit trước đó","text":"Điều gì sẽ xảy ra nếu bạn đã commit một số thay đổi, tiếp tục làm việc và nhận ra rằng bạn đã thực hiện các thay đổi mà lẽ ra “thuộc về” lần commit trước đó (theo ý kiến của bạn). Đừng sợ! Bạn có thể nối những thay đổi này vào lần commit trước đó của mình.Trong Rstudio, nó sẽ khá rõ ràng vì có một hộp kiểm “Thêm vào commit trước - Amend previous commit” trên cùng dòng với nút COMMIT.Vì một số lý không rõ ràng, chức năng này không có sẵn trong Github Desktop, nhưng vẫn có cách (khó hiểu về mặt khái niệm nhưng dễ dàng). Nếu bạn đã commit nhưng chưa đẩy các thay đổi của bạn lên nhánh chính, nút “UNDO” xuất hiện ngay dưới nút COMMIT. Nhấp vào nó và nó sẽ khôi phục commit của bạn (nhưng vẫn giữ các staged files và thông điệp commit). Lưu các thay đổi của bạn, thêm tệp mới vào commit nếu cần và commit lại.Trong cửa số console:Lưu ý: hãy suy nghĩ trước khi sửa đổi các commit đã được công khai và chia sẻ với các cộng tác viên của bạn.","code":"git add [YOUR FILES] # Stage your new changes\n\ngit commit --amend  # Amend the previous commit\n\ngit commit --amend -m \"An updated commit message\"  # Amend the previous commit AND update the commit message"},{"path":"collaboration.html","id":"pull-và-push-các-thay-đổi-lên-github","chapter":"46 Version control với Git và Github","heading":"46.9 Pull và push các thay đổi lên Github","text":"“PULL trước, PUSH sau”Một thực hành tốt đố là fetch và pull trước khi bạn bắt đầu làm việc dự án của bạn, để cập nhật phiên bản nhánh trên máy tính của bạn với bất kỳ thay đổi nào đã được thực hiện trên nhanh đó ở phiên bản từ xa/Github.Đừng ngần ngại PULL thường xuyên. Luôn nhớ pull trước khi push.Khi các thay đổi của bạn được thực hiện và được commit, cũng như bạn hài lòng với chúng, bạn có thể push (đẩy) commit của mình lên sang phiên bản từ xa/Github nhánh làm việc của bạn.Kiểm tra và lặp lại trong khi bạn đang làm việc trên kho lưu trữ.Lưu ý: việc khôi phục các thay đổi đã được commit nhưng chưa push lên Github (tức là vẫn còn ở local) dễ dàng hơn nhiều với các commit đã được push lên kho lưu trữ từ xa (và có thể đã được ai đó pull xuống), vì vậy tốt nhất là bạn nên push những thay đổi khi bạn hoàn thành nó và giới thiệu về các thay đổi mà bạn đã thực hiện.","code":""},{"path":"collaboration.html","id":"trong-rstudio-3","chapter":"46 Version control với Git và Github","heading":"Trong Rstudio","text":"PULL - Đầu tiên, ấn vào biểu tượng “Pull” (mũi tên hướng xuống) để fetch và pull cùng một lúc.PUSH - Ấn vào icon màu xanh “Push” (mũi tên hướng lên). Bạn có thể được yêu cầu nhập tên người dùng và mật khẩu Github của bạn. Trong lần đầu tiên được hỏi, bạn có thể cần nhập hai dòng lệnh Git sau vào Terminal:git config –global user.email “@example.com” (Địa chỉ email Github của bạn), vàgit config –global user.name “Tên đăng nhập Github của bạn”Để tìm hiểu thêm về cách nhập các lệnh này, hãy xem phần bên dưới về các lệnh Git.MẸO: Bị yêu cầu cung cấp mật khẩu quá nhiều? Xem các chương 10 & 11 trong hướng dẫn này để kết nối với kho lưu trữ bằng khóa SSH (phức tạp hơn)","code":""},{"path":"collaboration.html","id":"trong-github-desktop-4","chapter":"46 Version control với Git và Github","heading":"Trong Github Desktop","text":"Nhấp vào nút “Fetch origin” để kiểm tra xem có commit mới nào trên kho lưu trữ từ xa hay không.Nếu Git tìm thấy các commit mới trên kho lưu trữ từ xa, nút commit sẽ thay đổi thành nút “Push”. Bởi vì cùng một nút được sử dụng để push và pull, bạn không thể push các thay đổi của mình nếu bạn không pull trước đó.Bạn có thể chuyển đến tab “History” (gần tab “Changes”) để xem tất cả các commits (của bạn và những người khác). Đây là một cách tốt để tự làm quen với những gì những người cộng tác với bạn đã làm. Bạn có thể đọc các thông điệp commit, các mô tả nếu có và sánh code của hai tệp bằng cách sử dụng cửa sổ diff.Khi tất cả các thay đổi từ xa đã được pull và ít nhất một thay đổi cục bộ đã được commit, bạn có thể push bằng cách nhấp trên cùng một nút.","code":""},{"path":"collaboration.html","id":"console","chapter":"46 Version control với Git và Github","heading":"Console","text":"Không có gì ngạc nhiên, các lệnh là fetch, pull và push.","code":"git fetch  # are there new commits in the remote directory?\ngit pull   # Bring remote commits into your local branch\ngit push   # Puch local commits of this branch to the remote branch"},{"path":"collaboration.html","id":"tôi-muốn-pull-nhưng-tôi-cũng-có-các-chỉnh-sửa-trong-local","chapter":"46 Version control với Git và Github","heading":"Tôi muốn pull nhưng tôi cũng có các chỉnh sửa trong local","text":"Điều này đôi khi có thể xảy ra: khi bạn đã thực hiện một số thay đổi trên kho lưu trữ cục bộ của mình, nhưng kho lưu trữ từ xa có các commit mà bạn đã không pull.Git sẽ từ chối pull vì nó có thể ghi đè các thay đổi của bạn. Có một số chiến lược để giữ các thay đổi của bạn, được mô tả tốt trong trang Happy Git R, trong đó có hai điểm chính sau:commit các thay đổi của bạn, fetch các thay đổi từ xa, pull chúng xuống, giải quyết các xung đột nếu có (xem phần bên dưới) và push mọi thứ lêncommit các thay đổi của bạn, fetch các thay đổi từ xa, pull chúng xuống, giải quyết các xung đột nếu có (xem phần bên dưới) và push mọi thứ lênstash các thay đổi của bạn, tức là lưu trữ chúng sang một bên, sau đó pull và unstash (khôi phục), sau đó commit, giải quyết các xung đột và push.stash các thay đổi của bạn, tức là lưu trữ chúng sang một bên, sau đó pull và unstash (khôi phục), sau đó commit, giải quyết các xung đột và push.Nếu các tệp có thay đổi từ remote và hay đổi bởi local không trùng lặp, Git có thể tự động giải quyết các xung đột.Trong Github Desktop, việc này có thể được thực hiện với các nút bấm. Để stash, hãy truy cập Branch > Stash changes.","code":""},{"path":"collaboration.html","id":"hợp-nhất-nhánh-vào-nhánh-chính","chapter":"46 Version control với Git và Github","heading":"46.10 Hợp nhất nhánh vào Nhánh chính","text":"Nếu bạn đã thực hiện xong các thay đổi, bạn có thể bắt đầu quá trình hợp nhất những thay đổi đó vào nhánh chính. Tùy thuộc vào tình huống của bạn, việc này có thể nhanh hoặc bạn có thể cần sự xem xét và phê duyệt của các thành viên trong nhóm.","code":""},{"path":"collaboration.html","id":"hợp-nhất-cục-bộ-bằng-github-desktop","chapter":"46 Version control với Git và Github","heading":"Hợp nhất cục bộ bằng Github Desktop","text":"Bạn có thể hợp nhất các nhánh bằng Github Desktop. Đầu tiên, hãy truy cập (checkout) nhánh sẽ là nơi tiếp nhận các commit, nói cách khác, nhánh bạn muốn cập nhật. Sau đó vào menu và lựa chọn Branch > Merge current branch. Một hộp thoại sẽ cho phép bạn chọn nhánh bạn muốn nhập vào.","code":""},{"path":"collaboration.html","id":"trong-console-2","chapter":"46 Version control với Git và Github","heading":"Trong console","text":"Đầu tiên hãy quay lại nhánh sẽ nhận các thay đổi. Nó thường là nhánh có tên master, nhưng nó cũng có thể là một nhánh khác. Sau đó hợp nhất nhánh làm việc của bạn vào master.Trang này trình bày một ví dụ nâng cao hơn về phân nhánh và giải thích sơ bộ về cơ chế của nó.","code":"git checkout master  # Go back to master (or to the branch you want to move your )\ngit merge this_fancy_new_branch"},{"path":"collaboration.html","id":"trong-github-gửi-một-pull-requests","chapter":"46 Version control với Git và Github","heading":"Trong Github: gửi một pull requests","text":"Mặc dù hoàn toàn có thể hợp nhất hai nhánh một cách cục bộ, hoặc không thông báo cho bất kỳ ai, thì việc hợp nhất có thể được thảo luận hoặc kiểm tra bởi một số người trước khi được tích hợp vào nhánh master. Để giúp đỡ quá trình này, Github cung cấp một số tính năng thảo luận cho việc hợp nhất có tên là: pull request.Một pull request (một “PR”) là một yêu cầu hợp nhất một nhánh vào một nhánh khác (nói cách khác, một yêu cầu nhánh làm việc của bạn được pull vào nhánh “chính”). Một pull request thường bao gồm nhiều lần commit. Một pull request thường bắt đầu một cuộc thảo luận và quá trình review trước khi nó được chấp nhận và được hợp nhất vào nhánh chính. Ví dụ, bạn có thể đọc các cuộc thảo luận về pull request trên trang github của package dplyr.Bạn có thể gửi một pull request (PR) trực tiếp từ trang web (như minh họa bên dưới) hoặc từ Github Desktop.Đi tới kho lưu trữ Github (trực tuyến)Xem tab “Pull Requests” và ấn vào nút “New pull request”Chọn nhánh cần hợp nhất từ menu thả xuống để hợp nhất vào nhánh chínhViết chi tiết bình luận cho Pull Request và ấn vào “Create Pull Request”.Trong ảnh dưới đây, nhánh “forest” được chọn để hợp nhất vào nhánh “chính” (main):Bây giờ bạn đã có thể xem một pull request (ảnh minh họa bên dưới):Kiểm tra tab “Files changed” để xem nhánh “chính” sẽ thay đổi như thế nào nếu được hợp nhất.Ở phía bên phải, bạn có thể yêu cầu một thành viên trong nhóm review bằng cách gắn thẻ (tag) ID Github của họ. Nếu bạn muốn, bạn có thể thiết lập các cài đặt cho repository để yêu cầu một ai đó chấp thuận trước khi hợp nhất vào nhánh chính.Khi pull request được chấp thuận, nút “Merge pull request” sẽ được active. Hãy ấn vào đó.Khi hợp nhất thành công, xóa nhánh của bạn như được giải thích bên dưới.","code":""},{"path":"collaboration.html","id":"giải-quyết-xung-đột","chapter":"46 Version control với Git và Github","heading":"Giải quyết xung đột","text":"Khi hai người cùng thay đổi code trên cùng một (hoặc nhiều) dòng, thì xung đột khi hợp nhất sẽ xảy ra. Thực tế là Git sẽ từ chối việc đưa ra quyết định phiên bản nào sẽ được giữ, nhưng nó cho phép bạn tìm kiếm nơi xảy ra xung đột. ĐỪNG HOẢNG LẠN. Hầu hết các trường hợp khá dễ dàng để giải quyết.Ví dụ, trên Github:Sau khi việc hợp nhất nhắc nhở về có xung đột, hãy mở tệp trong trình chỉnh sửa ưa thích của bạn. Xung đột sẽ được đánh dấu bằng một chuỗi các ký tự như sau:Đoạn văn bản nằm giữa <<<<<<< HEAD và ======= đến từ local repository của bạn, và đoạn văn bản nằm giữa ======= và >>>>>>> đến từ một nhánh khác (có thể là bản gốc, master hoặc bất kỳ nhánh nào theo lựa chọn của bạn).Bạn phải quyết định phiên bản nào của code bạn muốn giữ (hoặc thậm chí viết một phiên bản thứ ba, bao gồm các thay đổi từ cả hai phía), xóa phần còn lại và loại bỏ tất cả các ký tự đánh dấu mà Git đã thêm vào (<<<<<<< HEAD, =======, >>>>>>> origin/master/your_branch_name).Sau đó, lưu tệp, stage và commit nó: Đây là commit để tạo phiên bản hợp nhất “chính thức”. Đừng quên push sau đó.Nếu bạn và những người cộng tác với bạn thường xuyên pull và push, thì các xung đột lớn hiếm khi xảy ra.Lưu ý: Nếu bạn tự tin tương tác với console, có nhiều lựa chọn hợp nhất nâng cao (ví dụ: bỏ qua khoảng trống, cho người cộng tác quyền ưu tiên, v.v.).","code":""},{"path":"collaboration.html","id":"xóa-nhánh-của-bạn","chapter":"46 Version control với Git và Github","heading":"Xóa nhánh của bạn","text":"Khi một nhánh đã được hợp nhất vào master và bạn không cần đến nó nữa, bạn có thể xóa nó.","code":""},{"path":"collaboration.html","id":"github-rstudio","chapter":"46 Version control với Git và Github","heading":"46.10.0.1 Github + Rstudio","text":"Đi tới thư mục lưu trữ trên Github và nhấn nút để xem toàn bộ các nhánh hiện có (cạnh mũi tên trỏ xuống để lựa chọn nhánh). Bây giờ tìm nhánh của bạn và nhấn biểu tượng thúng rác bên cạnh nó. Đọc thêm về cách xóa một nhánh tại đây.Hãy chắc chắn là bạn cũng đã xóa nhánh trong máy tính của mình bởi vì quá trình này không được diễn ra một cách tự động.Trong RStudio, hãy chắc chắn bạn đang ở nhánh chính (Main branch)Chuyển sang cửa sổ “Terminal” của RStudio (bên cạnh cửa sổR console), và gõ: git branch -d branch_name, trong đó “branch_name” là tên của nhánh mà bạn muốn xóaRefresh lại cửa sổ Git và nhánh đó sẽ biến mất","code":""},{"path":"collaboration.html","id":"trong-github-desktop-5","chapter":"46 Version control với Git và Github","heading":"46.10.0.2 Trong Github Desktop","text":"Đơn giản chỉ cần checkout tới nhánh bạn muốn xóa, và đi tới menu Branch > Delete.","code":""},{"path":"collaboration.html","id":"forking","chapter":"46 Version control với Git và Github","heading":"Forking","text":"Bạn có thể fork một dự án nếu bạn muốn đóng góp cho nó nhưng không có quyền để thực hiện, hoặc chỉ là bạn muốn chỉnh sửa cho mục đích sử dụng cá nhân. Một mô tả ngắn về forking có thể xem tại đây.Trong Github, nhấp vào nút “Fork”:Thao tác này sẽ clone kho lưu trữ gốc, nhưng được lưu trong hồ sơ của bạn. đó, bây giờ có hai phiển bản của kho lưu trữ trong Github: phiên bản gốc mà bạn không thể chỉnh sửa, và phiên bản clone trong hồ sơ của bạn.Sau đó, bạn có thể tiếp tục clone phiên bản trực tuyến xuống máy tính của bạn, sử dụng bất kỳ phương pháp nào đã được mô tả bên trên. Tiếp theo, bạn có thể tạo một nhánh mới, tạo các thay đổi, commit và push chúng lên kho lưu trữ từ xa của bạn.Khi bạn hài lòng với các kết quả, bạn có thể tạo một Pull Request từ Github hoặc Github Desktop để bắt đầu một cuộc thảo luận với chủ sở hữu/người bảo trì của kho lưu trữ gốc.Nếu bạn muốn lấy những commits mới hơn từ kho lưu trữ gốc thì sao?hãy tưởng tượng ai đó đã tạo một thay đổi quan trọng trong kho lưu trữ gốc, và bạn muốn thêm những thay đổi đó vào kho lưu trữ của mình. Điều này là khả thi để đồng bộ hóa kho lưu trữ bạn đã fork với kho lưu trữ gốc. Nó yêu cầu sử dụng terminal, nhưng không quá phức tạp. Bạn chỉ cần nhớ rằng: - upstream (thượng nguồn) = kho lưu trữ gốc, là cái mà bạn không thể chỉnh sửa - origin (bản gốc) = phiên bản kho lưu trữ trong hồ sơ Github của bạnBạn có thể đọc tutorial này hoặc theo dõi các bước dưới đây:Đầu tiên, gõ vào Git terminal (bên trong repo của bạn):Nếu bạn chưa từng cấu hình upstream repository (kho lưu trữ gốc), bạn sẽ thấy hai dòng, bắt đầu bởi từ origin. Chúng hiển thị kho lưu trữ từ xa để fetch và push các điểm vào. Hãy nhớ, origin là biệt danh thường dùng cho phiên bản kho lưu trữ của chính bạn trên Github. Ví dụ:Bây giờ, thêm một kho lưu trữ từ xa:Địa chỉ ở đây là địa chỉ mà Github tạo ra khi bạn clone một repository (xem mục về cloning). Bây giờ bạn sẽ có bốn điểm từ xa:Quá trình thiết lập đã xong. Bất cứ khi nào bạn muốn lấy các sự thay đổi từ kho lưu trữ gốc (upstream), bạn chỉ cần đi tới (checkout) nhánh bạn muốn cập nhật và gõ:Nếu có xung đột, bạn sẽ phải giải quyết chúng như đã trình bày ở bên trên.Tổng kết: forking là cloning, nhưng chỉ trên phía máy chủ của Github. Các hành động còn lại là điển hình của mô quy trình cộng tác(clone, push, pull, commit, merge, gửi pull requests…).Lưu ý: trong khi forking là một khái niệm, không phải là một lệnh Git, nó cũng tồn tại ở các nền tảng khác, chẳng hạn như Bitbucket.","code":"git remote -vgit remote add upstream https://github.com/appliedepi/epirhandbook_eng.gitgit fetch upstream # Get the new commits from the remote repository\ngit checkout the_branch_you_want_to_update\ngit merge upstream/the_branch_you_want_to_update  # Merge the upstream branch into your branch.\ngit push # Update your own version of the remote repo"},{"path":"collaboration.html","id":"chúng-ta-đã-học-được-những-gì","chapter":"46 Version control với Git và Github","heading":"46.11 Chúng ta đã học được những gì","text":"Bạn đã học được cách:thiết lập Git để theo dõi sự thay đổi trong thư mục của bạn,kết nối kho lưu trữ cục bộ và từ xa,commit các thay đổi,đồng bộ kho lưu trữ cục bộ và từ xa.Tất cả chúng là khá đầy đủ cho những nhu cầu của một nhà dịch tễ học. Chúng ta thường không cần sử dụng những chức năng nâng cao như những lập trình viên.Tuy nhiên, nếu bạn muốn (hoặc cần) đi xa hơn, Git cung cấp nhiều tính năng để đơn giản hóa lịch sử commit, khôi phục một hoặc nhiều commits, cherry-pick commits (chỉ lấy một vài commit trong PR), v.v. Một số chúng nghe thực sự rất thần thánh, nhưng không sao vì bạn đã có cơ bản rồi, sẽ dễ dàng để bổ sung kiến thức trên nền tảng đó.Lưu ý là trong khi cửa sổ Git trong Rstudio và Github Desktop tốt cho những người mới bắt đầu / sử dụng trong các công việc hàng này, thì chúng không cung cấp giao diện cho những hàm Git trung cấp / cao cấp. Các giao diện đầy đủ hơn cho phép bạn phải sử dụng những tính năng nâng cao chỉ với các thao tác chuột (thông thường phải trả phí).Hãy nhớ là bạn có thể sử dụng bất kỳ công cụ nào tại mọi thời điểm để theo dõi kho lưu trữ của mình, đó bạn có thể cài đặt một giao diện để thỉnh thoảng sử dụng, hoặc thực hiện những tác vụ không phiỉ biến, trong khi lựa chọn một giao diện đơn giản hầu hết thời gian (vd: sử dụng Github Desktop phần lớn thời gian, và chuyển qua phần mềm SourceTree hoặc Gitbash cho những tác vụ cụ thể).","code":""},{"path":"collaboration.html","id":"git","chapter":"46 Version control với Git và Github","heading":"46.12 Các lệnh Git","text":"","code":""},{"path":"collaboration.html","id":"được-khuyến-khích-học","chapter":"46 Version control với Git và Github","heading":"Được khuyến khích học","text":"Để học các lệnh Git một cách tương tác, xem trang web này.","code":""},{"path":"collaboration.html","id":"gõ-lệnh-vào-đâu","chapter":"46 Version control với Git và Github","heading":"Gõ lệnh vào đâu","text":"Bạn gõ lệnh vào Git shell.Lựa chọn 1 Bạn mở một Terminal mới trong RStudio. Tab này ở bên cạnh R Console. Nếu bạn không thể gõ trên đó, nhấp vào menu thả xuống ở dưới chữ “Terminal” và chọn “New terminal”. Gõ lệnh ở khoảng trống phía sau ký tự dollar “$”.Lựa chọn 2 Bạn cũng có thể mở một shell (một terminal để gõ lệnh) bằng cách nhấp vào biểu tượng “bánh răng” màu xanh trong cửa sổ Git (bên cạnh cửa sổ RStudio Environment). Chọn “Shell” từ menu thả xuống. Một cửa sổ mới sẽ mở ra nơi mà bạn có thể gõ các lệnh sau ký tự dollar “$”.Lựa chọn 3 Nháy chuột phải để mở “Git Bash ”, cho phép mở một cửa sổ terminal tương tự, hoặc mở Git Bash từ danh sách ứng dụng của bạn. Các thông tin về Git Bash cho người mới bắt đầu, cách tìm nó và một số lệnh bash bạn sẽ cần.","code":""},{"path":"collaboration.html","id":"một-số-lệnh-mẫu","chapter":"46 Version control với Git và Github","heading":"Một số lệnh mẫu","text":"Sau đây chúng tôi sẽ trình bày một số lệnh git phổ biến. Khi bạn sử dụng chúng, hãy chú ý nhánh nào đang được active (checked-), bởi vì điều này sẽ quyết định hành động nào được thực hiện!Trong các lệnh dưới đây,  đại diện cho tên nhánh.  đại diện cho hash ID của một commit cụ thể.  đại diện cho một số. Bạn không cần gõ ký tự < hoặc >.","code":""},{"path":"collaboration.html","id":"tài-nguyên-học-liệu-16","chapter":"46 Version control với Git và Github","heading":"46.13 Tài nguyên học liệu","text":"Phần lớn chương này lấy thông tin từ trang web “Happy Git R” viết bởi Jenny Bryan. Có một chuyên mục rất hữu ích trong trang web đó có thể giúp bạn giải quyết những lỗi phổ biến về Git và các lỗi liên quan tới R.Tài liệu Github.com documentation start guide.RStudio “IDE” cheatsheet bao gồm các mẹo về Git với RStudio.https://ohi-science.org/news/github-going-back--timeLệnh Git cho người mớiMột hướng dẫn tương tác để học các lệnh Git.https://www.freecodecamp.org/news/-introduction--git--absolute-beginners-86fa1d32ff71/: tốt cho việc học những thứ cơ bản để theo dõi các thay đổi trong một thư mục của máy tính của bạnLược đồ để hiểu về nhánh: https://speakerdeck.com/alicebartlett/git--humansHướng dẫn bao gồm các chủ đề cơ bản và nâng caohttps://tutorialzine.com/2016/06/learn-git--30-minuteshttps://dzone.com/articles/git-tutorial-commands--operations--git https://swcarpentry.github.io/git-novice/ (khóa ngắn hạn) https://rsjakob.gitbooks.io/git/content/chapter1.htmlSách Pro Git được xem là tài liệu tham khảo chính thức. Trong khi một số chương khá ổn, đa số khá nặng tính kỹ thuật. Nó có thể là một nguồn tốt khi bạn đã sử dụng Git một thời gian và muốn học thêm những kiến thức nâng cao.","code":""},{"path":"errors.html","id":"errors","chapter":"47 Các lỗi thường gặp","heading":"47 Các lỗi thường gặp","text":"Chương này bao gồm một danh sách các lỗi phổ biến và các giải pháp đề xuất để khắc phục chúng.","code":""},{"path":"errors.html","id":"phiên-giải-thông-báo-lỗi","chapter":"47 Các lỗi thường gặp","heading":"47.1 Phiên giải thông báo lỗi","text":"Các lỗi trong R đôi khi có thể khó hiểu, vì vậy Google là bạn của bạn. Tìm kiếm thông báo lỗi với “R” và tìm các bài đăng gần đây trong StackExchange.com, stackoverflow.com, community.rstudio.com, twitter (#rstats), và các diễn đàn khác được lập trình viên sử dụng để gửi câu hỏi và câu trả lời. Hãy cố gắng tìm các bài đăng gần đây đã giải quyết các vấn đề tương tự.Nếu sau nhiều lần tìm kiếm, bạn không thể tìm thấy câu trả lời cho vấn đề của mình, hãy cân nhắc tạo một ví dụ có thể tái tạo (“reprex”) và tự đăng câu hỏi. Xem chương Nhờ sự trợ giúp để biết các mẹo về cách tạo và đăng một ví dụ có thể tái tạo lên diễn đàn.","code":""},{"path":"errors.html","id":"các-lỗi-thường-gặp","chapter":"47 Các lỗi thường gặp","heading":"47.2 Các lỗi thường gặp","text":"Dưới đây, chúng tôi liệt kê một số lỗi phổ biến và các giải thích/giải pháp tiềm năng. Một số trong số này được mượn từ Noam Ross, người đã phân tích các bài đăng phổ biến nhất trên diễn đàn Stack Overflow về các thông báo lỗi trên R (xem bài phân tích tại đây)","code":""},{"path":"errors.html","id":"lỗi-đánh-máy","chapter":"47 Các lỗi thường gặp","heading":"Lỗi đánh máy","text":"Nếu bạn thấy lỗi “unexpected symbol”, kiểm tra xem có thiếu dấu phẩy không","code":"Error: unexpected symbol in:\n\"  geom_histogram(stat = \"identity\")+\n  tidyquant::geom_ma(n=7, size = 2, color = \"red\" lty\""},{"path":"errors.html","id":"các-lỗi-liên-quan-đến-package","chapter":"47 Các lỗi thường gặp","heading":"Các lỗi liên quan đến Package","text":"Điều này có thể có nghĩa là bạn đã nhập sai tên hàm hoặc quên cài đặt hoặc gọi một package.Bạn nghĩ rằng bạn đang sử dụng dplyr::select() nhưng thực tế là hàm select() đã bị đè bởi hàm MASS::select() - hãy ghi rõ dplyr:: hoặc sắp xếp lại thứ tự các package được gọi để dplyr đứng sau tất cả các package khác.Các lỗi hàm bị đè phổ biến khác bắt nguồn từ: plyr::summarise() và stats::filter(). Cân nhắc sử dụng conflicted package.Nếu bạn gặp lỗi thông báo rằng bạn cần xóa tệp “00LOCK”, go “R” library computer directory (e.g. R/win-library/) look folder called “00LOCK”. Delete manually, try installing package . previous install process probably interrupted, led .","code":"could not find function \"x\"...Error in select(data, var) : unused argument (var)Error in install.packages : ERROR: failed to lock directory ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0’ for modifying\nTry removing ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0/00LOCK’"},{"path":"errors.html","id":"các-lỗi-liên-quan-tới-đối-tượng","chapter":"47 Các lỗi thường gặp","heading":"Các lỗi liên quan tới đối tượng","text":"Nếu bạn gặp lỗi như thế này khi cố gắng xuất hoặc nhập: Hãy kiểm tra lỗi chính tả của tệp và đường dẫn tệp và nếu đường dẫn chứa dấu gạch chéo, hãy đảm bảo rằng bạn đang dùng dấu gạch chéo xuôi / chứ không phải dấu gạch chéo ngược \\. Ngoài ra, hãy đảm bảo rằng bạn đã sử dụng đúng phần mở rộng tệp (ví dụ: .csv, .xlsx).Điều này có nghĩa là một đối tượng bạn đang tham chiếu không tồn tại. Có lẽ code trên đã không chạy đúng cách?Điều này có nghĩa là bạn đã cố gắng truy cập vào thứ gì đó (một phần tử của vectơ hoặc danh sách) không có ở đó.","code":"No such file or directory:object 'x' not found Error in 'x': subscript out of bounds"},{"path":"errors.html","id":"các-lỗi-liên-quan-tới-cú-pháp-hàm","chapter":"47 Các lỗi thường gặp","heading":"Các lỗi liên quan tới cú pháp hàm","text":"Lỗi bên trên (argument .x missing, default) thường gặp với hàm mutate() nếu bạn đang cung cấp một hàm như recode() hoặc replace_na() trong đó nó yêu cầu bạn cung cấp tên cột làm đối số đầu tiên. Điều này rất dễ quên.","code":"# ran recode without re-stating the x variable in mutate(x = recode(x, OLD = NEW)\nError: Problem with `mutate()` input `hospital`.\nx argument \".x\" is missing, with no default\ni Input `hospital` is `recode(...)`."},{"path":"errors.html","id":"các-lỗi-logic","chapter":"47 Các lỗi thường gặp","heading":"Các lỗi logic","text":"Điều này có thể có nghĩa là một mệnh đề đã được áp dụng cho một cái gì đó không phải là TRUE hoặc FALSE.","code":"Error in if"},{"path":"errors.html","id":"các-lỗi-liên-quan-tới-factor","chapter":"47 Các lỗi thường gặp","heading":"Các lỗi liên quan tới Factor","text":"Nếu bạn nhìn thấy lỗi liên quan tới thứ bậc kiểu factor không hợp lệ, có thể bạn đang có một cột kiểu Factor(chứa các thứ bậc đã được xác định) và bạn đang cố gắng thêm một giá trị mới vào nó. Chuyển nó thành kiểu ký tự trước khi thêm giá trị mới.","code":"#Tried to add a value (\"Missing\") to a factor (with replace_na operating on a factor)\nProblem with `mutate()` input `age_cat`.\ni invalid factor level, NA generated\ni Input `age_cat` is `replace_na(age_cat, \"Missing\")`.invalid factor level, NA generated"},{"path":"errors.html","id":"lỗi-khi-vẽ-biểu-đồ","chapter":"47 Các lỗi thường gặp","heading":"Lỗi khi vẽ biểu đồ","text":"Error: Insufficient values manual scale. 3 needed 2 provided.\nĐây có thể là lỗi khi bạn vẽ biểu đồ bằng ggplot, sử dụng scale_fill_manual() values = c(“orange”, “purple”), trong đó bạn chưa cung cấp đủ số lượng màu cho hàm. Nếu cột này dạng factor, hãy cân nhắc liệu NA có phải là một bậc của factor hay không.Bạn có thể thừa dấu + ở cuối lệnh ggplot mà bạn cần xóa.","code":"Can't add x object"},{"path":"errors.html","id":"lỗi-r-markdown","chapter":"47 Các lỗi thường gặp","heading":"Lỗi R Markdown","text":"Nếu thông báo lỗi là Error options[[sprintf(\"fig.%s\", )]], kiểm tra xem các tùy chọn của knitr ở đầu mỗi đoạn code có sử dụng chính xác .width = hoặc .height = và không phải fig.width= và fig.height= hay không.","code":""},{"path":"errors.html","id":"tổng-hợp-2","chapter":"47 Các lỗi thường gặp","heading":"Tổng hợp","text":"Cân nhắc liệu bạn có đã sắp xếp lại các hàm đã được pipe trong package dplyr và đã không thay thế một pipe ở giữa, hoặc đã không xóa một pipe ở cuối sau khi sắp xếp lại.","code":""},{"path":"errors.html","id":"nguồn-14","chapter":"47 Các lỗi thường gặp","heading":"47.3 Nguồn","text":"Đây là một bài đăng trên blog khác liệt kê Các lỗi lập trình R phổ biến mà người mới bắt đầu gặp phải","code":""},{"path":"help.html","id":"help","chapter":"48 Nhờ sự trợ giúp","heading":"48 Nhờ sự trợ giúp","text":"Chương này hướng dẫn cách nhận trợ giúp bằng cách đăng vấn đề mà bạn gặp phải lên Github hoặc đưa ra một ví dụ giả lập (“reprex”) lên các diễn đàn trực tuyến.","code":""},{"path":"help.html","id":"đăng-vấn-đề-lên-github","chapter":"48 Nhờ sự trợ giúp","heading":"48.1 Đăng vấn đề lên Github","text":"Nhiều packages và dự án trong R được lưu trữ mã code của chúng trên trang web Github.com. Bạn có thể trao đổi trực tiếp với các tác giả của các package hoặc dự án này bằng cách đăng một “Issue” qua trang web Github.com..Tìm hiểu thêm về cách lưu trữ các tệp của bạn trên Github trong chương Version control với Git và Github.Trên Github, mỗi dự án được chứa trong một kho lưu trữ. Mỗi kho chứa code, dữ liệu, kết quả đầu ra, tài liệu trợ giúp, v.v. Ngoài ra còn có một cách để trao đổi với các tác giả được gọi là “Issues”.Xem các ảnh bên dưới về Github để hiểu thêm về package incidence2 (được sử dụng để tạo đường cong dịch bệnh). Trong ảnh dưới, bạn có thể thấy mục “Issues” được tô màu vàng. Số 5 bên cạnh chữ “Issues” có nghĩa là có 5 vấn đề đang được mở.Ấn vào mục Issues, bạn có thể thấy các vấn đề đang mở được hiện ra. Hãy xem lại chúng để đảm bảo những vấn đề này chưa được giải quyết. Bạn có thể mở một vấn đề mới bằng cách nhấp vào nút màu xanh lá cây “New issue” ở bên phải. Để thực hiện những thao tác này, bạn sẽ cần mở một tài khoản Github.Để đọc các tài liệu nâng cao hơn về cách xử lý các vấn đề trong kho lưu trữ Github của riêng bạn, hãy xem Tài liệu về Issues trong Github.","code":""},{"path":"help.html","id":"ví-dụ-giả-lập","chapter":"48 Nhờ sự trợ giúp","heading":"48.2 Ví dụ giả lập","text":"Cung cấp một ví dụ giả lập (“reprex”) là chìa khóa để nhận được giúp đỡ khi đăng bài thảo luận trên các diễn đàn hoặc trong vấn đề Github issue. Để người khác có thể giúp bạn, bạn phải cho họ một ví dụ cụ thể để họ có thể xử ý vấn dề của bạn trên máy tính của chính họ. Ví dụ của bạn cần phải:Trình bày sự cố bạn gặp phảiHãy nhớ ngắn gọn nhất có thể, bạn chi cân ghi dữ liệu và đoạn code cần thiết để giả lập lại sự cố của bạnĐủ thông tin để giả lập lại tình huống của bạn, ví dụ như các thông tin như các đối tượng (ví dụ: dữ liệu), tất cả package được gọi (ví dụ: library() hoặc p_load()).Ngoài ra, hãy đảm bảo rằng bạn không đăng bất kỳ dữ liệu nhạy cảm nào với reprex! Bạn có thể tạo các data frames mẫu hoặc sử dụng một trong các data frames có sẵn trong R (nhập data()để mở danh sách các tập dữ liệu này).","code":""},{"path":"help.html","id":"package-reprex","chapter":"48 Nhờ sự trợ giúp","heading":"Package reprex","text":"Package reprex có thể hỗ trợ bạn tạo một ví dụ giả lậpPackage reprex được cài đặt với package tidyverse, vì vậy hãy gọi một trong hai package:Bắt đầu một đoạn R script tạo ra vấn đề của bạn, hãy làm từng từng bước một, bắt đầu từ việc tải các package và dữ liệu.Sao chép tất cả code vào bộ nhớ tạm của bạn và chạy lệnh sau:Bạn sẽ thấy một tệp HTML xuất hiện trong cửa sổ RStudio Viewer. Nó sẽ chứa tất cả code của bạn và bất kỳ cảnh báo, lỗi hoặc biểu đồ nào. Tệp này cũng được sao chép vào bộ nhớ tạm của bạn, vì vậy bạn có thể đăng trực tiếp nó lên một vấn đề trên Github hoặc một bài đăng trên diễn đàn.Nếu bạn đặt session_info = TRUE, thì kết quả đầu ra của lệnh sessioninfo::session_info() sẽ được bao gồm với các phiên bản R và package R của bạn.Bạn có thể cung cấp một thư mục làm việc cho wd =Bạn có thể đọc thêm về các đối số và các biến số có thể có tại Tài liệu này hoặc bằng cách nhập ?reprexTrong ví dụ trên, lệnh ggplot() không chạy vì đối số date_format = không đúng. Nó phải là date_labels =.","code":"\n# install/load tidyverse (which includes reprex)\npacman::p_load(tidyverse)\n# load packages\npacman::p_load(\n     tidyverse,  # data mgmt and vizualization\n     outbreaks)  # example outbreak datasets\n\n# flu epidemic case linelist\noutbreak_raw <- outbreaks::fluH7N9_china_2013  # retrieve dataset from outbreaks package\n\n# Clean dataset\noutbreak <- outbreak_raw %>% \n     mutate(across(contains(\"date\"), as.Date))\n\n# Plot epidemic\n\nggplot(data = outbreak)+\n     geom_histogram(\n          mapping = aes(x = date_of_onset),\n          binwidth = 7\n     )+\n  scale_x_date(\n    date_format = \"%d %m\"\n  )\nreprex::reprex()"},{"path":"help.html","id":"bộ-dữ-liệu-tối-giản","chapter":"48 Nhờ sự trợ giúp","heading":"Bộ dữ liệu tối giản","text":"Những người giúp bạn cần sử dụng dữ liệu của bạn - lý tưởng nhất là họ có thể tạo ra nó bằng code.Để tạo một tập dữ liệu tối giản, hãy xem xét việc ẩn danh và chỉ sử dụng một tập con của các quan sát.ĐANG ĐƯỢC PHÁT TRIỂN - Bạn có thể sử dụng lệnh dput() để tạo một bộ dữ liệu tối giản.","code":""},{"path":"help.html","id":"đăng-lên-diễn-đàn","chapter":"48 Nhờ sự trợ giúp","heading":"48.3 Đăng lên diễn đàn","text":"Bạn cần đọc nhiều bài viết trên diễn đàn. Hiểu được bài đăng nào được viết tốt và bài nào thì không.Đầu tiên, bạn hãy quyết định xem có nên đặt câu hỏi hay không. Bạn đã kỹ lưỡng tìm kiếm câu trả lời trên các trang web diễn đàn, thử các cụm từ tìm kiếm khác nhau, để xem liệu câu hỏi của bạn đã được đặt ra chưa?Đặt cho câu hỏi của bạn với một tiêu đề thông tin đầy đủ (không phải “Trợ giúp! Điều này không hoạt động”).Viết câu hỏi của bạn:Giới thiệu hoàn cảnh và vấn đề của bạnLiên kết đến các bài đăng về các vấn đề tương tự và giải thích cách họ không trả lời câu hỏi của bạnGhi bất kỳ thông tin liên quan nào để giúp những người không rõ bối cảnh công việc của bạnĐưa ra một ví dụ giả lập với thông tin tối thiểu về phiên làm việc R của bạnSử dụng đúng chính tả, ngữ pháp, dấu câu và ngắt câu hỏi của bạn thành các đoạn văn để dễ đọc hơnTheo dõi câu hỏi của bạn sau khi được đăng để trả lời bất kỳ yêu cầu làm rõ nào. Lịch sự và nhã nhặn - thường những người trả lời đều tình nguyện dành thời gian của họ để giúp bạn. Nếu bạn có một câu hỏi tiếp theo, hãy cân nhắc xem nó có nên là một câu hỏi được đăng riêng hay không.Theo dõi câu hỏi của bạn sau khi được đăng để trả lời bất kỳ yêu cầu làm rõ nào. Lịch sự và nhã nhặn - thường những người trả lời đều tình nguyện dành thời gian của họ để giúp bạn. Nếu bạn có một câu hỏi tiếp theo, hãy cân nhắc xem nó có nên là một câu hỏi được đăng riêng hay không.Đánh dấu câu hỏi là đã trả lời, nếu bạn đã nhận được câu trả lời đáp ứng yêu cầu ban đầu của bạn. Điều này giúp những người truy cập sau nhanh chóng nhận ra giải pháp cho vấn đề tương tự với bạn.Đánh dấu câu hỏi là đã trả lời, nếu bạn đã nhận được câu trả lời đáp ứng yêu cầu ban đầu của bạn. Điều này giúp những người truy cập sau nhanh chóng nhận ra giải pháp cho vấn đề tương tự với bạn.Đọc những bài đăng này trong các tài liệu Cách đặt một câu hỏi tốt và Bộ quy tắc ứng xử.","code":""},{"path":"help.html","id":"tài-liệu-tham-khảo-2","chapter":"48 Nhờ sự trợ giúp","heading":"48.4 Tài liệu tham khảo","text":"Package Tidyverse về cách nhận trợ giúp!Lời khuyên về tạo ra một tập dữ liệu tối thiểuTài liệu về Hàm dput","code":""},{"path":"network-drives.html","id":"network-drives","chapter":"49 R trên ổ cứng mạng","heading":"49 R trên ổ cứng mạng","text":"","code":""},{"path":"network-drives.html","id":"tổng-quan-9","chapter":"49 R trên ổ cứng mạng","heading":"49.1 Tổng quan","text":"Việc sử dụng R trên một ổ cứng mạng dùng chung tại “công ty” hoặc một nhóm có thể gây ra một số vấn đề phát sinh. Chương này sẽ giới thiệu các phương pháp tiếp cận, các lỗi phổ biến và các đề xuất về cách khắc phục sự cố từ những bài học kinh nghiệm của chúng tôi khi giải quyết các vấn đề này. Chúng bao gồm các mẹo cho các tình huống khó liên quan đến R Markdown.Sử dụng R trên ổ cứng mạng: Một số nguyên tắc chínhBạn phải có quyền truy cập quản trị đối với máy tính của mình. Thiết lập RStudio đặc biệt để chạy với tư cách quản trị viên (run administrator).Hãy lưu các packages trong thư viện trên một ổ cứng vật lý (ví dụ: “C:”). Hạn chế tối đa Sử dụng package thư viện có đường dẫn bắt đầu bằng “\\\".Package rmarkdown không được nằm trong thư viện package “\\\", vì khi đó nó không thể kết nối với TinyTex hoặc Pandoc.","code":""},{"path":"network-drives.html","id":"rstudio-với-tư-cách-quản-trị-viên","chapter":"49 R trên ổ cứng mạng","heading":"49.2 RStudio với tư cách quản trị viên","text":"Bạn cần nhấp vào biểu tượng RStudio để mở RStudio, sau đó bấm chuột phải. Tùy thuộc vào máy của bạn, bạn có thể thấy tùy chọn “Run Administrator”. Nếu không, bạn có thể thấy một tùy chọn để chọn Properties (sau đó sẽ xuất hiện một cửa sổ có tùy chọn “Compatibility” và bạn có thể chọn hộp kiểm “Run Administrator”).","code":""},{"path":"network-drives.html","id":"các-lệnh-hữu-ích","chapter":"49 R trên ổ cứng mạng","heading":"49.3 Các lệnh hữu ích","text":"Dưới đây là một số lệnh hữu ích trong việc khắc phục sự cố khi sử dụng R trên ổ đĩa mạng.Bạn có thể trả về (các) đường dẫn đến các thư thư mục lưu trữ package mà R đang sử dụng. Chúng sẽ được liệt kê theo thứ tự mà R đang sử dụng để cài đặt/tải/tìm kiếm các packages. Vì vậy, nếu bạn muốn R sử dụng một thư viện mặc định khác, bạn có thể chuyển đổi thứ tự của các đường dẫn này (xem bên dưới).Bạn có thể muốn chuyển đổi thứ tự của các thư viện package được sử dụng bởi R. Ví dụ: nếu R đang chọn một vị trí thư viện với đường dẫn bắt đầu bằng “\\\" và một đường dẫn bắt đầu bằng chữ cái, ví dụ:”D:“. Bạn có thể điều chỉnh thứ tự của .libPaths() bằng đoạn mã code dưới đây.Nếu bạn gặp khó khăn với R Markdown kết nối với Pandoc, hãy bắt đầu với đoạn code mã này để tìm hiểu RStudio cài đặt Pandoc của bạn ở đâu.Nếu bạn muốn xem package đang được tải từ thư viện ở đâu, hãy thử đoạn code dưới đây:","code":"\n# Find libraries\n.libPaths()                   # Your library paths, listed in order that R installs/searches. \n                              # Note: all libraries will be listed, but to install to some (e.g. C:) you \n                              # may need to be running RStudio as an administrator (it won't appear in the \n                              # install packages library drop-down menu) \n# Switch order of libraries\n# this can effect the priority of R finding a package. E.g. you may want your C: library to be listed first\nmyPaths <- .libPaths() # get the paths\nmyPaths <- c(myPaths[2], myPaths[1]) # switch them\n.libPaths(myPaths) # reassign them\n# Find Pandoc\nSys.getenv(\"RSTUDIO_PANDOC\")  # Find where RStudio thinks your Pandoc installation is\n# Find a package\n# gives first location of package (note order of your libraries)\nfind.package(\"rmarkdown\", lib.loc = NULL, quiet = FALSE, verbose = getOption(\"verbose\")) "},{"path":"network-drives.html","id":"khắc-phục-các-lỗi-thường-gặp","chapter":"49 R trên ổ cứng mạng","heading":"49.4 Khắc phục các lỗi thường gặp","text":"“Failed compile…tex rmarkdown”Kiểm tra cài đặt TinyTex hoặc cài đặt TinyTex vào ổ C:. Xem thêm chương R cơ bản để biết về cách cài đặt TinyTexInternet routines loadedVí dụ, Error tools::startDynamicHelp() : internet routines loadedThử chọn phiên bản 32-bit từ RStudio qua Tools/Global Options .\nChú ý: nếu phiên bản 32-bit không xuất hiện trong menu, hãy đảm bảo rằng bạn không sử dụng RStudio phiên bản 1.2.\nChú ý: nếu phiên bản 32-bit không xuất hiện trong menu, hãy đảm bảo rằng bạn không sử dụng RStudio phiên bản 1.2.Ngoài ra, hãy thử gỡ cài đặt R và cài đặt lại với phiên bản bit khác (32 thay vì 64)C: library appear option try install packages manuallyChạy RStudio với tư cách quản trị viên, sau đó tùy chọn này sẽ xuất hiện.Để thiết lập R Studio luôn chạy với tư cách quản trị viên (thuận tiện khi sử dụng dự án R mà bạn không nhấp vào biểu tượng R Studio để mở) … nhấp chuột phải vào biểu tượng R studioHình ảnh bên dưới cho thấy cách bạn có thể chọn thủ công thư viện để cài đặt một gói. Cửa sổ này xuất hiện khi bạn mở ngăn Packages RStudio và nhấp vào “Install”.Pandoc 1 errorNếu bạn gặp phải “pandoc error 1” khi knitting tập lệnh R Markdowns trên ổ đĩa mạng:Trong số nhiều vị trí thư viện đặt lưu trữ, hãy chọn một vị trí ổ cứng bắt đầu bằng một chữ cái (xem lại ở trên)Giải pháp trên có thể thực hiện được khi knitting trên ổ đĩa cá nhân trong khi máy tính có kết nối internetXem thêm các mẹo khác tại đây: https://ciser.cornell.edu/rmarkdown-knit--html-word-pdf/Pandoc Error 83Lỗi sẽ có dạng như sau: find file...rmarkdown...lua.... Điều này có nghĩa là nó không thể tìm thấy tệp này.Xem thêm tại đây: https://stackoverflow.com/questions/58830927/rmarkdown-unable--locate-lua-filter--knitting--wordCác khả năng có thể xảy ra:Package Rmarkdown chưa được cài đặtPackage Rmarkdown không thể tìm thấyVấn đề về quyền quản trị.Có thể R không thể tìm thấy các package sử dụng trong file rmarkdown, vì vậy hãy kiểm tra thư viện nào mà package trong rmarkdown đang được lưu trữ (xem đoạn code để thực hiện thao tác này ở trên). Nếu package được cài đặt vào một thư viện không thể truy cập được (ví dụ: bắt đầu bằng “\\\") hãy xem xét việc di chuyển nó sang C: hoặc thư viện ổ cứng theo cách thủ công. Lưu ý rằng package rmarkdown phải có thể kết nối với cài đặt TinyTex, vì vậy không thể tồn tại trong thư viện trên ổ đĩa mạng.Lỗi Pandoc 61Vú dụ: Error: pandoc document conversion failed error 61 hoặc fetch...Thử chạy RStudio với tư cách quản trị viên (nhấp chuột phải vào biểu tượng, chọn chạy với tư cách quản trị viên, xem hướng dẫn ở trên)Ngoài ra, hãy xem nếu có package cụ thể nào không thể truy cập được có thể được chuyển đến ổ C: library.Lỗi LaTex (xem bên dưới)Một lỗi như: ! Package pdftex.def Error: File 'cict_qm2_2020-06-29_files/figure-latex/unnamed-chunk-5-1.png' found: using draft setting. hoặc Error: LaTeX failed compile file_name.tex.Xem thêm tại đây https://yihui.org/tinytex/r/#debugging để biết các mẹo debug.Xem thêm file_name.log để biết thêm chi tiết.Lỗi Pandoc 127Đây có thể là vấn đề về RAM (dung lượng). Hãy bắt đầu lại phiên làm việc R của bạn và thử lại.Định vị các ổ đĩa mạngĐịnh vị ổ đĩa mạng có thể gặp một số rủi ro. Hãy tham khảo ý kiến với bộ phận CNTT của bạn trước khi làm!Bạn có thể xem thêm các thảo luận trên diễn đàn này:Làm cách nào để mở một tệp “thông qua một ổ đĩa mạng đã được đinh vị”?Trước tiên, bạn cần biết vị trí ổ mạng mà bạn đang cố gắng truy cập.Tiếp theo, trong trình quản lý tệp của Windows, bạn sẽ cần phải nhấp chuột phải vào “Máy tính này” ở ngăn bên phải và chọn “Map network drive”.Đi qua hộp thoại để xác định vị trí mạng trước đó dưới dạng ổ đĩa có tên bắt đầu chữ cái.Bây giờ bạn có hai cách để truy cập tệp bạn đang mở. Sử dụng đường dẫn ổ đĩa bắt đầu bằng ký tự có thể hoạt động.Lỗi khi cài đặt install.packages()Nếu bạn gặp lỗi bao gồm đề cập đến thư mục “khóa”, ví dụ: Error install.packages : ERROR: failed lock directory...Tìm trong thư viện package của bạn và bạn sẽ thấy một thư mục có tên bắt đầu bằng “00LOCK”. Hãy thử các mẹo sau:Xóa thủ công thư mục thư mục “00LOCK” khỏi thư viện package của bạn. Thử cài đặt lại package này.Bạn cũng có thể thử lệnh pacman::p_unlock() (bạn cũng có thể đặt lệnh này trong Rprofile để nó chạy mỗi khi mở dự án). Sau đó, hãy thử cài đặt lại package. Bạn có thể cần thử một vìa lần.Thử chạy RStudio ở chế độ Quản trị viên và thử cài đặt từng package một.Nếu vẫn không thành công, hãy cài đặt packge vào thư viện hoặc thư mục khác (ví dụ: Temp) và sau đó sao chép thủ công thư mục của package vào thư viện mong muốn.","code":"\n# check/install tinytex, to C: location\ntinytex::install_tinytex()\ntinytex:::is_tinytex() # should return TRUE (note three colons)"},{"path":"data-table.html","id":"data-table","chapter":"50 Data Table","heading":"50 Data Table","text":"Cuốn sổ tay này tập trung vào các hàm của dplyr và toán tử pipe của magrittr %>% như một phương pháp để làm sạch và nhóm dữ liệu, tuy nhiên package data.table cũng cung cấp một giải pháp thay thế mà bạn có thể sử dụng trong quá trình làm việc với R của mình.","code":""},{"path":"data-table.html","id":"giới-thiệu-về-data-table","chapter":"50 Data Table","heading":"50.1 Giới thiệu về data table","text":"Một data table là một cấu trúc dữ liệu 2-chiều giống như một data frame mà cho phép thực hiện các thao tác phân nhóm phức tạp. Cú pháp data.table được cấu trúc để có thể thực hiện các thao tác trên hàng, cột và nhóm.Cấu trúc là DT[, j, ], được chia thành 3 phần; đối số , j và . Đối số cho phép tạo tập con trên các hàng được yêu cầu, đối số j cho phép bạn vận hành trên cột và đối số cho phép bạn vận hành theo nhóm.Chương này sẽ giải quyết các chủ đề sau:Nhập dữ liệu và sử dụng fread() và fwrite()Chọn và lọc các hàng bằng cách sử dụng đối số iSử dụng các hàm trợ giúp %like%, %chin%, %%Chọn và tính toán trên các cột bằng cách sử dụng đối số jTính toán theo nhóm bằng cách sử dụng đối số byThêm và cập nhật dữ liệu vào data table bằng cách sử dụng :=","code":""},{"path":"data-table.html","id":"gọi-package-và-nhập-dữ-liệu","chapter":"50 Data Table","heading":"50.2 Gọi package và nhập dữ liệu","text":"","code":""},{"path":"data-table.html","id":"gọi-package-11","chapter":"50 Data Table","heading":"Gọi package","text":"Sử dụng hàm p_load() từ pacman, chúng ta sẽ gọi (và cài đặt nếu cần) các package cần thiết cho phân tích này.","code":"\npacman::p_load(\n  rio,        # to import data\n  data.table, # to group and clean data\n  tidyverse,  # allows use of pipe (%>%) function in this chapter\n  here \n  ) "},{"path":"data-table.html","id":"nhập-dữ-liệu-27","chapter":"50 Data Table","heading":"Nhập dữ liệu","text":"Chương này sẽ khám phá một số hàm cốt lõi của data.table thông qua bộ số liệu linelist đã được nhắc đền nhiều lần trong sổ tay này.Chúng ta nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương Tải sách và dữ liệu. Bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương về Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau. Từ đây chúng tôi sử dụng data.table() để chuyển data frame thành data table.Hàm fread() được sử dụng để nhập trực tiếp các delimited files phổ biến, chẳng hạn như tệp .csv, trực tiếp sang định dạng data table. Hàm này và đối tác của nó, fwrite(), được sử dụng để ghi data.table dưới dạng các delimited files phổ biến, là các tùy chọn rất nhanh và hiệu quả về mặt tính toán đối với cơ sở dữ liệu lớn.20 hàng đầu tiên của linelist:Các lệnh base R như dim() được sử dụng cho data frame cũng có thể được sử dụng cho data table","code":"\nlinelist <- rio::import(here(\"data\", \"linelist_cleaned.xlsx\")) %>% data.table()\ndim(linelist) #gives the number of rows and columns in the data table## [1] 5888   30"},{"path":"data-table.html","id":"đối-số-i-chọn-và-lọc-hàng","chapter":"50 Data Table","heading":"50.3 Đối số i: chọn và lọc hàng","text":"Nhắc lại cấu trúc DT[, j, ], chúng ta có thể lọc các hàng bằng cách sử dụng số hàng hoặc biểu thức logic. Đối số là đối số đầu tiên; đó, cú pháp DT[] hoặc DT[,] có thể được sử dụng.Ví dụ đầu là việc truy xuất 5 hàng đầu tiên của data table, ví dụ thứ hai là tập hợp các trường hợp từ 18 tuổi trở lên và ví dụ thứ ba là tập hợp các trường hợp từ 18 tuổi trở lên nhưng không được chẩn đoán tại Bệnh viện Trung tâm (Central Hospital):Sử dụng .N trong đối số đại diện cho tổng số hàng trong data table. Điều này có thể được sử dụng để subset dữ liệu dựa trên số thứ tự hàng:","code":"\nlinelist[1:5] #returns the 1st to 5th row\nlinelist[age >= 18] #subsets cases are equal to or over 18 years\nlinelist[age >= 18 & hospital != \"Central Hospital\"] #subsets cases equal to or over 18 years old but not diagnosed at the Central Hospital\nlinelist[.N] #returns the last row\nlinelist[15:.N] #returns the 15th to the last row"},{"path":"data-table.html","id":"sử-dụng-hàm-trợ-giúp-để-lọc","chapter":"50 Data Table","heading":"Sử dụng hàm trợ giúp để lọc","text":"Data table sử dụng các hàm trợ giúp để việc subset các hàng trở nên dễ dàng. Hàm %like% được sử dụng để khớp với một pattern trong cột, %chin% được sử dụng để khớp với một ký tự cụ thể và hàm trợ giúp %% được sử dụng để khớp các cột theo số thứ tự trong một phạm vi xác định trước.Trong các ví dụ dưới đây, chúng ta: * lọc các hàng mà biến hospital có chứa “Hospital” * lọc các hàng có kết quả là “Recover” hoặc “Death” * lọc các hàng trong độ tuổi 40-60","code":"\nlinelist[hospital %like% \"Hospital\"] #filter rows where the hospital variable contains “Hospital”\nlinelist[outcome %chin% c(\"Recover\", \"Death\")] #filter rows where the outcome is “Recover” or “Death”\nlinelist[age %between% c(40, 60)] #filter rows in the age range 40-60\n\n#%between% must take a vector of length 2, whereas %chin% can take vectors of length >= 1"},{"path":"data-table.html","id":"đối-số-j-chọn-và-tính-toán-trên-cột","chapter":"50 Data Table","heading":"50.4 Đối số j: chọn và tính toán trên cột","text":"Sử dụng cấu trúc DT[, j, ], chúng ta có thể chọn cột bằng cách sử dụng số hoặc tên. Đối số j là đối số thứ hai; đó, cú pháp DT[, j] được sử dụng. Để tạo điều kiện tính toán trên đối số j, cột được bao quanh bằng cách sử dụng list() hoặc .().","code":""},{"path":"data-table.html","id":"chọn-cột","chapter":"50 Data Table","heading":"Chọn cột","text":"Ví dụ đầu tiên lấy các cột thứ nhất, thứ ba và thứ năm của data table, ví dụ thứ hai chọn tất cả các cột ngoại trừ các cột height, weight và gender. Ví dụ thứ ba sử dụng .() phía trước để chọn cột case_id và outcome.","code":"\nlinelist[ , c(1,3,5)]\nlinelist[ , -c(\"gender\", \"age\", \"wt_kg\", \"ht_cm\")]\nlinelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] works just as well"},{"path":"data-table.html","id":"tính-toán-trên-cột","chapter":"50 Data Table","heading":"Tính toán trên cột","text":"Bằng cách kết hợp các đối số và j, có thể lọc các hàng và tính toán trên các cột. Sử dụng .N trong đối số j cũng thể hiện cho tổng số hàng trong data table và có thể hữu ích để trả về số hàng sau khi lọc.Trong các ví dụ dưới đây, chúng tôi: * Đếm số trường hợp nằm viện trên 7 ngày * Tính tuổi trung bình của các trường hợp tử vong tại military hospital * Tính toán độ lệch chuẩn, trung vị, tuổi trung bình của các trường hợp đã khỏi bệnh tại Central HospitalHãy nhớ rằng việc sử dụng .() bao quanh đối số j sẽ tạo điều kiện thuận lợi cho việc tính toán, trả về data table và cho phép đặt tên cột.","code":"\nlinelist[days_onset_hosp > 7 , .N]## [1] 189\nlinelist[hospital %like% \"Military\" & outcome %chin% \"Death\", .(mean(age, na.rm = T))] #na.rm = T removes N/A values##         V1\n## 1: 15.9084\nlinelist[hospital == \"Central Hospital\" & outcome == \"Recover\", \n                 .(mean_age = mean(age, na.rm = T),\n                   median_age = median(age, na.rm = T),\n                   sd_age = sd(age, na.rm = T))] #this syntax does not use the helper functions but works just as well##    mean_age median_age   sd_age\n## 1: 16.85185         14 12.93857"},{"path":"data-table.html","id":"đối-số-by-tính-toán-theo-nhóm","chapter":"50 Data Table","heading":"50.5 Đối số by: tính toán theo nhóm","text":"Đối số là đối số thứ ba trong cấu trúc DT[, j, ]. Đối số chấp nhận cả vectơ ký tự và cú pháp list() hoặc .(). Sử dụng cú pháp .() trong đối số cho phép đổi tên cột một cách nhanh chóng.Trong các ví dụ dưới đây, chúng ta:\n* nhóm số trường hợp theo bệnh viện * trường hợp từ 18 tuổi trở lên, tính chiều cao và cân nặng trung bình theo giới tính và theo tình trạng hồi phục hay tử vong * trong những lần nhập viện kéo dài trên 7 ngày, đếm số trường hợp theo tháng họ nhập viện và theo bệnh viện họ nằmData.table cũng cho phép các biểu thức chuỗi như sau:Trong các ví dụ này, chúng ta đang tuân theo giả định rằng một hàng trong data table tương đương với một trường hợp mới, vì vậy chúng ta có thể sử dụng .N để thể hiện số hàng trong data table. Một hàm hữu ích khác thể hiện số lượng các trường hợp duy nhất là uniqueN(), hàm này trả về số lượng các giá trị duy nhất trong một đầu vào nhất định.Đáp án là 3, vì các giá trị duy nhất trong cột gender là m, f và N/. sánh với hàm base R là unique(), trả về tất cả các giá trị duy nhất trong một đầu vào nhất định:Để tìm số trường hợp duy nhất trong một tháng (month) nhất định, chúng tôi sẽ viết như sau:","code":"\nlinelist[, .N, .(hospital)] #the number of cases by hospital##                                hospital    N\n## 1:                                Other  885\n## 2:                              Missing 1469\n## 3: St. Mark's Maternity Hospital (SMMH)  422\n## 4:                        Port Hospital 1762\n## 5:                    Military Hospital  896\n## 6:                     Central Hospital  454\nlinelist[age > 18, .(mean_wt = mean(wt_kg, na.rm = T),\n                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAs represent the categories where the data is missing##    gender outcome  mean_wt  mean_ht\n## 1:      m Recover 71.90227 178.1977\n## 2:      f   Death 63.27273 159.9448\n## 3:      m   Death 71.61770 175.4726\n## 4:      f    <NA> 64.49375 162.7875\n## 5:      m    <NA> 72.65505 176.9686\n## 6:      f Recover 62.86498 159.2996\n## 7:   <NA> Recover 67.21429 175.2143\n## 8:   <NA>   Death 69.16667 170.7917\n## 9:   <NA>    <NA> 70.25000 175.5000\nlinelist[days_onset_hosp > 7, .N, .(month = month(date_hospitalisation), hospital)]##     month                             hospital  N\n##  1:     5                    Military Hospital  3\n##  2:     6                        Port Hospital  4\n##  3:     7                        Port Hospital  8\n##  4:     8 St. Mark's Maternity Hospital (SMMH)  5\n##  5:     8                    Military Hospital  9\n##  6:     8                                Other 10\n##  7:     8                        Port Hospital 10\n##  8:     9                        Port Hospital 28\n##  9:     9                              Missing 27\n## 10:     9                     Central Hospital 10\n## 11:     9 St. Mark's Maternity Hospital (SMMH)  6\n## 12:    10                              Missing  2\n## 13:    10                    Military Hospital  3\n## 14:     3                        Port Hospital  1\n## 15:     4                    Military Hospital  1\n## 16:     5                                Other  2\n## 17:     5                     Central Hospital  1\n## 18:     5                              Missing  1\n## 19:     6                              Missing  7\n## 20:     6 St. Mark's Maternity Hospital (SMMH)  2\n## 21:     6                    Military Hospital  1\n## 22:     7                    Military Hospital  3\n## 23:     7                                Other  1\n## 24:     7                              Missing  2\n## 25:     7 St. Mark's Maternity Hospital (SMMH)  1\n## 26:     8                     Central Hospital  2\n## 27:     8                              Missing  6\n## 28:     9                                Other  9\n## 29:     9                    Military Hospital 11\n## 30:    10                        Port Hospital  3\n## 31:    10                                Other  4\n## 32:    10 St. Mark's Maternity Hospital (SMMH)  1\n## 33:    10                     Central Hospital  1\n## 34:    11                              Missing  2\n## 35:    11                        Port Hospital  1\n## 36:    12                        Port Hospital  1\n##     month                             hospital  N\nlinelist[, .N, .(hospital)][order(-N)][1:3] #1st selects all cases by hospital, 2nd orders the cases in descending order, 3rd subsets the 3 hospitals with the largest caseload##             hospital    N\n## 1:     Port Hospital 1762\n## 2:           Missing 1469\n## 3: Military Hospital  896\nlinelist[, .(uniqueN(gender))] #remember .() in the j argument returns a data table##    V1\n## 1:  3\nlinelist[, .(unique(gender))]##      V1\n## 1:    m\n## 2:    f\n## 3: <NA>\nlinelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]##     month   V1\n##  1:     5   62\n##  2:     6  100\n##  3:     7  198\n##  4:     8  509\n##  5:     9 1170\n##  6:    10 1228\n##  7:    11  813\n##  8:    12  576\n##  9:     1  434\n## 10:     2  310\n## 11:     3  290\n## 12:     4  198"},{"path":"data-table.html","id":"thêm-và-cập-nhật-dữ-liệu-vào-data-table","chapter":"50 Data Table","heading":"50.6 Thêm và cập nhật dữ liệu vào data table","text":"Toán tử := được sử dụng để thêm hoặc cập nhật dữ liệu trong data table. Việc thêm cột vào data table của bạn có thể được thực hiện theo những cách dưới đây:Các tổ hợp phức tạp hơn nằm ngoài phạm vi của chương giới thiệu này, nhưng ý tưởng của chương này là cung cấp một giải pháp thay thế phổ biến và khả thi cho dplyr để phân nhóm và làm sạch dữ liệu. Package data.table là một package tốt giúp code gọn gàng và dễ đọc.","code":"\nlinelist[, adult := age >= 18] #adds one column\nlinelist[, c(\"child\", \"wt_lbs\") := .(age < 18, wt_kg*2.204)] #to add multiple columns requires c(\"\") and list() or .() syntax\nlinelist[, `:=` (bmi_in_range = (bmi > 16 & bmi < 40),\n                         no_infector_source_data = is.na(infector) | is.na(source))] #this method uses := as a functional operator `:=`\nlinelist[, adult := NULL] #deletes the column"},{"path":"data-table.html","id":"tài-nguyên-học-liệu-17","chapter":"50 Data Table","heading":"50.7 Tài nguyên học liệu","text":"Để có thêm thông tin, dưới đây là một số tài nguyên hữu ích: * https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html * https://github.com/Rdatatable/data.table * https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf * https://www.machinelearningplus.com/data-manipulation/datatable--r-complete-guide/ * https://www.datacamp.com/community/tutorials/data-table-r-tutorialBạn có thể thực hiện bất kỳ chức năng tóm tắt nào trên dữ liệu được nhóm; xem Cheat Sheet tại đây để có thêm thông tin: https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Shgiteet_R.pdf","code":""}]
